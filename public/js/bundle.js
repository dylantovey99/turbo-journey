"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all3) => {
    for (var name in all3)
      __defProp(target, name, { get: all3[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module2) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component9.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component9(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e3) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type5) {
          if (null == type5) return null;
          if ("function" === typeof type5)
            return type5.$$typeof === REACT_CLIENT_REFERENCE ? null : type5.displayName || type5.name || null;
          if ("string" === typeof type5) return type5;
          switch (type5) {
            case REACT_FRAGMENT_TYPE2:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type5)
            switch ("number" === typeof type5.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type5.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return (type5.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type5._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type5.render;
                type5 = type5.displayName;
                type5 || (type5 = innerType.displayName || innerType.name || "", type5 = "" !== type5 ? "ForwardRef(" + type5 + ")" : "ForwardRef");
                return type5;
              case REACT_MEMO_TYPE:
                return innerType = type5.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type5.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type5._payload;
                type5 = type5._init;
                try {
                  return getComponentNameFromType(type5(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getTaskName(type5) {
          if (type5 === REACT_FRAGMENT_TYPE2) return "<>";
          if ("object" === typeof type5 && null !== type5 && type5.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type5);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty2.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type5, key, self2, source, owner, props, debugStack, debugTask) {
          self2 = props.ref;
          type5 = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type5,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type5, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type5, "ref", { enumerable: false, value: null });
          type5._store = {};
          Object.defineProperty(type5._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type5, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type5, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type5, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type5.props), Object.freeze(type5));
          return type5;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            void 0,
            void 0,
            oldElement._owner,
            oldElement.props,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function isValidElement27(object4) {
          return "object" === typeof object4 && null !== object4 && object4.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match2) {
            return escaperLookup[match2];
          });
        }
        function getElementKey(element, index3) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index3.toString(36);
        }
        function noop$1() {
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array4, escapedPrefix, nameSoFar, callback) {
          var type5 = typeof children;
          if ("undefined" === type5 || "boolean" === type5) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type5) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array4,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array4, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement27(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement27(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array4.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type5 = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array4,
                escapedPrefix,
                type5,
                callback
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type5 = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array4,
                escapedPrefix,
                type5,
                callback
              );
          else if ("object" === type5) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array4,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array4 = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array4 ? "object with keys {" + Object.keys(children).join(", ") + "}" : array4) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 1, payload._result = moduleObject;
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 2, payload._result = error;
              }
            );
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
          }
          if (1 === payload._status)
            return ctor = payload._result, void 0 === ctor && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ), "default" in ctor || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ), ctor.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function noop7() {
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module2 && module2[requireString]).call(
                module2,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback;
                      queue.splice(0, i);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        Symbol.for("react.provider");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign2 = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component9.prototype.isReactComponent = {};
        Component9.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component9.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        }, fnName;
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component9.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign2(deprecatedAPIs, Component9.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          V: null,
          actQueue: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty2 = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        exports.Children = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n2 = 0;
            mapChildren(children, function() {
              n2++;
            });
            return n2;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement27(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Component = Component9;
        exports.Fragment = REACT_FRAGMENT_TYPE2;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign2({}, element.props), key = element.key, owner = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty2.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty2.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            void 0,
            void 0,
            owner,
            props,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            owner = arguments[key], isValidElement27(owner) && owner._store && (owner._store.validated = 1);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type5, config, children) {
          for (var i = 2; i < arguments.length; i++) {
            var node2 = arguments[i];
            isValidElement27(node2) && node2._store && (node2._store.validated = 1);
          }
          i = {};
          node2 = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node2 = "" + config.key), config)
              hasOwnProperty2.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type5 && type5.defaultProps)
            for (propName in childrenLength = type5.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          node2 && defineKeyPropWarningGetter(
            i,
            "function" === typeof type5 ? type5.displayName || type5.name || "Unknown" : type5
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type5,
            node2,
            void 0,
            void 0,
            getOwner(),
            i,
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type5)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render4) {
          null != render4 && render4.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render4 ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render4 ? "null" : typeof render4
          ) : 0 !== render4.length && 2 !== render4.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render4.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render4 && null != render4.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render4 }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render4.name || render4.displayName || (Object.defineProperty(render4, "name", { value: name }), render4.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement27;
        exports.lazy = function(ctor) {
          return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: { _status: -1, _result: ctor },
            _init: lazyInitializer
          };
        };
        exports.memo = function(type5, compare) {
          null == type5 && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type5 ? "null" : typeof type5
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type: type5,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type5.name || type5.displayName || (Object.defineProperty(type5, "name", { value: name }), type5.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop7, reportGlobalError);
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context3) {
          var dispatcher = resolveDispatcher();
          Context3.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context3);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, createDeps, update) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          var dispatcher = resolveDispatcher();
          if ("function" === typeof update)
            throw Error(
              "useEffect CRUD overload is not enabled in this build of React."
            );
          return dispatcher.useEffect(create, createDeps);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.1.1";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek2(taskQueue2); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek2(taskQueue2) && pop(taskQueue2);
                        advanceTimers(currentTime);
                      } else pop(taskQueue2);
                      currentTask = peek2(taskQueue2);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek2(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node2) {
          var index3 = heap.length;
          heap.push(node2);
          a: for (; 0 < index3; ) {
            var parentIndex = index3 - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node2))
              heap[parentIndex] = node2, heap[index3] = parent, index3 = parentIndex;
            else break a;
          }
        }
        function peek2(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index3 = 0, length2 = heap.length, halfLength = length2 >>> 1; index3 < halfLength; ) {
              var leftIndex = 2 * (index3 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length2 && 0 > compare(right, left) ? (heap[index3] = right, heap[rightIndex] = last, index3 = rightIndex) : (heap[index3] = left, heap[leftIndex] = last, index3 = leftIndex);
              else if (rightIndex < length2 && 0 > compare(right, last))
                heap[index3] = right, heap[rightIndex] = last, index3 = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek2(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue2, timer);
            else break;
            timer = peek2(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek2(taskQueue2))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek2(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue2 = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek2(taskQueue2) && priorityLevel === peek2(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue2, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop7() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e3) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React404 = require_react(), Internals = {
          d: {
            f: noop7,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop7,
            C: noop7,
            L: noop7,
            m: noop7,
            X: noop7,
            S: noop7,
            M: noop7
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React404.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a) {
          return fn(a);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.1.1";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module2) {
      "use strict";
      if (false) {
        checkDCE();
        module2.exports = null;
      } else {
        module2.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path2, index3, value) {
          if (index3 >= path2.length) return value;
          var key = path2[index3], updated = isArrayImpl(obj) ? obj.slice() : assign2({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path2, index3 + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index3) {
          var oldKey = oldPath[index3], updated = isArrayImpl(obj) ? obj.slice() : assign2({}, obj);
          index3 + 1 === oldPath.length ? (updated[newPath[index3]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index3 + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path2, index3) {
          var key = path2[index3], updated = isArrayImpl(obj) ? obj.slice() : assign2({}, obj);
          if (index3 + 1 === path2.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path2, index3 + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnForMissingKey() {
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop$2() {
        }
        function setToSortedString(set2) {
          var array4 = [];
          set2.forEach(function(value) {
            array4.push(value);
          });
          return array4.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root3, element) {
          root3.context === emptyContextObject && (updateContainerImpl(root3.current, 2, element, root3, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root3, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root3.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node2) {
          return !(!node2 || 1 !== node2.nodeType && 9 !== node2.nodeType && 11 !== node2.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node2 = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node2.return; ) node2 = node2.return;
          else {
            fiber = node2;
            do
              node2 = fiber, 0 !== (node2.flags & 4098) && (nearestMounted = node2.return), fiber = node2.return;
            while (fiber);
          }
          return 3 === node2.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node2) {
          var tag = node2.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node2;
          for (node2 = node2.child; null !== node2; ) {
            tag = findCurrentHostFiberImpl(node2);
            if (null !== tag) return tag;
            node2 = node2.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type5) {
          if (null == type5) return null;
          if ("function" === typeof type5)
            return type5.$$typeof === REACT_CLIENT_REFERENCE ? null : type5.displayName || type5.name || null;
          if ("string" === typeof type5) return type5;
          switch (type5) {
            case REACT_FRAGMENT_TYPE2:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type5)
            switch ("number" === typeof type5.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type5.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return (type5.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type5._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type5.render;
                type5 = type5.displayName;
                type5 || (type5 = innerType.displayName || innerType.name || "", type5 = "" !== type5 ? "ForwardRef(" + type5 + ")" : "ForwardRef");
                return type5;
              case REACT_MEMO_TYPE:
                return innerType = type5.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type5.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type5._payload;
                type5 = type5._init;
                try {
                  return getComponentNameFromType(type5(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type5 = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type5._context.displayName || "Context") + ".Consumer";
            case 10:
              return (type5.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type5.render, fiber = fiber.displayName || fiber.name || "", type5.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type5;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type5);
            case 8:
              return type5 === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type5)
                return type5.displayName || type5.name || null;
              if ("string" === typeof type5) return type5;
              break;
            case 29:
              type5 = fiber._debugInfo;
              if (null != type5) {
                for (var i = type5.length - 1; 0 <= i; i--)
                  if ("string" === typeof type5[i].name) return type5[i].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c) {
          null === c && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type5 = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type5);
          type5 = updatedAncestorInfoDev(context.ancestorInfo, type5);
          nextContext = { context: nextContext, ancestorInfo: type5 };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e3) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %s.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function markCommitStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
        }
        function markComponentRenderStarted(fiber) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
        }
        function markComponentRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
        }
        function markRenderStarted(lanes) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
        }
        function markRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
        }
        function markStateUpdateScheduled(fiber, lane) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
        }
        function getLabelForLane(lane) {
          if (lane & 1) return "SyncHydrationLane";
          if (lane & 2) return "Sync";
          if (lane & 4) return "InputContinuousHydration";
          if (lane & 8) return "InputContinuous";
          if (lane & 16) return "DefaultHydration";
          if (lane & 32) return "Default";
          if (lane & 128) return "TransitionHydration";
          if (lane & 4194048) return "Transition";
          if (lane & 62914560) return "Retry";
          if (lane & 67108864) return "SelectiveHydration";
          if (lane & 134217728) return "IdleHydration";
          if (lane & 268435456) return "Idle";
          if (lane & 536870912) return "Offscreen";
          if (lane & 1073741824) return "Deferred";
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 4194048;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root3.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
          root3 = root3.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root3, renderLanes2) {
          return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root3, updateLane) {
          root3.pendingLanes |= updateLane;
          268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
        }
        function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root3.pendingLanes;
          root3.pendingLanes = remainingLanes;
          root3.suspendedLanes = 0;
          root3.pingedLanes = 0;
          root3.warmLanes = 0;
          root3.expiredLanes &= remainingLanes;
          root3.entangledLanes &= remainingLanes;
          root3.errorRecoveryDisabledLanes &= remainingLanes;
          root3.shellSuspendCounter = 0;
          var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index3 = 31 - clz32(remainingLanes), lane = 1 << index3;
            entanglements[index3] = 0;
            expirationTimes[index3] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index3];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index3] = null, index3 = 0; index3 < hiddenUpdatesForLane.length; index3++) {
                var update = hiddenUpdatesForLane[index3];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
          root3.pendingLanes |= spawnedLane;
          root3.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root3.entangledLanes |= spawnedLane;
          root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
        }
        function markRootEntangled(root3, entangledLanes) {
          var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
          for (root3 = root3.entanglements; rootEntangledLanes; ) {
            var index3 = 31 - clz32(rootEntangledLanes), lane = 1 << index3;
            lane & entangledLanes | root3[index3] & entangledLanes && (root3[index3] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root3, fiber, lanes) {
          if (isDevToolsPresent)
            for (root3 = root3.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index3 = 31 - clz32(lanes), lane = 1 << index3;
              root3[index3].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root3, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap, memoizedUpdaters = root3.memoizedUpdaters; 0 < lanes; ) {
              var index3 = 31 - clz32(lanes);
              root3 = 1 << index3;
              index3 = pendingUpdatersLaneMap[index3];
              0 < index3.size && (index3.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index3.clear());
              lanes &= ~root3;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node2) {
          delete node2[internalInstanceKey];
          delete node2[internalPropsKey];
          delete node2[internalEventHandlersKey];
          delete node2[internalEventHandlerListenersKey];
          delete node2[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentSuspenseInstance(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node2) {
          if (node2 = node2[internalInstanceKey] || node2[internalContainerInstanceKey]) {
            var tag = node2.tag;
            if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node2;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root3) {
          var resources = root3[internalRootNodeResourcesKey];
          resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node2) {
          node2[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node2, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node2.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node2 = node2.getAttribute(name);
            if ("" === node2 && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node2 === "" + expected ? expected : node2;
          }
        }
        function setValueForAttribute(node2, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node2.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node2.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node2.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node2.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node2, name, value) {
          if (null === value) node2.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node2.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node2.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node2, namespace, name, value) {
          if (null === value) node2.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node2.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node2.setAttributeNS(namespace, name, "" + value);
          }
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign2({}, props, { value: prevLog }),
              info: assign2({}, props, { value: prevInfo }),
              warn: assign2({}, props, { value: prevWarn }),
              error: assign2({}, props, { value: prevError }),
              group: assign2({}, props, { value: prevGroup }),
              groupCollapsed: assign2({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign2({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match2 && match2[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeFiber(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            do {
              info += describeFiber(workInProgress2);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i = debugInfo.length - 1; 0 <= i; i--) {
                  var entry = debugInfo[i];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info, env = entry.env;
                    var JSCompiler_inline_result = describeBuiltInComponentFrame(
                      entry.name + (env ? " [" + env + "]" : "")
                    );
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn) {
          return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                workInProgress2 && debugStack && ("string" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), "" !== debugStack && (info += "\n" + debugStack));
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type5 = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type5 || "radio" === type5);
        }
        function trackValueOnNode(node2) {
          var valueField = isCheckable(node2) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
            node2.constructor.prototype,
            valueField
          );
          checkFormFieldValueStringCoercion(node2[valueField]);
          var currentValue = "" + node2[valueField];
          if (!node2.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get2 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node2, valueField, {
              configurable: true,
              get: function() {
                return get2.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node2, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node2._valueTracker = null;
                delete node2[valueField];
              }
            };
          }
        }
        function track(node2) {
          node2._valueTracker || (node2._valueTracker = trackValueOnNode(node2));
        }
        function updateValueIfChanged(node2) {
          if (!node2) return false;
          var tracker = node2._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node2 && (value = isCheckable(node2) ? node2.checked ? "true" : "false" : node2.value);
          node2 = value;
          return node2 !== lastValue ? (tracker.setValue(node2), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e3) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type5, name) {
          element.name = "";
          null != type5 && "function" !== typeof type5 && "symbol" !== typeof type5 && "boolean" !== typeof type5 ? (checkAttributeStringCoercion(type5, "type"), element.type = type5) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type5) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type5 && "reset" !== type5 || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type5, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type5, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type5, name, isHydrating2) {
          null != type5 && "function" !== typeof type5 && "symbol" !== typeof type5 && "boolean" !== typeof type5 && (checkAttributeStringCoercion(type5, "type"), element.type = type5);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type5 && "reset" !== type5 || void 0 !== value && null !== value))
              return;
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
        }
        function setDefaultValue(node2, type5, value) {
          "number" === type5 && getActiveElement(node2.ownerDocument) === node2 || node2.defaultValue === "" + value || (node2.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React404.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node2, multiple, propValue, setDefaultSelected) {
          node2 = node2.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple["$" + propValue[i]] = true;
            for (propValue = 0; propValue < node2.length; propValue++)
              i = multiple.hasOwnProperty("$" + node2[propValue].value), node2[propValue].selected !== i && (node2[propValue].selected = i), i && setDefaultSelected && (node2[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node2.length; i++) {
              if (node2[i].value === propValue) {
                node2[i].selected = true;
                setDefaultSelected && (node2[i].defaultSelected = true);
                return;
              }
              null !== multiple || node2[i].disabled || (multiple = node2[i]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
        }
        function findNotableNode(node2, indent) {
          return void 0 === node2.serverProps && 0 === node2.serverTail.length && 1 === node2.children.length && 3 < node2.distanceFromLeaf && node2.distanceFromLeaf > 15 - indent ? findNotableNode(node2.children[0], indent) : node2;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object4) {
          return Object.prototype.toString.call(object4).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type5, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type5.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type5 + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type5 + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type5 + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign2({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type5, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type5,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type5 + ">\n" : indentation(indent) + "<" + type5 + "\n" + content + indentation(indent) + ">\n";
          }
          type5 = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type5 || "number" === typeof type5 || "bigint" === typeof type5) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type5, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type5 ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type5 = describeFiberType(fiber);
          if (null === type5) {
            type5 = "";
            for (fiber = fiber.child; fiber; )
              type5 += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type5;
          }
          return indentation(indent) + "<" + type5 + ">\n";
        }
        function describeNode(node2, indent) {
          var skipToNode = findNotableNode(node2, indent);
          if (skipToNode !== node2 && (1 !== node2.children.length || node2.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node2.fiber._debugInfo;
          if (debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var serverComponentName = debugInfo[i].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i = node2.fiber.pendingProps;
          if (6 === node2.fiber.tag)
            debugInfo = describeTextDiff(i, node2.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node2.fiber), null !== serverComponentName)
            if (void 0 === node2.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i)
                if (i.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node2.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              ), indent++) : "string" === typeof node2.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i,
                node2.serverProps,
                indent
              ), indent++);
          var propName = "";
          i = node2.fiber.child;
          for (serverComponentName = 0; i && serverComponentName < node2.children.length; )
            maxLength = node2.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
          i && 0 < node2.children.length && (propName += indentation(indent) + "...\n");
          i = node2.serverTail;
          null === node2.serverProps && indent--;
          for (node2 = 0; node2 < i.length; node2++)
            serverComponentName = i[node2], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node2 = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node2 = {
              fiber,
              children: null !== node2 ? [node2] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node2 ? describeDiff(node2).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node2, text) {
          if (text) {
            var firstChild = node2.firstChild;
            if (firstChild && firstChild === node2.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node2.textContent = text;
        }
        function camelize(string3) {
          return string3.replace(hyphenPattern, function(_, character2) {
            return character2.toUpperCase();
          });
        }
        function setValueForStyle(style3, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style3.setProperty(styleName, "") : "float" === styleName ? style3.cssFloat = "" : style3[styleName] = "" : isCustomProperty ? style3.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style3.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style3[styleName] = ("" + value).trim()) : style3[styleName] = value + "px";
        }
        function setValueForStyles(node2, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node2 = node2.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                      expandedUpdates[longhands[i]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                  key$jscomp$0[i] = true;
                  i = console;
                  var value = styles[key];
                  i.error.call(
                    i,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node2.setProperty(styleName, "") : "float" === styleName ? node2.cssFloat = "" : node2[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node2, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node2, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty2.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type5, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type5, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type5
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type5
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty2.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type5, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type5, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type5
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type5
          );
        }
        function sanitizeURL(url2) {
          return isJavaScriptProtocol.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a, b) {
          if (isInsideEventHandler) return fn(a, b);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
          return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign2(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node2) {
          for (; node2 && node2.firstChild; ) node2 = node2.firstChild;
          return node2;
        }
        function getNodeForCharacterOffset(root3, offset3) {
          var node2 = getLeafNode(root3);
          root3 = 0;
          for (var nodeEnd; node2; ) {
            if (3 === node2.nodeType) {
              nodeEnd = root3 + node2.textContent.length;
              if (root3 <= offset3 && nodeEnd >= offset3)
                return { node: node2, offset: offset3 - root3 };
              root3 = nodeEnd;
            }
            a: {
              for (; node2; ) {
                if (node2.nextSibling) {
                  node2 = node2.nextSibling;
                  break a;
                }
                node2 = node2.parentNode;
              }
              node2 = void 0;
            }
            node2 = getLeafNode(node2);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap2(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName2(eventName) {
          if (prefixedEventNames2[eventName]) return prefixedEventNames2[eventName];
          if (!vendorPrefixes2[eventName]) return eventName;
          var prefixMap = vendorPrefixes2[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2)
              return prefixedEventNames2[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node2 = sourceFiber, parent = node2.return; null !== parent; )
            null === node2.alternate && 0 !== (node2.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node2 = parent, parent = node2.return;
          return 3 === node2.tag ? node2.stateNode : null;
        }
        function resolveFunctionForHotReloading(type5) {
          if (null === resolveFamily) return type5;
          var family = resolveFamily(type5);
          return void 0 === family ? type5 : family.current;
        }
        function resolveForwardRefForHotReloading(type5) {
          if (null === resolveFamily) return type5;
          var family = resolveFamily(type5);
          return void 0 === family ? null !== type5 && void 0 !== type5 && "function" === typeof type5.render && (family = resolveFunctionForHotReloading(type5.render), type5.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type5.displayName && (family.displayName = type5.displayName), family) : type5 : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type5 = fiber.type, candidateType = null;
          switch (tag) {
            case 0:
            case 15:
            case 1:
              candidateType = type5;
              break;
            case 11:
              candidateType = type5.render;
          }
          if (null === resolveFamily)
            throw Error("Expected resolveFamily to be set during hot reload.");
          var needsRender = false;
          type5 = false;
          null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type5 = true : updatedFamilies.has(candidateType) && (1 === tag ? type5 = true : needsRender = true)));
          null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type5 = true);
          type5 && (fiber._debugNeedsRemount = true);
          if (type5 || needsRender)
            alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
          null === child || type5 || scheduleFibersWithFamiliesRecursively(
            child,
            updatedFamilies,
            staleFamilies
          );
          null !== sibling && scheduleFibersWithFamiliesRecursively(
            sibling,
            updatedFamilies,
            staleFamilies
          );
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component9) {
          Component9 = Component9.prototype;
          return !(!Component9 || !Component9.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type5, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type5;
          if ("function" === typeof type5)
            shouldConstruct(type5) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type5)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type5, pendingProps, fiberTag) ? 26 : "html" === type5 || "head" === type5 || "body" === type5 ? 27 : 5;
          else
            a: switch (type5) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE2:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type5 = pendingProps, owner = mode, "string" !== typeof type5.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type5.id
                ), key = createFiber(12, type5, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type5 && null !== type5)
                  switch (type5.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type5 || "object" === typeof type5 && null !== type5 && 0 === Object.keys(type5).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type5 ? pendingProps = "null" : isArrayImpl(type5) ? pendingProps = "array" : void 0 !== type5 && type5.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type5.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type5;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type5;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index3) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index3 += 1;
          var length2 = 32 - clz32(totalChildren) + baseLength;
          if (30 < length2) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length2 = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index3 << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length2 + workInProgress2;
          } else
            treeContextId = 1 << length2 | index3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type5 = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type5, props);
          switch (type5) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type5 = 0; type5 < mediaEventTypes.length; type5++)
                listenToNonDelegatedEvent(mediaEventTypes[type5], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              track(didHydrate);
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              ), track(didHydrate);
          }
          type5 = props.children;
          "string" !== typeof type5 && "number" !== typeof type5 && "bigint" !== typeof type5 || didHydrate.textContent === "" + type5 || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type5) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function createCache2() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache) {
          cache.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache.refCount++;
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 > cache.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
            cache.controller.abort();
          });
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now2();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now2() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now2() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var elapsedTime = now2() - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
          }
        }
        function startEffectTimer() {
          profilerStartTime = now2();
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function noop$3() {
        }
        function trackUsedThenable(thenableState2, thenable, index3) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index3 = trackedThenables[index3];
          void 0 === index3 ? trackedThenables.push(thenable) : index3 !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$3, noop$3), thenable = index3);
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$3, noop$3);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root3, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root3.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root3, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign2({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component9, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component9) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component9))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component9, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component9,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component9,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState$1 && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState$1
          }) : workInProgress2.dependencies._debugThenableState = thenableState$1;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter$1 = 0;
          thenableState$1 = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component9, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
            thenableIndexCounter$1 = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component9, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter$1 = localIdCounter = 0;
          thenableState$1 = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index3 = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          thenable = trackUsedThenable(thenableState$1, thenable, index3);
          index3 = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index3.memoizedState : workInProgressHook.next) && (index3 = index3.alternate, ReactSharedInternals.H = null !== index3 && null !== index3.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array4) {
                return array4.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current2, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              createEffectInstance(),
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node2) {
          var action = node2.action, payload = node2.payload, prevState = actionQueue.state;
          if (node2.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            ReactSharedInternals.T._updatedFibers = /* @__PURE__ */ new Set();
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node2, returnValue);
            } catch (error) {
              onActionError(actionQueue, node2, error);
            } finally {
              ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node2, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node2, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node2, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node2, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node2, error);
            }
          ), node2.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node2, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x) {
              if (x === SuspenseException) throw SuspenseActionException;
              throw x;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            createEffectInstance(),
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushSimpleEffect(tag, inst, create, createDeps) {
          tag = {
            tag,
            create,
            deps: createDeps,
            inst,
            next: null
          };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create = inst.lastEffect;
          null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
          return tag;
        }
        function createEffectInstance() {
          return { destroy: void 0, resource: void 0 };
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
          var hook = mountWorkInProgressHook();
          createDeps = void 0 === createDeps ? null : createDeps;
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            createEffectInstance(),
            create,
            createDeps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          ));
        }
        function mountEffect(create, createDeps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276826112, Passive, create, createDeps) : mountEffectImpl(8390656, Passive, create, createDeps);
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout3, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create = create(), ref.current = create, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout3,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout3,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop$2 : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
          dispatchSetStateInternal(
            formFiber,
            resetStateQueue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "\xAB" + identifierPrefix + "R" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "\xBB";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + treeId.toString(32) + "\xBB";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider);
                fiber = createUpdate(lane);
                var root3 = enqueueUpdate(provider, fiber, lane);
                null !== root3 && (scheduleUpdateOnFiber(root3, provider, lane), entangleTransitions(root3, provider, lane));
                provider = createCache2();
                null !== seedKey && void 0 !== seedKey && null !== root3 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                fiber.payload = { cache: provider };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
          markStateUpdateScheduled(fiber, args);
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args);
          markStateUpdateScheduled(fiber, args);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
          markStateUpdateScheduled(fiber, 2);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root3, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root3.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root3, lane);
          }
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys2 = Object.keys(element.props), i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index3 = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          return trackUsedThenable(thenableState, thenable, index3);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE2)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE2 && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE2) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE2 ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState = null;
              return firstChildFiber;
            } catch (x) {
              if (x === SuspenseException || x === SuspenseActionException) throw x;
              var fiber = createFiber(29, x, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i = debugInfo.length - 1; 0 <= i; i--)
                  if ("string" === typeof debugInfo[i].stack) {
                    fiber._debugOwner = debugInfo[i];
                    fiber._debugTask = debugInfo[i].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushOffscreenSuspenseHandler(fiber) {
          if (22 === fiber.tag) {
            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
              var current2 = fiber.alternate;
              null !== current2 && null !== current2.memoizedState && (shellBoundary = fiber);
            }
          } else reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node2 = row; null !== node2; ) {
            if (13 === node2.tag) {
              var state = node2.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state)))
                return node2;
            } else if (19 === node2.tag && void 0 !== node2.memoizedProps.revealOrder) {
              if (0 !== (node2.flags & 128)) return node2;
            } else if (null !== node2.child) {
              node2.child.return = node2;
              node2 = node2.child;
              continue;
            }
            if (node2 === row) break;
            for (; null === node2.sibling; ) {
              if (null === node2.return || node2.return === row) return null;
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
          return null;
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign2({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component9, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component9 = Component9.defaultProps) {
            newProps === baseProps && (newProps = assign2({}, newProps));
            for (var _propName in Component9)
              void 0 === newProps[_propName] && (newProps[_propName] = Component9[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              badgeFormat + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            ) : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
            error.unshift(console);
            JSCompiler_inline_result = bind2.apply(console.error, error);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root3, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root3.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root3, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root3.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root3, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root3, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root3,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root3,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root3, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root3, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root3.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root3, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root3
                ), enqueueCapturedUpdate(sourceFiber, root3), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root3,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component9, nextProps, renderLanes2) {
          Component9 = Component9.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component9,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
          if (null === current2) {
            var type5 = Component9.type;
            if ("function" === typeof type5 && !shouldConstruct(type5) && void 0 === type5.defaultProps && null === Component9.compare)
              return Component9 = resolveFunctionForHotReloading(type5), workInProgress2.tag = 15, workInProgress2.type = Component9, validateFunctionComponentInDev(workInProgress2, type5), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component9,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component9.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type5 = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type5.memoizedProps;
            Component9 = Component9.compare;
            Component9 = null !== Component9 ? Component9 : shallowEqual;
            if (Component9(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type5, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component9,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextChildren = workInProgress2.child = current2.child;
                for (prevState = 0; null !== nextChildren; )
                  prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
                workInProgress2.childLanes = prevState & ~nextProps;
              } else workInProgress2.childLanes = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                nextProps,
                renderLanes2
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          return null;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
          if (Component9.prototype && "function" === typeof Component9.prototype.render) {
            var componentName2 = getComponentNameFromType(Component9) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component9.contextTypes && (componentName2 = getComponentNameFromType(Component9) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          Component9 = renderWithHooks(
            current2,
            workInProgress2,
            Component9,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component9, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component9, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component9,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component9 = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component9 && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component9.contextType;
            "contextType" in Component9 && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component9) && (didWarnAboutInvalidateContextType.add(Component9), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component9) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component9(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component9(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component9.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component9) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component9.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component9) || "Component";
                var newApiName = "function" === typeof Component9.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component9) || "Component";
            _instance.render || (Component9.prototype && "function" === typeof Component9.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component9.childContextTypes && !didWarnAboutChildContextTypes.has(Component9) && (didWarnAboutChildContextTypes.add(Component9), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component9.contextTypes && !didWarnAboutContextTypes$1.has(Component9) && (didWarnAboutContextTypes$1.add(Component9), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component9.prototype && Component9.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component9) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component9) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component9), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component9)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component9.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component9.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component9.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component9) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component9.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component9,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component9.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component9, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component9.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component9.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component9,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component9,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component9, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component9.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component9.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component9,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component9,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component9.getDerivedStateFromError)
              Component9 = null, profilerStartTime = -1;
            else {
              markComponentRenderStarted(workInProgress2);
              Component9 = callRenderInDEV(lane);
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  callRenderInDEV(lane);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              markComponentRenderStopped();
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component9,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component9, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component9) {
          Component9 && Component9.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component9.displayName || Component9.name || "Component"
          );
          "function" === typeof Component9.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component9) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component9.contextType && null !== Component9.contextType && (Component9 = getComponentNameFromType(Component9) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component9] || (console.error(
            "%s: Function components do not support contextType.",
            Component9
          ), didWarnAboutContextTypeOnFunctionComponent[Component9] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2451;
          var JSCompiler_object_inline_stack_2452 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_componentStack_2453 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2451 = didSuspend) || (JSCompiler_object_inline_digest_2451 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_componentStack_2453 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2451 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_componentStack_2453 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              if (isHydrating) {
                var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
                var JSCompiler_temp;
                if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
                  c: {
                    var instance = JSCompiler_object_inline_message_2450;
                    for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType; ) {
                      if (!JSCompiler_temp) {
                        JSCompiler_temp = null;
                        break c;
                      }
                      instance = getNextHydratable(instance.nextSibling);
                      if (null === instance) {
                        JSCompiler_temp = null;
                        break c;
                      }
                    }
                    JSCompiler_temp = instance;
                  }
                  null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress2.memoizedState = {
                    dehydrated: JSCompiler_temp,
                    treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                  }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress2, workInProgress2.child = instance, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp = true) : JSCompiler_temp = false;
                  JSCompiler_temp = !JSCompiler_temp;
                }
                JSCompiler_temp && (warnNonHydratedInstance(
                  workInProgress2,
                  JSCompiler_object_inline_message_2450
                ), throwOnHydrationMismatch(workInProgress2));
              }
              JSCompiler_object_inline_message_2450 = workInProgress2.memoizedState;
              if (null !== JSCompiler_object_inline_message_2450 && (JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_message_2450.dehydrated, null !== JSCompiler_object_inline_message_2450))
                return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
              popSuspenseHandler(workInProgress2);
            }
            JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_stack_2452.children;
            JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_stack_2452.fallback;
            if (JSCompiler_object_inline_componentStack_2453)
              return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = workInProgress2.mode, JSCompiler_object_inline_message_2450 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "hidden",
                  children: JSCompiler_object_inline_message_2450
                },
                JSCompiler_object_inline_componentStack_2453
              ), JSCompiler_object_inline_stack_2452 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2452,
                JSCompiler_object_inline_componentStack_2453,
                renderLanes2,
                null
              ), JSCompiler_object_inline_message_2450.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_message_2450.sibling = JSCompiler_object_inline_stack_2452, workInProgress2.child = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_componentStack_2453.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2451,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              JSCompiler_object_inline_message_2450
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState && (JSCompiler_object_inline_message_2450 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2450)) {
            if (didSuspend)
              workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_object_inline_stack_2452 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "visible",
                  children: JSCompiler_object_inline_stack_2452.children
                },
                JSCompiler_object_inline_message_2450
              ), JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
                JSCompiler_object_inline_componentStack_2453,
                JSCompiler_object_inline_message_2450,
                renderLanes2,
                null
              ), JSCompiler_object_inline_componentStack_2453.flags |= 2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, reconcileChildFibers(
                workInProgress2,
                current2.child,
                null,
                renderLanes2
              ), JSCompiler_object_inline_stack_2452 = workInProgress2.child, JSCompiler_object_inline_stack_2452.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2452.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2451,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = JSCompiler_object_inline_componentStack_2453);
            else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error(
              "We should not be hydrating here. This is a bug in React. Please file a bug."
            ), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)) {
              JSCompiler_object_inline_digest_2451 = JSCompiler_object_inline_message_2450.nextSibling && JSCompiler_object_inline_message_2450.nextSibling.dataset;
              if (JSCompiler_object_inline_digest_2451) {
                JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
                var message2 = JSCompiler_object_inline_digest_2451.msg;
                instance = JSCompiler_object_inline_digest_2451.stck;
                var componentStack = JSCompiler_object_inline_digest_2451.cstck;
              }
              JSCompiler_object_inline_message_2450 = message2;
              JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
              JSCompiler_object_inline_stack_2452 = instance;
              JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 = componentStack;
              JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_message_2450 ? Error(JSCompiler_object_inline_message_2450) : Error(
                "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
              );
              JSCompiler_object_inline_componentStack_2453.stack = JSCompiler_object_inline_stack_2452 || "";
              JSCompiler_object_inline_componentStack_2453.digest = JSCompiler_object_inline_digest_2451;
              JSCompiler_object_inline_digest_2451 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
              JSCompiler_object_inline_stack_2452 = {
                value: JSCompiler_object_inline_componentStack_2453,
                source: null,
                stack: JSCompiler_object_inline_digest_2451
              };
              "string" === typeof JSCompiler_object_inline_digest_2451 && CapturedStacks.set(
                JSCompiler_object_inline_componentStack_2453,
                JSCompiler_object_inline_stack_2452
              );
              queueHydrationError(JSCompiler_object_inline_stack_2452);
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else if (didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), JSCompiler_object_inline_digest_2451 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2451) {
              JSCompiler_object_inline_digest_2451 = workInProgressRoot;
              if (null !== JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_stack_2452 = renderLanes2 & -renderLanes2, JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & 42) ? 1 : getBumpedLaneForHydrationByLane(
                JSCompiler_object_inline_stack_2452
              ), JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & (JSCompiler_object_inline_digest_2451.suspendedLanes | renderLanes2)) ? 0 : JSCompiler_object_inline_stack_2452, 0 !== JSCompiler_object_inline_stack_2452 && JSCompiler_object_inline_stack_2452 !== prevState.retryLane))
                throw prevState.retryLane = JSCompiler_object_inline_stack_2452, enqueueConcurrentRenderForLane(
                  current2,
                  JSCompiler_object_inline_stack_2452
                ), scheduleUpdateOnFiber(
                  JSCompiler_object_inline_digest_2451,
                  current2,
                  JSCompiler_object_inline_stack_2452
                ), SelectiveHydrationException;
              JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                JSCompiler_object_inline_message_2450.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current2.id, treeContextOverflow = current2.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
                workInProgress2,
                JSCompiler_object_inline_stack_2452.children
              ), workInProgress2.flags |= 4096);
            return workInProgress2;
          }
          if (JSCompiler_object_inline_componentStack_2453)
            return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_temp = current2.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2452 = createWorkInProgress(
              JSCompiler_temp,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2452.children
              }
            ), JSCompiler_object_inline_stack_2452.subtreeFlags = JSCompiler_temp.subtreeFlags & 65011712, null !== instance ? JSCompiler_object_inline_componentStack_2453 = createWorkInProgress(
              instance,
              JSCompiler_object_inline_componentStack_2453
            ) : (JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
              JSCompiler_object_inline_componentStack_2453,
              JSCompiler_object_inline_message_2450,
              renderLanes2,
              null
            ), JSCompiler_object_inline_componentStack_2453.flags |= 2), JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_message_2450 = current2.child.memoizedState, null === JSCompiler_object_inline_message_2450 ? JSCompiler_object_inline_message_2450 = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp = JSCompiler_object_inline_message_2450.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? { parent: instance, pool: instance } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2450 = {
              baseLanes: JSCompiler_object_inline_message_2450.baseLanes | renderLanes2,
              cachePool: JSCompiler_temp
            }), JSCompiler_object_inline_componentStack_2453.memoizedState = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2451,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2452.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2451 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2451 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2451.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          offscreenProps.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          };
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function validateSuspenseListNestedChild(childSlot, index3) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index3,
            isAnArray
          ), false) : true;
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
          nextProps = nextProps.children;
          if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder])
            if (didWarnAboutRevealOrder[revealOrder] = true, "string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                revealOrder
              );
          void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = true, console.error(
            '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
            tailMode
          )) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = true, console.error(
            '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
            tailMode
          )));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && false !== nextProps)
            if (isArrayImpl(nextProps))
              for (var i = 0; i < nextProps.length; i++) {
                if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
              }
            else if (i = getIteratorFn(nextProps), "function" === typeof i) {
              if (i = i.call(nextProps))
                for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          nextProps = suspenseStackCursor.current;
          if (0 !== (nextProps & ForceSuspenseFallback))
            nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;
          else {
            if (null !== current2 && 0 !== (current2.flags & 128))
              a: for (current2 = workInProgress2.child; null !== current2; ) {
                if (13 === current2.tag)
                  null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(
                    current2,
                    renderLanes2,
                    workInProgress2
                  );
                else if (19 === current2.tag)
                  scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
                else if (null !== current2.child) {
                  current2.child.return = current2;
                  current2 = current2.child;
                  continue;
                }
                if (current2 === workInProgress2) break a;
                for (; null === current2.sibling; ) {
                  if (null === current2.return || current2.return === workInProgress2)
                    break a;
                  current2 = current2.return;
                }
                current2.sibling.return = current2.return;
                current2 = current2.sibling;
              }
            nextProps &= SubtreeSuspenseContextMask;
          }
          push(suspenseStackCursor, nextProps, workInProgress2);
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode
              );
              break;
            case "backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode
              );
              break;
            case "together":
              initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
            case 23:
              return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                current2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    current2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = current2; current2; )
                      current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (current2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = current2 : isHydrating || (current2 = workInProgress2.type, renderLanes2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(current2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = renderLanes2, setInitialProperties(returnFiber, current2, renderLanes2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), returnFiber = renderLanes2.ancestorInfo.current, current2 = null != returnFiber ? validateTextNesting(
                current2,
                returnFiber.tag,
                renderLanes2.ancestorInfo.implicitRootScope
              ) : true, renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return returnFiber = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, returnFiber = {
                mode: returnFiber.mode,
                children: returnFiber.children
              }, null === current2 ? (current2 = mountWorkInProgressOffscreenFiber(
                returnFiber,
                renderLanes2
              ), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2) : (current2 = createWorkInProgress(current2.child, returnFiber), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2), workInProgress2;
            case 22:
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache2(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
            resource = suspenseHandlerStackCursor.current;
            if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
            workInProgress2.flags |= 8192;
          }
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 31:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              return renderLanes2 = workInProgress2.memoizedState, null === current2 ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              var _type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  _type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              renderLanes2 = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                _type = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _type);
                else {
                  current2 = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(renderLanes2, _type.ancestorInfo);
                  _type = _type.context;
                  current2 = getOwnerDocumentFromRootContainer(current2);
                  switch (_type) {
                    case HostContextNamespaceSvg:
                      current2 = current2.createElementNS(SVG_NAMESPACE, renderLanes2);
                      break;
                    case HostContextNamespaceMath:
                      current2 = current2.createElementNS(
                        MATH_NAMESPACE,
                        renderLanes2
                      );
                      break;
                    default:
                      switch (renderLanes2) {
                        case "svg":
                          current2 = current2.createElementNS(
                            SVG_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "math":
                          current2 = current2.createElementNS(
                            MATH_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "script":
                          current2 = current2.createElement("div");
                          current2.innerHTML = "<script><\/script>";
                          current2 = current2.removeChild(current2.firstChild);
                          break;
                        case "select":
                          current2 = "string" === typeof newProps.is ? current2.createElement("select", { is: newProps.is }) : current2.createElement("select");
                          newProps.multiple ? current2.multiple = true : newProps.size && (current2.size = newProps.size);
                          break;
                        default:
                          current2 = "string" === typeof newProps.is ? current2.createElement(renderLanes2, {
                            is: newProps.is
                          }) : current2.createElement(renderLanes2), -1 === renderLanes2.indexOf("-") && (renderLanes2 !== renderLanes2.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            renderLanes2
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current2) || hasOwnProperty2.call(
                            warnedUnknownTags,
                            renderLanes2
                          ) || (warnedUnknownTags[renderLanes2] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            renderLanes2
                          )));
                      }
                  }
                  current2[internalInstanceKey] = workInProgress2;
                  current2[internalPropsKey] = newProps;
                  a: for (_type = workInProgress2.child; null !== _type; ) {
                    if (5 === _type.tag || 6 === _type.tag)
                      current2.appendChild(_type.stateNode);
                    else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                      _type.child.return = _type;
                      _type = _type.child;
                      continue;
                    }
                    if (_type === workInProgress2) break a;
                    for (; null === _type.sibling; ) {
                      if (null === _type.return || _type.return === workInProgress2)
                        break a;
                      _type = _type.return;
                    }
                    _type.sibling.return = _type.return;
                    _type = _type.sibling;
                  }
                  workInProgress2.stateNode = current2;
                  a: switch (setInitialProperties(current2, renderLanes2, newProps), renderLanes2) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      current2 = !!newProps.autoFocus;
                      break a;
                    case "img":
                      current2 = true;
                      break a;
                    default:
                      current2 = false;
                  }
                  current2 && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              workInProgress2.flags &= -16777217;
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  _type = !didSuspendOrErrorDEV;
                  newProps = null;
                  var returnFiber = hydrationParentFiber;
                  if (null !== returnFiber)
                    switch (returnFiber.tag) {
                      case 3:
                        _type && (_type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== _type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
                        break;
                      case 27:
                      case 5:
                        newProps = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== _type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = _type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2);
                } else
                  _type = renderLanes2.ancestorInfo.current, null != _type && validateTextNesting(
                    newProps,
                    _type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                _type = popHydrationState(workInProgress2);
                if (null !== newProps && null !== newProps.dehydrated) {
                  if (null === current2) {
                    if (!_type)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    _type = workInProgress2.memoizedState;
                    _type = null !== _type ? _type.dehydrated : null;
                    if (!_type)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    _type[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  _type = false;
                } else
                  _type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = _type), _type = true;
                if (!_type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, _type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (_type = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== _type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              _type = workInProgress2.memoizedState;
              if (null === _type) return bubbleProperties(workInProgress2), null;
              newProps = 0 !== (workInProgress2.flags & 128);
              returnFiber = _type.rendering;
              if (null === returnFiber)
                if (newProps) cutOffTailIfNeeded(_type, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      returnFiber = findFirstSuspended(current2);
                      if (null !== returnFiber) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(_type, false);
                        current2 = returnFiber.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!newProps)
                  if (current2 = findFirstSuspended(returnFiber), null !== current2) {
                    if (workInProgress2.flags |= 128, newProps = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(_type, true), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                _type.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current2 = _type.last, null !== current2 ? current2.sibling = returnFiber : workInProgress2.child = returnFiber, _type.last = returnFiber);
              }
              if (null !== _type.tail)
                return current2 = _type.tail, _type.rendering = current2, _type.tail = current2.sibling, _type.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProps ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                  finishedWork
                ) : (flags & Layout3) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                  finishedWork
                ), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout3) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout3) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n2, a) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n2,
                        a
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy2 = inst.destroy;
                  void 0 !== destroy2 && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                    finishedWork
                  ) : (flags & Layout3) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                    finishedWork
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy2
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout3) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps,
              finishedWork.elementType === finishedWork.type
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(
            finishedWork.memoizedProps.id,
            current2,
            effectDuration,
            commitStartTime2
          );
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type5 = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type5,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
          var tag = node2.tag;
          if (5 === tag || 6 === tag)
            node2 = node2.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node2, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node2), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode, before = null), node2 = node2.child, null !== node2))
            for (insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling; null !== node2; )
              insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling;
        }
        function insertOrAppendPlacementNode(node2, before, parent) {
          var tag = node2.tag;
          if (5 === tag || 6 === tag)
            node2 = node2.stateNode, before ? parent.insertBefore(node2, before) : parent.appendChild(node2);
          else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode), node2 = node2.child, null !== node2))
            for (insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling; null !== node2; )
              insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitBeforeMutationEffects(root3, firstChild) {
          root3 = root3.containerInfo;
          eventsEnabled = _enabled;
          root3 = getActiveElementDeep(root3);
          if (hasSelectionCapabilities(root3)) {
            if ("selectionStart" in root3)
              var JSCompiler_temp = {
                start: root3.selectionStart,
                end: root3.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length2 = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node2 = root3, parentNode = null;
                  b: for (; ; ) {
                    for (var next2; ; ) {
                      node2 !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node2.nodeType || (start = length2 + anchorOffset);
                      node2 !== focusNode || 0 !== selection && 3 !== node2.nodeType || (end = length2 + selection);
                      3 === node2.nodeType && (length2 += node2.nodeValue.length);
                      if (null === (next2 = node2.firstChild)) break;
                      parentNode = node2;
                      node2 = next2;
                    }
                    for (; ; ) {
                      if (node2 === root3) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length2);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length2);
                      if (null !== (next2 = node2.nextSibling)) break;
                      node2 = parentNode;
                      parentNode = node2.parentNode;
                    }
                    node2 = next2;
                  }
                  JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root3,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root3)
              root3.return = firstChild, nextEffect = root3;
            else
              for (; null !== nextEffect; ) {
                root3 = firstChild = nextEffect;
                JSCompiler_temp = root3.alternate;
                anchorOffset = root3.flags;
                switch (root3.tag) {
                  case 0:
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root3, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root3 = root3.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root3);
                      else if (1 === JSCompiler_temp)
                        switch (root3.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root3);
                            break;
                          default:
                            root3.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root3 = firstChild.sibling;
                if (null !== root3) {
                  root3.return = firstChild.return;
                  nextEffect = root3;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout3 | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              null === current2 && flags & 4 && commitHostMount(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              offscreenSubtreeWasHidden || commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout3
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var root3 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              root3 = deletedFiber;
              returnFiber = root3.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root3.return = null;
            }
          if (parentFiber.subtreeFlags & 13878)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root3) {
          var current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout3 | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current2 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current2 ? flags : current2.concat(flags))));
              break;
            case 26:
              var hoistableRoot = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4)
                if (root3 = null !== current2 ? current2.memoizedState : null, flags = finishedWork.memoizedState, null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        root3 = hoistableRoot.ownerDocument || hoistableRoot;
                        b: switch (flags) {
                          case "title":
                            hoistableRoot = root3.getElementsByTagName("title")[0];
                            if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop"))
                              hoistableRoot = root3.createElement(flags), root3.head.insertBefore(
                                hoistableRoot,
                                root3.querySelector("head > title")
                              );
                            setInitialProperties(hoistableRoot, flags, current2);
                            hoistableRoot[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(hoistableRoot);
                            flags = hoistableRoot;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              root3
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && hoistableRoot.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && hoistableRoot.getAttribute("title") === (null == current2.title ? null : current2.title) && hoistableRoot.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root3.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current2);
                            root3.head.appendChild(hoistableRoot);
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              root3
                            ).get(flags + (current2.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), hoistableRoot.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && hoistableRoot.getAttribute("name") === (null == current2.name ? null : current2.name) && hoistableRoot.getAttribute("property") === (null == current2.property ? null : current2.property) && hoistableRoot.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root3.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current2);
                            root3.head.appendChild(hoistableRoot);
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        hoistableRoot[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(hoistableRoot);
                        flags = hoistableRoot;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      hoistableRoot,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  root3 !== flags ? (null === root3 ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : root3.count--, null === flags ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              break;
            case 27:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                root3 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(finishedWork, resetTextContent, root3);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (root3 = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                root3,
                null !== current2 ? current2.memoizedProps : root3
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                root3 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    root3,
                    current2,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              hoistableRoot = pushNestedEffectDurations();
              tagCaches = null;
              maybeNodes = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root3.containerInfo);
              recursivelyTraverseMutationEffects(root3, finishedWork);
              currentHoistableRoot = maybeNodes;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root3.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root3.effectDuration += popNestedEffectDurations(hoistableRoot);
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 13:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              hoistableRoot = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root3, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & ~OffscreenVisible : root3._visibility | OffscreenVisible, hoistableRoot && (null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current2 = null, root3 = finishedWork; ; ) {
                  if (5 === root3.tag || 26 === root3.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root3;
                      try {
                        maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root3.tag) {
                    if (null === current2) {
                      wasHidden = root3;
                      try {
                        i = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          i,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                    root3.child.return = root3;
                    root3 = root3.child;
                    continue;
                  }
                  if (root3 === finishedWork) break a;
                  for (; null === root3.sibling; ) {
                    if (null === root3.return || root3.return === finishedWork)
                      break a;
                    current2 === root3 && (current2 = null);
                    root3 = root3.return;
                  }
                  current2 === root3 && (current2 = null);
                  root3.sibling.return = root3.return;
                  root3 = root3.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root3, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout3
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout3);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveMountOnFiber(
                root3,
                parentFiber,
                committedLanes,
                committedTransitions
              ), parentFiber = parentFiber.sibling;
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
              break;
            case 13:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              break;
            case 23:
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              var _current = finishedWork.alternate;
              null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256)
              ));
              flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
          }
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitCachePassiveMountEffect(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
              }
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(fiber);
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(fiber);
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(fiber);
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(fiber);
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber;
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (current2 = current2.memoizedState.cachePool.pool, null != current2 && retainCache(current2));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                var sibling = current2.sibling, returnFiber = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== sibling) {
                  sibling.return = returnFiber;
                  nextEffect = sibling;
                  break a;
                }
                nextEffect = returnFiber;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
          var suspenseHandler = suspenseHandlerStackCursor.current;
          null !== suspenseHandler && (suspenseHandler.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root3, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root3 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root3.cancelPendingCommit)
            prepareFreshStack(root3, 0), markRootSuspended(
              root3,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root3, lane);
          if (0 !== (executionContext & RenderContext) && root3 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root3 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root3) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root3), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root3,
                    root3
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root3, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root3 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root3,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root3);
        }
        function performWorkOnRoot(root3, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root3.expiredLanes) || checkIfRootIsPrerendering(root3, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes, true), renderWasConcurrent = shouldTimeSlice;
          do {
            if (exitStatus === RootInProgress) {
              workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root3, lanes, 0, false);
              break;
            } else {
              forceSync = root3.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                exitStatus = renderRootSync(root3, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (exitStatus === RootErrored) {
                renderWasConcurrent = lanes;
                if (root3.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root3.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  lanes = errorRetryLanes;
                  a: {
                    exitStatus = root3;
                    var errorRetryLanes$jscomp$0 = errorRetryLanes;
                    errorRetryLanes = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(
                      exitStatus,
                      errorRetryLanes$jscomp$0
                    ).flags |= 256);
                    errorRetryLanes$jscomp$0 = renderRootSync(
                      exitStatus,
                      errorRetryLanes$jscomp$0,
                      false
                    );
                    if (errorRetryLanes$jscomp$0 !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                        workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                        exitStatus = RootSuspendedWithDelay;
                        break a;
                      }
                      exitStatus = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = errorRetryLanes;
                      null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        exitStatus
                      ));
                    }
                    exitStatus = errorRetryLanes$jscomp$0;
                  }
                  renderWasConcurrent = false;
                  if (exitStatus !== RootErrored) continue;
                }
              }
              if (exitStatus === RootFatalErrored) {
                prepareFreshStack(root3, 0);
                markRootSuspended(root3, lanes, 0, true);
                break;
              }
              a: {
                shouldTimeSlice = root3;
                switch (exitStatus) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    shouldTimeSlice,
                    forceSync,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                    shouldTimeSlice.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        shouldTimeSlice,
                        forceSync,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        exitStatus,
                        THROTTLED_COMMIT,
                        renderStartTime,
                        0
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    exitStatus,
                    IMMEDIATE_COMMIT,
                    renderStartTime,
                    0
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root3);
        }
        function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root3.timeoutHandle = noTimeout;
          suspendedCommitReason = finishedWork.subtreeFlags;
          if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
            if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop7 }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
              root3.cancelPendingCommit = suspendedCommitReason(
                commitRoot.bind(
                  null,
                  root3,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  SUSPENDED_COMMIT,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root3,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root3,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node2 = finishedWork; ; ) {
            var tag = node2.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node2.flags & 16384 && (tag = node2.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node2.child;
            if (node2.subtreeFlags & 16384 && null !== tag)
              tag.return = node2, node2 = tag;
            else {
              if (node2 === finishedWork) break;
              for (; null === node2.sibling; ) {
                if (null === node2.return || node2.return === finishedWork) return true;
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root3.suspendedLanes |= suspendedLanes;
          root3.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root3.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index3 = 31 - clz32(lanes), lane = 1 << index3;
            didAttemptEntireTree[index3] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function prepareFreshStack(root3, lanes) {
          var timeoutHandle = root3.timeoutHandle;
          timeoutHandle !== noTimeout && (root3.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
          timeoutHandle = root3.cancelPendingCommit;
          null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
          resetWorkInProgressStack();
          workInProgressRoot = root3;
          workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          var allEntangledLanes = root3.entangledLanes;
          if (0 !== allEntangledLanes)
            for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
              var index3 = 31 - clz32(allEntangledLanes), lane = 1 << index3;
              lanes |= root3[index3];
              allEntangledLanes &= ~lane;
            }
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          lanes = getCurrentTime();
          1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
          ReactStrictModeWarnings.discardPendingWarnings();
          return timeoutHandle;
        }
        function handleThrow(root3, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          if (null === erroredWork)
            workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
          else
            switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
              case SuspendedOnError:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
                break;
              case SuspendedOnData:
              case SuspendedOnAction:
              case SuspendedOnImmediate:
              case SuspendedOnDeprecatedThrowPromise:
              case SuspendedAndReadyToContinue:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
            }
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root3, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root3, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root3, lanes);
          }
          markRenderStarted(lanes);
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root3, thrownValue$8);
            }
          while (1);
          lanes && root3.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          markRenderStopped();
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root3, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root3, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root3, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root3, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root3,
              lanes
            );
          markRenderStarted(lanes);
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root3 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root3);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : 1) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root3,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root3, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress)
            return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
          markRenderStopped();
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next2 = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState = null;
          thenableIndexCounter = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root3,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root3,
                createCapturedValueAtFiber(thrownValue, root3.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root3 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root3 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root3);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next2 = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next2) {
              next2.flags &= 32767;
              workInProgress = next2;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next2 = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next2 += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next2;
            }
            next2 = unitOfWork.return;
            null !== next2 && (next2.flags |= 32768, next2.subtreeFlags = 0, next2.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next2;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
          root3.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);
          if (null === finishedWork) markCommitStopped();
          else {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root3.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root3,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root3;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              flushPassiveEffects(true);
              return null;
            })) : (root3.callbackNode = null, root3.callbackPriority = 0);
            commitStartTime = now2();
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root3, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root3;
                commitMutationEffectsOnFiber(finishedWork, root3);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start = priorSelectionRange.start, end = priorSelectionRange.end;
                    void 0 === end && (end = start);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length2 = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length2
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length2);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range3 = doc.createRange();
                          range3.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range3), selection.extend(endMarker.node, endMarker.offset)) : (range3.setEnd(endMarker.node, endMarker.offset), selection.addRange(range3));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root3.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
            if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root3, commitLayoutEffectOnFiber(
                  root3,
                  finishedWork.alternate,
                  finishedWork
                ), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = root3.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root3);
            rootDidHavePassiveEffects = lanesToEventPriority(lanes);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (rootDidHavePassiveEffects) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            isDevToolsPresent && root3.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== recoverableErrors) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = root3.onRecoverableError;
                for (finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) {
                  var recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(root3);
            remainingLanes = root3.pendingLanes;
            0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3)) : nestedUpdateCount = 0;
            flushSyncWorkAcrossRoots_impl(0, false);
            markCommitStopped();
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root3, remainingLanes) {
          0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects(wasDelayedCommit) {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects(wasDelayedCommit);
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            priority = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountOnFiber(root$jscomp$0.current);
            commitPassiveMountOnFiber(
              root$jscomp$0,
              root$jscomp$0.current,
              lanes,
              priority
            );
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
            commitDoubleInvokeEffectsInDEV(root$jscomp$0);
            executionContext = prevExecutionContext;
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            var stateNode = root$jscomp$0.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root3, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root3, wakeable, lanes) {
          var pingCache = root3.pingCache;
          if (null === pingCache) {
            pingCache = root3.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root3, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root3, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root3, wakeable, pingedLanes) {
          var pingCache = root3.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
          root3.warmLanes &= ~pingedLanes;
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root3);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root3 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root3,
                fiber,
                (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root3,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root3,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root3,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root3, fiber) {
          var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root3, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root3, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root3) {
          var doubleInvokeEffects = true;
          root3.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root3,
            root3.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root3, lanes) {
          isDevToolsPresent && root3.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root3, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root3) {
          root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root3 = firstScheduledRoot; null !== root3; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root3.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root3, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root3,
                      root3 === workInProgressRoot ? nextLanes : 0,
                      null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root3, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root3, nextLanes));
                root3 = root3.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
          for (var currentTime = now$1(), prev2 = null, root3 = firstScheduledRoot; null !== root3; ) {
            var next2 = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
            if (0 === nextLanes)
              root3.next = null, null === prev2 ? firstScheduledRoot = next2 : prev2.next = next2, null === next2 && (lastScheduledRoot = prev2);
            else if (prev2 = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root3 = next2;
          }
          flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
        }
        function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
          for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
            var index3 = 31 - clz32(lanes), lane = 1 << index3, expirationTime = expirationTimes[index3];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index3] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root3,
            root3 === currentTime ? suspendedLanes : 0,
            null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
          );
          pingedLanes = root3.callbackNode;
          if (0 === suspendedLanes || root3 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root3.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root3.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root3.callbackPriority = currentTime;
            root3.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root3.callbackPriority = 2;
          root3.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root3.callbackNode = null, root3.callbackPriority = 0, null;
          var originalCallbackNode = root3.callbackNode;
          if (flushPendingEffects(true) && root3.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root3,
            root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root3.cancelPendingCommit || root3.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root3,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root3, now$1());
          return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
        }
        function performSyncWorkOnRoot(root3, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root3, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement("input");
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = SyntheticEventCtor;
                        reactEventName = reactEventType;
                        instance = 0;
                        for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                          instance++;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))
                          lastHostComponent++;
                        for (; 0 < instance - lastHostComponent; )
                          inCapturePhase = getParent(inCapturePhase), instance--;
                        for (; 0 < lastHostComponent - instance; )
                          reactEventName = getParent(reactEventName), lastHostComponent--;
                        for (; instance--; ) {
                          if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                            break b;
                          inCapturePhase = getParent(inCapturePhase);
                          reactEventName = getParent(reactEventName);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type5, props) {
          validateProperties$2(type5, props);
          "input" !== type5 && "textarea" !== type5 && "select" !== type5 || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type5 && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type5
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type5
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type5) || "string" === typeof props.is || warnUnknownProperties(type5, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function noop$1() {
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              track(domElement);
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              track(domElement);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type5 = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type5 = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type5,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type5 in lastProps)
                if (lastDefaultValue = lastProps[type5], lastProps.hasOwnProperty(type5) && null != lastDefaultValue)
                  switch (type5) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type5) || setProp(
                        domElement,
                        tag,
                        type5,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type5 = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type5 || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type5;
                      break;
                    case "defaultValue":
                      defaultValue = type5;
                      break;
                    case "multiple":
                      value = type5;
                    default:
                      type5 !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type5,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type5 = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type5))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type5 && setProp(domElement, tag, value, name, nextProps, type5);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i = 0; i < domElement.length; i++) {
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter2 = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter2 + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter2 + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter2 + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter2 = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes2 = domElement.attributes, i = 0; i < attributes2.length; i++)
            switch (attributes2[i].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes2[i].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes2 = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes2,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes2 = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes2,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes2 = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes2,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes2 = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes2 !== propKey && (serverDifferences[value] = { __html: attributes2 }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes2 = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes2,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes2 = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes2 === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i = domElement;
                        var attributeName = attributes2 = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes2), i === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes2,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i = domElement;
                        attributeName = attributes2 = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes2), i === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes2,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes2 = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes2 = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i,
                              serverDifferences$jscomp$0
                            ), i = attributeName === "" + i ? i : attributeName;
                          else {
                            switch (typeof i) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i = void 0 === i ? void 0 : null;
                          }
                        else i = void 0;
                        attributes2 || warnForPropDifference(
                          value,
                          i,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type5) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type5) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type5 ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type5, props) {
          return "textarea" === type5 || "noscript" === type5 || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type5, newProps) {
          switch (type5) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitUpdate(domElement, type5, oldProps, newProps) {
          updateProperties(domElement, type5, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function isSingletonScope(type5) {
          return "head" === type5;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node2 = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
          do {
            var nextNode = node2.nextSibling;
            parentInstance.removeChild(node2);
            if (nextNode && 8 === nextNode.nodeType)
              if (node2 = nextNode.data, node2 === SUSPENSE_END_DATA) {
                if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                  node2 = possiblePreambleContribution;
                  var ownerDocument = parentInstance.ownerDocument;
                  node2 & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);
                  node2 & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);
                  if (node2 & PREAMBLE_CONTRIBUTION_HEAD)
                    for (node2 = ownerDocument.head, releaseSingletonInstance(node2), ownerDocument = node2.firstChild; ownerDocument; ) {
                      var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                      ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node2.removeChild(ownerDocument);
                      ownerDocument = nextNode$jscomp$0;
                    }
                }
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                }
                depth--;
              } else
                node2 === SUSPENSE_START_DATA || node2 === SUSPENSE_PENDING_START_DATA || node2 === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node2.charCodeAt(0) - 48;
            else possiblePreambleContribution = 0;
            node2 = nextNode;
          } while (node2);
          retryIfBlockedOn(suspenseInstance);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node2 = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node2.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node2);
                detachDeletedInstance(node2);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node2.rel.toLowerCase()) continue;
            }
            container.removeChild(node2);
          }
        }
        function canHydrateInstance(instance, type5, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type5.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type5 && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type5) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node2) {
          for (; null != node2; node2 = node2.nextSibling) {
            var nodeType = node2.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node2.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA) return null;
            }
          }
          return node2;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes2 = instance.attributes, i = 0; i < attributes2.length; i++) {
              var attr = attributes2[i];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          suspenseInstance = suspenseInstance.nextSibling;
          for (var depth = 0; suspenseInstance; ) {
            if (8 === suspenseInstance.nodeType) {
              var data = suspenseInstance.data;
              if (data === SUSPENSE_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(suspenseInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
            }
            suspenseInstance = suspenseInstance.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else data === SUSPENSE_END_DATA && depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type5, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type5, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type5) {
            case "html":
              type5 = props.documentElement;
              if (!type5)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type5;
            case "head":
              type5 = props.head;
              if (!type5)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type5;
            case "body":
              type5 = props.body;
              if (!type5)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type5;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type5, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type5) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type5, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes2 = instance.attributes; attributes2.length; )
            instance.removeAttributeNode(attributes2[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type5, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type5) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type5 = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type5);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type5, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type5)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type5))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type5, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type5,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type5 + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty2.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty2.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty2.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign2({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign2({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign2({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root3) {
          for (var nodes = root3.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
            var node2 = nodes[i];
            if (node2.dataset.precedence === precedence) prior = node2;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type5, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache);
          } else
            caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
          if (cache.has(type5)) return cache;
          cache.set(type5, null);
          ownerDocument = ownerDocument.getElementsByTagName(type5);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node2 = ownerDocument[caches];
            if (!(node2[internalHoistableMarker] || node2[internalInstanceKey] || "link" === type5 && "stylesheet" === node2.getAttribute("rel")) && node2.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node2.getAttribute(keyAttribute) || "";
              nodeKey = type5 + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node2) : cache.set(nodeKey, [node2]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type5, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type5 ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type5, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type5 && "title" !== type5 && "style" !== type5 && "link" !== type5 && "script" !== type5 || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type5,
              type5
            ), false;
          switch (type5) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type5 = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type5,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type5 = props.precedence, props = props.disabled, "string" !== typeof type5 && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type5 && null == props;
                default:
                  return true;
              }
            case "script":
              type5 = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type5 || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type5 ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type5
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function noop7() {
        }
        function suspendResource(hoistableRoot, resource, props) {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady() {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, 6e4);
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root3, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root3);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root3, precedences);
              for (var nodes = root3.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i = 0; i < nodes.length; i++) {
                var node2 = nodes[i];
                if ("LINK" === node2.nodeName || "not all" !== node2.getAttribute("media"))
                  precedences.set(node2.dataset.precedence, node2), last = node2;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node2 = nodes.getAttribute("data-precedence");
            i = precedences.get(node2) || last;
            i === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node2, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          isDevToolsPresent && (tag |= ProfileMode);
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache2();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag) {
            var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function getLaneLabelMap() {
          for (var map = /* @__PURE__ */ new Map(), lane = 1, index3 = 0; 31 > index3; index3++) {
            var label = getLabelForLane(lane);
            map.set(lane, label);
            lane *= 2;
          }
          return map;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root3 = fiber;
                          root3.pendingLanes |= 2;
                          for (root3.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root3.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 13:
                      root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    if (13 === nearestMounted.tag) {
                      var lane = requestUpdateLane(nearestMounted);
                      lane = getBumpedLaneForHydrationByLane(lane);
                      var root3 = enqueueConcurrentRenderForLane(
                        nearestMounted,
                        lane
                      );
                      null !== root3 && scheduleUpdateOnFiber(root3, nearestMounted, lane);
                      markRetryLaneIfNotHydrated(nearestMounted, lane);
                    }
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i = 0; i < formReplayingQueue.length; i += 3) {
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
            attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React404 = require_react(), ReactDOM6 = require_react_dom(), assign2 = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React404.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM6.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty2 = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e3) {
            passiveBrowserEventsSupported = false;
          }
        var root2 = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign2({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign2({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign2({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign2({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign2({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign2({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign2({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign2({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign2({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign2({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign2({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign2({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign2({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes2 = {
          animationend: makePrefixMap2("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap2("Animation", "AnimationIteration"),
          animationstart: makePrefixMap2("Animation", "AnimationStart"),
          transitionrun: makePrefixMap2("Transition", "TransitionRun"),
          transitionstart: makePrefixMap2("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap2("Transition", "TransitionCancel"),
          transitionend: makePrefixMap2("Transition", "TransitionEnd")
        }, prefixedEventNames2 = {}, style2 = {};
        canUseDOM && (style2 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes2.animationend.animation, delete vendorPrefixes2.animationiteration.animation, delete vendorPrefixes2.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes2.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName2("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName2("animationiteration"), ANIMATION_START = getVendorPrefixedEventName2("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName2("transitionrun"), TRANSITION_START = getVendorPrefixedEventName2("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName2("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName2("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type5, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now2 = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node2 = fiber; null !== node2; )
            node2.mode & StrictLegacyMode && (strictRoot = node2), node2 = node2.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node2 = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node2 && (node2 = [], pendingLegacyContextWarning.set(strictRoot, node2)), node2.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, NoFlags = 0, HasEffect = 1, Insertion = 2, Layout3 = 4, Passive = 8, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(createDeps);
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout3, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout3, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout3, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout3, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        var callComponent = {
          react_stack_bottom_frame: function(Component9, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component9(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
          react_stack_bottom_frame: function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
          callComponentDidMount
        ), callComponentDidUpdate = {
          react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
          callComponentDidUpdate
        ), callComponentDidCatch = {
          react_stack_bottom_frame: function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
          callComponentDidCatch
        ), callComponentWillUnmount = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
          callComponentWillUnmount
        ), callCreate = {
          react_stack_bottom_frame: function(effect) {
            null != effect.resourceKind && console.error(
              "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
              effect.resourceKind
            );
            var create = effect.create;
            effect = effect.inst;
            create = create();
            return effect.destroy = create;
          }
        }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy2) {
            try {
              destroy2();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), thenableState = null, thenableIndexCounter = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
          }
        }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = 1, PREAMBLE_CONTRIBUTION_BODY = 2, PREAMBLE_CONTRIBUTION_HEAD = 4, FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_COMPLETE = "complete", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign2(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign2({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign2({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign2(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject) {
                    link.onload = resolve;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign2({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind2 = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path2, value) {
          id = findHook(fiber, id);
          null !== id && (path2 = copyWithSetImpl(id.memoizedState, path2, 0, value), id.memoizedState = path2, id.baseState = path2, fiber.memoizedProps = assign2({}, fiber.memoizedProps), path2 = enqueueConcurrentRenderForLane(fiber, 2), null !== path2 && scheduleUpdateOnFiber(path2, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path2) {
          id = findHook(fiber, id);
          null !== id && (path2 = copyWithDeleteImpl(id.memoizedState, path2, 0), id.memoizedState = path2, id.baseState = path2, fiber.memoizedProps = assign2({}, fiber.memoizedProps), path2 = enqueueConcurrentRenderForLane(fiber, 2), null !== path2 && scheduleUpdateOnFiber(path2, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign2({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path2, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path2, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path2 && scheduleUpdateOnFiber(path2, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path2) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path2, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path2 && scheduleUpdateOnFiber(path2, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root3 = this._internalRoot;
          if (null === root3) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root3.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root3, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React404.version;
          if ("19.1.1" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.1\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!function() {
          var internals = {
            bundleType: 1,
            version: "19.1.1",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.1.1"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          internals.getLaneLabelMap = getLaneLabelMap;
          internals.injectProfilingHooks = injectProfilingHooks;
          return injectInternals(internals);
        }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            null
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            formState
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.1.1";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module2) {
      "use strict";
      if (false) {
        checkDCE();
        module2.exports = null;
      } else {
        module2.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module2) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        function classNames146() {
          var classes = "";
          for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              classes = appendClass(classes, parseValue(arg));
            }
          }
          return classes;
        }
        function parseValue(arg) {
          if (typeof arg === "string" || typeof arg === "number") {
            return arg;
          }
          if (typeof arg !== "object") {
            return "";
          }
          if (Array.isArray(arg)) {
            return classNames146.apply(null, arg);
          }
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            return arg.toString();
          }
          var classes = "";
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes = appendClass(classes, key);
            }
          }
          return classes;
        }
        function appendClass(value, newClass) {
          if (!newClass) {
            return value;
          }
          if (value) {
            return value + " " + newClass;
          }
          return value + newClass;
        }
        if (typeof module2 !== "undefined" && module2.exports) {
          classNames146.default = classNames146;
          module2.exports = classNames146;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames146;
          });
        } else {
          window.classNames = classNames146;
        }
      })();
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type5) {
            if (typeof type5 === "string" || typeof type5 === "function") {
              return true;
            }
            if (type5 === REACT_FRAGMENT_TYPE2 || type5 === REACT_PROFILER_TYPE || enableDebugTracing || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type5 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type5 === "object" && type5 !== null) {
              if (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type5.$$typeof === REACT_MODULE_REFERENCE || type5.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function typeOf(object4) {
            if (typeof object4 === "object" && object4 !== null) {
              var $$typeof = object4.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type5 = object4.type;
                  switch (type5) {
                    case REACT_FRAGMENT_TYPE2:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                    case REACT_SUSPENSE_LIST_TYPE:
                      return type5;
                    default:
                      var $$typeofType = type5 && type5.$$typeof;
                      switch ($$typeofType) {
                        case REACT_SERVER_CONTEXT_TYPE:
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element3 = REACT_ELEMENT_TYPE;
          var ForwardRef2 = REACT_FORWARD_REF_TYPE;
          var Fragment24 = REACT_FRAGMENT_TYPE2;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal2 = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          var hasWarnedAboutDeprecatedIsConcurrentMode = false;
          function isAsyncMode(object4) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
              }
            }
            return false;
          }
          function isConcurrentMode(object4) {
            {
              if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                hasWarnedAboutDeprecatedIsConcurrentMode = true;
                console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
              }
            }
            return false;
          }
          function isContextConsumer(object4) {
            return typeOf(object4) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object4) {
            return typeOf(object4) === REACT_PROVIDER_TYPE;
          }
          function isElement(object4) {
            return typeof object4 === "object" && object4 !== null && object4.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object4) {
            return typeOf(object4) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment3(object4) {
            return typeOf(object4) === REACT_FRAGMENT_TYPE2;
          }
          function isLazy(object4) {
            return typeOf(object4) === REACT_LAZY_TYPE;
          }
          function isMemo2(object4) {
            return typeOf(object4) === REACT_MEMO_TYPE;
          }
          function isPortal(object4) {
            return typeOf(object4) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object4) {
            return typeOf(object4) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object4) {
            return typeOf(object4) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object4) {
            return typeOf(object4) === REACT_SUSPENSE_TYPE;
          }
          function isSuspenseList(object4) {
            return typeOf(object4) === REACT_SUSPENSE_LIST_TYPE;
          }
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element3;
          exports.ForwardRef = ForwardRef2;
          exports.Fragment = Fragment24;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal2;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.SuspenseList = SuspenseList;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment3;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo2;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isSuspenseList = isSuspenseList;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_is_development();
      }
    }
  });

  // public/js/main.js
  var import_react125 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // public/js/components/Dashboard.tsx
  var import_react124 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t2 = arguments[e3];
        for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
      }
      return n2;
    }, _extends.apply(null, arguments);
  }

  // node_modules/rc-resize-observer/es/index.js
  var React7 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(o3) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
      return typeof o4;
    } : function(o4) {
      return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
    }, _typeof(o3);
  }

  // node_modules/rc-util/es/React/isFragment.js
  var REACT_ELEMENT_TYPE_18 = Symbol.for("react.element");
  var REACT_ELEMENT_TYPE_19 = Symbol.for("react.transitional.element");
  var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function isFragment(object4) {
    return (
      // Base object type
      object4 && _typeof(object4) === "object" && // React Element type
      (object4.$$typeof === REACT_ELEMENT_TYPE_18 || object4.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
      object4.type === REACT_FRAGMENT_TYPE
    );
  }

  // node_modules/rc-util/es/Children/toArray.js
  var import_react = __toESM(require_react());
  function toArray(children) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var ret = [];
    import_react.default.Children.forEach(children, function(child) {
      if ((child === void 0 || child === null) && !option.keepEmpty) {
        return;
      }
      if (Array.isArray(child)) {
        ret = ret.concat(toArray(child));
      } else if (isFragment(child) && child.props) {
        ret = ret.concat(toArray(child.props.children, option));
      } else {
        ret.push(child);
      }
    });
    return ret;
  }

  // node_modules/rc-util/es/warning.js
  var warned = {};
  var preWarningFns = [];
  var preMessage = function preMessage2(fn) {
    preWarningFns.push(fn);
  };
  function warning(valid, message2) {
    if (!valid && console !== void 0) {
      var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
        return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "warning");
      }, message2);
      if (finalMessage) {
        console.error("Warning: ".concat(finalMessage));
      }
    }
  }
  function note(valid, message2) {
    if (!valid && console !== void 0) {
      var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
        return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "note");
      }, message2);
      if (finalMessage) {
        console.warn("Note: ".concat(finalMessage));
      }
    }
  }
  function resetWarned() {
    warned = {};
  }
  function call(method4, valid, message2) {
    if (!valid && !warned[message2]) {
      method4(false, message2);
      warned[message2] = true;
    }
  }
  function warningOnce(valid, message2) {
    call(warning, valid, message2);
  }
  function noteOnce(valid, message2) {
    call(note, valid, message2);
  }
  warningOnce.preMessage = preMessage;
  warningOnce.resetWarned = resetWarned;
  warningOnce.noteOnce = noteOnce;
  var warning_default = warningOnce;

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function toPrimitive(t2, r2) {
    if ("object" != _typeof(t2) || !t2) return t2;
    var e3 = t2[Symbol.toPrimitive];
    if (void 0 !== e3) {
      var i = e3.call(t2, r2 || "default");
      if ("object" != _typeof(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function toPropertyKey(t2) {
    var i = toPrimitive(t2, "string");
    return "symbol" == _typeof(i) ? i : i + "";
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(e3, r2, t2) {
    return (r2 = toPropertyKey(r2)) in e3 ? Object.defineProperty(e3, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e3[r2] = t2, e3;
  }

  // node_modules/@babel/runtime/helpers/esm/objectSpread2.js
  function ownKeys(e3, r2) {
    var t2 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o3 = Object.getOwnPropertySymbols(e3);
      r2 && (o3 = o3.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
      })), t2.push.apply(t2, o3);
    }
    return t2;
  }
  function _objectSpread2(e3) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e3, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e3;
  }

  // node_modules/rc-util/es/Dom/findDOMNode.js
  var import_react2 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());
  function isDOM(node2) {
    return node2 instanceof HTMLElement || node2 instanceof SVGElement;
  }
  function getDOM(node2) {
    if (node2 && _typeof(node2) === "object" && isDOM(node2.nativeElement)) {
      return node2.nativeElement;
    }
    if (isDOM(node2)) {
      return node2;
    }
    return null;
  }
  function findDOMNode(node2) {
    var domNode = getDOM(node2);
    if (domNode) {
      return domNode;
    }
    if (node2 instanceof import_react2.default.Component) {
      var _ReactDOM$findDOMNode;
      return (_ReactDOM$findDOMNode = import_react_dom.default.findDOMNode) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.call(import_react_dom.default, node2);
    }
    return null;
  }

  // node_modules/rc-util/es/ref.js
  var import_react3 = __toESM(require_react());
  var import_react_is = __toESM(require_react_is());

  // node_modules/rc-util/es/hooks/useMemo.js
  var React3 = __toESM(require_react());
  function useMemo(getValue3, condition, shouldUpdate) {
    var cacheRef = React3.useRef({});
    if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
      cacheRef.current.value = getValue3();
      cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
  }

  // node_modules/rc-util/es/ref.js
  var ReactMajorVersion = Number(import_react3.version.split(".")[0]);
  var fillRef = function fillRef2(ref, node2) {
    if (typeof ref === "function") {
      ref(node2);
    } else if (_typeof(ref) === "object" && ref && "current" in ref) {
      ref.current = node2;
    }
  };
  var composeRef = function composeRef2() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    var refList = refs.filter(Boolean);
    if (refList.length <= 1) {
      return refList[0];
    }
    return function(node2) {
      refs.forEach(function(ref) {
        fillRef(ref, node2);
      });
    };
  };
  var useComposeRef = function useComposeRef2() {
    for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      refs[_key2] = arguments[_key2];
    }
    return useMemo(function() {
      return composeRef.apply(void 0, refs);
    }, refs, function(prev2, next2) {
      return prev2.length !== next2.length || prev2.every(function(ref, i) {
        return ref !== next2[i];
      });
    });
  };
  var supportRef = function supportRef2(nodeOrComponent) {
    var _type$prototype, _nodeOrComponent$prot;
    if (!nodeOrComponent) {
      return false;
    }
    if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) {
      return true;
    }
    var type5 = (0, import_react_is.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
    if (typeof type5 === "function" && !((_type$prototype = type5.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type5.$$typeof !== import_react_is.ForwardRef) {
      return false;
    }
    if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== import_react_is.ForwardRef) {
      return false;
    }
    return true;
  };
  function isReactElement(node2) {
    return /* @__PURE__ */ (0, import_react3.isValidElement)(node2) && !isFragment(node2);
  }
  var supportNodeRef = function supportNodeRef2(node2) {
    return isReactElement(node2) && supportRef(node2);
  };
  var getNodeRef = function getNodeRef2(node2) {
    if (node2 && isReactElement(node2)) {
      var ele = node2;
      return ele.props.propertyIsEnumerable("ref") ? ele.props.ref : ele.ref;
    }
    return null;
  };

  // node_modules/rc-resize-observer/es/SingleObserver/index.js
  var React6 = __toESM(require_react());

  // node_modules/rc-resize-observer/es/Collection.js
  var React4 = __toESM(require_react());
  var CollectionContext = /* @__PURE__ */ React4.createContext(null);
  function Collection(_ref) {
    var children = _ref.children, onBatchResize = _ref.onBatchResize;
    var resizeIdRef = React4.useRef(0);
    var resizeInfosRef = React4.useRef([]);
    var onCollectionResize = React4.useContext(CollectionContext);
    var onResize2 = React4.useCallback(function(size, element, data) {
      resizeIdRef.current += 1;
      var currentId = resizeIdRef.current;
      resizeInfosRef.current.push({
        size,
        element,
        data
      });
      Promise.resolve().then(function() {
        if (currentId === resizeIdRef.current) {
          onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
          resizeInfosRef.current = [];
        }
      });
      onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
    }, [onBatchResize, onCollectionResize]);
    return /* @__PURE__ */ React4.createElement(CollectionContext.Provider, {
      value: onResize2
    }, children);
  }

  // node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
  var MapShim = function() {
    if (typeof Map !== "undefined") {
      return Map;
    }
    function getIndex(arr, key) {
      var result = -1;
      arr.some(function(entry, index3) {
        if (entry[0] === key) {
          result = index3;
          return true;
        }
        return false;
      });
      return result;
    }
    return (
      /** @class */
      function() {
        function class_1() {
          this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        class_1.prototype.get = function(key) {
          var index3 = getIndex(this.__entries__, key);
          var entry = this.__entries__[index3];
          return entry && entry[1];
        };
        class_1.prototype.set = function(key, value) {
          var index3 = getIndex(this.__entries__, key);
          if (~index3) {
            this.__entries__[index3][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        class_1.prototype.delete = function(key) {
          var entries = this.__entries__;
          var index3 = getIndex(entries, key);
          if (~index3) {
            entries.splice(index3, 1);
          }
        };
        class_1.prototype.has = function(key) {
          return !!~getIndex(this.__entries__, key);
        };
        class_1.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        class_1.prototype.forEach = function(callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }
          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
            var entry = _a[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };
        return class_1;
      }()
    );
  }();
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
  var global$1 = function() {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    return Function("return this")();
  }();
  var requestAnimationFrame$1 = function() {
    if (typeof requestAnimationFrame === "function") {
      return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
      return setTimeout(function() {
        return callback(Date.now());
      }, 1e3 / 60);
    };
  }();
  var trailingTimeout = 2;
  function throttle(callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }
  var REFRESH_DELAY = 20;
  var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  var ResizeObserverController = (
    /** @class */
    function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer) {
        var observers2 = this.observers_;
        var index3 = observers2.indexOf(observer);
        if (~index3) {
          observers2.splice(index3, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer) {
          return observer.gatherActive(), observer.hasActive();
        });
        activeObservers.forEach(function(observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
        var isReflowProperty = transitionKeys.some(function(key) {
          return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }()
  );
  var defineConfigurable = function(target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }
    return target;
  };
  var getWindowOf = function(target) {
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    return ownerGlobal || global$1;
  };
  var emptyRect = createRectInit(0, 0, 0, 0);
  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size, position3) {
      var value = styles["border-" + position3 + "-width"];
      return size + toFloat(value);
    }, 0);
  }
  function getPaddings(styles) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position3 = positions_1[_i];
      var value = styles["padding-" + position3];
      paddings[position3] = toFloat(value);
    }
    return paddings;
  }
  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  function getHTMLElementContentRect(target) {
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    var width = toFloat(styles.width), height = toFloat(styles.height);
    if (styles.boxSizing === "border-box") {
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, "left", "right") + horizPad;
      }
      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, "top", "bottom") + vertPad;
      }
    }
    if (!isDocumentElement(target)) {
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight;
      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
  }
  var isSVGGraphicsElement = function() {
    if (typeof SVGGraphicsElement !== "undefined") {
      return function(target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    }
    return function(target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
    };
  }();
  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
  }
  function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    defineConfigurable(rect, {
      x,
      y,
      width,
      height,
      top: y,
      right: x + width,
      bottom: height + y,
      left: x
    });
    return rect;
  }
  function createRectInit(x, y, width, height) {
    return { x, y, width, height };
  }
  var ResizeObservation = (
    /** @class */
    function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }()
  );
  var ResizeObserverEntry = (
    /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }()
  );
  var ResizeObserverSPI = (
    /** @class */
    function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }()
  );
  var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
  var ResizeObserver2 = (
    /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserver4(callback) {
        if (!(this instanceof ResizeObserver4)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }
      return ResizeObserver4;
    }()
  );
  [
    "observe",
    "unobserve",
    "disconnect"
  ].forEach(function(method4) {
    ResizeObserver2.prototype[method4] = function() {
      var _a;
      return (_a = observers.get(this))[method4].apply(_a, arguments);
    };
  });
  var index = function() {
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver2;
  }();
  var ResizeObserver_es_default = index;

  // node_modules/rc-resize-observer/es/utils/observerUtil.js
  var elementListeners = /* @__PURE__ */ new Map();
  function onResize(entities) {
    entities.forEach(function(entity) {
      var _elementListeners$get;
      var target = entity.target;
      (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function(listener) {
        return listener(target);
      });
    });
  }
  var resizeObserver = new ResizeObserver_es_default(onResize);
  function observe(element, callback) {
    if (!elementListeners.has(element)) {
      elementListeners.set(element, /* @__PURE__ */ new Set());
      resizeObserver.observe(element);
    }
    elementListeners.get(element).add(callback);
  }
  function unobserve(element, callback) {
    if (elementListeners.has(element)) {
      elementListeners.get(element).delete(callback);
      if (!elementListeners.get(element).size) {
        resizeObserver.unobserve(element);
        elementListeners.delete(element);
      }
    }
  }

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(a, n2) {
    if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
  }

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(e3, r2) {
    for (var t2 = 0; t2 < r2.length; t2++) {
      var o3 = r2[t2];
      o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(e3, toPropertyKey(o3.key), o3);
    }
  }
  function _createClass(e3, r2, t2) {
    return r2 && _defineProperties(e3.prototype, r2), t2 && _defineProperties(e3, t2), Object.defineProperty(e3, "prototype", {
      writable: false
    }), e3;
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(t2, e3) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e4) {
      return t3.__proto__ = e4, t3;
    }, _setPrototypeOf(t2, e3);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(t2, e3) {
    if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
    t2.prototype = Object.create(e3 && e3.prototype, {
      constructor: {
        value: t2,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t2, "prototype", {
      writable: false
    }), e3 && _setPrototypeOf(t2, e3);
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  function _getPrototypeOf(t2) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
      return t3.__proto__ || Object.getPrototypeOf(t3);
    }, _getPrototypeOf(t2);
  }

  // node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
  function _isNativeReflectConstruct() {
    try {
      var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t3) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
      return !!t2;
    })();
  }

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(e3) {
    if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(t2, e3) {
    if (e3 && ("object" == _typeof(e3) || "function" == typeof e3)) return e3;
    if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t2);
  }

  // node_modules/@babel/runtime/helpers/esm/createSuper.js
  function _createSuper(t2) {
    var r2 = _isNativeReflectConstruct();
    return function() {
      var e3, o3 = _getPrototypeOf(t2);
      if (r2) {
        var s = _getPrototypeOf(this).constructor;
        e3 = Reflect.construct(o3, arguments, s);
      } else e3 = o3.apply(this, arguments);
      return _possibleConstructorReturn(this, e3);
    };
  }

  // node_modules/rc-resize-observer/es/SingleObserver/DomWrapper.js
  var React5 = __toESM(require_react());
  var DomWrapper = /* @__PURE__ */ function(_React$Component) {
    _inherits(DomWrapper3, _React$Component);
    var _super = _createSuper(DomWrapper3);
    function DomWrapper3() {
      _classCallCheck(this, DomWrapper3);
      return _super.apply(this, arguments);
    }
    _createClass(DomWrapper3, [{
      key: "render",
      value: function render4() {
        return this.props.children;
      }
    }]);
    return DomWrapper3;
  }(React5.Component);

  // node_modules/rc-resize-observer/es/SingleObserver/index.js
  function SingleObserver(props, ref) {
    var children = props.children, disabled = props.disabled;
    var elementRef = React6.useRef(null);
    var wrapperRef = React6.useRef(null);
    var onCollectionResize = React6.useContext(CollectionContext);
    var isRenderProps = typeof children === "function";
    var mergedChildren = isRenderProps ? children(elementRef) : children;
    var sizeRef = React6.useRef({
      width: -1,
      height: -1,
      offsetWidth: -1,
      offsetHeight: -1
    });
    var canRef = !isRenderProps && /* @__PURE__ */ React6.isValidElement(mergedChildren) && supportRef(mergedChildren);
    var originRef = canRef ? getNodeRef(mergedChildren) : null;
    var mergedRef = useComposeRef(originRef, elementRef);
    var getDom = function getDom2() {
      var _elementRef$current;
      return findDOMNode(elementRef.current) || // Support `nativeElement` format
      (elementRef.current && _typeof(elementRef.current) === "object" ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
    };
    React6.useImperativeHandle(ref, function() {
      return getDom();
    });
    var propsRef = React6.useRef(props);
    propsRef.current = props;
    var onInternalResize = React6.useCallback(function(target) {
      var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
      var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
      var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
      var fixedWidth = Math.floor(width);
      var fixedHeight = Math.floor(height);
      if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
        var size = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        sizeRef.current = size;
        var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
        var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
        var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
          offsetWidth: mergedOffsetWidth,
          offsetHeight: mergedOffsetHeight
        });
        onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
        if (onResize2) {
          Promise.resolve().then(function() {
            onResize2(sizeInfo, target);
          });
        }
      }
    }, []);
    React6.useEffect(function() {
      var currentElement = getDom();
      if (currentElement && !disabled) {
        observe(currentElement, onInternalResize);
      }
      return function() {
        return unobserve(currentElement, onInternalResize);
      };
    }, [elementRef.current, disabled]);
    return /* @__PURE__ */ React6.createElement(DomWrapper, {
      ref: wrapperRef
    }, canRef ? /* @__PURE__ */ React6.cloneElement(mergedChildren, {
      ref: mergedRef
    }) : mergedChildren);
  }
  var RefSingleObserver = /* @__PURE__ */ React6.forwardRef(SingleObserver);
  if (true) {
    RefSingleObserver.displayName = "SingleObserver";
  }
  var SingleObserver_default = RefSingleObserver;

  // node_modules/rc-resize-observer/es/index.js
  var INTERNAL_PREFIX_KEY = "rc-observer-key";
  function ResizeObserver3(props, ref) {
    var children = props.children;
    var childNodes = typeof children === "function" ? [children] : toArray(children);
    if (true) {
      if (childNodes.length > 1) {
        warning(false, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.");
      } else if (childNodes.length === 0) {
        warning(false, "`children` of ResizeObserver is empty. Nothing is in observe.");
      }
    }
    return childNodes.map(function(child, index3) {
      var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index3);
      return /* @__PURE__ */ React7.createElement(SingleObserver_default, _extends({}, props, {
        key,
        ref: index3 === 0 ? ref : void 0
      }), child);
    });
  }
  var RefResizeObserver = /* @__PURE__ */ React7.forwardRef(ResizeObserver3);
  if (true) {
    RefResizeObserver.displayName = "ResizeObserver";
  }
  RefResizeObserver.Collection = Collection;
  var es_default = RefResizeObserver;

  // node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
  function _arrayLikeToArray(r2, a) {
    (null == a || a > r2.length) && (a = r2.length);
    for (var e3 = 0, n2 = Array(a); e3 < a; e3++) n2[e3] = r2[e3];
    return n2;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
  function _arrayWithoutHoles(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray(r2);
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArray.js
  function _iterableToArray(r2) {
    if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
  }

  // node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
  function _unsupportedIterableToArray(r2, a) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a) : void 0;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
  function _toConsumableArray(r2) {
    return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
  }

  // node_modules/rc-util/es/raf.js
  var raf = function raf2(callback) {
    return +setTimeout(callback, 16);
  };
  var caf = function caf2(num) {
    return clearTimeout(num);
  };
  if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
    raf = function raf3(callback) {
      return window.requestAnimationFrame(callback);
    };
    caf = function caf3(handle) {
      return window.cancelAnimationFrame(handle);
    };
  }
  var rafUUID = 0;
  var rafIds = /* @__PURE__ */ new Map();
  function cleanup(id) {
    rafIds.delete(id);
  }
  var wrapperRaf = function wrapperRaf2(callback) {
    var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    rafUUID += 1;
    var id = rafUUID;
    function callRef(leftTimes) {
      if (leftTimes === 0) {
        cleanup(id);
        callback();
      } else {
        var realId = raf(function() {
          callRef(leftTimes - 1);
        });
        rafIds.set(id, realId);
      }
    }
    callRef(times);
    return id;
  };
  wrapperRaf.cancel = function(id) {
    var realId = rafIds.get(id);
    cleanup(id);
    return caf(realId);
  };
  if (true) {
    wrapperRaf.ids = function() {
      return rafIds;
    };
  }
  var raf_default = wrapperRaf;

  // node_modules/antd/es/config-provider/index.js
  var React38 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
  function _arrayWithHoles(r2) {
    if (Array.isArray(r2)) return r2;
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e3, n2, i, u, a = [], f = true, o3 = false;
      try {
        if (i = (t2 = t2.call(r2)).next, 0 === l2) {
          if (Object(t2) !== t2) return;
          f = false;
        } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
      } catch (r3) {
        o3 = true, n2 = r3;
      } finally {
        try {
          if (!f && null != t2["return"] && (u = t2["return"](), Object(u) !== u)) return;
        } finally {
          if (o3) throw n2;
        }
      }
      return a;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/slicedToArray.js
  function _slicedToArray(r2, e3) {
    return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e3) || _unsupportedIterableToArray(r2, e3) || _nonIterableRest();
  }

  // node_modules/@emotion/hash/dist/hash.browser.esm.js
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }
  var hash_browser_esm_default = murmur2;

  // node_modules/rc-util/es/Dom/canUseDom.js
  function canUseDom() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }

  // node_modules/rc-util/es/Dom/contains.js
  function contains(root2, n2) {
    if (!root2) {
      return false;
    }
    if (root2.contains) {
      return root2.contains(n2);
    }
    var node2 = n2;
    while (node2) {
      if (node2 === root2) {
        return true;
      }
      node2 = node2.parentNode;
    }
    return false;
  }

  // node_modules/rc-util/es/Dom/dynamicCSS.js
  var APPEND_ORDER = "data-rc-order";
  var APPEND_PRIORITY = "data-rc-priority";
  var MARK_KEY = "rc-util-key";
  var containerCache = /* @__PURE__ */ new Map();
  function getMark() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
    if (mark) {
      return mark.startsWith("data-") ? mark : "data-".concat(mark);
    }
    return MARK_KEY;
  }
  function getContainer(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    var head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles(container) {
    return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
      return node2.tagName === "STYLE";
    });
  }
  function injectCSS(css) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom()) {
      return null;
    }
    var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
    var mergedOrder = getOrder(prepend);
    var isPrependQueue = mergedOrder === "prependQueue";
    var styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER, mergedOrder);
    if (isPrependQueue && priority) {
      styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
    }
    if (csp !== null && csp !== void 0 && csp.nonce) {
      styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
    }
    styleNode.innerHTML = css;
    var container = getContainer(option);
    var firstChild = container.firstChild;
    if (prepend) {
      if (isPrependQueue) {
        var existStyle = (option.styles || findStyles(container)).filter(function(node2) {
          if (!["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER))) {
            return false;
          }
          var nodePriority = Number(node2.getAttribute(APPEND_PRIORITY) || 0);
          return priority >= nodePriority;
        });
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode(key) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var container = getContainer(option);
    return (option.styles || findStyles(container)).find(function(node2) {
      return node2.getAttribute(getMark(option)) === key;
    });
  }
  function removeCSS(key) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var existNode = findExistNode(key, option);
    if (existNode) {
      var container = getContainer(option);
      container.removeChild(existNode);
    }
  }
  function syncRealContainer(container, option) {
    var cachedRealContainer = containerCache.get(container);
    if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
      var placeholderStyle = injectCSS("", option);
      var parentNode = placeholderStyle.parentNode;
      containerCache.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS(css, key) {
    var originOption = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var container = getContainer(originOption);
    var styles = findStyles(container);
    var option = _objectSpread2(_objectSpread2({}, originOption), {}, {
      styles
    });
    syncRealContainer(container, option);
    var existNode = findExistNode(key, option);
    if (existNode) {
      var _option$csp, _option$csp2;
      if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
        var _option$csp3;
        existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
      }
      if (existNode.innerHTML !== css) {
        existNode.innerHTML = css;
      }
      return existNode;
    }
    var newNode = injectCSS(css, option);
    newNode.setAttribute(getMark(option), key);
    return newNode;
  }

  // node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
  var import_react4 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose(r2, e3) {
    if (null == r2) return {};
    var t2 = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (-1 !== e3.indexOf(n2)) continue;
      t2[n2] = r2[n2];
    }
    return t2;
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
  function _objectWithoutProperties(e3, t2) {
    if (null == e3) return {};
    var o3, r2, i = _objectWithoutPropertiesLoose(e3, t2);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e3);
      for (r2 = 0; r2 < n2.length; r2++) o3 = n2[r2], -1 === t2.indexOf(o3) && {}.propertyIsEnumerable.call(e3, o3) && (i[o3] = e3[o3]);
    }
    return i;
  }

  // node_modules/rc-util/es/isEqual.js
  function isEqual(obj1, obj2) {
    var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var refSet = /* @__PURE__ */ new Set();
    function deepEqual(a, b) {
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var circular = refSet.has(a);
      warning_default(!circular, "Warning: There may be circular references");
      if (circular) {
        return false;
      }
      if (a === b) {
        return true;
      }
      if (shallow && level > 1) {
        return false;
      }
      refSet.add(a);
      var newLevel = level + 1;
      if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!deepEqual(a[i], b[i], newLevel)) {
            return false;
          }
        }
        return true;
      }
      if (a && b && _typeof(a) === "object" && _typeof(b) === "object") {
        var keys2 = Object.keys(a);
        if (keys2.length !== Object.keys(b).length) {
          return false;
        }
        return keys2.every(function(key) {
          return deepEqual(a[key], b[key], newLevel);
        });
      }
      return false;
    }
    return deepEqual(obj1, obj2);
  }
  var isEqual_default = isEqual;

  // node_modules/@ant-design/cssinjs/es/StyleContext.js
  var React8 = __toESM(require_react());

  // node_modules/@ant-design/cssinjs/es/Cache.js
  var SPLIT = "%";
  function pathKey(keys2) {
    return keys2.join(SPLIT);
  }
  var Entity = /* @__PURE__ */ function() {
    function Entity2(instanceId) {
      _classCallCheck(this, Entity2);
      _defineProperty(this, "instanceId", void 0);
      _defineProperty(this, "cache", /* @__PURE__ */ new Map());
      _defineProperty(this, "extracted", /* @__PURE__ */ new Set());
      this.instanceId = instanceId;
    }
    _createClass(Entity2, [{
      key: "get",
      value: function get2(keys2) {
        return this.opGet(pathKey(keys2));
      }
      /** A fast get cache with `get` concat. */
    }, {
      key: "opGet",
      value: function opGet(keyPathStr) {
        return this.cache.get(keyPathStr) || null;
      }
    }, {
      key: "update",
      value: function update(keys2, valueFn) {
        return this.opUpdate(pathKey(keys2), valueFn);
      }
      /** A fast get cache with `get` concat. */
    }, {
      key: "opUpdate",
      value: function opUpdate(keyPathStr, valueFn) {
        var prevValue = this.cache.get(keyPathStr);
        var nextValue = valueFn(prevValue);
        if (nextValue === null) {
          this.cache.delete(keyPathStr);
        } else {
          this.cache.set(keyPathStr, nextValue);
        }
      }
    }]);
    return Entity2;
  }();
  var Cache_default = Entity;

  // node_modules/@ant-design/cssinjs/es/StyleContext.js
  var ATTR_TOKEN = "data-token-hash";
  var ATTR_MARK = "data-css-hash";
  var ATTR_CACHE_PATH = "data-cache-path";
  var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
  function createCache() {
    var cssinjsInstanceId = Math.random().toString(12).slice(2);
    if (typeof document !== "undefined" && document.head && document.body) {
      var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
      var firstChild = document.head.firstChild;
      Array.from(styles).forEach(function(style2) {
        style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
        if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          document.head.insertBefore(style2, firstChild);
        }
      });
      var styleHash = {};
      Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
        var hash = style2.getAttribute(ATTR_MARK);
        if (styleHash[hash]) {
          if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            var _style$parentNode;
            (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
          }
        } else {
          styleHash[hash] = true;
        }
      });
    }
    return new Cache_default(cssinjsInstanceId);
  }
  var StyleContext = /* @__PURE__ */ React8.createContext({
    hashPriority: "low",
    cache: createCache(),
    defaultCache: true
  });
  var StyleContext_default = StyleContext;

  // node_modules/@ant-design/cssinjs/es/theme/calc/CSSCalculator.js
  var CALC_UNIT = "CALC_UNIT";
  var regexp = new RegExp(CALC_UNIT, "g");

  // node_modules/@ant-design/cssinjs/es/theme/ThemeCache.js
  function sameDerivativeOption(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (var i = 0; i < left.length; i++) {
      if (left[i] !== right[i]) {
        return false;
      }
    }
    return true;
  }
  var ThemeCache = /* @__PURE__ */ function() {
    function ThemeCache2() {
      _classCallCheck(this, ThemeCache2);
      _defineProperty(this, "cache", void 0);
      _defineProperty(this, "keys", void 0);
      _defineProperty(this, "cacheCallTimes", void 0);
      this.cache = /* @__PURE__ */ new Map();
      this.keys = [];
      this.cacheCallTimes = 0;
    }
    _createClass(ThemeCache2, [{
      key: "size",
      value: function size() {
        return this.keys.length;
      }
    }, {
      key: "internalGet",
      value: function internalGet(derivativeOption) {
        var _cache2, _cache3;
        var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var cache = {
          map: this.cache
        };
        derivativeOption.forEach(function(derivative2) {
          if (!cache) {
            cache = void 0;
          } else {
            var _cache;
            cache = (_cache = cache) === null || _cache === void 0 || (_cache = _cache.map) === null || _cache === void 0 ? void 0 : _cache.get(derivative2);
          }
        });
        if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
          cache.value[1] = this.cacheCallTimes++;
        }
        return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
      }
    }, {
      key: "get",
      value: function get2(derivativeOption) {
        var _this$internalGet;
        return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
      }
    }, {
      key: "has",
      value: function has(derivativeOption) {
        return !!this.internalGet(derivativeOption);
      }
    }, {
      key: "set",
      value: function set2(derivativeOption, value) {
        var _this = this;
        if (!this.has(derivativeOption)) {
          if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
            var _this$keys$reduce = this.keys.reduce(function(result, key) {
              var _result = _slicedToArray(result, 2), callTimes = _result[1];
              if (_this.internalGet(key)[1] < callTimes) {
                return [key, _this.internalGet(key)[1]];
              }
              return result;
            }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
            this.delete(targetKey);
          }
          this.keys.push(derivativeOption);
        }
        var cache = this.cache;
        derivativeOption.forEach(function(derivative2, index3) {
          if (index3 === derivativeOption.length - 1) {
            cache.set(derivative2, {
              value: [value, _this.cacheCallTimes++]
            });
          } else {
            var cacheValue = cache.get(derivative2);
            if (!cacheValue) {
              cache.set(derivative2, {
                map: /* @__PURE__ */ new Map()
              });
            } else if (!cacheValue.map) {
              cacheValue.map = /* @__PURE__ */ new Map();
            }
            cache = cache.get(derivative2).map;
          }
        });
      }
    }, {
      key: "deleteByPath",
      value: function deleteByPath(currentCache, derivatives) {
        var cache = currentCache.get(derivatives[0]);
        if (derivatives.length === 1) {
          var _cache$value;
          if (!cache.map) {
            currentCache.delete(derivatives[0]);
          } else {
            currentCache.set(derivatives[0], {
              map: cache.map
            });
          }
          return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
        }
        var result = this.deleteByPath(cache.map, derivatives.slice(1));
        if ((!cache.map || cache.map.size === 0) && !cache.value) {
          currentCache.delete(derivatives[0]);
        }
        return result;
      }
    }, {
      key: "delete",
      value: function _delete(derivativeOption) {
        if (this.has(derivativeOption)) {
          this.keys = this.keys.filter(function(item) {
            return !sameDerivativeOption(item, derivativeOption);
          });
          return this.deleteByPath(this.cache, derivativeOption);
        }
        return void 0;
      }
    }]);
    return ThemeCache2;
  }();
  _defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
  _defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);

  // node_modules/@ant-design/cssinjs/es/theme/Theme.js
  var uuid = 0;
  var Theme = /* @__PURE__ */ function() {
    function Theme2(derivatives) {
      _classCallCheck(this, Theme2);
      _defineProperty(this, "derivatives", void 0);
      _defineProperty(this, "id", void 0);
      this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
      this.id = uuid;
      if (derivatives.length === 0) {
        warning(derivatives.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function.");
      }
      uuid += 1;
    }
    _createClass(Theme2, [{
      key: "getDerivativeToken",
      value: function getDerivativeToken(token2) {
        return this.derivatives.reduce(function(result, derivative2) {
          return derivative2(token2, result);
        }, void 0);
      }
    }]);
    return Theme2;
  }();

  // node_modules/@ant-design/cssinjs/es/theme/createTheme.js
  var cacheThemes = new ThemeCache();
  function createTheme(derivatives) {
    var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
    if (!cacheThemes.has(derivativeArr)) {
      cacheThemes.set(derivativeArr, new Theme(derivativeArr));
    }
    return cacheThemes.get(derivativeArr);
  }

  // node_modules/@ant-design/cssinjs/es/util/index.js
  var resultCache = /* @__PURE__ */ new WeakMap();
  var RESULT_VALUE = {};
  function memoResult(callback, deps) {
    var current = resultCache;
    for (var i = 0; i < deps.length; i += 1) {
      var dep = deps[i];
      if (!current.has(dep)) {
        current.set(dep, /* @__PURE__ */ new WeakMap());
      }
      current = current.get(dep);
    }
    if (!current.has(RESULT_VALUE)) {
      current.set(RESULT_VALUE, callback());
    }
    return current.get(RESULT_VALUE);
  }
  var flattenTokenCache = /* @__PURE__ */ new WeakMap();
  function flattenToken(token2) {
    var str = flattenTokenCache.get(token2) || "";
    if (!str) {
      Object.keys(token2).forEach(function(key) {
        var value = token2[key];
        str += key;
        if (value instanceof Theme) {
          str += value.id;
        } else if (value && _typeof(value) === "object") {
          str += flattenToken(value);
        } else {
          str += value;
        }
      });
      str = hash_browser_esm_default(str);
      flattenTokenCache.set(token2, str);
    }
    return str;
  }
  function token2key(token2, salt) {
    return hash_browser_esm_default("".concat(salt, "_").concat(flattenToken(token2)));
  }
  var randomSelectorKey = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
  var isClientSide = canUseDom();
  function unit(num) {
    if (typeof num === "number") {
      return "".concat(num, "px");
    }
    return num;
  }
  function toStyleStr(style2, tokenKey, styleId) {
    var customizeAttrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var plain = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    if (plain) {
      return style2;
    }
    var attrs = _objectSpread2(_objectSpread2({}, customizeAttrs), {}, _defineProperty(_defineProperty({}, ATTR_TOKEN, tokenKey), ATTR_MARK, styleId));
    var attrStr = Object.keys(attrs).map(function(attr) {
      var val = attrs[attr];
      return val ? "".concat(attr, '="').concat(val, '"') : null;
    }).filter(function(v) {
      return v;
    }).join(" ");
    return "<style ".concat(attrStr, ">").concat(style2, "</style>");
  }

  // node_modules/@ant-design/cssinjs/es/util/css-variables.js
  var token2CSSVar = function token2CSSVar2(token2) {
    var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return "--".concat(prefix ? "".concat(prefix, "-") : "").concat(token2).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
  };
  var serializeCSSVar = function serializeCSSVar2(cssVars, hashId, options) {
    if (!Object.keys(cssVars).length) {
      return "";
    }
    return ".".concat(hashId).concat(options !== null && options !== void 0 && options.scope ? ".".concat(options.scope) : "", "{").concat(Object.entries(cssVars).map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
      return "".concat(key, ":").concat(value, ";");
    }).join(""), "}");
  };
  var transformToken = function transformToken2(token2, themeKey, config) {
    var cssVars = {};
    var result = {};
    Object.entries(token2).forEach(function(_ref3) {
      var _config$preserve, _config$ignore;
      var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
      if (config !== null && config !== void 0 && (_config$preserve = config.preserve) !== null && _config$preserve !== void 0 && _config$preserve[key]) {
        result[key] = value;
      } else if ((typeof value === "string" || typeof value === "number") && !(config !== null && config !== void 0 && (_config$ignore = config.ignore) !== null && _config$ignore !== void 0 && _config$ignore[key])) {
        var _config$unitless;
        var cssVar = token2CSSVar(key, config === null || config === void 0 ? void 0 : config.prefix);
        cssVars[cssVar] = typeof value === "number" && !(config !== null && config !== void 0 && (_config$unitless = config.unitless) !== null && _config$unitless !== void 0 && _config$unitless[key]) ? "".concat(value, "px") : String(value);
        result[key] = "var(".concat(cssVar, ")");
      }
    });
    return [result, serializeCSSVar(cssVars, themeKey, {
      scope: config === null || config === void 0 ? void 0 : config.scope
    })];
  };

  // node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
  var React12 = __toESM(require_react());

  // node_modules/rc-util/es/hooks/useLayoutEffect.js
  var React9 = __toESM(require_react());
  var useInternalLayoutEffect = canUseDom() ? React9.useLayoutEffect : React9.useEffect;
  var useLayoutEffect2 = function useLayoutEffect3(callback, deps) {
    var firstMountRef = React9.useRef(true);
    useInternalLayoutEffect(function() {
      return callback(firstMountRef.current);
    }, deps);
    useInternalLayoutEffect(function() {
      firstMountRef.current = false;
      return function() {
        firstMountRef.current = true;
      };
    }, []);
  };
  var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
    useLayoutEffect2(function(firstMount) {
      if (!firstMount) {
        return callback();
      }
    }, deps);
  };
  var useLayoutEffect_default = useLayoutEffect2;

  // node_modules/@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js
  var React10 = __toESM(require_react());
  var fullClone = _objectSpread2({}, React10);
  var useInsertionEffect = fullClone.useInsertionEffect;
  var useInsertionEffectPolyfill = function useInsertionEffectPolyfill2(renderEffect, effect, deps) {
    React10.useMemo(renderEffect, deps);
    useLayoutEffect_default(function() {
      return effect(true);
    }, deps);
  };
  var useCompatibleInsertionEffect = useInsertionEffect ? function(renderEffect, effect, deps) {
    return useInsertionEffect(function() {
      renderEffect();
      return effect();
    }, deps);
  } : useInsertionEffectPolyfill;
  var useCompatibleInsertionEffect_default = useCompatibleInsertionEffect;

  // node_modules/@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js
  var React11 = __toESM(require_react());
  var fullClone2 = _objectSpread2({}, React11);
  var useInsertionEffect2 = fullClone2.useInsertionEffect;
  var useCleanupRegister = function useCleanupRegister2(deps) {
    var effectCleanups = [];
    var cleanupFlag = false;
    function register2(fn) {
      if (cleanupFlag) {
        if (true) {
          warning(false, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
        }
        return;
      }
      effectCleanups.push(fn);
    }
    React11.useEffect(function() {
      cleanupFlag = false;
      return function() {
        cleanupFlag = true;
        if (effectCleanups.length) {
          effectCleanups.forEach(function(fn) {
            return fn();
          });
        }
      };
    }, deps);
    return register2;
  };
  var useRun = function useRun2() {
    return function(fn) {
      fn();
    };
  };
  var useEffectCleanupRegister = typeof useInsertionEffect2 !== "undefined" ? useCleanupRegister : useRun;
  var useEffectCleanupRegister_default = useEffectCleanupRegister;

  // node_modules/@ant-design/cssinjs/es/hooks/useHMR.js
  var webpackHMR = false;
  function useDevHMR() {
    return webpackHMR;
  }
  var useHMR_default = false ? useProdHMR : useDevHMR;
  if (typeof module !== "undefined" && module && module.hot && typeof window !== "undefined") {
    win = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : null;
    if (win && typeof win.webpackHotUpdate === "function") {
      originWebpackHotUpdate = win.webpackHotUpdate;
      win.webpackHotUpdate = function() {
        webpackHMR = true;
        setTimeout(function() {
          webpackHMR = false;
        }, 0);
        return originWebpackHotUpdate.apply(void 0, arguments);
      };
    }
  }
  var win;
  var originWebpackHotUpdate;

  // node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
  function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
    var _React$useContext = React12.useContext(StyleContext_default), globalCache = _React$useContext.cache;
    var fullPath = [prefix].concat(_toConsumableArray(keyPath));
    var fullPathStr = pathKey(fullPath);
    var register2 = useEffectCleanupRegister_default([fullPathStr]);
    var HMRUpdate = useHMR_default();
    var buildCache = function buildCache2(updater) {
      globalCache.opUpdate(fullPathStr, function(prevCache) {
        var _ref = prevCache || [void 0, void 0], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
        var tmpCache = cache;
        if (cache && HMRUpdate) {
          onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(tmpCache, HMRUpdate);
          tmpCache = null;
        }
        var mergedCache = tmpCache || cacheFn();
        var data = [times, mergedCache];
        return updater ? updater(data) : data;
      });
    };
    React12.useMemo(
      function() {
        buildCache();
      },
      /* eslint-disable react-hooks/exhaustive-deps */
      [fullPathStr]
      /* eslint-enable */
    );
    var cacheEntity = globalCache.opGet(fullPathStr);
    if (!cacheEntity) {
      buildCache();
      cacheEntity = globalCache.opGet(fullPathStr);
    }
    var cacheContent = cacheEntity[1];
    useCompatibleInsertionEffect_default(function() {
      onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
    }, function(polyfill) {
      buildCache(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), times = _ref4[0], cache = _ref4[1];
        if (polyfill && times === 0) {
          onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
        }
        return [times + 1, cache];
      });
      return function() {
        globalCache.opUpdate(fullPathStr, function(prevCache) {
          var _ref5 = prevCache || [], _ref6 = _slicedToArray(_ref5, 2), _ref6$ = _ref6[0], times = _ref6$ === void 0 ? 0 : _ref6$, cache = _ref6[1];
          var nextCount = times - 1;
          if (nextCount === 0) {
            register2(function() {
              if (polyfill || !globalCache.opGet(fullPathStr)) {
                onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);
              }
            });
            return null;
          }
          return [times - 1, cache];
        });
      };
    }, [fullPathStr]);
    return cacheContent;
  }

  // node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
  var EMPTY_OVERRIDE = {};
  var hashPrefix = true ? "css-dev-only-do-not-override" : "css";
  var tokenKeys = /* @__PURE__ */ new Map();
  function recordCleanToken(tokenKey) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
  }
  function removeStyleTags(key, instanceId) {
    if (typeof document !== "undefined") {
      var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
      styles.forEach(function(style2) {
        if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
          var _style$parentNode;
          (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
        }
      });
    }
  }
  var TOKEN_THRESHOLD = 0;
  function cleanTokenStyle(tokenKey, instanceId) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
    var cleanableKeyList = /* @__PURE__ */ new Set();
    tokenKeys.forEach(function(value, key) {
      if (value <= 0) cleanableKeyList.add(key);
    });
    if (tokenKeys.size - cleanableKeyList.size > TOKEN_THRESHOLD) {
      cleanableKeyList.forEach(function(key) {
        removeStyleTags(key, instanceId);
        tokenKeys.delete(key);
      });
    }
  }
  var getComputedToken = function getComputedToken2(originToken, overrideToken, theme, format2) {
    var derivativeToken = theme.getDerivativeToken(originToken);
    var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), overrideToken);
    if (format2) {
      mergedDerivativeToken = format2(mergedDerivativeToken);
    }
    return mergedDerivativeToken;
  };
  var TOKEN_PREFIX = "token";
  function useCacheToken(theme, tokens) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _useContext = (0, import_react4.useContext)(StyleContext_default), instanceId = _useContext.cache.instanceId, container = _useContext.container;
    var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken, compute = option.getComputedToken, cssVar = option.cssVar;
    var mergedToken = memoResult(function() {
      return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
    }, tokens);
    var tokenStr = flattenToken(mergedToken);
    var overrideTokenStr = flattenToken(override);
    var cssVarStr = cssVar ? flattenToken(cssVar) : "";
    var cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr], function() {
      var _cssVar$key;
      var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken2);
      var actualToken = _objectSpread2({}, mergedDerivativeToken);
      var cssVarsStr = "";
      if (!!cssVar) {
        var _transformToken = transformToken(mergedDerivativeToken, cssVar.key, {
          prefix: cssVar.prefix,
          ignore: cssVar.ignore,
          unitless: cssVar.unitless,
          preserve: cssVar.preserve
        });
        var _transformToken2 = _slicedToArray(_transformToken, 2);
        mergedDerivativeToken = _transformToken2[0];
        cssVarsStr = _transformToken2[1];
      }
      var tokenKey = token2key(mergedDerivativeToken, salt);
      mergedDerivativeToken._tokenKey = tokenKey;
      actualToken._tokenKey = token2key(actualToken, salt);
      var themeKey = (_cssVar$key = cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) !== null && _cssVar$key !== void 0 ? _cssVar$key : tokenKey;
      mergedDerivativeToken._themeKey = themeKey;
      recordCleanToken(themeKey);
      var hashId = "".concat(hashPrefix, "-").concat(hash_browser_esm_default(tokenKey));
      mergedDerivativeToken._hashId = hashId;
      return [mergedDerivativeToken, hashId, actualToken, cssVarsStr, (cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) || ""];
    }, function(cache) {
      cleanTokenStyle(cache[0]._themeKey, instanceId);
    }, function(_ref) {
      var _ref2 = _slicedToArray(_ref, 4), token2 = _ref2[0], cssVarsStr = _ref2[3];
      if (cssVar && cssVarsStr) {
        var style2 = updateCSS(cssVarsStr, hash_browser_esm_default("css-variables-".concat(token2._themeKey)), {
          mark: ATTR_MARK,
          prepend: "queue",
          attachTo: container,
          priority: -999
        });
        style2[CSS_IN_JS_INSTANCE] = instanceId;
        style2.setAttribute(ATTR_TOKEN, token2._themeKey);
      }
    });
    return cachedToken;
  }
  var extract = function extract2(cache, effectStyles, options) {
    var _cache = _slicedToArray(cache, 5), realToken = _cache[2], styleStr = _cache[3], cssVarKey = _cache[4];
    var _ref3 = options || {}, plain = _ref3.plain;
    if (!styleStr) {
      return null;
    }
    var styleId = realToken._tokenKey;
    var order = -999;
    var sharedAttrs = {
      "data-rc-order": "prependQueue",
      "data-rc-priority": "".concat(order)
    };
    var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
    return [order, styleId, styleText];
  };

  // node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
  var import_react5 = __toESM(require_react());

  // node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
  var React13 = __toESM(require_react());

  // node_modules/@emotion/unitless/dist/unitless.browser.esm.js
  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var unitless_browser_esm_default = unitlessKeys;

  // node_modules/stylis/src/Enum.js
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var NAMESPACE = "@namespace";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";

  // node_modules/stylis/src/Utility.js
  var abs = Math.abs;
  var from = String.fromCharCode;
  function trim(value) {
    return value.trim();
  }
  function replace(value, pattern6, replacement) {
    return value.replace(pattern6, replacement);
  }
  function indexof(value, search, position3) {
    return value.indexOf(search, position3);
  }
  function charat(value, index3) {
    return value.charCodeAt(index3) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array4) {
    return array4.push(value), value;
  }

  // node_modules/stylis/src/Tokenizer.js
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type5, props, children, length2, siblings) {
    return { value, root: root2, parent, type: type5, props, children, line, column, length: length2, return: "", siblings };
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type5) {
    switch (type5) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type5) {
    return trim(slice(position - 1, delimiter(type5 === 91 ? type5 + 2 : type5 === 40 ? type5 + 1 : type5)));
  }
  function whitespace(type5) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type5) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index3, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index3, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type5) {
    while (next())
      switch (character) {
        // ] ) " '
        case type5:
          return position;
        // " '
        case 34:
        case 39:
          if (type5 !== 34 && type5 !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type5 === 41)
            delimiter(type5);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type5, index3) {
    while (next())
      if (type5 + character === 47 + 10)
        break;
      else if (type5 + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index3, position - 1) + "*" + from(type5 === 47 ? type5 : next());
  }
  function identifier(index3) {
    while (!token(peek()))
      next();
    return slice(index3, position);
  }

  // node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index3 = 0;
    var offset3 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type5 = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters2 = type5;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index3 ? points[index3 - 1] : 0)) != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent, declarations), declarations);
              if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ") characters2 += " ";
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index3++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset3:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47))
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference = ruleset(characters2, root2, parent, index3, offset3, rules, points, type5, props = [], children = [], length2, rulesets), rulesets);
              if (character2 === 123)
                if (offset3 === 0)
                  parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                else {
                  switch (atrule) {
                    // c(ontainer)
                    case 99:
                      if (charat(characters2, 3) === 110) break;
                    // l(ayer)
                    case 108:
                      if (charat(characters2, 2) === 97) break;
                    default:
                      offset3 = 0;
                    // d(ocument) m(edia) s(upports)
                    case 100:
                    case 109:
                    case 115:
                  }
                  if (offset3) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type5, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                  else parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
          }
          index3 = offset3 = property = 0, variable = ampersand = 1, type5 = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index3++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset3 = length2 = strlen(type5 = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index3, offset3, rules, points, type5, props, children, length2, siblings) {
    var post = offset3 - 1;
    var rule = offset3 === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k = 0; i < index3; ++i)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node(value, root2, parent, offset3 === 0 ? RULESET : type5, props, children, length2, siblings);
  }
  function comment(value, root2, parent, siblings) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
  }
  function declaration(value, root2, parent, length2, siblings) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
  }

  // node_modules/stylis/src/Serializer.js
  function serialize(children, callback) {
    var output = "";
    for (var i = 0; i < children.length; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index3, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case NAMESPACE:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        if (!strlen(element.value = element.props.join(","))) return "";
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }

  // node_modules/@ant-design/cssinjs/es/linters/utils.js
  function lintWarning(message2, info) {
    var path2 = info.path, parentSelectors = info.parentSelectors;
    warning_default(false, "[Ant Design CSS-in-JS] ".concat(path2 ? "Error in ".concat(path2, ": ") : "").concat(message2).concat(parentSelectors.length ? " Selector: ".concat(parentSelectors.join(" | ")) : ""));
  }

  // node_modules/@ant-design/cssinjs/es/linters/contentQuotesLinter.js
  var linter = function linter2(key, value, info) {
    if (key === "content") {
      var contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
      var contentValues = ["normal", "none", "initial", "inherit", "unset"];
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        lintWarning("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(value, "\"'`."), info);
      }
    }
  };
  var contentQuotesLinter_default = linter;

  // node_modules/@ant-design/cssinjs/es/linters/hashedAnimationLinter.js
  var linter3 = function linter4(key, value, info) {
    if (key === "animation") {
      if (info.hashId && value !== "none") {
        lintWarning("You seem to be using hashed animation '".concat(value, "', in which case 'animationName' with Keyframe as value is recommended."), info);
      }
    }
  };
  var hashedAnimationLinter_default = linter3;

  // node_modules/@ant-design/cssinjs/es/util/cacheMapUtil.js
  var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
  var CSS_FILE_STYLE = "_FILE_STYLE__";
  var cachePathMap;
  var fromCSSFile = true;
  function prepare() {
    if (!cachePathMap) {
      cachePathMap = {};
      if (canUseDom()) {
        var div = document.createElement("div");
        div.className = ATTR_CACHE_MAP;
        div.style.position = "fixed";
        div.style.visibility = "hidden";
        div.style.top = "-9999px";
        document.body.appendChild(div);
        var content = getComputedStyle(div).content || "";
        content = content.replace(/^"/, "").replace(/"$/, "");
        content.split(";").forEach(function(item) {
          var _item$split = item.split(":"), _item$split2 = _slicedToArray(_item$split, 2), path2 = _item$split2[0], hash = _item$split2[1];
          cachePathMap[path2] = hash;
        });
        var inlineMapStyle = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
        if (inlineMapStyle) {
          var _inlineMapStyle$paren;
          fromCSSFile = false;
          (_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 || _inlineMapStyle$paren.removeChild(inlineMapStyle);
        }
        document.body.removeChild(div);
      }
    }
  }
  function existPath(path2) {
    prepare();
    return !!cachePathMap[path2];
  }
  function getStyleAndHash(path2) {
    var hash = cachePathMap[path2];
    var styleStr = null;
    if (hash && canUseDom()) {
      if (fromCSSFile) {
        styleStr = CSS_FILE_STYLE;
      } else {
        var _style = document.querySelector("style[".concat(ATTR_MARK, '="').concat(cachePathMap[path2], '"]'));
        if (_style) {
          styleStr = _style.innerHTML;
        } else {
          delete cachePathMap[path2];
        }
      }
    }
    return [styleStr, hash];
  }

  // node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
  var SKIP_CHECK = "_skip_check_";
  var MULTI_VALUE = "_multi_value_";
  function normalizeStyle(styleStr) {
    var serialized = serialize(compile(styleStr), stringify);
    return serialized.replace(/\{%%%\:[^;];}/g, ";");
  }
  function isCompoundCSSProperty(value) {
    return _typeof(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
  }
  function injectSelectorHash(key, hashId, hashPriority) {
    if (!hashId) {
      return key;
    }
    var hashClassName = ".".concat(hashId);
    var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
    var keys2 = key.split(",").map(function(k) {
      var _firstPath$match;
      var fullPath = k.trim().split(/\s+/);
      var firstPath = fullPath[0] || "";
      var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
      firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
      return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
    });
    return keys2.join(",");
  }
  var parseStyle = function parseStyle2(interpolation) {
    var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      root: true,
      parentSelectors: []
    }, root2 = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
    var hashId = config.hashId, layer = config.layer, path2 = config.path, hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers, _config$linters = config.linters, linters = _config$linters === void 0 ? [] : _config$linters;
    var styleStr = "";
    var effectStyle = {};
    function parseKeyframes(keyframes) {
      var animationName = keyframes.getName(hashId);
      if (!effectStyle[animationName]) {
        var _parseStyle = parseStyle2(keyframes.style, config, {
          root: false,
          parentSelectors
        }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
        effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
      }
    }
    function flattenList(list) {
      var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      list.forEach(function(item) {
        if (Array.isArray(item)) {
          flattenList(item, fullList);
        } else if (item) {
          fullList.push(item);
        }
      });
      return fullList;
    }
    var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
    flattenStyleList.forEach(function(originStyle) {
      var style2 = typeof originStyle === "string" && !root2 ? {} : originStyle;
      if (typeof style2 === "string") {
        styleStr += "".concat(style2, "\n");
      } else if (style2._keyframe) {
        parseKeyframes(style2);
      } else {
        var mergedStyle = transformers.reduce(function(prev2, trans) {
          var _trans$visit;
          return (trans === null || trans === void 0 || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
        }, style2);
        Object.keys(mergedStyle).forEach(function(key) {
          var value = mergedStyle[key];
          if (_typeof(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
            var subInjectHash = false;
            var mergedKey = key.trim();
            var nextRoot = false;
            if ((root2 || injectHash) && hashId) {
              if (mergedKey.startsWith("@")) {
                subInjectHash = true;
              } else if (mergedKey === "&") {
                mergedKey = injectSelectorHash("", hashId, hashPriority);
              } else {
                mergedKey = injectSelectorHash(key, hashId, hashPriority);
              }
            } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
              mergedKey = "";
              nextRoot = true;
            }
            var _parseStyle3 = parseStyle2(value, config, {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
            }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
            effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
            styleStr += "".concat(mergedKey).concat(_parsedStr2);
          } else {
            let appendStyle = function(cssKey, cssValue) {
              if (_typeof(value) !== "object" || !(value !== null && value !== void 0 && value[SKIP_CHECK])) {
                [contentQuotesLinter_default, hashedAnimationLinter_default].concat(_toConsumableArray(linters)).forEach(function(linter5) {
                  return linter5(cssKey, cssValue, {
                    path: path2,
                    hashId,
                    parentSelectors
                  });
                });
              }
              var styleName = cssKey.replace(/[A-Z]/g, function(match2) {
                return "-".concat(match2.toLowerCase());
              });
              var formatValue = cssValue;
              if (!unitless_browser_esm_default[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
                formatValue = "".concat(formatValue, "px");
              }
              if (cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
                parseKeyframes(cssValue);
                formatValue = cssValue.getName(hashId);
              }
              styleStr += "".concat(styleName, ":").concat(formatValue, ";");
            };
            var _value;
            var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
            if (_typeof(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
              actualValue.forEach(function(item) {
                appendStyle(key, item);
              });
            } else {
              appendStyle(key, actualValue);
            }
          }
        });
      }
    });
    if (!root2) {
      styleStr = "{".concat(styleStr, "}");
    } else if (layer) {
      if (styleStr) {
        styleStr = "@layer ".concat(layer.name, " {").concat(styleStr, "}");
      }
      if (layer.dependencies) {
        effectStyle["@layer ".concat(layer.name)] = layer.dependencies.map(function(deps) {
          return "@layer ".concat(deps, ", ").concat(layer.name, ";");
        }).join("\n");
      }
    }
    return [styleStr, effectStyle];
  };
  function uniqueHash(path2, styleStr) {
    return hash_browser_esm_default("".concat(path2.join("%")).concat(styleStr));
  }
  function Empty() {
    return null;
  }
  var STYLE_PREFIX = "style";
  function useStyleRegister(info, styleFn) {
    var token2 = info.token, path2 = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce, clientOnly = info.clientOnly, _info$order = info.order, order = _info$order === void 0 ? 0 : _info$order;
    var _React$useContext = React13.useContext(StyleContext_default), autoClear = _React$useContext.autoClear, mock = _React$useContext.mock, defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache, enableLayer = _React$useContext.layer;
    var tokenKey = token2._tokenKey;
    var fullPath = [tokenKey];
    if (enableLayer) {
      fullPath.push("layer");
    }
    fullPath.push.apply(fullPath, _toConsumableArray(path2));
    var isMergedClientSide = isClientSide;
    if (mock !== void 0) {
      isMergedClientSide = mock === "client";
    }
    var _useGlobalCache = useGlobalCache(
      STYLE_PREFIX,
      fullPath,
      // Create cache if needed
      function() {
        var cachePath = fullPath.join("|");
        if (existPath(cachePath)) {
          var _getStyleAndHash = getStyleAndHash(cachePath), _getStyleAndHash2 = _slicedToArray(_getStyleAndHash, 2), inlineCacheStyleStr = _getStyleAndHash2[0], styleHash = _getStyleAndHash2[1];
          if (inlineCacheStyleStr) {
            return [inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order];
          }
        }
        var styleObj = styleFn();
        var _parseStyle5 = parseStyle(styleObj, {
          hashId,
          hashPriority,
          layer: enableLayer ? layer : void 0,
          path: path2.join("-"),
          transformers,
          linters
        }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
        var styleStr = normalizeStyle(parsedStyle);
        var styleId = uniqueHash(fullPath, styleStr);
        return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order];
      },
      // Remove cache if no need
      function(_ref2, fromHMR) {
        var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
        if ((fromHMR || autoClear) && isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK,
            attachTo: container
          });
        }
      },
      // Effect: Inject style here
      function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 4), styleStr = _ref5[0], _ = _ref5[1], styleId = _ref5[2], effectStyle = _ref5[3];
        if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
          var mergedCSSConfig = {
            mark: ATTR_MARK,
            prepend: enableLayer ? false : "queue",
            attachTo: container,
            priority: order
          };
          var nonceStr = typeof nonce === "function" ? nonce() : nonce;
          if (nonceStr) {
            mergedCSSConfig.csp = {
              nonce: nonceStr
            };
          }
          var effectLayerKeys = [];
          var effectRestKeys = [];
          Object.keys(effectStyle).forEach(function(key) {
            if (key.startsWith("@layer")) {
              effectLayerKeys.push(key);
            } else {
              effectRestKeys.push(key);
            }
          });
          effectLayerKeys.forEach(function(effectKey) {
            updateCSS(normalizeStyle(effectStyle[effectKey]), "_layer-".concat(effectKey), _objectSpread2(_objectSpread2({}, mergedCSSConfig), {}, {
              prepend: true
            }));
          });
          var style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
          style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
          style2.setAttribute(ATTR_TOKEN, tokenKey);
          if (true) {
            style2.setAttribute(ATTR_CACHE_PATH, fullPath.join("|"));
          }
          effectRestKeys.forEach(function(effectKey) {
            updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
          });
        }
      }
    ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
    return function(node2) {
      var styleNode;
      if (!ssrInline || isMergedClientSide || !defaultCache) {
        styleNode = /* @__PURE__ */ React13.createElement(Empty, null);
      } else {
        styleNode = /* @__PURE__ */ React13.createElement("style", _extends({}, _defineProperty(_defineProperty({}, ATTR_TOKEN, cachedTokenKey), ATTR_MARK, cachedStyleId), {
          dangerouslySetInnerHTML: {
            __html: cachedStyleStr
          }
        }));
      }
      return /* @__PURE__ */ React13.createElement(React13.Fragment, null, styleNode, node2);
    };
  }
  var extract3 = function extract4(cache, effectStyles, options) {
    var _cache = _slicedToArray(cache, 6), styleStr = _cache[0], tokenKey = _cache[1], styleId = _cache[2], effectStyle = _cache[3], clientOnly = _cache[4], order = _cache[5];
    var _ref7 = options || {}, plain = _ref7.plain;
    if (clientOnly) {
      return null;
    }
    var keyStyleText = styleStr;
    var sharedAttrs = {
      "data-rc-order": "prependQueue",
      "data-rc-priority": "".concat(order)
    };
    keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain);
    if (effectStyle) {
      Object.keys(effectStyle).forEach(function(effectKey) {
        if (!effectStyles[effectKey]) {
          effectStyles[effectKey] = true;
          var effectStyleStr = normalizeStyle(effectStyle[effectKey]);
          var effectStyleHTML = toStyleStr(effectStyleStr, tokenKey, "_effect-".concat(effectKey), sharedAttrs, plain);
          if (effectKey.startsWith("@layer")) {
            keyStyleText = effectStyleHTML + keyStyleText;
          } else {
            keyStyleText += effectStyleHTML;
          }
        }
      });
    }
    return [order, styleId, keyStyleText];
  };

  // node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
  var CSS_VAR_PREFIX = "cssVar";
  var useCSSVarRegister = function useCSSVarRegister2(config, fn) {
    var key = config.key, prefix = config.prefix, unitless2 = config.unitless, ignore2 = config.ignore, token2 = config.token, _config$scope = config.scope, scope = _config$scope === void 0 ? "" : _config$scope;
    var _useContext = (0, import_react5.useContext)(StyleContext_default), instanceId = _useContext.cache.instanceId, container = _useContext.container;
    var tokenKey = token2._tokenKey;
    var stylePath = [].concat(_toConsumableArray(config.path), [key, scope, tokenKey]);
    var cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, function() {
      var originToken = fn();
      var _transformToken = transformToken(originToken, key, {
        prefix,
        unitless: unitless2,
        ignore: ignore2,
        scope
      }), _transformToken2 = _slicedToArray(_transformToken, 2), mergedToken = _transformToken2[0], cssVarsStr = _transformToken2[1];
      var styleId = uniqueHash(stylePath, cssVarsStr);
      return [mergedToken, cssVarsStr, styleId, key];
    }, function(_ref) {
      var _ref2 = _slicedToArray(_ref, 3), styleId = _ref2[2];
      if (isClientSide) {
        removeCSS(styleId, {
          mark: ATTR_MARK,
          attachTo: container
        });
      }
    }, function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 3), cssVarsStr = _ref4[1], styleId = _ref4[2];
      if (!cssVarsStr) {
        return;
      }
      var style2 = updateCSS(cssVarsStr, styleId, {
        mark: ATTR_MARK,
        prepend: "queue",
        attachTo: container,
        priority: -999
      });
      style2[CSS_IN_JS_INSTANCE] = instanceId;
      style2.setAttribute(ATTR_TOKEN, key);
    });
    return cache;
  };
  var extract5 = function extract6(cache, effectStyles, options) {
    var _cache = _slicedToArray(cache, 4), styleStr = _cache[1], styleId = _cache[2], cssVarKey = _cache[3];
    var _ref5 = options || {}, plain = _ref5.plain;
    if (!styleStr) {
      return null;
    }
    var order = -999;
    var sharedAttrs = {
      "data-rc-order": "prependQueue",
      "data-rc-priority": "".concat(order)
    };
    var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
    return [order, styleId, styleText];
  };
  var useCSSVarRegister_default = useCSSVarRegister;

  // node_modules/@ant-design/cssinjs/es/extractStyle.js
  var ExtractStyleFns = _defineProperty(_defineProperty(_defineProperty({}, STYLE_PREFIX, extract3), TOKEN_PREFIX, extract), CSS_VAR_PREFIX, extract5);

  // node_modules/@ant-design/cssinjs/es/Keyframes.js
  var Keyframe = /* @__PURE__ */ function() {
    function Keyframe2(name, style2) {
      _classCallCheck(this, Keyframe2);
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "style", void 0);
      _defineProperty(this, "_keyframe", true);
      this.name = name;
      this.style = style2;
    }
    _createClass(Keyframe2, [{
      key: "getName",
      value: function getName() {
        var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
      }
    }]);
    return Keyframe2;
  }();
  var Keyframes_default = Keyframe;

  // node_modules/@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js
  function noSplit(list) {
    list.notSplit = true;
    return list;
  }
  var keyMap = {
    // Inset
    inset: ["top", "right", "bottom", "left"],
    insetBlock: ["top", "bottom"],
    insetBlockStart: ["top"],
    insetBlockEnd: ["bottom"],
    insetInline: ["left", "right"],
    insetInlineStart: ["left"],
    insetInlineEnd: ["right"],
    // Margin
    marginBlock: ["marginTop", "marginBottom"],
    marginBlockStart: ["marginTop"],
    marginBlockEnd: ["marginBottom"],
    marginInline: ["marginLeft", "marginRight"],
    marginInlineStart: ["marginLeft"],
    marginInlineEnd: ["marginRight"],
    // Padding
    paddingBlock: ["paddingTop", "paddingBottom"],
    paddingBlockStart: ["paddingTop"],
    paddingBlockEnd: ["paddingBottom"],
    paddingInline: ["paddingLeft", "paddingRight"],
    paddingInlineStart: ["paddingLeft"],
    paddingInlineEnd: ["paddingRight"],
    // Border
    borderBlock: noSplit(["borderTop", "borderBottom"]),
    borderBlockStart: noSplit(["borderTop"]),
    borderBlockEnd: noSplit(["borderBottom"]),
    borderInline: noSplit(["borderLeft", "borderRight"]),
    borderInlineStart: noSplit(["borderLeft"]),
    borderInlineEnd: noSplit(["borderRight"]),
    // Border width
    borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
    borderBlockStartWidth: ["borderTopWidth"],
    borderBlockEndWidth: ["borderBottomWidth"],
    borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
    borderInlineStartWidth: ["borderLeftWidth"],
    borderInlineEndWidth: ["borderRightWidth"],
    // Border style
    borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
    borderBlockStartStyle: ["borderTopStyle"],
    borderBlockEndStyle: ["borderBottomStyle"],
    borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
    borderInlineStartStyle: ["borderLeftStyle"],
    borderInlineEndStyle: ["borderRightStyle"],
    // Border color
    borderBlockColor: ["borderTopColor", "borderBottomColor"],
    borderBlockStartColor: ["borderTopColor"],
    borderBlockEndColor: ["borderBottomColor"],
    borderInlineColor: ["borderLeftColor", "borderRightColor"],
    borderInlineStartColor: ["borderLeftColor"],
    borderInlineEndColor: ["borderRightColor"],
    // Border radius
    borderStartStartRadius: ["borderTopLeftRadius"],
    borderStartEndRadius: ["borderTopRightRadius"],
    borderEndStartRadius: ["borderBottomLeftRadius"],
    borderEndEndRadius: ["borderBottomRightRadius"]
  };

  // node_modules/@ant-design/icons/es/components/Context.js
  var import_react6 = __toESM(require_react());
  var IconContext = /* @__PURE__ */ (0, import_react6.createContext)({});
  var Context_default = IconContext;

  // node_modules/@babel/runtime/helpers/esm/toArray.js
  function _toArray(r2) {
    return _arrayWithHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableRest();
  }

  // node_modules/rc-util/es/utils/get.js
  function get(entity, path2) {
    var current = entity;
    for (var i = 0; i < path2.length; i += 1) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[path2[i]];
    }
    return current;
  }

  // node_modules/rc-util/es/utils/set.js
  function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
      return value;
    }
    var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1);
    var clone;
    if (!entity && typeof path2 === "number") {
      clone = [];
    } else if (Array.isArray(entity)) {
      clone = _toConsumableArray(entity);
    } else {
      clone = _objectSpread2({}, entity);
    }
    if (removeIfUndefined && value === void 0 && restPath.length === 1) {
      delete clone[path2][restPath[0]];
    } else {
      clone[path2] = internalSet(clone[path2], restPath, value, removeIfUndefined);
    }
    return clone;
  }
  function set(entity, paths, value) {
    var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
      return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
  }
  function isObject(obj) {
    return _typeof(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
  }
  function createEmpty(source) {
    return Array.isArray(source) ? [] : {};
  }
  var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
  function merge() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var clone = createEmpty(sources[0]);
    sources.forEach(function(src) {
      function internalMerge(path2, parentLoopSet) {
        var loopSet = new Set(parentLoopSet);
        var value = get(src, path2);
        var isArr = Array.isArray(value);
        if (isArr || isObject(value)) {
          if (!loopSet.has(value)) {
            loopSet.add(value);
            var originValue = get(clone, path2);
            if (isArr) {
              clone = set(clone, path2, []);
            } else if (!originValue || _typeof(originValue) !== "object") {
              clone = set(clone, path2, createEmpty(value));
            }
            keys(value).forEach(function(key) {
              internalMerge([].concat(_toConsumableArray(path2), [key]), loopSet);
            });
          }
        } else {
          clone = set(clone, path2, value);
        }
      }
      internalMerge([]);
    });
    return clone;
  }

  // node_modules/antd/es/_util/warning.js
  var React14 = __toESM(require_react());
  function noop() {
  }
  var deprecatedWarnList = null;
  var _warning = noop;
  if (true) {
    _warning = (valid, component, message2) => {
      warning_default(valid, `[antd: ${component}] ${message2}`);
      if (false) {
        resetWarned();
      }
    };
  }
  var warning2 = _warning;
  var WarningContext = /* @__PURE__ */ React14.createContext({});
  var devUseWarning = true ? (component) => {
    const {
      strict
    } = React14.useContext(WarningContext);
    const typeWarning = (valid, type5, message2) => {
      if (!valid) {
        if (strict === false && type5 === "deprecated") {
          const existWarning = deprecatedWarnList;
          if (!deprecatedWarnList) {
            deprecatedWarnList = {};
          }
          deprecatedWarnList[component] = deprecatedWarnList[component] || [];
          if (!deprecatedWarnList[component].includes(message2 || "")) {
            deprecatedWarnList[component].push(message2 || "");
          }
          if (!existWarning) {
            console.warn("[antd] There exists deprecated usage in your code:", deprecatedWarnList);
          }
        } else {
          true ? warning2(valid, component, message2) : void 0;
        }
      }
    };
    typeWarning.deprecated = (valid, oldProp, newProp, message2) => {
      typeWarning(valid, "deprecated", `\`${oldProp}\` is deprecated. Please use \`${newProp}\` instead.${message2 ? ` ${message2}` : ""}`);
    };
    return typeWarning;
  } : () => {
    const noopWarning = () => {
    };
    noopWarning.deprecated = noop;
    return noopWarning;
  };
  var warning_default2 = warning2;

  // node_modules/antd/es/form/validateMessagesContext.js
  var import_react7 = __toESM(require_react());
  var validateMessagesContext_default = /* @__PURE__ */ (0, import_react7.createContext)(void 0);

  // node_modules/antd/es/locale/index.js
  var React16 = __toESM(require_react());

  // node_modules/rc-pagination/es/locale/en_US.js
  var locale = {
    // Options
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    // Pagination
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size"
  };
  var en_US_default = locale;

  // node_modules/rc-picker/es/locale/common.js
  var commonLocale = {
    yearFormat: "YYYY",
    dayFormat: "D",
    cellMeridiemFormat: "A",
    monthBeforeYear: true
  };

  // node_modules/rc-picker/es/locale/en_US.js
  var locale2 = _objectSpread2(_objectSpread2({}, commonLocale), {}, {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    week: "Week",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    dateFormat: "M/D/YYYY",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
  });
  var en_US_default2 = locale2;

  // node_modules/antd/es/time-picker/locale/en_US.js
  var locale3 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
  };
  var en_US_default3 = locale3;

  // node_modules/antd/es/date-picker/locale/en_US.js
  var locale4 = {
    lang: Object.assign({
      placeholder: "Select date",
      yearPlaceholder: "Select year",
      quarterPlaceholder: "Select quarter",
      monthPlaceholder: "Select month",
      weekPlaceholder: "Select week",
      rangePlaceholder: ["Start date", "End date"],
      rangeYearPlaceholder: ["Start year", "End year"],
      rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
      rangeMonthPlaceholder: ["Start month", "End month"],
      rangeWeekPlaceholder: ["Start week", "End week"]
    }, en_US_default2),
    timePickerLocale: Object.assign({}, en_US_default3)
  };
  var en_US_default4 = locale4;

  // node_modules/antd/es/calendar/locale/en_US.js
  var en_US_default5 = en_US_default4;

  // node_modules/antd/es/locale/en_US.js
  var typeTemplate = "${label} is not a valid ${type}";
  var localeValues = {
    locale: "en",
    Pagination: en_US_default,
    DatePicker: en_US_default4,
    TimePicker: en_US_default3,
    Calendar: en_US_default5,
    global: {
      placeholder: "Please select",
      close: "Close"
    },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckAll: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting"
    },
    Tour: {
      Next: "Next",
      Previous: "Previous",
      Finish: "Finish"
    },
    Modal: {
      okText: "OK",
      cancelText: "Cancel",
      justOkText: "OK"
    },
    Popconfirm: {
      okText: "OK",
      cancelText: "Cancel"
    },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      deselectAll: "Deselect all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page"
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file"
    },
    Empty: {
      description: "No data"
    },
    Icon: {
      icon: "icon"
    },
    Text: {
      edit: "Edit",
      copy: "Copy",
      copied: "Copied",
      expand: "Expand",
      collapse: "Collapse"
    },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date"
        },
        types: {
          string: typeTemplate,
          method: typeTemplate,
          array: typeTemplate,
          object: typeTemplate,
          number: typeTemplate,
          date: typeTemplate,
          boolean: typeTemplate,
          integer: typeTemplate,
          float: typeTemplate,
          regexp: typeTemplate,
          email: typeTemplate,
          url: typeTemplate,
          hex: typeTemplate
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters"
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}"
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}"
        },
        pattern: {
          mismatch: "${label} does not match the pattern ${pattern}"
        }
      }
    },
    Image: {
      preview: "Preview"
    },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh",
      scanned: "Scanned"
    },
    ColorPicker: {
      presetEmpty: "Empty",
      transparent: "Transparent",
      singleColor: "Single",
      gradientColor: "Gradient"
    }
  };
  var en_US_default6 = localeValues;

  // node_modules/antd/es/modal/locale.js
  var runtimeLocale = Object.assign({}, en_US_default6.Modal);
  var localeList = [];
  var generateLocale = () => localeList.reduce((merged, locale6) => Object.assign(Object.assign({}, merged), locale6), en_US_default6.Modal);
  function changeConfirmLocale(newLocale) {
    if (newLocale) {
      const cloneLocale = Object.assign({}, newLocale);
      localeList.push(cloneLocale);
      runtimeLocale = generateLocale();
      return () => {
        localeList = localeList.filter((locale6) => locale6 !== cloneLocale);
        runtimeLocale = generateLocale();
      };
    }
    runtimeLocale = Object.assign({}, en_US_default6.Modal);
  }
  function getConfirmLocale() {
    return runtimeLocale;
  }

  // node_modules/antd/es/locale/context.js
  var import_react8 = __toESM(require_react());
  var LocaleContext = /* @__PURE__ */ (0, import_react8.createContext)(void 0);
  var context_default = LocaleContext;

  // node_modules/antd/es/locale/useLocale.js
  var React15 = __toESM(require_react());
  var useLocale = (componentName, defaultLocale) => {
    const fullLocale = React15.useContext(context_default);
    const getLocale = React15.useMemo(() => {
      var _a;
      const locale6 = defaultLocale || en_US_default6[componentName];
      const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
      return Object.assign(Object.assign({}, typeof locale6 === "function" ? locale6() : locale6), localeFromContext || {});
    }, [componentName, defaultLocale, fullLocale]);
    const getLocaleCode = React15.useMemo(() => {
      const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
      if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
        return en_US_default6.locale;
      }
      return localeCode;
    }, [fullLocale]);
    return [getLocale, getLocaleCode];
  };
  var useLocale_default = useLocale;

  // node_modules/antd/es/locale/index.js
  var ANT_MARK = "internalMark";
  var LocaleProvider = (props) => {
    const {
      locale: locale6 = {},
      children,
      _ANT_MARK__
    } = props;
    if (true) {
      const warning6 = devUseWarning("LocaleProvider");
      true ? warning6(_ANT_MARK__ === ANT_MARK, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale") : void 0;
    }
    React16.useEffect(() => {
      const clearLocale = changeConfirmLocale(locale6 === null || locale6 === void 0 ? void 0 : locale6.Modal);
      return clearLocale;
    }, [locale6]);
    const getMemoizedContextValue = React16.useMemo(() => Object.assign(Object.assign({}, locale6), {
      exist: true
    }), [locale6]);
    return /* @__PURE__ */ React16.createElement(context_default.Provider, {
      value: getMemoizedContextValue
    }, children);
  };
  if (true) {
    LocaleProvider.displayName = "LocaleProvider";
  }
  var locale_default = LocaleProvider;

  // node_modules/antd/es/theme/context.js
  var import_react9 = __toESM(require_react());

  // node_modules/antd/es/theme/themes/seed.js
  var defaultPresetColors = {
    blue: "#1677FF",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    /**
     * @deprecated Use magenta instead
     */
    pink: "#EB2F96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
  };
  var seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
    // Color
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
    // Font
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
    fontSize: 14,
    // Line
    lineWidth: 1,
    lineType: "solid",
    // Motion
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    // Radius
    borderRadius: 6,
    // Size
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    // Control Base
    controlHeight: 32,
    // zIndex
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    // Image
    opacityImage: 1,
    // Wireframe
    wireframe: false,
    // Motion
    motion: true
  });
  var seed_default = seedToken;

  // node_modules/@ant-design/fast-color/es/FastColor.js
  var round = Math.round;
  function splitColorStr(str, parseNum) {
    const match2 = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [];
    const numList = match2.map((item) => parseFloat(item));
    for (let i = 0; i < 3; i += 1) {
      numList[i] = parseNum(numList[i] || 0, match2[i] || "", i);
    }
    if (match2[3]) {
      numList[3] = match2[3].includes("%") ? numList[3] / 100 : numList[3];
    } else {
      numList[3] = 1;
    }
    return numList;
  }
  var parseHSVorHSL = (num, _, index3) => index3 === 0 ? num : num / 100;
  function limitRange(value, max) {
    const mergedMax = max || 255;
    if (value > mergedMax) {
      return mergedMax;
    }
    if (value < 0) {
      return 0;
    }
    return value;
  }
  var FastColor = class _FastColor {
    constructor(input) {
      _defineProperty(this, "isValid", true);
      _defineProperty(this, "r", 0);
      _defineProperty(this, "g", 0);
      _defineProperty(this, "b", 0);
      _defineProperty(this, "a", 1);
      _defineProperty(this, "_h", void 0);
      _defineProperty(this, "_s", void 0);
      _defineProperty(this, "_l", void 0);
      _defineProperty(this, "_v", void 0);
      _defineProperty(this, "_max", void 0);
      _defineProperty(this, "_min", void 0);
      _defineProperty(this, "_brightness", void 0);
      function matchFormat(str) {
        return str[0] in input && str[1] in input && str[2] in input;
      }
      if (!input) {
      } else if (typeof input === "string") {
        let matchPrefix = function(prefix) {
          return trimStr.startsWith(prefix);
        };
        const trimStr = input.trim();
        if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) {
          this.fromHexString(trimStr);
        } else if (matchPrefix("rgb")) {
          this.fromRgbString(trimStr);
        } else if (matchPrefix("hsl")) {
          this.fromHslString(trimStr);
        } else if (matchPrefix("hsv") || matchPrefix("hsb")) {
          this.fromHsvString(trimStr);
        }
      } else if (input instanceof _FastColor) {
        this.r = input.r;
        this.g = input.g;
        this.b = input.b;
        this.a = input.a;
        this._h = input._h;
        this._s = input._s;
        this._l = input._l;
        this._v = input._v;
      } else if (matchFormat("rgb")) {
        this.r = limitRange(input.r);
        this.g = limitRange(input.g);
        this.b = limitRange(input.b);
        this.a = typeof input.a === "number" ? limitRange(input.a, 1) : 1;
      } else if (matchFormat("hsl")) {
        this.fromHsl(input);
      } else if (matchFormat("hsv")) {
        this.fromHsv(input);
      } else {
        throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
      }
    }
    // ======================= Setter =======================
    setR(value) {
      return this._sc("r", value);
    }
    setG(value) {
      return this._sc("g", value);
    }
    setB(value) {
      return this._sc("b", value);
    }
    setA(value) {
      return this._sc("a", value, 1);
    }
    setHue(value) {
      const hsv = this.toHsv();
      hsv.h = value;
      return this._c(hsv);
    }
    // ======================= Getter =======================
    /**
     * Returns the perceived luminance of a color, from 0-1.
     * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
     */
    getLuminance() {
      function adjustGamma(raw) {
        const val = raw / 255;
        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
      }
      const R = adjustGamma(this.r);
      const G = adjustGamma(this.g);
      const B = adjustGamma(this.b);
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }
    getHue() {
      if (typeof this._h === "undefined") {
        const delta = this.getMax() - this.getMin();
        if (delta === 0) {
          this._h = 0;
        } else {
          this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
        }
      }
      return this._h;
    }
    getSaturation() {
      if (typeof this._s === "undefined") {
        const delta = this.getMax() - this.getMin();
        if (delta === 0) {
          this._s = 0;
        } else {
          this._s = delta / this.getMax();
        }
      }
      return this._s;
    }
    getLightness() {
      if (typeof this._l === "undefined") {
        this._l = (this.getMax() + this.getMin()) / 510;
      }
      return this._l;
    }
    getValue() {
      if (typeof this._v === "undefined") {
        this._v = this.getMax() / 255;
      }
      return this._v;
    }
    /**
     * Returns the perceived brightness of the color, from 0-255.
     * Note: this is not the b of HSB
     * @see http://www.w3.org/TR/AERT#color-contrast
     */
    getBrightness() {
      if (typeof this._brightness === "undefined") {
        this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3;
      }
      return this._brightness;
    }
    // ======================== Func ========================
    darken(amount = 10) {
      const h = this.getHue();
      const s = this.getSaturation();
      let l2 = this.getLightness() - amount / 100;
      if (l2 < 0) {
        l2 = 0;
      }
      return this._c({
        h,
        s,
        l: l2,
        a: this.a
      });
    }
    lighten(amount = 10) {
      const h = this.getHue();
      const s = this.getSaturation();
      let l2 = this.getLightness() + amount / 100;
      if (l2 > 1) {
        l2 = 1;
      }
      return this._c({
        h,
        s,
        l: l2,
        a: this.a
      });
    }
    /**
     * Mix the current color a given amount with another color, from 0 to 100.
     * 0 means no mixing (return current color).
     */
    mix(input, amount = 50) {
      const color = this._c(input);
      const p = amount / 100;
      const calc = (key) => (color[key] - this[key]) * p + this[key];
      const rgba = {
        r: round(calc("r")),
        g: round(calc("g")),
        b: round(calc("b")),
        a: round(calc("a") * 100) / 100
      };
      return this._c(rgba);
    }
    /**
     * Mix the color with pure white, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return white.
     */
    tint(amount = 10) {
      return this.mix({
        r: 255,
        g: 255,
        b: 255,
        a: 1
      }, amount);
    }
    /**
     * Mix the color with pure black, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return black.
     */
    shade(amount = 10) {
      return this.mix({
        r: 0,
        g: 0,
        b: 0,
        a: 1
      }, amount);
    }
    onBackground(background) {
      const bg = this._c(background);
      const alpha = this.a + bg.a * (1 - this.a);
      const calc = (key) => {
        return round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha);
      };
      return this._c({
        r: calc("r"),
        g: calc("g"),
        b: calc("b"),
        a: alpha
      });
    }
    // ======================= Status =======================
    isDark() {
      return this.getBrightness() < 128;
    }
    isLight() {
      return this.getBrightness() >= 128;
    }
    // ======================== MISC ========================
    equals(other) {
      return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
    }
    clone() {
      return this._c(this);
    }
    // ======================= Format =======================
    toHexString() {
      let hex2 = "#";
      const rHex = (this.r || 0).toString(16);
      hex2 += rHex.length === 2 ? rHex : "0" + rHex;
      const gHex = (this.g || 0).toString(16);
      hex2 += gHex.length === 2 ? gHex : "0" + gHex;
      const bHex = (this.b || 0).toString(16);
      hex2 += bHex.length === 2 ? bHex : "0" + bHex;
      if (typeof this.a === "number" && this.a >= 0 && this.a < 1) {
        const aHex = round(this.a * 255).toString(16);
        hex2 += aHex.length === 2 ? aHex : "0" + aHex;
      }
      return hex2;
    }
    /** CSS support color pattern */
    toHsl() {
      return {
        h: this.getHue(),
        s: this.getSaturation(),
        l: this.getLightness(),
        a: this.a
      };
    }
    /** CSS support color pattern */
    toHslString() {
      const h = this.getHue();
      const s = round(this.getSaturation() * 100);
      const l2 = round(this.getLightness() * 100);
      return this.a !== 1 ? `hsla(${h},${s}%,${l2}%,${this.a})` : `hsl(${h},${s}%,${l2}%)`;
    }
    /** Same as toHsb */
    toHsv() {
      return {
        h: this.getHue(),
        s: this.getSaturation(),
        v: this.getValue(),
        a: this.a
      };
    }
    toRgb() {
      return {
        r: this.r,
        g: this.g,
        b: this.b,
        a: this.a
      };
    }
    toRgbString() {
      return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
    }
    toString() {
      return this.toRgbString();
    }
    // ====================== Privates ======================
    /** Return a new FastColor object with one channel changed */
    _sc(rgb, value, max) {
      const clone = this.clone();
      clone[rgb] = limitRange(value, max);
      return clone;
    }
    _c(input) {
      return new this.constructor(input);
    }
    getMax() {
      if (typeof this._max === "undefined") {
        this._max = Math.max(this.r, this.g, this.b);
      }
      return this._max;
    }
    getMin() {
      if (typeof this._min === "undefined") {
        this._min = Math.min(this.r, this.g, this.b);
      }
      return this._min;
    }
    fromHexString(trimStr) {
      const withoutPrefix = trimStr.replace("#", "");
      function connectNum(index1, index22) {
        return parseInt(withoutPrefix[index1] + withoutPrefix[index22 || index1], 16);
      }
      if (withoutPrefix.length < 6) {
        this.r = connectNum(0);
        this.g = connectNum(1);
        this.b = connectNum(2);
        this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
      } else {
        this.r = connectNum(0, 1);
        this.g = connectNum(2, 3);
        this.b = connectNum(4, 5);
        this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
      }
    }
    fromHsl({
      h,
      s,
      l: l2,
      a
    }) {
      this._h = h % 360;
      this._s = s;
      this._l = l2;
      this.a = typeof a === "number" ? a : 1;
      if (s <= 0) {
        const rgb = round(l2 * 255);
        this.r = rgb;
        this.g = rgb;
        this.b = rgb;
      }
      let r2 = 0, g = 0, b = 0;
      const huePrime = h / 60;
      const chroma = (1 - Math.abs(2 * l2 - 1)) * s;
      const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      if (huePrime >= 0 && huePrime < 1) {
        r2 = chroma;
        g = secondComponent;
      } else if (huePrime >= 1 && huePrime < 2) {
        r2 = secondComponent;
        g = chroma;
      } else if (huePrime >= 2 && huePrime < 3) {
        g = chroma;
        b = secondComponent;
      } else if (huePrime >= 3 && huePrime < 4) {
        g = secondComponent;
        b = chroma;
      } else if (huePrime >= 4 && huePrime < 5) {
        r2 = secondComponent;
        b = chroma;
      } else if (huePrime >= 5 && huePrime < 6) {
        r2 = chroma;
        b = secondComponent;
      }
      const lightnessModification = l2 - chroma / 2;
      this.r = round((r2 + lightnessModification) * 255);
      this.g = round((g + lightnessModification) * 255);
      this.b = round((b + lightnessModification) * 255);
    }
    fromHsv({
      h,
      s,
      v,
      a
    }) {
      this._h = h % 360;
      this._s = s;
      this._v = v;
      this.a = typeof a === "number" ? a : 1;
      const vv = round(v * 255);
      this.r = vv;
      this.g = vv;
      this.b = vv;
      if (s <= 0) {
        return;
      }
      const hh = h / 60;
      const i = Math.floor(hh);
      const ff = hh - i;
      const p = round(v * (1 - s) * 255);
      const q = round(v * (1 - s * ff) * 255);
      const t2 = round(v * (1 - s * (1 - ff)) * 255);
      switch (i) {
        case 0:
          this.g = t2;
          this.b = p;
          break;
        case 1:
          this.r = q;
          this.b = p;
          break;
        case 2:
          this.r = p;
          this.b = t2;
          break;
        case 3:
          this.r = p;
          this.g = q;
          break;
        case 4:
          this.r = t2;
          this.g = p;
          break;
        case 5:
        default:
          this.g = p;
          this.b = q;
          break;
      }
    }
    fromHsvString(trimStr) {
      const cells = splitColorStr(trimStr, parseHSVorHSL);
      this.fromHsv({
        h: cells[0],
        s: cells[1],
        v: cells[2],
        a: cells[3]
      });
    }
    fromHslString(trimStr) {
      const cells = splitColorStr(trimStr, parseHSVorHSL);
      this.fromHsl({
        h: cells[0],
        s: cells[1],
        l: cells[2],
        a: cells[3]
      });
    }
    fromRgbString(trimStr) {
      const cells = splitColorStr(trimStr, (num, txt) => (
        // Convert percentage to number. e.g. 50% -> 128
        txt.includes("%") ? round(num / 100 * 255) : num
      ));
      this.r = cells[0];
      this.g = cells[1];
      this.b = cells[2];
      this.a = cells[3];
    }
  };

  // node_modules/@ant-design/colors/es/generate.js
  var hueStep = 2;
  var saturationStep = 0.16;
  var saturationStep2 = 0.05;
  var brightnessStep1 = 0.05;
  var brightnessStep2 = 0.15;
  var lightColorCount = 5;
  var darkColorCount = 4;
  var darkColorMap = [{
    index: 7,
    amount: 15
  }, {
    index: 6,
    amount: 25
  }, {
    index: 5,
    amount: 30
  }, {
    index: 5,
    amount: 45
  }, {
    index: 5,
    amount: 65
  }, {
    index: 5,
    amount: 85
  }, {
    index: 4,
    amount: 90
  }, {
    index: 3,
    amount: 95
  }, {
    index: 2,
    amount: 97
  }, {
    index: 1,
    amount: 98
  }];
  function getHue(hsv, i, light) {
    var hue;
    if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
      hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
    } else {
      hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
    }
    if (hue < 0) {
      hue += 360;
    } else if (hue >= 360) {
      hue -= 360;
    }
    return hue;
  }
  function getSaturation(hsv, i, light) {
    if (hsv.h === 0 && hsv.s === 0) {
      return hsv.s;
    }
    var saturation;
    if (light) {
      saturation = hsv.s - saturationStep * i;
    } else if (i === darkColorCount) {
      saturation = hsv.s + saturationStep;
    } else {
      saturation = hsv.s + saturationStep2 * i;
    }
    if (saturation > 1) {
      saturation = 1;
    }
    if (light && i === lightColorCount && saturation > 0.1) {
      saturation = 0.1;
    }
    if (saturation < 0.06) {
      saturation = 0.06;
    }
    return Math.round(saturation * 100) / 100;
  }
  function getValue(hsv, i, light) {
    var value;
    if (light) {
      value = hsv.v + brightnessStep1 * i;
    } else {
      value = hsv.v - brightnessStep2 * i;
    }
    value = Math.max(0, Math.min(1, value));
    return Math.round(value * 100) / 100;
  }
  function generate(color) {
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var patterns = [];
    var pColor = new FastColor(color);
    var hsv = pColor.toHsv();
    for (var i = lightColorCount; i > 0; i -= 1) {
      var c = new FastColor({
        h: getHue(hsv, i, true),
        s: getSaturation(hsv, i, true),
        v: getValue(hsv, i, true)
      });
      patterns.push(c);
    }
    patterns.push(pColor);
    for (var _i = 1; _i <= darkColorCount; _i += 1) {
      var _c = new FastColor({
        h: getHue(hsv, _i),
        s: getSaturation(hsv, _i),
        v: getValue(hsv, _i)
      });
      patterns.push(_c);
    }
    if (opts.theme === "dark") {
      return darkColorMap.map(function(_ref) {
        var index3 = _ref.index, amount = _ref.amount;
        return new FastColor(opts.backgroundColor || "#141414").mix(patterns[index3], amount).toHexString();
      });
    }
    return patterns.map(function(c2) {
      return c2.toHexString();
    });
  }

  // node_modules/@ant-design/colors/es/presets.js
  var presetPrimaryColors = {
    "red": "#F5222D",
    "volcano": "#FA541C",
    "orange": "#FA8C16",
    "gold": "#FAAD14",
    "yellow": "#FADB14",
    "lime": "#A0D911",
    "green": "#52C41A",
    "cyan": "#13C2C2",
    "blue": "#1677FF",
    "geekblue": "#2F54EB",
    "purple": "#722ED1",
    "magenta": "#EB2F96",
    "grey": "#666666"
  };
  var red = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
  red.primary = red[5];
  var volcano = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
  volcano.primary = volcano[5];
  var orange = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
  orange.primary = orange[5];
  var gold = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
  gold.primary = gold[5];
  var yellow = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
  yellow.primary = yellow[5];
  var lime = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
  lime.primary = lime[5];
  var green = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
  green.primary = green[5];
  var cyan = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
  cyan.primary = cyan[5];
  var blue = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
  blue.primary = blue[5];
  var geekblue = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
  geekblue.primary = geekblue[5];
  var purple = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
  purple.primary = purple[5];
  var magenta = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
  magenta.primary = magenta[5];
  var grey = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
  grey.primary = grey[5];
  var presetPalettes = {
    red,
    volcano,
    orange,
    gold,
    yellow,
    lime,
    green,
    cyan,
    blue,
    geekblue,
    purple,
    magenta,
    grey
  };
  var redDark = ["#2a1215", "#431418", "#58181c", "#791a1f", "#a61d24", "#d32029", "#e84749", "#f37370", "#f89f9a", "#fac8c3"];
  redDark.primary = redDark[5];
  var volcanoDark = ["#2b1611", "#441d12", "#592716", "#7c3118", "#aa3e19", "#d84a1b", "#e87040", "#f3956a", "#f8b692", "#fad4bc"];
  volcanoDark.primary = volcanoDark[5];
  var orangeDark = ["#2b1d11", "#442a11", "#593815", "#7c4a15", "#aa6215", "#d87a16", "#e89a3c", "#f3b765", "#f8cf8d", "#fae3b7"];
  orangeDark.primary = orangeDark[5];
  var goldDark = ["#2b2111", "#443111", "#594214", "#7c5914", "#aa7714", "#d89614", "#e8b339", "#f3cc62", "#f8df8b", "#faedb5"];
  goldDark.primary = goldDark[5];
  var yellowDark = ["#2b2611", "#443b11", "#595014", "#7c6e14", "#aa9514", "#d8bd14", "#e8d639", "#f3ea62", "#f8f48b", "#fafab5"];
  yellowDark.primary = yellowDark[5];
  var limeDark = ["#1f2611", "#2e3c10", "#3e4f13", "#536d13", "#6f9412", "#8bbb11", "#a9d134", "#c9e75d", "#e4f88b", "#f0fab5"];
  limeDark.primary = limeDark[5];
  var greenDark = ["#162312", "#1d3712", "#274916", "#306317", "#3c8618", "#49aa19", "#6abe39", "#8fd460", "#b2e58b", "#d5f2bb"];
  greenDark.primary = greenDark[5];
  var cyanDark = ["#112123", "#113536", "#144848", "#146262", "#138585", "#13a8a8", "#33bcb7", "#58d1c9", "#84e2d8", "#b2f1e8"];
  cyanDark.primary = cyanDark[5];
  var blueDark = ["#111a2c", "#112545", "#15325b", "#15417e", "#1554ad", "#1668dc", "#3c89e8", "#65a9f3", "#8dc5f8", "#b7dcfa"];
  blueDark.primary = blueDark[5];
  var geekblueDark = ["#131629", "#161d40", "#1c2755", "#203175", "#263ea0", "#2b4acb", "#5273e0", "#7f9ef3", "#a8c1f8", "#d2e0fa"];
  geekblueDark.primary = geekblueDark[5];
  var purpleDark = ["#1a1325", "#24163a", "#301c4d", "#3e2069", "#51258f", "#642ab5", "#854eca", "#ab7ae0", "#cda8f0", "#ebd7fa"];
  purpleDark.primary = purpleDark[5];
  var magentaDark = ["#291321", "#40162f", "#551c3b", "#75204f", "#a02669", "#cb2b83", "#e0529c", "#f37fb7", "#f8a8cc", "#fad2e3"];
  magentaDark.primary = magentaDark[5];
  var greyDark = ["#151515", "#1f1f1f", "#2d2d2d", "#393939", "#494949", "#5a5a5a", "#6a6a6a", "#7b7b7b", "#888888", "#969696"];
  greyDark.primary = greyDark[5];

  // node_modules/antd/es/theme/themes/shared/genColorMapToken.js
  function genColorMapToken(seed, {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  }) {
    const {
      colorSuccess: colorSuccessBase,
      colorWarning: colorWarningBase,
      colorError: colorErrorBase,
      colorInfo: colorInfoBase,
      colorPrimary: colorPrimaryBase,
      colorBgBase,
      colorTextBase
    } = seed;
    const primaryColors = generateColorPalettes2(colorPrimaryBase);
    const successColors = generateColorPalettes2(colorSuccessBase);
    const warningColors = generateColorPalettes2(colorWarningBase);
    const errorColors = generateColorPalettes2(colorErrorBase);
    const infoColors = generateColorPalettes2(colorInfoBase);
    const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
    const colorLink = seed.colorLink || seed.colorInfo;
    const linkColors = generateColorPalettes2(colorLink);
    const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
    return Object.assign(Object.assign({}, neutralColors), {
      colorPrimaryBg: primaryColors[1],
      colorPrimaryBgHover: primaryColors[2],
      colorPrimaryBorder: primaryColors[3],
      colorPrimaryBorderHover: primaryColors[4],
      colorPrimaryHover: primaryColors[5],
      colorPrimary: primaryColors[6],
      colorPrimaryActive: primaryColors[7],
      colorPrimaryTextHover: primaryColors[8],
      colorPrimaryText: primaryColors[9],
      colorPrimaryTextActive: primaryColors[10],
      colorSuccessBg: successColors[1],
      colorSuccessBgHover: successColors[2],
      colorSuccessBorder: successColors[3],
      colorSuccessBorderHover: successColors[4],
      colorSuccessHover: successColors[4],
      colorSuccess: successColors[6],
      colorSuccessActive: successColors[7],
      colorSuccessTextHover: successColors[8],
      colorSuccessText: successColors[9],
      colorSuccessTextActive: successColors[10],
      colorErrorBg: errorColors[1],
      colorErrorBgHover: errorColors[2],
      colorErrorBgFilledHover,
      colorErrorBgActive: errorColors[3],
      colorErrorBorder: errorColors[3],
      colorErrorBorderHover: errorColors[4],
      colorErrorHover: errorColors[5],
      colorError: errorColors[6],
      colorErrorActive: errorColors[7],
      colorErrorTextHover: errorColors[8],
      colorErrorText: errorColors[9],
      colorErrorTextActive: errorColors[10],
      colorWarningBg: warningColors[1],
      colorWarningBgHover: warningColors[2],
      colorWarningBorder: warningColors[3],
      colorWarningBorderHover: warningColors[4],
      colorWarningHover: warningColors[4],
      colorWarning: warningColors[6],
      colorWarningActive: warningColors[7],
      colorWarningTextHover: warningColors[8],
      colorWarningText: warningColors[9],
      colorWarningTextActive: warningColors[10],
      colorInfoBg: infoColors[1],
      colorInfoBgHover: infoColors[2],
      colorInfoBorder: infoColors[3],
      colorInfoBorderHover: infoColors[4],
      colorInfoHover: infoColors[4],
      colorInfo: infoColors[6],
      colorInfoActive: infoColors[7],
      colorInfoTextHover: infoColors[8],
      colorInfoText: infoColors[9],
      colorInfoTextActive: infoColors[10],
      colorLinkHover: linkColors[4],
      colorLink: linkColors[6],
      colorLinkActive: linkColors[7],
      colorBgMask: new FastColor("#000").setA(0.45).toRgbString(),
      colorWhite: "#fff"
    });
  }

  // node_modules/antd/es/theme/themes/shared/genRadius.js
  var genRadius = (radiusBase) => {
    let radiusLG = radiusBase;
    let radiusSM = radiusBase;
    let radiusXS = radiusBase;
    let radiusOuter = radiusBase;
    if (radiusBase < 6 && radiusBase >= 5) {
      radiusLG = radiusBase + 1;
    } else if (radiusBase < 16 && radiusBase >= 6) {
      radiusLG = radiusBase + 2;
    } else if (radiusBase >= 16) {
      radiusLG = 16;
    }
    if (radiusBase < 7 && radiusBase >= 5) {
      radiusSM = 4;
    } else if (radiusBase < 8 && radiusBase >= 7) {
      radiusSM = 5;
    } else if (radiusBase < 14 && radiusBase >= 8) {
      radiusSM = 6;
    } else if (radiusBase < 16 && radiusBase >= 14) {
      radiusSM = 7;
    } else if (radiusBase >= 16) {
      radiusSM = 8;
    }
    if (radiusBase < 6 && radiusBase >= 2) {
      radiusXS = 1;
    } else if (radiusBase >= 6) {
      radiusXS = 2;
    }
    if (radiusBase > 4 && radiusBase < 8) {
      radiusOuter = 4;
    } else if (radiusBase >= 8) {
      radiusOuter = 6;
    }
    return {
      borderRadius: radiusBase,
      borderRadiusXS: radiusXS,
      borderRadiusSM: radiusSM,
      borderRadiusLG: radiusLG,
      borderRadiusOuter: radiusOuter
    };
  };
  var genRadius_default = genRadius;

  // node_modules/antd/es/theme/themes/shared/genCommonMapToken.js
  function genCommonMapToken(token2) {
    const {
      motionUnit,
      motionBase,
      borderRadius,
      lineWidth
    } = token2;
    return Object.assign({
      // motion
      motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
      motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
      motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
      // line
      lineWidthBold: lineWidth + 1
    }, genRadius_default(borderRadius));
  }

  // node_modules/antd/es/theme/themes/shared/genControlHeight.js
  var genControlHeight = (token2) => {
    const {
      controlHeight
    } = token2;
    return {
      controlHeightSM: controlHeight * 0.75,
      controlHeightXS: controlHeight * 0.5,
      controlHeightLG: controlHeight * 1.25
    };
  };
  var genControlHeight_default = genControlHeight;

  // node_modules/antd/es/theme/themes/shared/genFontSizes.js
  function getLineHeight(fontSize) {
    return (fontSize + 8) / fontSize;
  }
  function getFontSizes(base) {
    const fontSizes = Array.from({
      length: 10
    }).map((_, index3) => {
      const i = index3 - 1;
      const baseSize = base * Math.pow(Math.E, i / 5);
      const intSize = index3 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
      return Math.floor(intSize / 2) * 2;
    });
    fontSizes[1] = base;
    return fontSizes.map((size) => ({
      size,
      lineHeight: getLineHeight(size)
    }));
  }

  // node_modules/antd/es/theme/themes/shared/genFontMapToken.js
  var genFontMapToken = (fontSize) => {
    const fontSizePairs = getFontSizes(fontSize);
    const fontSizes = fontSizePairs.map((pair) => pair.size);
    const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
    const fontSizeMD = fontSizes[1];
    const fontSizeSM = fontSizes[0];
    const fontSizeLG = fontSizes[2];
    const lineHeight = lineHeights[1];
    const lineHeightSM = lineHeights[0];
    const lineHeightLG = lineHeights[2];
    return {
      fontSizeSM,
      fontSize: fontSizeMD,
      fontSizeLG,
      fontSizeXL: fontSizes[3],
      fontSizeHeading1: fontSizes[6],
      fontSizeHeading2: fontSizes[5],
      fontSizeHeading3: fontSizes[4],
      fontSizeHeading4: fontSizes[3],
      fontSizeHeading5: fontSizes[2],
      lineHeight,
      lineHeightLG,
      lineHeightSM,
      fontHeight: Math.round(lineHeight * fontSizeMD),
      fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
      fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
      lineHeightHeading1: lineHeights[6],
      lineHeightHeading2: lineHeights[5],
      lineHeightHeading3: lineHeights[4],
      lineHeightHeading4: lineHeights[3],
      lineHeightHeading5: lineHeights[2]
    };
  };
  var genFontMapToken_default = genFontMapToken;

  // node_modules/antd/es/theme/themes/shared/genSizeMapToken.js
  function genSizeMapToken(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    return {
      sizeXXL: sizeUnit * (sizeStep + 8),
      // 48
      sizeXL: sizeUnit * (sizeStep + 4),
      // 32
      sizeLG: sizeUnit * (sizeStep + 2),
      // 24
      sizeMD: sizeUnit * (sizeStep + 1),
      // 20
      sizeMS: sizeUnit * sizeStep,
      // 16
      size: sizeUnit * sizeStep,
      // 16
      sizeSM: sizeUnit * (sizeStep - 1),
      // 12
      sizeXS: sizeUnit * (sizeStep - 2),
      // 8
      sizeXXS: sizeUnit * (sizeStep - 3)
      // 4
    };
  }

  // node_modules/antd/es/theme/themes/default/colorAlgorithm.js
  var getAlphaColor = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
  var getSolidColor = (baseColor, brightness) => {
    const instance = new FastColor(baseColor);
    return instance.darken(brightness).toHexString();
  };

  // node_modules/antd/es/theme/themes/default/colors.js
  var generateColorPalettes = (baseColor) => {
    const colors = generate(baseColor);
    return {
      1: colors[0],
      2: colors[1],
      3: colors[2],
      4: colors[3],
      5: colors[4],
      6: colors[5],
      7: colors[6],
      8: colors[4],
      9: colors[5],
      10: colors[6]
      // 8: colors[7],
      // 9: colors[8],
      // 10: colors[9],
    };
  };
  var generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#fff";
    const colorTextBase = textBaseColor || "#000";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor(colorTextBase, 0.88),
      colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
      colorFill: getAlphaColor(colorTextBase, 0.15),
      colorFillSecondary: getAlphaColor(colorTextBase, 0.06),
      colorFillTertiary: getAlphaColor(colorTextBase, 0.04),
      colorFillQuaternary: getAlphaColor(colorTextBase, 0.02),
      colorBgSolid: getAlphaColor(colorTextBase, 1),
      colorBgSolidHover: getAlphaColor(colorTextBase, 0.75),
      colorBgSolidActive: getAlphaColor(colorTextBase, 0.95),
      colorBgLayout: getSolidColor(colorBgBase, 4),
      colorBgContainer: getSolidColor(colorBgBase, 0),
      colorBgElevated: getSolidColor(colorBgBase, 0),
      colorBgSpotlight: getAlphaColor(colorTextBase, 0.85),
      colorBgBlur: "transparent",
      colorBorder: getSolidColor(colorBgBase, 15),
      colorBorderSecondary: getSolidColor(colorBgBase, 6)
    };
  };

  // node_modules/antd/es/theme/themes/default/index.js
  function derivative(token2) {
    presetPrimaryColors.pink = presetPrimaryColors.magenta;
    presetPalettes.pink = presetPalettes.magenta;
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors = token2[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate(token2[colorKey]);
      return Array.from({
        length: 10
      }, () => 1).reduce((prev2, _, i) => {
        prev2[`${colorKey}-${i + 1}`] = colors[i];
        prev2[`${colorKey}${i + 1}`] = colors[i];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = Object.assign(Object.assign({}, prev2), cur);
      return prev2;
    }, {});
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    })), genFontMapToken_default(token2.fontSize)), genSizeMapToken(token2)), genControlHeight_default(token2)), genCommonMapToken(token2));
  }

  // node_modules/antd/es/theme/themes/default/theme.js
  var defaultTheme = createTheme(derivative);
  var theme_default = defaultTheme;

  // node_modules/antd/es/theme/context.js
  var defaultConfig = {
    token: seed_default,
    override: {
      override: seed_default
    },
    hashed: true
  };
  var DesignTokenContext = /* @__PURE__ */ import_react9.default.createContext(defaultConfig);

  // node_modules/antd/es/config-provider/context.js
  var React18 = __toESM(require_react());
  var defaultPrefixCls = "ant";
  var defaultIconPrefixCls = "anticon";
  var Variants = ["outlined", "borderless", "filled", "underlined"];
  var defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
  };
  var ConfigContext = /* @__PURE__ */ React18.createContext({
    // We provide a default function for Context without provider
    getPrefixCls: defaultGetPrefixCls,
    iconPrefixCls: defaultIconPrefixCls
  });
  var {
    Consumer: ConfigConsumer
  } = ConfigContext;
  var EMPTY_OBJECT = {};
  function useComponentConfig(propName) {
    const context = React18.useContext(ConfigContext);
    const {
      getPrefixCls,
      direction,
      getPopupContainer
    } = context;
    const propValue = context[propName];
    return Object.assign(Object.assign({
      classNames: EMPTY_OBJECT,
      styles: EMPTY_OBJECT
    }, propValue), {
      getPrefixCls,
      direction,
      getPopupContainer
    });
  }

  // node_modules/antd/es/config-provider/cssVariables.js
  var dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
  function getStyle(globalPrefixCls2, theme) {
    const variables = {};
    const formatColor = (color, updater) => {
      let clone = color.clone();
      clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
      return clone.toRgbString();
    };
    const fillColor = (colorVal, type5) => {
      const baseColor = new FastColor(colorVal);
      const colorPalettes = generate(baseColor.toRgbString());
      variables[`${type5}-color`] = formatColor(baseColor);
      variables[`${type5}-color-disabled`] = colorPalettes[1];
      variables[`${type5}-color-hover`] = colorPalettes[4];
      variables[`${type5}-color-active`] = colorPalettes[6];
      variables[`${type5}-color-outline`] = baseColor.clone().setA(0.2).toRgbString();
      variables[`${type5}-color-deprecated-bg`] = colorPalettes[0];
      variables[`${type5}-color-deprecated-border`] = colorPalettes[2];
    };
    if (theme.primaryColor) {
      fillColor(theme.primaryColor, "primary");
      const primaryColor = new FastColor(theme.primaryColor);
      const primaryColors = generate(primaryColor.toRgbString());
      primaryColors.forEach((color, index3) => {
        variables[`primary-${index3 + 1}`] = color;
      });
      variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c) => c.lighten(35));
      variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c) => c.lighten(20));
      variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c) => c.tint(20));
      variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c) => c.tint(50));
      variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c) => c.setA(c.a * 0.12));
      const primaryActiveColor = new FastColor(primaryColors[0]);
      variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c) => c.setA(c.a * 0.3));
      variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c) => c.darken(2));
    }
    if (theme.successColor) {
      fillColor(theme.successColor, "success");
    }
    if (theme.warningColor) {
      fillColor(theme.warningColor, "warning");
    }
    if (theme.errorColor) {
      fillColor(theme.errorColor, "error");
    }
    if (theme.infoColor) {
      fillColor(theme.infoColor, "info");
    }
    const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
    return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
  }
  function registerTheme(globalPrefixCls2, theme) {
    const style2 = getStyle(globalPrefixCls2, theme);
    if (canUseDom()) {
      updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
    } else {
      true ? warning_default2(false, "ConfigProvider", "SSR do not support dynamic theme with css variables.") : void 0;
    }
  }

  // node_modules/antd/es/config-provider/DisabledContext.js
  var React19 = __toESM(require_react());
  var DisabledContext = /* @__PURE__ */ React19.createContext(false);
  var DisabledContextProvider = ({
    children,
    disabled
  }) => {
    const originDisabled = React19.useContext(DisabledContext);
    return /* @__PURE__ */ React19.createElement(DisabledContext.Provider, {
      value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
    }, children);
  };
  var DisabledContext_default = DisabledContext;

  // node_modules/antd/es/config-provider/hooks/useConfig.js
  var import_react10 = __toESM(require_react());

  // node_modules/antd/es/config-provider/SizeContext.js
  var React20 = __toESM(require_react());
  var SizeContext = /* @__PURE__ */ React20.createContext(void 0);
  var SizeContextProvider = ({
    children,
    size
  }) => {
    const originSize = React20.useContext(SizeContext);
    return /* @__PURE__ */ React20.createElement(SizeContext.Provider, {
      value: size || originSize
    }, children);
  };
  var SizeContext_default = SizeContext;

  // node_modules/antd/es/config-provider/hooks/useConfig.js
  function useConfig() {
    const componentDisabled = (0, import_react10.useContext)(DisabledContext_default);
    const componentSize = (0, import_react10.useContext)(SizeContext_default);
    return {
      componentDisabled,
      componentSize
    };
  }
  var useConfig_default = useConfig;

  // node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
  var import_react12 = __toESM(require_react());

  // node_modules/@ant-design/cssinjs-utils/es/util/calc/calculator.js
  var AbstractCalculator = /* @__PURE__ */ _createClass(function AbstractCalculator2() {
    _classCallCheck(this, AbstractCalculator2);
  });
  var calculator_default2 = AbstractCalculator;

  // node_modules/@ant-design/cssinjs-utils/es/util/calc/CSSCalculator.js
  var CALC_UNIT2 = "CALC_UNIT";
  var regexp2 = new RegExp(CALC_UNIT2, "g");
  function unit2(value) {
    if (typeof value === "number") {
      return "".concat(value).concat(CALC_UNIT2);
    }
    return value;
  }
  var CSSCalculator2 = /* @__PURE__ */ function(_AbstractCalculator) {
    _inherits(CSSCalculator3, _AbstractCalculator);
    var _super = _createSuper(CSSCalculator3);
    function CSSCalculator3(num, unitlessCssVar) {
      var _this;
      _classCallCheck(this, CSSCalculator3);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "result", "");
      _defineProperty(_assertThisInitialized(_this), "unitlessCssVar", void 0);
      _defineProperty(_assertThisInitialized(_this), "lowPriority", void 0);
      var numType = _typeof(num);
      _this.unitlessCssVar = unitlessCssVar;
      if (num instanceof CSSCalculator3) {
        _this.result = "(".concat(num.result, ")");
      } else if (numType === "number") {
        _this.result = unit2(num);
      } else if (numType === "string") {
        _this.result = num;
      }
      return _this;
    }
    _createClass(CSSCalculator3, [{
      key: "add",
      value: function add(num) {
        if (num instanceof CSSCalculator3) {
          this.result = "".concat(this.result, " + ").concat(num.getResult());
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " + ").concat(unit2(num));
        }
        this.lowPriority = true;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(num) {
        if (num instanceof CSSCalculator3) {
          this.result = "".concat(this.result, " - ").concat(num.getResult());
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " - ").concat(unit2(num));
        }
        this.lowPriority = true;
        return this;
      }
    }, {
      key: "mul",
      value: function mul(num) {
        if (this.lowPriority) {
          this.result = "(".concat(this.result, ")");
        }
        if (num instanceof CSSCalculator3) {
          this.result = "".concat(this.result, " * ").concat(num.getResult(true));
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " * ").concat(num);
        }
        this.lowPriority = false;
        return this;
      }
    }, {
      key: "div",
      value: function div(num) {
        if (this.lowPriority) {
          this.result = "(".concat(this.result, ")");
        }
        if (num instanceof CSSCalculator3) {
          this.result = "".concat(this.result, " / ").concat(num.getResult(true));
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " / ").concat(num);
        }
        this.lowPriority = false;
        return this;
      }
    }, {
      key: "getResult",
      value: function getResult(force) {
        return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
      }
    }, {
      key: "equal",
      value: function equal(options) {
        var _this2 = this;
        var _ref = options || {}, cssUnit = _ref.unit;
        var mergedUnit = true;
        if (typeof cssUnit === "boolean") {
          mergedUnit = cssUnit;
        } else if (Array.from(this.unitlessCssVar).some(function(cssVar) {
          return _this2.result.includes(cssVar);
        })) {
          mergedUnit = false;
        }
        this.result = this.result.replace(regexp2, mergedUnit ? "px" : "");
        if (typeof this.lowPriority !== "undefined") {
          return "calc(".concat(this.result, ")");
        }
        return this.result;
      }
    }]);
    return CSSCalculator3;
  }(calculator_default2);

  // node_modules/@ant-design/cssinjs-utils/es/util/calc/NumCalculator.js
  var NumCalculator2 = /* @__PURE__ */ function(_AbstractCalculator) {
    _inherits(NumCalculator3, _AbstractCalculator);
    var _super = _createSuper(NumCalculator3);
    function NumCalculator3(num) {
      var _this;
      _classCallCheck(this, NumCalculator3);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "result", 0);
      if (num instanceof NumCalculator3) {
        _this.result = num.result;
      } else if (typeof num === "number") {
        _this.result = num;
      }
      return _this;
    }
    _createClass(NumCalculator3, [{
      key: "add",
      value: function add(num) {
        if (num instanceof NumCalculator3) {
          this.result += num.result;
        } else if (typeof num === "number") {
          this.result += num;
        }
        return this;
      }
    }, {
      key: "sub",
      value: function sub(num) {
        if (num instanceof NumCalculator3) {
          this.result -= num.result;
        } else if (typeof num === "number") {
          this.result -= num;
        }
        return this;
      }
    }, {
      key: "mul",
      value: function mul(num) {
        if (num instanceof NumCalculator3) {
          this.result *= num.result;
        } else if (typeof num === "number") {
          this.result *= num;
        }
        return this;
      }
    }, {
      key: "div",
      value: function div(num) {
        if (num instanceof NumCalculator3) {
          this.result /= num.result;
        } else if (typeof num === "number") {
          this.result /= num;
        }
        return this;
      }
    }, {
      key: "equal",
      value: function equal() {
        return this.result;
      }
    }]);
    return NumCalculator3;
  }(calculator_default2);
  var NumCalculator_default = NumCalculator2;

  // node_modules/@ant-design/cssinjs-utils/es/util/calc/index.js
  var genCalc = function genCalc2(type5, unitlessCssVar) {
    var Calculator = type5 === "css" ? CSSCalculator2 : NumCalculator_default;
    return function(num) {
      return new Calculator(num, unitlessCssVar);
    };
  };
  var calc_default2 = genCalc;

  // node_modules/@ant-design/cssinjs-utils/es/util/getCompVarPrefix.js
  var getCompVarPrefix = function getCompVarPrefix2(component, prefix) {
    return "".concat([prefix, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
  };
  var getCompVarPrefix_default = getCompVarPrefix;

  // node_modules/rc-util/es/hooks/useEvent.js
  var React21 = __toESM(require_react());
  function useEvent(callback) {
    var fnRef = React21.useRef();
    fnRef.current = callback;
    var memoFn = React21.useCallback(function() {
      var _fnRef$current;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
    }, []);
    return memoFn;
  }

  // node_modules/rc-util/es/hooks/useState.js
  var React22 = __toESM(require_react());
  function useSafeState(defaultValue) {
    var destroyRef = React22.useRef(false);
    var _React$useState = React22.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
    React22.useEffect(function() {
      destroyRef.current = false;
      return function() {
        destroyRef.current = true;
      };
    }, []);
    function safeSetState(updater, ignoreDestroy) {
      if (ignoreDestroy && destroyRef.current) {
        return;
      }
      setValue(updater);
    }
    return [value, safeSetState];
  }

  // node_modules/rc-util/es/hooks/useMergedState.js
  function hasValue(value) {
    return value !== void 0;
  }
  function useMergedState(defaultStateValue, option) {
    var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
    var _useState = useSafeState(function() {
      if (hasValue(value)) {
        return value;
      } else if (hasValue(defaultValue)) {
        return typeof defaultValue === "function" ? defaultValue() : defaultValue;
      } else {
        return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      }
    }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
    var mergedValue = value !== void 0 ? value : innerValue;
    var postMergedValue = postState ? postState(mergedValue) : mergedValue;
    var onChangeFn = useEvent(onChange);
    var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
    useLayoutUpdateEffect(function() {
      var prev2 = prevValue[0];
      if (innerValue !== prev2) {
        onChangeFn(innerValue, prev2);
      }
    }, [prevValue]);
    useLayoutUpdateEffect(function() {
      if (!hasValue(value)) {
        setInnerValue(value);
      }
    }, [value]);
    var triggerChange = useEvent(function(updater, ignoreDestroy) {
      setInnerValue(updater, ignoreDestroy);
      setPrevValue([mergedValue], ignoreDestroy);
    });
    return [postMergedValue, triggerChange];
  }

  // node_modules/@ant-design/cssinjs-utils/es/util/getComponentToken.js
  function getComponentToken(component, token2, defaultToken, options) {
    var customToken = _objectSpread2({}, token2[component]);
    if (options !== null && options !== void 0 && options.deprecatedTokens) {
      var deprecatedTokens = options.deprecatedTokens;
      deprecatedTokens.forEach(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
        if (true) {
          warning_default(!(customToken !== null && customToken !== void 0 && customToken[oldTokenKey]), "Component Token `".concat(String(oldTokenKey), "` of ").concat(String(component), " is deprecated. Please use `").concat(String(newTokenKey), "` instead."));
        }
        if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
          var _customToken$newToken;
          (_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 ? _customToken$newToken : customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey];
        }
      });
    }
    var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);
    Object.keys(mergedToken).forEach(function(key) {
      if (mergedToken[key] === token2[key]) {
        delete mergedToken[key];
      }
    });
    return mergedToken;
  }
  var getComponentToken_default = getComponentToken;

  // node_modules/@ant-design/cssinjs-utils/es/util/statistic.js
  var enableStatistic = true;
  var recording = true;
  function merge2() {
    for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
      objs[_key] = arguments[_key];
    }
    if (!enableStatistic) {
      return Object.assign.apply(Object, [{}].concat(objs));
    }
    recording = false;
    var ret = {};
    objs.forEach(function(obj) {
      if (_typeof(obj) !== "object") {
        return;
      }
      var keys2 = Object.keys(obj);
      keys2.forEach(function(key) {
        Object.defineProperty(ret, key, {
          configurable: true,
          enumerable: true,
          get: function get2() {
            return obj[key];
          }
        });
      });
    });
    recording = true;
    return ret;
  }
  var statistic = {};
  function noop2() {
  }
  var statisticToken = function statisticToken2(token2) {
    var tokenKeys2;
    var proxy = token2;
    var flush = noop2;
    if (enableStatistic && typeof Proxy !== "undefined") {
      tokenKeys2 = /* @__PURE__ */ new Set();
      proxy = new Proxy(token2, {
        get: function get2(obj, prop) {
          if (recording) {
            var _tokenKeys;
            (_tokenKeys = tokenKeys2) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
          }
          return obj[prop];
        }
      });
      flush = function flush2(componentName, componentToken) {
        var _statistic$componentN;
        statistic[componentName] = {
          global: Array.from(tokenKeys2),
          component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
        };
      };
    }
    return {
      token: proxy,
      keys: tokenKeys2,
      flush
    };
  };
  var statistic_default = statisticToken;

  // node_modules/@ant-design/cssinjs-utils/es/util/getDefaultComponentToken.js
  function getDefaultComponentToken(component, token2, getDefaultToken) {
    if (typeof getDefaultToken === "function") {
      var _token$component;
      return getDefaultToken(merge2(token2, (_token$component = token2[component]) !== null && _token$component !== void 0 ? _token$component : {}));
    }
    return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
  }
  var getDefaultComponentToken_default = getDefaultComponentToken;

  // node_modules/@ant-design/cssinjs-utils/es/util/maxmin.js
  function genMaxMin(type5) {
    if (type5 === "js") {
      return {
        max: Math.max,
        min: Math.min
      };
    }
    return {
      max: function max() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return "max(".concat(args.map(function(value) {
          return unit(value);
        }).join(","), ")");
      },
      min: function min() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return "min(".concat(args.map(function(value) {
          return unit(value);
        }).join(","), ")");
      }
    };
  }
  var maxmin_default = genMaxMin;

  // node_modules/@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js
  var import_react11 = __toESM(require_react());
  var BEAT_LIMIT = 1e3 * 60 * 10;
  var ArrayKeyMap = /* @__PURE__ */ function() {
    function ArrayKeyMap2() {
      _classCallCheck(this, ArrayKeyMap2);
      _defineProperty(this, "map", /* @__PURE__ */ new Map());
      _defineProperty(this, "objectIDMap", /* @__PURE__ */ new WeakMap());
      _defineProperty(this, "nextID", 0);
      _defineProperty(this, "lastAccessBeat", /* @__PURE__ */ new Map());
      _defineProperty(this, "accessBeat", 0);
    }
    _createClass(ArrayKeyMap2, [{
      key: "set",
      value: function set2(keys2, value) {
        this.clear();
        var compositeKey = this.getCompositeKey(keys2);
        this.map.set(compositeKey, value);
        this.lastAccessBeat.set(compositeKey, Date.now());
      }
    }, {
      key: "get",
      value: function get2(keys2) {
        var compositeKey = this.getCompositeKey(keys2);
        var cache = this.map.get(compositeKey);
        this.lastAccessBeat.set(compositeKey, Date.now());
        this.accessBeat += 1;
        return cache;
      }
    }, {
      key: "getCompositeKey",
      value: function getCompositeKey(keys2) {
        var _this = this;
        var ids = keys2.map(function(key) {
          if (key && _typeof(key) === "object") {
            return "obj_".concat(_this.getObjectID(key));
          }
          return "".concat(_typeof(key), "_").concat(key);
        });
        return ids.join("|");
      }
    }, {
      key: "getObjectID",
      value: function getObjectID(obj) {
        if (this.objectIDMap.has(obj)) {
          return this.objectIDMap.get(obj);
        }
        var id = this.nextID;
        this.objectIDMap.set(obj, id);
        this.nextID += 1;
        return id;
      }
    }, {
      key: "clear",
      value: function clear() {
        var _this2 = this;
        if (this.accessBeat > 1e4) {
          var now2 = Date.now();
          this.lastAccessBeat.forEach(function(beat, key) {
            if (now2 - beat > BEAT_LIMIT) {
              _this2.map.delete(key);
              _this2.lastAccessBeat.delete(key);
            }
          });
          this.accessBeat = 0;
        }
      }
    }]);
    return ArrayKeyMap2;
  }();
  var uniqueMap = new ArrayKeyMap();
  function useUniqueMemo(memoFn, deps) {
    return import_react11.default.useMemo(function() {
      var cachedValue = uniqueMap.get(deps);
      if (cachedValue) {
        return cachedValue;
      }
      var newValue = memoFn();
      uniqueMap.set(deps, newValue);
      return newValue;
    }, deps);
  }
  var useUniqueMemo_default = useUniqueMemo;

  // node_modules/@ant-design/cssinjs-utils/es/hooks/useCSP.js
  var useDefaultCSP = function useDefaultCSP2() {
    return {};
  };
  var useCSP_default = useDefaultCSP;

  // node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
  function genStyleUtils(config) {
    var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useCSP_default : _config$useCSP, useToken2 = config.useToken, usePrefix = config.usePrefix, getResetStyles = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
    function genStyleHooks2(component, styleFn, getDefaultToken, options) {
      var componentName = Array.isArray(component) ? component[0] : component;
      function prefixToken(key) {
        return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
      }
      var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
      var originCompUnitless = typeof getCompUnitless === "function" ? getCompUnitless(component) : {};
      var compUnitless = _objectSpread2(_objectSpread2({}, originCompUnitless), {}, _defineProperty({}, prefixToken("zIndexPopup"), true));
      Object.keys(originUnitless).forEach(function(key) {
        compUnitless[prefixToken(key)] = originUnitless[key];
      });
      var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
        unitless: compUnitless,
        prefixToken
      });
      var useStyle = genComponentStyleHook2(component, styleFn, getDefaultToken, mergedOptions);
      var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
      return function(prefixCls) {
        var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
        var _useStyle = useStyle(prefixCls, rootCls), _useStyle2 = _slicedToArray(_useStyle, 2), hashId = _useStyle2[1];
        var _useCSSVar = useCSSVar(rootCls), _useCSSVar2 = _slicedToArray(_useCSSVar, 2), wrapCSSVar = _useCSSVar2[0], cssVarCls = _useCSSVar2[1];
        return [wrapCSSVar, hashId, cssVarCls];
      };
    }
    function genCSSVarRegister(component, getDefaultToken, options) {
      var compUnitless = options.unitless, _options$injectStyle = options.injectStyle, injectStyle = _options$injectStyle === void 0 ? true : _options$injectStyle, prefixToken = options.prefixToken, ignore2 = options.ignore;
      var CSSVarRegister = function CSSVarRegister2(_ref) {
        var rootCls = _ref.rootCls, _ref$cssVar = _ref.cssVar, cssVar = _ref$cssVar === void 0 ? {} : _ref$cssVar;
        var _useToken = useToken2(), realToken = _useToken.realToken;
        useCSSVarRegister_default({
          path: [component],
          prefix: cssVar.prefix,
          key: cssVar.key,
          unitless: compUnitless,
          ignore: ignore2,
          token: realToken,
          scope: rootCls
        }, function() {
          var defaultToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
          var componentToken = getComponentToken_default(component, realToken, defaultToken, {
            deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens
          });
          Object.keys(defaultToken).forEach(function(key) {
            componentToken[prefixToken(key)] = componentToken[key];
            delete componentToken[key];
          });
          return componentToken;
        });
        return null;
      };
      var useCSSVar = function useCSSVar2(rootCls) {
        var _useToken2 = useToken2(), cssVar = _useToken2.cssVar;
        return [function(node2) {
          return injectStyle && cssVar ? /* @__PURE__ */ import_react12.default.createElement(import_react12.default.Fragment, null, /* @__PURE__ */ import_react12.default.createElement(CSSVarRegister, {
            rootCls,
            cssVar,
            component
          }), node2) : node2;
        }, cssVar === null || cssVar === void 0 ? void 0 : cssVar.key];
      };
      return useCSSVar;
    }
    function genComponentStyleHook2(componentName, styleFn, getDefaultToken) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
      var _cells = _slicedToArray(cells, 1), component = _cells[0];
      var concatComponent = cells.join("-");
      var mergedLayer = config.layer || {
        name: "antd"
      };
      return function(prefixCls) {
        var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
        var _useToken3 = useToken2(), theme = _useToken3.theme, realToken = _useToken3.realToken, hashId = _useToken3.hashId, token2 = _useToken3.token, cssVar = _useToken3.cssVar;
        var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls;
        var csp = useCSP();
        var type5 = cssVar ? "css" : "js";
        var calc = useUniqueMemo_default(function() {
          var unitlessCssVar = /* @__PURE__ */ new Set();
          if (cssVar) {
            Object.keys(options.unitless || {}).forEach(function(key) {
              unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
              unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)));
            });
          }
          return calc_default2(type5, unitlessCssVar);
        }, [type5, component, cssVar === null || cssVar === void 0 ? void 0 : cssVar.prefix]);
        var _genMaxMin = maxmin_default(type5), max = _genMaxMin.max, min = _genMaxMin.min;
        var sharedConfig = {
          theme,
          token: token2,
          hashId,
          nonce: function nonce() {
            return csp.nonce;
          },
          clientOnly: options.clientOnly,
          layer: mergedLayer,
          // antd is always at top of styles
          order: options.order || -999
        };
        if (typeof getResetStyles === "function") {
          useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
            clientOnly: false,
            path: ["Shared", rootPrefixCls]
          }), function() {
            return getResetStyles(token2, {
              prefix: {
                rootPrefixCls,
                iconPrefixCls
              },
              csp
            });
          });
        }
        var wrapSSR = useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
          path: [concatComponent, prefixCls, iconPrefixCls]
        }), function() {
          if (options.injectStyle === false) {
            return [];
          }
          var _statisticToken = statistic_default(token2), proxyToken = _statisticToken.token, flush = _statisticToken.flush;
          var defaultComponentToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
          var componentCls = ".".concat(prefixCls);
          var componentToken = getComponentToken_default(component, realToken, defaultComponentToken, {
            deprecatedTokens: options.deprecatedTokens
          });
          if (cssVar && defaultComponentToken && _typeof(defaultComponentToken) === "object") {
            Object.keys(defaultComponentToken).forEach(function(key) {
              defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)), ")");
            });
          }
          var mergedToken = merge2(proxyToken, {
            componentCls,
            prefixCls,
            iconCls: ".".concat(iconPrefixCls),
            antCls: ".".concat(rootPrefixCls),
            calc,
            // @ts-ignore
            max,
            // @ts-ignore
            min
          }, cssVar ? defaultComponentToken : componentToken);
          var styleInterpolation = styleFn(mergedToken, {
            hashId,
            prefixCls,
            rootPrefixCls,
            iconPrefixCls
          });
          flush(component, componentToken);
          var commonStyle = typeof getCommonStyle === "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
          return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
        });
        return [wrapSSR, hashId];
      };
    }
    function genSubStyleComponent2(componentName, styleFn, getDefaultToken) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var useStyle = genComponentStyleHook2(componentName, styleFn, getDefaultToken, _objectSpread2({
        resetStyle: false,
        // Sub Style should default after root one
        order: -998
      }, options));
      var StyledComponent = function StyledComponent2(_ref2) {
        var prefixCls = _ref2.prefixCls, _ref2$rootCls = _ref2.rootCls, rootCls = _ref2$rootCls === void 0 ? prefixCls : _ref2$rootCls;
        useStyle(prefixCls, rootCls);
        return null;
      };
      if (true) {
        StyledComponent.displayName = "SubStyle_".concat(String(Array.isArray(componentName) ? componentName.join(".") : componentName));
      }
      return StyledComponent;
    }
    return {
      genStyleHooks: genStyleHooks2,
      genSubStyleComponent: genSubStyleComponent2,
      genComponentStyleHook: genComponentStyleHook2
    };
  }
  var genStyleUtils_default = genStyleUtils;

  // node_modules/antd/es/theme/interface/presetColors.js
  var PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];

  // node_modules/antd/es/theme/useToken.js
  var import_react13 = __toESM(require_react());

  // node_modules/antd/es/version/version.js
  var version_default = "5.26.7";

  // node_modules/antd/es/version/index.js
  var version_default2 = version_default;

  // node_modules/antd/es/theme/util/getAlphaColor.js
  function isStableColor(color) {
    return color >= 0 && color <= 255;
  }
  function getAlphaColor2(frontColor, backgroundColor) {
    const {
      r: fR,
      g: fG,
      b: fB,
      a: originAlpha
    } = new FastColor(frontColor).toRgb();
    if (originAlpha < 1) {
      return frontColor;
    }
    const {
      r: bR,
      g: bG,
      b: bB
    } = new FastColor(backgroundColor).toRgb();
    for (let fA = 0.01; fA <= 1; fA += 0.01) {
      const r2 = Math.round((fR - bR * (1 - fA)) / fA);
      const g = Math.round((fG - bG * (1 - fA)) / fA);
      const b = Math.round((fB - bB * (1 - fA)) / fA);
      if (isStableColor(r2) && isStableColor(g) && isStableColor(b)) {
        return new FastColor({
          r: r2,
          g,
          b,
          a: Math.round(fA * 100) / 100
        }).toRgbString();
      }
    }
    return new FastColor({
      r: fR,
      g: fG,
      b: fB,
      a: 1
    }).toRgbString();
  }
  var getAlphaColor_default = getAlphaColor2;

  // node_modules/antd/es/theme/util/alias.js
  var __rest = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function formatToken(derivativeToken) {
    const {
      override
    } = derivativeToken, restToken = __rest(derivativeToken, ["override"]);
    const overrideTokens = Object.assign({}, override);
    Object.keys(seed_default).forEach((token2) => {
      delete overrideTokens[token2];
    });
    const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
    const screenXS = 480;
    const screenSM = 576;
    const screenMD = 768;
    const screenLG = 992;
    const screenXL = 1200;
    const screenXXL = 1600;
    if (mergedToken.motion === false) {
      const fastDuration = "0s";
      mergedToken.motionDurationFast = fastDuration;
      mergedToken.motionDurationMid = fastDuration;
      mergedToken.motionDurationSlow = fastDuration;
    }
    const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
      // ============== Background ============== //
      colorFillContent: mergedToken.colorFillSecondary,
      colorFillContentHover: mergedToken.colorFill,
      colorFillAlter: mergedToken.colorFillQuaternary,
      colorBgContainerDisabled: mergedToken.colorFillTertiary,
      // ============== Split ============== //
      colorBorderBg: mergedToken.colorBgContainer,
      colorSplit: getAlphaColor_default(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
      // ============== Text ============== //
      colorTextPlaceholder: mergedToken.colorTextQuaternary,
      colorTextDisabled: mergedToken.colorTextQuaternary,
      colorTextHeading: mergedToken.colorText,
      colorTextLabel: mergedToken.colorTextSecondary,
      colorTextDescription: mergedToken.colorTextTertiary,
      colorTextLightSolid: mergedToken.colorWhite,
      colorHighlight: mergedToken.colorError,
      colorBgTextHover: mergedToken.colorFillSecondary,
      colorBgTextActive: mergedToken.colorFill,
      colorIcon: mergedToken.colorTextTertiary,
      colorIconHover: mergedToken.colorText,
      colorErrorOutline: getAlphaColor_default(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
      colorWarningOutline: getAlphaColor_default(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
      // Font
      fontSizeIcon: mergedToken.fontSizeSM,
      // Line
      lineWidthFocus: mergedToken.lineWidth * 3,
      // Control
      lineWidth: mergedToken.lineWidth,
      controlOutlineWidth: mergedToken.lineWidth * 2,
      // Checkbox size and expand icon size
      controlInteractiveSize: mergedToken.controlHeight / 2,
      controlItemBgHover: mergedToken.colorFillTertiary,
      controlItemBgActive: mergedToken.colorPrimaryBg,
      controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
      controlItemBgActiveDisabled: mergedToken.colorFill,
      controlTmpOutline: mergedToken.colorFillQuaternary,
      controlOutline: getAlphaColor_default(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
      lineType: mergedToken.lineType,
      borderRadius: mergedToken.borderRadius,
      borderRadiusXS: mergedToken.borderRadiusXS,
      borderRadiusSM: mergedToken.borderRadiusSM,
      borderRadiusLG: mergedToken.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: mergedToken.sizeXXS,
      paddingXS: mergedToken.sizeXS,
      paddingSM: mergedToken.sizeSM,
      padding: mergedToken.size,
      paddingMD: mergedToken.sizeMD,
      paddingLG: mergedToken.sizeLG,
      paddingXL: mergedToken.sizeXL,
      paddingContentHorizontalLG: mergedToken.sizeLG,
      paddingContentVerticalLG: mergedToken.sizeMS,
      paddingContentHorizontal: mergedToken.sizeMS,
      paddingContentVertical: mergedToken.sizeSM,
      paddingContentHorizontalSM: mergedToken.size,
      paddingContentVerticalSM: mergedToken.sizeXS,
      marginXXS: mergedToken.sizeXXS,
      marginXS: mergedToken.sizeXS,
      marginSM: mergedToken.sizeSM,
      margin: mergedToken.size,
      marginMD: mergedToken.sizeMD,
      marginLG: mergedToken.sizeLG,
      marginXL: mergedToken.sizeXL,
      marginXXL: mergedToken.sizeXXL,
      boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS,
      screenXSMin: screenXS,
      screenXSMax: screenSM - 1,
      screenSM,
      screenSMMin: screenSM,
      screenSMMax: screenMD - 1,
      screenMD,
      screenMDMin: screenMD,
      screenMDMax: screenLG - 1,
      screenLG,
      screenLGMin: screenLG,
      screenLGMax: screenXL - 1,
      screenXL,
      screenXLMin: screenXL,
      screenXLMax: screenXXL - 1,
      screenXXL,
      screenXXLMin: screenXXL,
      boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
      boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), overrideTokens);
    return aliasToken;
  }

  // node_modules/antd/es/theme/useToken.js
  var __rest2 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var unitless = {
    lineHeight: true,
    lineHeightSM: true,
    lineHeightLG: true,
    lineHeightHeading1: true,
    lineHeightHeading2: true,
    lineHeightHeading3: true,
    lineHeightHeading4: true,
    lineHeightHeading5: true,
    opacityLoading: true,
    fontWeightStrong: true,
    zIndexPopupBase: true,
    zIndexBase: true,
    opacityImage: true
  };
  var ignore = {
    size: true,
    sizeSM: true,
    sizeLG: true,
    sizeMD: true,
    sizeXS: true,
    sizeXXS: true,
    sizeMS: true,
    sizeXL: true,
    sizeXXL: true,
    sizeUnit: true,
    sizeStep: true,
    motionBase: true,
    motionUnit: true
  };
  var preserve = {
    screenXS: true,
    screenXSMin: true,
    screenXSMax: true,
    screenSM: true,
    screenSMMin: true,
    screenSMMax: true,
    screenMD: true,
    screenMDMin: true,
    screenMDMax: true,
    screenLG: true,
    screenLGMin: true,
    screenLGMax: true,
    screenXL: true,
    screenXLMin: true,
    screenXLMax: true,
    screenXXL: true,
    screenXXLMin: true
  };
  var getComputedToken3 = (originToken, overrideToken, theme) => {
    const derivativeToken = theme.getDerivativeToken(originToken);
    const {
      override
    } = overrideToken, components = __rest2(overrideToken, ["override"]);
    let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), {
      override
    });
    mergedDerivativeToken = formatToken(mergedDerivativeToken);
    if (components) {
      Object.entries(components).forEach(([key, value]) => {
        const {
          theme: componentTheme
        } = value, componentTokens = __rest2(value, ["theme"]);
        let mergedComponentToken = componentTokens;
        if (componentTheme) {
          mergedComponentToken = getComputedToken3(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), {
            override: componentTokens
          }, componentTheme);
        }
        mergedDerivativeToken[key] = mergedComponentToken;
      });
    }
    return mergedDerivativeToken;
  };
  function useToken() {
    const {
      token: rootDesignToken,
      hashed,
      theme,
      override,
      cssVar
    } = import_react13.default.useContext(DesignTokenContext);
    const salt = `${version_default2}-${hashed || ""}`;
    const mergedTheme = theme || theme_default;
    const [token2, hashId, realToken] = useCacheToken(mergedTheme, [seed_default, rootDesignToken], {
      salt,
      override,
      getComputedToken: getComputedToken3,
      // formatToken will not be consumed after 1.15.0 with getComputedToken.
      // But token will break if @ant-design/cssinjs is under 1.15.0 without it
      formatToken,
      cssVar: cssVar && {
        prefix: cssVar.prefix,
        key: cssVar.key,
        unitless,
        ignore,
        preserve
      }
    });
    return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar];
  }

  // node_modules/antd/es/theme/util/genStyleUtils.js
  var import_react14 = __toESM(require_react());

  // node_modules/antd/es/style/index.js
  var textEllipsis = {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  };
  var resetComponent = (token2, needInheritFontFamily = false) => ({
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: token2.colorText,
    fontSize: token2.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: token2.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
  });
  var resetIcon = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
      lineHeight: 1
    },
    svg: {
      display: "inline-block"
    }
  });
  var clearFix = () => ({
    // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
    "&::before": {
      display: "table",
      content: '""'
    },
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/21864
      display: "table",
      clear: "both",
      content: '""'
    }
  });
  var genLinkStyle = (token2) => ({
    a: {
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      backgroundColor: "transparent",
      // remove the gray background on active links in IE 10.
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      // remove gaps in links underline in iOS 8+ and Safari 8+.
      "&:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      },
      "&:active, &:hover": {
        textDecoration: token2.linkHoverDecoration,
        outline: 0
      },
      // https://github.com/ant-design/ant-design/issues/22503
      "&:focus": {
        textDecoration: token2.linkFocusDecoration,
        outline: 0
      },
      "&[disabled]": {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  });
  var genCommonStyle = (token2, componentPrefixCls, rootCls, resetFont) => {
    const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
    const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
    const resetStyle = {
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      }
    };
    let resetFontStyle = {};
    if (resetFont !== false) {
      resetFontStyle = {
        fontFamily: token2.fontFamily,
        fontSize: token2.fontSize
      };
    }
    return {
      [rootPrefixSelector]: Object.assign(Object.assign(Object.assign({}, resetFontStyle), resetStyle), {
        [prefixSelector]: resetStyle
      })
    };
  };
  var genFocusOutline = (token2, offset3) => ({
    outline: `${unit(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
    outlineOffset: offset3 !== null && offset3 !== void 0 ? offset3 : 1,
    transition: "outline-offset 0s, outline 0s"
  });
  var genFocusStyle = (token2, offset3) => ({
    "&:focus-visible": Object.assign({}, genFocusOutline(token2, offset3))
  });
  var genIconStyle = (iconPrefixCls) => ({
    [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
      [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
        display: "block"
      }
    })
  });
  var operationUnit = (token2) => Object.assign(Object.assign({
    // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
    // And Typography use this to generate link style which should not do this.
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    outline: "none",
    cursor: "pointer",
    transition: `all ${token2.motionDurationSlow}`,
    border: 0,
    padding: 0,
    background: "none",
    userSelect: "none"
  }, genFocusStyle(token2)), {
    "&:focus, &:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    }
  });

  // node_modules/antd/es/theme/util/genStyleUtils.js
  var {
    genStyleHooks,
    genComponentStyleHook,
    genSubStyleComponent
  } = genStyleUtils_default({
    usePrefix: () => {
      const {
        getPrefixCls,
        iconPrefixCls
      } = (0, import_react14.useContext)(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      return {
        rootPrefixCls,
        iconPrefixCls
      };
    },
    useToken: () => {
      const [theme, realToken, hashId, token2, cssVar] = useToken();
      return {
        theme,
        realToken,
        hashId,
        token: token2,
        cssVar
      };
    },
    useCSP: () => {
      const {
        csp
      } = (0, import_react14.useContext)(ConfigContext);
      return csp !== null && csp !== void 0 ? csp : {};
    },
    getResetStyles: (token2, config) => {
      var _a;
      const linkStyle = genLinkStyle(token2);
      return [linkStyle, {
        "&": linkStyle
      }, genIconStyle((_a = config === null || config === void 0 ? void 0 : config.prefix.iconPrefixCls) !== null && _a !== void 0 ? _a : defaultIconPrefixCls)];
    },
    getCommonStyle: genCommonStyle,
    getCompUnitless: () => unitless
  });

  // node_modules/antd/es/theme/util/genPresetColor.js
  function genPresetColor(token2, genCss) {
    return PresetColors.reduce((prev2, colorKey) => {
      const lightColor = token2[`${colorKey}1`];
      const lightBorderColor = token2[`${colorKey}3`];
      const darkColor = token2[`${colorKey}6`];
      const textColor = token2[`${colorKey}7`];
      return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
        lightColor,
        lightBorderColor,
        darkColor,
        textColor
      }));
    }, {});
  }

  // node_modules/antd/es/theme/util/useResetIconStyle.js
  var useResetIconStyle = (iconPrefixCls, csp) => {
    const [theme, token2] = useToken();
    return useStyleRegister({
      theme,
      token: token2,
      hashId: "",
      path: ["ant-design-icons", iconPrefixCls],
      nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce,
      layer: {
        name: "antd"
      }
    }, () => [genIconStyle(iconPrefixCls)]);
  };
  var useResetIconStyle_default = useResetIconStyle;

  // node_modules/antd/es/config-provider/hooks/useThemeKey.js
  var React26 = __toESM(require_react());
  var fullClone3 = Object.assign({}, React26);
  var {
    useId
  } = fullClone3;
  var useEmptyId = () => "";
  var useThemeKey = typeof useId === "undefined" ? useEmptyId : useId;
  var useThemeKey_default = useThemeKey;

  // node_modules/antd/es/config-provider/hooks/useTheme.js
  function useTheme(theme, parentTheme, config) {
    var _a, _b;
    const warning6 = devUseWarning("ConfigProvider");
    const themeConfig = theme || {};
    const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? Object.assign(Object.assign({}, defaultConfig), {
      hashed: (_a = parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.hashed) !== null && _a !== void 0 ? _a : defaultConfig.hashed,
      cssVar: parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.cssVar
    }) : parentTheme;
    const themeKey = useThemeKey_default();
    if (true) {
      const cssVarEnabled = themeConfig.cssVar || parentThemeConfig.cssVar;
      const validKey = !!(typeof themeConfig.cssVar === "object" && ((_b = themeConfig.cssVar) === null || _b === void 0 ? void 0 : _b.key) || themeKey);
      true ? warning6(!cssVarEnabled || validKey, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.") : void 0;
    }
    return useMemo(() => {
      var _a2, _b2;
      if (!theme) {
        return parentTheme;
      }
      const mergedComponents = Object.assign({}, parentThemeConfig.components);
      Object.keys(theme.components || {}).forEach((componentName) => {
        mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme.components[componentName]);
      });
      const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
      const mergedCssVar = ((_a2 = themeConfig.cssVar) !== null && _a2 !== void 0 ? _a2 : parentThemeConfig.cssVar) && Object.assign(Object.assign(Object.assign({
        prefix: config === null || config === void 0 ? void 0 : config.prefixCls
      }, typeof parentThemeConfig.cssVar === "object" ? parentThemeConfig.cssVar : {}), typeof themeConfig.cssVar === "object" ? themeConfig.cssVar : {}), {
        key: typeof themeConfig.cssVar === "object" && ((_b2 = themeConfig.cssVar) === null || _b2 === void 0 ? void 0 : _b2.key) || cssVarKey
      });
      return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
        token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
        components: mergedComponents,
        cssVar: mergedCssVar
      });
    }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index3) => {
      const nextTheme = next2[index3];
      return !isEqual_default(prevTheme, nextTheme, true);
    }));
  }

  // node_modules/antd/es/config-provider/MotionWrapper.js
  var React36 = __toESM(require_react());

  // node_modules/rc-motion/es/CSSMotion.js
  var import_classnames = __toESM(require_classnames());
  var React34 = __toESM(require_react());
  var import_react18 = __toESM(require_react());

  // node_modules/rc-motion/es/context.js
  var React27 = __toESM(require_react());
  var _excluded = ["children"];
  var Context = /* @__PURE__ */ React27.createContext({});
  function MotionProvider(_ref) {
    var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded);
    return /* @__PURE__ */ React27.createElement(Context.Provider, {
      value: props
    }, children);
  }

  // node_modules/rc-motion/es/DomWrapper.js
  var React28 = __toESM(require_react());
  var DomWrapper2 = /* @__PURE__ */ function(_React$Component) {
    _inherits(DomWrapper3, _React$Component);
    var _super = _createSuper(DomWrapper3);
    function DomWrapper3() {
      _classCallCheck(this, DomWrapper3);
      return _super.apply(this, arguments);
    }
    _createClass(DomWrapper3, [{
      key: "render",
      value: function render4() {
        return this.props.children;
      }
    }]);
    return DomWrapper3;
  }(React28.Component);
  var DomWrapper_default = DomWrapper2;

  // node_modules/rc-util/es/hooks/useSyncState.js
  var React29 = __toESM(require_react());
  function useSyncState(defaultValue) {
    var _React$useReducer = React29.useReducer(function(x) {
      return x + 1;
    }, 0), _React$useReducer2 = _slicedToArray(_React$useReducer, 2), forceUpdate = _React$useReducer2[1];
    var currentValueRef = React29.useRef(defaultValue);
    var getValue3 = useEvent(function() {
      return currentValueRef.current;
    });
    var setValue = useEvent(function(updater) {
      currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
      forceUpdate();
    });
    return [getValue3, setValue];
  }

  // node_modules/rc-motion/es/hooks/useStatus.js
  var React33 = __toESM(require_react());
  var import_react17 = __toESM(require_react());

  // node_modules/rc-motion/es/interface.js
  var STATUS_NONE = "none";
  var STATUS_APPEAR = "appear";
  var STATUS_ENTER = "enter";
  var STATUS_LEAVE = "leave";
  var STEP_NONE = "none";
  var STEP_PREPARE = "prepare";
  var STEP_START = "start";
  var STEP_ACTIVE = "active";
  var STEP_ACTIVATED = "end";
  var STEP_PREPARED = "prepared";

  // node_modules/rc-motion/es/hooks/useDomMotionEvents.js
  var React30 = __toESM(require_react());
  var import_react15 = __toESM(require_react());

  // node_modules/rc-motion/es/util/motion.js
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
    prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
    prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
    prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
    return prefixes;
  }
  function getVendorPrefixes(domSupport, win) {
    var prefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    if (domSupport) {
      if (!("AnimationEvent" in win)) {
        delete prefixes.animationend.animation;
      }
      if (!("TransitionEvent" in win)) {
        delete prefixes.transitionend.transition;
      }
    }
    return prefixes;
  }
  var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
  var style = {};
  if (canUseDom()) {
    _document$createEleme = document.createElement("div");
    style = _document$createEleme.style;
  }
  var _document$createEleme;
  var prefixedEventNames = {};
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    }
    var prefixMap = vendorPrefixes[eventName];
    if (prefixMap) {
      var stylePropList = Object.keys(prefixMap);
      var len = stylePropList.length;
      for (var i = 0; i < len; i += 1) {
        var styleProp = stylePropList[i];
        if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
          prefixedEventNames[eventName] = prefixMap[styleProp];
          return prefixedEventNames[eventName];
        }
      }
    }
    return "";
  }
  var internalAnimationEndName = getVendorPrefixedEventName("animationend");
  var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
  var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
  var animationEndName = internalAnimationEndName || "animationend";
  var transitionEndName = internalTransitionEndName || "transitionend";
  function getTransitionName(transitionName, transitionType) {
    if (!transitionName) return null;
    if (_typeof(transitionName) === "object") {
      var type5 = transitionType.replace(/-\w/g, function(match2) {
        return match2[1].toUpperCase();
      });
      return transitionName[type5];
    }
    return "".concat(transitionName, "-").concat(transitionType);
  }

  // node_modules/rc-motion/es/hooks/useDomMotionEvents.js
  var useDomMotionEvents_default = function(onInternalMotionEnd) {
    var cacheElementRef = (0, import_react15.useRef)();
    function removeMotionEvents(element) {
      if (element) {
        element.removeEventListener(transitionEndName, onInternalMotionEnd);
        element.removeEventListener(animationEndName, onInternalMotionEnd);
      }
    }
    function patchMotionEvents(element) {
      if (cacheElementRef.current && cacheElementRef.current !== element) {
        removeMotionEvents(cacheElementRef.current);
      }
      if (element && element !== cacheElementRef.current) {
        element.addEventListener(transitionEndName, onInternalMotionEnd);
        element.addEventListener(animationEndName, onInternalMotionEnd);
        cacheElementRef.current = element;
      }
    }
    React30.useEffect(function() {
      return function() {
        removeMotionEvents(cacheElementRef.current);
      };
    }, []);
    return [patchMotionEvents, removeMotionEvents];
  };

  // node_modules/rc-motion/es/hooks/useIsomorphicLayoutEffect.js
  var import_react16 = __toESM(require_react());
  var useIsomorphicLayoutEffect = canUseDom() ? import_react16.useLayoutEffect : import_react16.useEffect;
  var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect;

  // node_modules/rc-motion/es/hooks/useStepQueue.js
  var React32 = __toESM(require_react());

  // node_modules/rc-motion/es/hooks/useNextFrame.js
  var React31 = __toESM(require_react());
  var useNextFrame_default = function() {
    var nextFrameRef = React31.useRef(null);
    function cancelNextFrame() {
      raf_default.cancel(nextFrameRef.current);
    }
    function nextFrame(callback) {
      var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      cancelNextFrame();
      var nextFrameId = raf_default(function() {
        if (delay <= 1) {
          callback({
            isCanceled: function isCanceled() {
              return nextFrameId !== nextFrameRef.current;
            }
          });
        } else {
          nextFrame(callback, delay - 1);
        }
      });
      nextFrameRef.current = nextFrameId;
    }
    React31.useEffect(function() {
      return function() {
        cancelNextFrame();
      };
    }, []);
    return [nextFrame, cancelNextFrame];
  };

  // node_modules/rc-motion/es/hooks/useStepQueue.js
  var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
  var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
  var SkipStep = false;
  var DoStep = true;
  function isActive(step) {
    return step === STEP_ACTIVE || step === STEP_ACTIVATED;
  }
  var useStepQueue_default = function(status, prepareOnly, callback) {
    var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
    var _useNextFrame = useNextFrame_default(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
    function startQueue() {
      setStep(STEP_PREPARE, true);
    }
    var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
    useIsomorphicLayoutEffect_default(function() {
      if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
        var index3 = STEP_QUEUE.indexOf(step);
        var nextStep = STEP_QUEUE[index3 + 1];
        var result = callback(step);
        if (result === SkipStep) {
          setStep(nextStep, true);
        } else if (nextStep) {
          nextFrame(function(info) {
            function doNext() {
              if (info.isCanceled()) return;
              setStep(nextStep, true);
            }
            if (result === true) {
              doNext();
            } else {
              Promise.resolve(result).then(doNext);
            }
          });
        }
      }
    }, [status, step]);
    React32.useEffect(function() {
      return function() {
        cancelNextFrame();
      };
    }, []);
    return [startQueue, step];
  };

  // node_modules/rc-motion/es/hooks/useStatus.js
  function useStatus(supportMotion, visible, getElement, _ref) {
    var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
    var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
    var _useSyncState = useSyncState(STATUS_NONE), _useSyncState2 = _slicedToArray(_useSyncState, 2), getStatus2 = _useSyncState2[0], setStatus = _useSyncState2[1];
    var _useState3 = useSafeState(null), _useState4 = _slicedToArray(_useState3, 2), style2 = _useState4[0], setStyle = _useState4[1];
    var currentStatus = getStatus2();
    var mountedRef = (0, import_react17.useRef)(false);
    var deadlineRef = (0, import_react17.useRef)(null);
    function getDomElement() {
      return getElement();
    }
    var activeRef = (0, import_react17.useRef)(false);
    function updateMotionEndStatus() {
      setStatus(STATUS_NONE);
      setStyle(null, true);
    }
    var onInternalMotionEnd = useEvent(function(event) {
      var status = getStatus2();
      if (status === STATUS_NONE) {
        return;
      }
      var element = getDomElement();
      if (event && !event.deadline && event.target !== element) {
        return;
      }
      var currentActive = activeRef.current;
      var canEnd;
      if (status === STATUS_APPEAR && currentActive) {
        canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
      } else if (status === STATUS_ENTER && currentActive) {
        canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
      } else if (status === STATUS_LEAVE && currentActive) {
        canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
      }
      if (currentActive && canEnd !== false) {
        updateMotionEndStatus();
      }
    });
    var _useDomMotionEvents = useDomMotionEvents_default(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
    var getEventHandlers = function getEventHandlers2(targetStatus) {
      switch (targetStatus) {
        case STATUS_APPEAR:
          return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);
        case STATUS_ENTER:
          return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);
        case STATUS_LEAVE:
          return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);
        default:
          return {};
      }
    };
    var eventHandlers = React33.useMemo(function() {
      return getEventHandlers(currentStatus);
    }, [currentStatus]);
    var _useStepQueue = useStepQueue_default(currentStatus, !supportMotion, function(newStep) {
      if (newStep === STEP_PREPARE) {
        var onPrepare = eventHandlers[STEP_PREPARE];
        if (!onPrepare) {
          return SkipStep;
        }
        return onPrepare(getDomElement());
      }
      if (step in eventHandlers) {
        var _eventHandlers$step;
        setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
      }
      if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
        patchMotionEvents(getDomElement());
        if (motionDeadline > 0) {
          clearTimeout(deadlineRef.current);
          deadlineRef.current = setTimeout(function() {
            onInternalMotionEnd({
              deadline: true
            });
          }, motionDeadline);
        }
      }
      if (step === STEP_PREPARED) {
        updateMotionEndStatus();
      }
      return DoStep;
    }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
    var active = isActive(step);
    activeRef.current = active;
    var visibleRef = (0, import_react17.useRef)(null);
    useIsomorphicLayoutEffect_default(function() {
      if (mountedRef.current && visibleRef.current === visible) {
        return;
      }
      setAsyncVisible(visible);
      var isMounted = mountedRef.current;
      mountedRef.current = true;
      var nextStatus;
      if (!isMounted && visible && motionAppear) {
        nextStatus = STATUS_APPEAR;
      }
      if (isMounted && visible && motionEnter) {
        nextStatus = STATUS_ENTER;
      }
      if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
        nextStatus = STATUS_LEAVE;
      }
      var nextEventHandlers = getEventHandlers(nextStatus);
      if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
        setStatus(nextStatus);
        startStep();
      } else {
        setStatus(STATUS_NONE);
      }
      visibleRef.current = visible;
    }, [visible]);
    (0, import_react17.useEffect)(function() {
      if (
        // Cancel appear
        currentStatus === STATUS_APPEAR && !motionAppear || // Cancel enter
        currentStatus === STATUS_ENTER && !motionEnter || // Cancel leave
        currentStatus === STATUS_LEAVE && !motionLeave
      ) {
        setStatus(STATUS_NONE);
      }
    }, [motionAppear, motionEnter, motionLeave]);
    (0, import_react17.useEffect)(function() {
      return function() {
        mountedRef.current = false;
        clearTimeout(deadlineRef.current);
      };
    }, []);
    var firstMountChangeRef = React33.useRef(false);
    (0, import_react17.useEffect)(function() {
      if (asyncVisible) {
        firstMountChangeRef.current = true;
      }
      if (asyncVisible !== void 0 && currentStatus === STATUS_NONE) {
        if (firstMountChangeRef.current || asyncVisible) {
          onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);
        }
        firstMountChangeRef.current = true;
      }
    }, [asyncVisible, currentStatus]);
    var mergedStyle = style2;
    if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
      mergedStyle = _objectSpread2({
        transition: "none"
      }, mergedStyle);
    }
    return [currentStatus, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
  }

  // node_modules/rc-motion/es/CSSMotion.js
  function genCSSMotion(config) {
    var transitionSupport = config;
    if (_typeof(config) === "object") {
      transitionSupport = config.transitionSupport;
    }
    function isSupportTransition(props, contextMotion) {
      return !!(props.motionName && transitionSupport && contextMotion !== false);
    }
    var CSSMotion = /* @__PURE__ */ React34.forwardRef(function(props, ref) {
      var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
      var _React$useContext = React34.useContext(Context), contextMotion = _React$useContext.motion;
      var supportMotion = isSupportTransition(props, contextMotion);
      var nodeRef = (0, import_react18.useRef)();
      var wrapperNodeRef = (0, import_react18.useRef)();
      function getDomElement() {
        try {
          return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
        } catch (e3) {
          return null;
        }
      }
      var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
      var renderedRef = React34.useRef(mergedVisible);
      if (mergedVisible) {
        renderedRef.current = true;
      }
      var setNodeRef = React34.useCallback(function(node2) {
        nodeRef.current = node2;
        fillRef(ref, node2);
      }, [ref]);
      var motionChildren;
      var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
        visible
      });
      if (!children) {
        motionChildren = null;
      } else if (status === STATUS_NONE) {
        if (mergedVisible) {
          motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
        } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            className: leavedClassName
          }), setNodeRef);
        } else if (forceRender || !removeOnLeave && !leavedClassName) {
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            style: {
              display: "none"
            }
          }), setNodeRef);
        } else {
          motionChildren = null;
        }
      } else {
        var statusSuffix;
        if (statusStep === STEP_PREPARE) {
          statusSuffix = "prepare";
        } else if (isActive(statusStep)) {
          statusSuffix = "active";
        } else if (statusStep === STEP_START) {
          statusSuffix = "start";
        }
        var motionCls = getTransitionName(motionName, "".concat(status, "-").concat(statusSuffix));
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          className: (0, import_classnames.default)(getTransitionName(motionName, status), _defineProperty(_defineProperty({}, motionCls, motionCls && statusSuffix), motionName, typeof motionName === "string")),
          style: statusStyle
        }), setNodeRef);
      }
      if (/* @__PURE__ */ React34.isValidElement(motionChildren) && supportRef(motionChildren)) {
        var originNodeRef = getNodeRef(motionChildren);
        if (!originNodeRef) {
          motionChildren = /* @__PURE__ */ React34.cloneElement(motionChildren, {
            ref: setNodeRef
          });
        }
      }
      return /* @__PURE__ */ React34.createElement(DomWrapper_default, {
        ref: wrapperNodeRef
      }, motionChildren);
    });
    CSSMotion.displayName = "CSSMotion";
    return CSSMotion;
  }
  var CSSMotion_default = genCSSMotion(supportTransition);

  // node_modules/rc-motion/es/CSSMotionList.js
  var React35 = __toESM(require_react());

  // node_modules/rc-motion/es/util/diff.js
  var STATUS_ADD = "add";
  var STATUS_KEEP = "keep";
  var STATUS_REMOVE = "remove";
  var STATUS_REMOVED = "removed";
  function wrapKeyToObject(key) {
    var keyObj;
    if (key && _typeof(key) === "object" && "key" in key) {
      keyObj = key;
    } else {
      keyObj = {
        key
      };
    }
    return _objectSpread2(_objectSpread2({}, keyObj), {}, {
      key: String(keyObj.key)
    });
  }
  function parseKeys() {
    var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return keys2.map(wrapKeyToObject);
  }
  function diffKeys() {
    var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var list = [];
    var currentIndex = 0;
    var currentLen = currentKeys.length;
    var prevKeyObjects = parseKeys(prevKeys);
    var currentKeyObjects = parseKeys(currentKeys);
    prevKeyObjects.forEach(function(keyObj) {
      var hit = false;
      for (var i = currentIndex; i < currentLen; i += 1) {
        var currentKeyObj = currentKeyObjects[i];
        if (currentKeyObj.key === keyObj.key) {
          if (currentIndex < i) {
            list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
              return _objectSpread2(_objectSpread2({}, obj), {}, {
                status: STATUS_ADD
              });
            }));
            currentIndex = i;
          }
          list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
            status: STATUS_KEEP
          }));
          currentIndex += 1;
          hit = true;
          break;
        }
      }
      if (!hit) {
        list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
          status: STATUS_REMOVE
        }));
      }
    });
    if (currentIndex < currentLen) {
      list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
        return _objectSpread2(_objectSpread2({}, obj), {}, {
          status: STATUS_ADD
        });
      }));
    }
    var keys2 = {};
    list.forEach(function(_ref) {
      var key = _ref.key;
      keys2[key] = (keys2[key] || 0) + 1;
    });
    var duplicatedKeys = Object.keys(keys2).filter(function(key) {
      return keys2[key] > 1;
    });
    duplicatedKeys.forEach(function(matchKey) {
      list = list.filter(function(_ref2) {
        var key = _ref2.key, status = _ref2.status;
        return key !== matchKey || status !== STATUS_REMOVE;
      });
      list.forEach(function(node2) {
        if (node2.key === matchKey) {
          node2.status = STATUS_KEEP;
        }
      });
    });
    return list;
  }

  // node_modules/rc-motion/es/CSSMotionList.js
  var _excluded2 = ["component", "children", "onVisibleChanged", "onAllRemoved"];
  var _excluded22 = ["status"];
  var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
  function genCSSMotionList(transitionSupport) {
    var CSSMotion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion_default;
    var CSSMotionList = /* @__PURE__ */ function(_React$Component) {
      _inherits(CSSMotionList2, _React$Component);
      var _super = _createSuper(CSSMotionList2);
      function CSSMotionList2() {
        var _this;
        _classCallCheck(this, CSSMotionList2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          keyEntities: []
        });
        _defineProperty(_assertThisInitialized(_this), "removeKey", function(removeKey) {
          _this.setState(function(prevState) {
            var nextKeyEntities = prevState.keyEntities.map(function(entity) {
              if (entity.key !== removeKey) return entity;
              return _objectSpread2(_objectSpread2({}, entity), {}, {
                status: STATUS_REMOVED
              });
            });
            return {
              keyEntities: nextKeyEntities
            };
          }, function() {
            var keyEntities = _this.state.keyEntities;
            var restKeysCount = keyEntities.filter(function(_ref) {
              var status = _ref.status;
              return status !== STATUS_REMOVED;
            }).length;
            if (restKeysCount === 0 && _this.props.onAllRemoved) {
              _this.props.onAllRemoved();
            }
          });
        });
        return _this;
      }
      _createClass(CSSMotionList2, [{
        key: "render",
        value: function render4() {
          var _this2 = this;
          var keyEntities = this.state.keyEntities;
          var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties(_this$props, _excluded2);
          var Component9 = component || React35.Fragment;
          var motionProps = {};
          MOTION_PROP_NAMES.forEach(function(prop) {
            motionProps[prop] = restProps[prop];
            delete restProps[prop];
          });
          delete restProps.keys;
          return /* @__PURE__ */ React35.createElement(Component9, restProps, keyEntities.map(function(_ref2, index3) {
            var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded22);
            var visible = status === STATUS_ADD || status === STATUS_KEEP;
            return /* @__PURE__ */ React35.createElement(CSSMotion, _extends({}, motionProps, {
              key: eventProps.key,
              visible,
              eventProps,
              onVisibleChanged: function onVisibleChanged(changedVisible) {
                _onVisibleChanged === null || _onVisibleChanged === void 0 || _onVisibleChanged(changedVisible, {
                  key: eventProps.key
                });
                if (!changedVisible) {
                  _this2.removeKey(eventProps.key);
                }
              }
            }), function(props, ref) {
              return children(_objectSpread2(_objectSpread2({}, props), {}, {
                index: index3
              }), ref);
            });
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(_ref3, _ref4) {
          var keys2 = _ref3.keys;
          var keyEntities = _ref4.keyEntities;
          var parsedKeyObjects = parseKeys(keys2);
          var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
          return {
            keyEntities: mixedKeyEntities.filter(function(entity) {
              var prevEntity = keyEntities.find(function(_ref5) {
                var key = _ref5.key;
                return entity.key === key;
              });
              if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                return false;
              }
              return true;
            })
          };
        }
      }]);
      return CSSMotionList2;
    }(React35.Component);
    _defineProperty(CSSMotionList, "defaultProps", {
      component: "div"
    });
    return CSSMotionList;
  }
  var CSSMotionList_default = genCSSMotionList(supportTransition);

  // node_modules/rc-motion/es/index.js
  var es_default2 = CSSMotion_default;

  // node_modules/antd/es/config-provider/MotionWrapper.js
  var MotionCacheContext = /* @__PURE__ */ React36.createContext(true);
  if (true) {
    MotionCacheContext.displayName = "MotionCacheContext";
  }
  function MotionWrapper(props) {
    const parentMotion = React36.useContext(MotionCacheContext);
    const {
      children
    } = props;
    const [, token2] = useToken();
    const {
      motion: motion2
    } = token2;
    const needWrapMotionProviderRef = React36.useRef(false);
    needWrapMotionProviderRef.current || (needWrapMotionProviderRef.current = parentMotion !== motion2);
    if (needWrapMotionProviderRef.current) {
      return /* @__PURE__ */ React36.createElement(MotionCacheContext.Provider, {
        value: motion2
      }, /* @__PURE__ */ React36.createElement(MotionProvider, {
        motion: motion2
      }, children));
    }
    return children;
  }

  // node_modules/antd/es/config-provider/PropWarning.js
  var React37 = __toESM(require_react());
  var PropWarning = /* @__PURE__ */ React37.memo(({
    dropdownMatchSelectWidth
  }) => {
    const warning6 = devUseWarning("ConfigProvider");
    warning6.deprecated(dropdownMatchSelectWidth === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth");
    return null;
  });
  if (true) {
    PropWarning.displayName = "PropWarning";
  }
  var PropWarning_default = true ? PropWarning : () => null;

  // node_modules/antd/es/config-provider/index.js
  var __rest3 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var existThemeConfig = false;
  var warnContext = true ? (componentName) => {
    true ? warning_default2(!existThemeConfig, componentName, `Static function can not consume context like dynamic theme. Please use 'App' component instead.`) : void 0;
  } : (
    /* istanbul ignore next */
    null
  );
  var PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
  var globalPrefixCls;
  var globalIconPrefixCls;
  var globalTheme;
  var globalHolderRender;
  function getGlobalPrefixCls() {
    return globalPrefixCls || defaultPrefixCls;
  }
  function getGlobalIconPrefixCls() {
    return globalIconPrefixCls || defaultIconPrefixCls;
  }
  function isLegacyTheme(theme) {
    return Object.keys(theme).some((key) => key.endsWith("Color"));
  }
  var setGlobalConfig = (props) => {
    const {
      prefixCls,
      iconPrefixCls,
      theme,
      holderRender
    } = props;
    if (prefixCls !== void 0) {
      globalPrefixCls = prefixCls;
    }
    if (iconPrefixCls !== void 0) {
      globalIconPrefixCls = iconPrefixCls;
    }
    if ("holderRender" in props) {
      globalHolderRender = holderRender;
    }
    if (theme) {
      if (isLegacyTheme(theme)) {
        true ? warning_default2(false, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead.") : void 0;
        registerTheme(getGlobalPrefixCls(), theme);
      } else {
        globalTheme = theme;
      }
    }
  };
  var globalConfig = () => ({
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: () => {
      if (globalPrefixCls) {
        return globalPrefixCls;
      }
      return getGlobalPrefixCls();
    },
    getTheme: () => globalTheme,
    holderRender: globalHolderRender
  });
  var ProviderChildren = (props) => {
    const {
      children,
      csp: customCsp,
      autoInsertSpaceInButton,
      alert,
      anchor,
      form,
      locale: locale6,
      componentSize,
      direction,
      space,
      splitter,
      virtual,
      dropdownMatchSelectWidth,
      popupMatchSelectWidth,
      popupOverflow,
      legacyLocale,
      parentContext,
      iconPrefixCls: customIconPrefixCls,
      theme,
      componentDisabled,
      segmented,
      statistic: statistic2,
      spin,
      calendar,
      carousel,
      cascader,
      collapse,
      typography,
      checkbox,
      descriptions,
      divider,
      drawer,
      skeleton,
      steps,
      image,
      layout,
      list,
      mentions,
      modal,
      progress,
      result,
      slider,
      breadcrumb,
      menu,
      pagination,
      input,
      textArea,
      empty: empty2,
      badge,
      radio,
      rate,
      switch: SWITCH,
      transfer,
      avatar,
      message: message2,
      tag,
      table,
      card,
      tabs,
      timeline,
      timePicker,
      upload: upload2,
      notification,
      tree,
      colorPicker,
      datePicker,
      rangePicker,
      flex,
      wave,
      dropdown,
      warning: warningConfig,
      tour,
      tooltip,
      popover,
      popconfirm,
      floatButtonGroup,
      variant,
      inputNumber,
      treeSelect
    } = props;
    const getPrefixCls = React38.useCallback((suffixCls, customizePrefixCls) => {
      const {
        prefixCls
      } = props;
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
      return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
    }, [parentContext.getPrefixCls, props.prefixCls]);
    const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
    const csp = customCsp || parentContext.csp;
    useResetIconStyle_default(iconPrefixCls, csp);
    const mergedTheme = useTheme(theme, parentContext.theme, {
      prefixCls: getPrefixCls("")
    });
    if (true) {
      existThemeConfig = existThemeConfig || !!mergedTheme;
    }
    const baseConfig = {
      csp,
      autoInsertSpaceInButton,
      alert,
      anchor,
      locale: locale6 || legacyLocale,
      direction,
      space,
      splitter,
      virtual,
      popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
      popupOverflow,
      getPrefixCls,
      iconPrefixCls,
      theme: mergedTheme,
      segmented,
      statistic: statistic2,
      spin,
      calendar,
      carousel,
      cascader,
      collapse,
      typography,
      checkbox,
      descriptions,
      divider,
      drawer,
      skeleton,
      steps,
      image,
      input,
      textArea,
      layout,
      list,
      mentions,
      modal,
      progress,
      result,
      slider,
      breadcrumb,
      menu,
      pagination,
      empty: empty2,
      badge,
      radio,
      rate,
      switch: SWITCH,
      transfer,
      avatar,
      message: message2,
      tag,
      table,
      card,
      tabs,
      timeline,
      timePicker,
      upload: upload2,
      notification,
      tree,
      colorPicker,
      datePicker,
      rangePicker,
      flex,
      wave,
      dropdown,
      warning: warningConfig,
      tour,
      tooltip,
      popover,
      popconfirm,
      floatButtonGroup,
      variant,
      inputNumber,
      treeSelect
    };
    if (true) {
      const warningFn = devUseWarning("ConfigProvider");
      warningFn(!("autoInsertSpaceInButton" in props), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
    }
    const config = Object.assign({}, parentContext);
    Object.keys(baseConfig).forEach((key) => {
      if (baseConfig[key] !== void 0) {
        config[key] = baseConfig[key];
      }
    });
    PASSED_PROPS.forEach((propName) => {
      const propValue = props[propName];
      if (propValue) {
        config[propName] = propValue;
      }
    });
    if (typeof autoInsertSpaceInButton !== "undefined") {
      config.button = Object.assign({
        autoInsertSpace: autoInsertSpaceInButton
      }, config.button);
    }
    const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
      const prevKeys = Object.keys(prevConfig);
      const currentKeys = Object.keys(currentConfig);
      return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
    });
    const {
      layer
    } = React38.useContext(StyleContext_default);
    const memoIconContextValue = React38.useMemo(() => ({
      prefixCls: iconPrefixCls,
      csp,
      layer: layer ? "antd" : void 0
    }), [iconPrefixCls, csp, layer]);
    let childNode = /* @__PURE__ */ React38.createElement(React38.Fragment, null, /* @__PURE__ */ React38.createElement(PropWarning_default, {
      dropdownMatchSelectWidth
    }), children);
    const validateMessages = React38.useMemo(() => {
      var _a, _b, _c, _d;
      return merge(((_a = en_US_default6.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) === null || _d === void 0 ? void 0 : _d.validateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
    }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
    if (Object.keys(validateMessages).length > 0) {
      childNode = /* @__PURE__ */ React38.createElement(validateMessagesContext_default.Provider, {
        value: validateMessages
      }, childNode);
    }
    if (locale6) {
      childNode = /* @__PURE__ */ React38.createElement(locale_default, {
        locale: locale6,
        _ANT_MARK__: ANT_MARK
      }, childNode);
    }
    if (iconPrefixCls || csp) {
      childNode = /* @__PURE__ */ React38.createElement(Context_default.Provider, {
        value: memoIconContextValue
      }, childNode);
    }
    if (componentSize) {
      childNode = /* @__PURE__ */ React38.createElement(SizeContextProvider, {
        size: componentSize
      }, childNode);
    }
    childNode = /* @__PURE__ */ React38.createElement(MotionWrapper, null, childNode);
    const memoTheme = React38.useMemo(() => {
      const _a = mergedTheme || {}, {
        algorithm,
        token: token2,
        components,
        cssVar
      } = _a, rest = __rest3(_a, ["algorithm", "token", "components", "cssVar"]);
      const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : theme_default;
      const parsedComponents = {};
      Object.entries(components || {}).forEach(([componentName, componentToken]) => {
        const parsedToken = Object.assign({}, componentToken);
        if ("algorithm" in parsedToken) {
          if (parsedToken.algorithm === true) {
            parsedToken.theme = themeObj;
          } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
            parsedToken.theme = createTheme(parsedToken.algorithm);
          }
          delete parsedToken.algorithm;
        }
        parsedComponents[componentName] = parsedToken;
      });
      const mergedToken = Object.assign(Object.assign({}, seed_default), token2);
      return Object.assign(Object.assign({}, rest), {
        theme: themeObj,
        token: mergedToken,
        components: parsedComponents,
        override: Object.assign({
          override: mergedToken
        }, parsedComponents),
        cssVar
      });
    }, [mergedTheme]);
    if (theme) {
      childNode = /* @__PURE__ */ React38.createElement(DesignTokenContext.Provider, {
        value: memoTheme
      }, childNode);
    }
    if (memoedConfig.warning) {
      childNode = /* @__PURE__ */ React38.createElement(WarningContext.Provider, {
        value: memoedConfig.warning
      }, childNode);
    }
    if (componentDisabled !== void 0) {
      childNode = /* @__PURE__ */ React38.createElement(DisabledContextProvider, {
        disabled: componentDisabled
      }, childNode);
    }
    return /* @__PURE__ */ React38.createElement(ConfigContext.Provider, {
      value: memoedConfig
    }, childNode);
  };
  var ConfigProvider = (props) => {
    const context = React38.useContext(ConfigContext);
    const antLocale = React38.useContext(context_default);
    return /* @__PURE__ */ React38.createElement(ProviderChildren, Object.assign({
      parentContext: context,
      legacyLocale: antLocale
    }, props));
  };
  ConfigProvider.ConfigContext = ConfigContext;
  ConfigProvider.SizeContext = SizeContext_default;
  ConfigProvider.config = setGlobalConfig;
  ConfigProvider.useConfig = useConfig_default;
  Object.defineProperty(ConfigProvider, "SizeContext", {
    get: () => {
      true ? warning_default2(false, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead.") : void 0;
      return SizeContext_default;
    }
  });
  if (true) {
    ConfigProvider.displayName = "ConfigProvider";
  }
  var config_provider_default = ConfigProvider;

  // node_modules/@ant-design/icons/es/icons/CheckCircleFilled.js
  var React42 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/CheckCircleFilled.js
  var CheckCircleFilled = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
  var CheckCircleFilled_default = CheckCircleFilled;

  // node_modules/@ant-design/icons/es/components/AntdIcon.js
  var React41 = __toESM(require_react());
  var import_classnames2 = __toESM(require_classnames());

  // node_modules/@ant-design/icons/es/components/IconBase.js
  var React40 = __toESM(require_react());

  // node_modules/rc-util/es/Dom/shadow.js
  function getRoot(ele) {
    var _ele$getRootNode;
    return ele === null || ele === void 0 || (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
  }
  function inShadow(ele) {
    return getRoot(ele) instanceof ShadowRoot;
  }
  function getShadowRoot(ele) {
    return inShadow(ele) ? getRoot(ele) : null;
  }

  // node_modules/@ant-design/icons/es/utils.js
  var import_react19 = __toESM(require_react());
  function camelCase(input) {
    return input.replace(/-(.)/g, function(match2, g) {
      return g.toUpperCase();
    });
  }
  function warning3(valid, message2) {
    warning_default(valid, "[@ant-design/icons] ".concat(message2));
  }
  function isIconDefinition(target) {
    return _typeof(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof(target.icon) === "object" || typeof target.icon === "function");
  }
  function normalizeAttrs() {
    var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.keys(attrs).reduce(function(acc, key) {
      var val = attrs[key];
      switch (key) {
        case "class":
          acc.className = val;
          delete acc.class;
          break;
        default:
          delete acc[key];
          acc[camelCase(key)] = val;
      }
      return acc;
    }, {});
  }
  function generate2(node2, key, rootProps) {
    if (!rootProps) {
      return /* @__PURE__ */ import_react19.default.createElement(node2.tag, _objectSpread2({
        key
      }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index3) {
        return generate2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index3));
      }));
    }
    return /* @__PURE__ */ import_react19.default.createElement(node2.tag, _objectSpread2(_objectSpread2({
      key
    }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index3) {
      return generate2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index3));
    }));
  }
  function getSecondaryColor(primaryColor) {
    return generate(primaryColor)[0];
  }
  function normalizeTwoToneColors(twoToneColor) {
    if (!twoToneColor) {
      return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
  }
  var iconStyles = "\n.anticon {\n  display: inline-flex;\n  align-items: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
  var useInsertStyles = function useInsertStyles2(eleRef) {
    var _useContext = (0, import_react19.useContext)(Context_default), csp = _useContext.csp, prefixCls = _useContext.prefixCls, layer = _useContext.layer;
    var mergedStyleStr = iconStyles;
    if (prefixCls) {
      mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
    }
    if (layer) {
      mergedStyleStr = "@layer ".concat(layer, " {\n").concat(mergedStyleStr, "\n}");
    }
    (0, import_react19.useEffect)(function() {
      var ele = eleRef.current;
      var shadowRoot = getShadowRoot(ele);
      updateCSS(mergedStyleStr, "@ant-design-icons", {
        prepend: !layer,
        csp,
        attachTo: shadowRoot
      });
    }, []);
  };

  // node_modules/@ant-design/icons/es/components/IconBase.js
  var _excluded3 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
  var twoToneColorPalette = {
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: false
  };
  function setTwoToneColors(_ref) {
    var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
    twoToneColorPalette.primaryColor = primaryColor;
    twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    twoToneColorPalette.calculated = !!secondaryColor;
  }
  function getTwoToneColors() {
    return _objectSpread2({}, twoToneColorPalette);
  }
  var IconBase = function IconBase2(props) {
    var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded3);
    var svgRef = React40.useRef();
    var colors = twoToneColorPalette;
    if (primaryColor) {
      colors = {
        primaryColor,
        secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
      };
    }
    useInsertStyles(svgRef);
    warning3(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
    if (!isIconDefinition(icon)) {
      return null;
    }
    var target = icon;
    if (target && typeof target.icon === "function") {
      target = _objectSpread2(_objectSpread2({}, target), {}, {
        icon: target.icon(colors.primaryColor, colors.secondaryColor)
      });
    }
    return generate2(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
      className,
      onClick,
      style: style2,
      "data-icon": target.name,
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true"
    }, restProps), {}, {
      ref: svgRef
    }));
  };
  IconBase.displayName = "IconReact";
  IconBase.getTwoToneColors = getTwoToneColors;
  IconBase.setTwoToneColors = setTwoToneColors;
  var IconBase_default = IconBase;

  // node_modules/@ant-design/icons/es/components/twoTonePrimaryColor.js
  function setTwoToneColor(twoToneColor) {
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return IconBase_default.setTwoToneColors({
      primaryColor,
      secondaryColor
    });
  }
  function getTwoToneColor() {
    var colors = IconBase_default.getTwoToneColors();
    if (!colors.calculated) {
      return colors.primaryColor;
    }
    return [colors.primaryColor, colors.secondaryColor];
  }

  // node_modules/@ant-design/icons/es/components/AntdIcon.js
  var _excluded4 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
  setTwoToneColor(blue.primary);
  var Icon = /* @__PURE__ */ React41.forwardRef(function(props, ref) {
    var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded4);
    var _React$useContext = React41.useContext(Context_default), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
    var classString = (0, import_classnames2.default)(rootClassName, prefixCls, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), className);
    var iconTabIndex = tabIndex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    var svgStyle = rotate ? {
      msTransform: "rotate(".concat(rotate, "deg)"),
      transform: "rotate(".concat(rotate, "deg)")
    } : void 0;
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return /* @__PURE__ */ React41.createElement("span", _extends({
      role: "img",
      "aria-label": icon.name
    }, restProps, {
      ref,
      tabIndex: iconTabIndex,
      onClick,
      className: classString
    }), /* @__PURE__ */ React41.createElement(IconBase_default, {
      icon,
      primaryColor,
      secondaryColor,
      style: svgStyle
    }));
  });
  Icon.displayName = "AntdIcon";
  Icon.getTwoToneColor = getTwoToneColor;
  Icon.setTwoToneColor = setTwoToneColor;
  var AntdIcon_default = Icon;

  // node_modules/@ant-design/icons/es/icons/CheckCircleFilled.js
  var CheckCircleFilled2 = function CheckCircleFilled3(props, ref) {
    return /* @__PURE__ */ React42.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: CheckCircleFilled_default
    }));
  };
  var RefIcon = /* @__PURE__ */ React42.forwardRef(CheckCircleFilled2);
  if (true) {
    RefIcon.displayName = "CheckCircleFilled";
  }
  var CheckCircleFilled_default2 = RefIcon;

  // node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js
  var React43 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/CloseCircleFilled.js
  var CloseCircleFilled = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
  var CloseCircleFilled_default = CloseCircleFilled;

  // node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js
  var CloseCircleFilled2 = function CloseCircleFilled3(props, ref) {
    return /* @__PURE__ */ React43.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: CloseCircleFilled_default
    }));
  };
  var RefIcon2 = /* @__PURE__ */ React43.forwardRef(CloseCircleFilled2);
  if (true) {
    RefIcon2.displayName = "CloseCircleFilled";
  }
  var CloseCircleFilled_default2 = RefIcon2;

  // node_modules/@ant-design/icons/es/icons/CloseOutlined.js
  var React44 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/CloseOutlined.js
  var CloseOutlined = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
  var CloseOutlined_default = CloseOutlined;

  // node_modules/@ant-design/icons/es/icons/CloseOutlined.js
  var CloseOutlined2 = function CloseOutlined3(props, ref) {
    return /* @__PURE__ */ React44.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: CloseOutlined_default
    }));
  };
  var RefIcon3 = /* @__PURE__ */ React44.forwardRef(CloseOutlined2);
  if (true) {
    RefIcon3.displayName = "CloseOutlined";
  }
  var CloseOutlined_default2 = RefIcon3;

  // node_modules/@ant-design/icons/es/icons/ExclamationCircleFilled.js
  var React45 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/ExclamationCircleFilled.js
  var ExclamationCircleFilled = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
  var ExclamationCircleFilled_default = ExclamationCircleFilled;

  // node_modules/@ant-design/icons/es/icons/ExclamationCircleFilled.js
  var ExclamationCircleFilled2 = function ExclamationCircleFilled3(props, ref) {
    return /* @__PURE__ */ React45.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: ExclamationCircleFilled_default
    }));
  };
  var RefIcon4 = /* @__PURE__ */ React45.forwardRef(ExclamationCircleFilled2);
  if (true) {
    RefIcon4.displayName = "ExclamationCircleFilled";
  }
  var ExclamationCircleFilled_default2 = RefIcon4;

  // node_modules/@ant-design/icons/es/icons/InfoCircleFilled.js
  var React46 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/InfoCircleFilled.js
  var InfoCircleFilled = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
  var InfoCircleFilled_default = InfoCircleFilled;

  // node_modules/@ant-design/icons/es/icons/InfoCircleFilled.js
  var InfoCircleFilled2 = function InfoCircleFilled3(props, ref) {
    return /* @__PURE__ */ React46.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: InfoCircleFilled_default
    }));
  };
  var RefIcon5 = /* @__PURE__ */ React46.forwardRef(InfoCircleFilled2);
  if (true) {
    RefIcon5.displayName = "InfoCircleFilled";
  }
  var InfoCircleFilled_default2 = RefIcon5;

  // node_modules/rc-util/es/pickAttrs.js
  var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
  var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
  var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
  var ariaPrefix = "aria-";
  var dataPrefix = "data-";
  function match(key, prefix) {
    return key.indexOf(prefix) === 0;
  }
  function pickAttrs(props) {
    var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var mergedConfig;
    if (ariaOnly === false) {
      mergedConfig = {
        aria: true,
        data: true,
        attr: true
      };
    } else if (ariaOnly === true) {
      mergedConfig = {
        aria: true
      };
    } else {
      mergedConfig = _objectSpread2({}, ariaOnly);
    }
    var attrs = {};
    Object.keys(props).forEach(function(key) {
      if (
        // Aria
        mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
        mergedConfig.data && match(key, dataPrefix) || // Attr
        mergedConfig.attr && propList.includes(key)
      ) {
        attrs[key] = props[key];
      }
    });
    return attrs;
  }

  // node_modules/antd/es/_util/reactNode.js
  var import_react20 = __toESM(require_react());
  function isFragment2(child) {
    return child && /* @__PURE__ */ import_react20.default.isValidElement(child) && child.type === import_react20.default.Fragment;
  }
  var replaceElement = (element, replacement, props) => {
    if (!/* @__PURE__ */ import_react20.default.isValidElement(element)) {
      return replacement;
    }
    return /* @__PURE__ */ import_react20.default.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
  };
  function cloneElement3(element, props) {
    return replaceElement(element, element, props);
  }

  // node_modules/compute-scroll-into-view/dist/index.js
  var t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
  var e = (t2, e3) => (!e3 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2);
  var n = (t2, n2) => {
    if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
      const o3 = getComputedStyle(t2, null);
      return e(o3.overflowY, n2) || e(o3.overflowX, n2) || ((t3) => {
        const e3 = ((t4) => {
          if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
          try {
            return t4.ownerDocument.defaultView.frameElement;
          } catch (t5) {
            return null;
          }
        })(t3);
        return !!e3 && (e3.clientHeight < t3.scrollHeight || e3.clientWidth < t3.scrollWidth);
      })(t2);
    }
    return false;
  };
  var o = (t2, e3, n2, o3, l2, r2, i, s) => r2 < t2 && i > e3 || r2 > t2 && i < e3 ? 0 : r2 <= t2 && s <= n2 || i >= e3 && s >= n2 ? r2 - t2 - o3 : i > e3 && s < n2 || r2 < t2 && s > n2 ? i - e3 + l2 : 0;
  var l = (t2) => {
    const e3 = t2.parentElement;
    return null == e3 ? t2.getRootNode().host || null : e3;
  };
  var r = (e3, r2) => {
    var i, s, d, h;
    if ("undefined" == typeof document) return [];
    const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t2) => t2 !== a;
    if (!t(e3)) throw new TypeError("Invalid target");
    const m = document.scrollingElement || document.documentElement, w = [];
    let W = e3;
    for (; t(W) && p(W); ) {
      if (W = l(W), W === m) {
        w.push(W);
        break;
      }
      null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
    }
    const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e3.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
      const e4 = window.getComputedStyle(t2);
      return { top: parseFloat(e4.scrollMarginTop) || 0, right: parseFloat(e4.scrollMarginRight) || 0, bottom: parseFloat(e4.scrollMarginBottom) || 0, left: parseFloat(e4.scrollMarginLeft) || 0 };
    })(e3);
    let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
    const L = [];
    for (let t2 = 0; t2 < w.length; t2++) {
      const e4 = w[t2], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h2 } = e4.getBoundingClientRect();
      if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e4 === m && !n(e4) || x >= i2 && I <= d2 && R >= h2 && C <= s2)) return L;
      const a2 = getComputedStyle(e4), g2 = parseInt(a2.borderLeftWidth, 10), p2 = parseInt(a2.borderTopWidth, 10), W2 = parseInt(a2.borderRightWidth, 10), T2 = parseInt(a2.borderBottomWidth, 10);
      let B2 = 0, F2 = 0;
      const V2 = "offsetWidth" in e4 ? e4.offsetWidth - e4.clientWidth - g2 - W2 : 0, S = "offsetHeight" in e4 ? e4.offsetHeight - e4.clientHeight - p2 - T2 : 0, X = "offsetWidth" in e4 ? 0 === e4.offsetWidth ? 0 : r3 / e4.offsetWidth : 0, Y = "offsetHeight" in e4 ? 0 === e4.offsetHeight ? 0 : l2 / e4.offsetHeight : 0;
      if (m === e4) B2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, p2, T2, M + k, M + k + v, v) : k - H / 2, F2 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, g2, W2, y + D, y + D + E, E), B2 = Math.max(0, B2 + M), F2 = Math.max(0, F2 + y);
      else {
        B2 = "start" === f ? k - i2 - p2 : "end" === f ? k - d2 + T2 + S : "nearest" === f ? o(i2, d2, l2, p2, T2 + S, k, k + v, v) : k - (i2 + l2 / 2) + S / 2, F2 = "start" === u ? D - h2 - g2 : "center" === u ? D - (h2 + r3 / 2) + V2 / 2 : "end" === u ? D - s2 + W2 + V2 : o(h2, s2, r3, g2, W2 + V2, D, D + E, E);
        const { scrollLeft: t3, scrollTop: n2 } = e4;
        B2 = 0 === Y ? 0 : Math.max(0, Math.min(n2 + B2 / Y, e4.scrollHeight - l2 / Y + S)), F2 = 0 === X ? 0 : Math.max(0, Math.min(t3 + F2 / X, e4.scrollWidth - r3 / X + V2)), k += n2 - B2, D += t3 - F2;
      }
      L.push({ el: e4, top: B2, left: F2 });
    }
    return L;
  };

  // node_modules/scroll-into-view-if-needed/dist/index.js
  var o2 = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
  function e2(e3, r2) {
    if (!e3.isConnected || !((t2) => {
      let o3 = t2;
      for (; o3 && o3.parentNode; ) {
        if (o3.parentNode === document) return true;
        o3 = o3.parentNode instanceof ShadowRoot ? o3.parentNode.host : o3.parentNode;
      }
      return false;
    })(e3)) return;
    const n2 = ((t2) => {
      const o3 = window.getComputedStyle(t2);
      return { top: parseFloat(o3.scrollMarginTop) || 0, right: parseFloat(o3.scrollMarginRight) || 0, bottom: parseFloat(o3.scrollMarginBottom) || 0, left: parseFloat(o3.scrollMarginLeft) || 0 };
    })(e3);
    if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2)) return r2.behavior(r(e3, r2));
    const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
    for (const { el: a, top: i, left: s } of r(e3, o2(r2))) {
      const t2 = i - n2.top + n2.bottom, o3 = s - n2.left + n2.right;
      a.scroll({ top: t2, left: o3, behavior: l2 });
    }
  }

  // node_modules/antd/es/_util/getScroll.js
  function isWindow(obj) {
    return obj !== null && obj !== void 0 && obj === obj.window;
  }
  var getScroll = (target) => {
    var _a, _b;
    if (typeof window === "undefined") {
      return 0;
    }
    let result = 0;
    if (isWindow(target)) {
      result = target.pageYOffset;
    } else if (target instanceof Document) {
      result = target.documentElement.scrollTop;
    } else if (target instanceof HTMLElement) {
      result = target.scrollTop;
    } else if (target) {
      result = target["scrollTop"];
    }
    if (target && !isWindow(target) && typeof result !== "number") {
      result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b.scrollTop;
    }
    return result;
  };
  var getScroll_default = getScroll;

  // node_modules/antd/es/_util/easings.js
  function easeInOutCubic(t2, b, c, d) {
    const cc = c - b;
    t2 /= d / 2;
    if (t2 < 1) {
      return cc / 2 * t2 * t2 * t2 + b;
    }
    return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b;
  }

  // node_modules/antd/es/_util/scrollTo.js
  function scrollTo(y, options = {}) {
    const {
      getContainer: getContainer2 = () => window,
      callback,
      duration = 450
    } = options;
    const container = getContainer2();
    const scrollTop = getScroll_default(container);
    const startTime = Date.now();
    const frameFunc = () => {
      const timestamp = Date.now();
      const time = timestamp - startTime;
      const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
      if (isWindow(container)) {
        container.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time < duration) {
        raf_default(frameFunc);
      } else if (typeof callback === "function") {
        callback();
      }
    };
    raf_default(frameFunc);
  }

  // node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
  var useCSSVarCls = (prefixCls) => {
    const [, , , , cssVar] = useToken();
    return cssVar ? `${prefixCls}-css-var` : "";
  };
  var useCSSVarCls_default = useCSSVarCls;

  // node_modules/antd/es/message/useMessage.js
  var React57 = __toESM(require_react());
  var import_classnames6 = __toESM(require_classnames());

  // node_modules/rc-notification/es/hooks/useNotification.js
  var React52 = __toESM(require_react());

  // node_modules/rc-notification/es/Notifications.js
  var React51 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());

  // node_modules/rc-notification/es/NoticeList.js
  var import_react22 = __toESM(require_react());
  var import_classnames4 = __toESM(require_classnames());

  // node_modules/rc-notification/es/Notice.js
  var import_classnames3 = __toESM(require_classnames());

  // node_modules/rc-util/es/KeyCode.js
  var KeyCode = {
    /**
     * MAC_ENTER
     */
    MAC_ENTER: 3,
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * NUMLOCK on FF/Safari Mac
     */
    NUM_CENTER: 12,
    // NUMLOCK on FF/Safari Mac
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * PAUSE
     */
    PAUSE: 19,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * PAGE_UP
     */
    PAGE_UP: 33,
    // also NUM_NORTH_EAST
    /**
     * PAGE_DOWN
     */
    PAGE_DOWN: 34,
    // also NUM_SOUTH_EAST
    /**
     * END
     */
    END: 35,
    // also NUM_SOUTH_WEST
    /**
     * HOME
     */
    HOME: 36,
    // also NUM_NORTH_WEST
    /**
     * LEFT
     */
    LEFT: 37,
    // also NUM_WEST
    /**
     * UP
     */
    UP: 38,
    // also NUM_NORTH
    /**
     * RIGHT
     */
    RIGHT: 39,
    // also NUM_EAST
    /**
     * DOWN
     */
    DOWN: 40,
    // also NUM_SOUTH
    /**
     * PRINT_SCREEN
     */
    PRINT_SCREEN: 44,
    /**
     * INSERT
     */
    INSERT: 45,
    // also NUM_INSERT
    /**
     * DELETE
     */
    DELETE: 46,
    // also NUM_DELETE
    /**
     * ZERO
     */
    ZERO: 48,
    /**
     * ONE
     */
    ONE: 49,
    /**
     * TWO
     */
    TWO: 50,
    /**
     * THREE
     */
    THREE: 51,
    /**
     * FOUR
     */
    FOUR: 52,
    /**
     * FIVE
     */
    FIVE: 53,
    /**
     * SIX
     */
    SIX: 54,
    /**
     * SEVEN
     */
    SEVEN: 55,
    /**
     * EIGHT
     */
    EIGHT: 56,
    /**
     * NINE
     */
    NINE: 57,
    /**
     * QUESTION_MARK
     */
    QUESTION_MARK: 63,
    // needs localization
    /**
     * A
     */
    A: 65,
    /**
     * B
     */
    B: 66,
    /**
     * C
     */
    C: 67,
    /**
     * D
     */
    D: 68,
    /**
     * E
     */
    E: 69,
    /**
     * F
     */
    F: 70,
    /**
     * G
     */
    G: 71,
    /**
     * H
     */
    H: 72,
    /**
     * I
     */
    I: 73,
    /**
     * J
     */
    J: 74,
    /**
     * K
     */
    K: 75,
    /**
     * L
     */
    L: 76,
    /**
     * M
     */
    M: 77,
    /**
     * N
     */
    N: 78,
    /**
     * O
     */
    O: 79,
    /**
     * P
     */
    P: 80,
    /**
     * Q
     */
    Q: 81,
    /**
     * R
     */
    R: 82,
    /**
     * S
     */
    S: 83,
    /**
     * T
     */
    T: 84,
    /**
     * U
     */
    U: 85,
    /**
     * V
     */
    V: 86,
    /**
     * W
     */
    W: 87,
    /**
     * X
     */
    X: 88,
    /**
     * Y
     */
    Y: 89,
    /**
     * Z
     */
    Z: 90,
    /**
     * META
     */
    META: 91,
    // WIN_KEY_LEFT
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * NUM_ZERO
     */
    NUM_ZERO: 96,
    /**
     * NUM_ONE
     */
    NUM_ONE: 97,
    /**
     * NUM_TWO
     */
    NUM_TWO: 98,
    /**
     * NUM_THREE
     */
    NUM_THREE: 99,
    /**
     * NUM_FOUR
     */
    NUM_FOUR: 100,
    /**
     * NUM_FIVE
     */
    NUM_FIVE: 101,
    /**
     * NUM_SIX
     */
    NUM_SIX: 102,
    /**
     * NUM_SEVEN
     */
    NUM_SEVEN: 103,
    /**
     * NUM_EIGHT
     */
    NUM_EIGHT: 104,
    /**
     * NUM_NINE
     */
    NUM_NINE: 105,
    /**
     * NUM_MULTIPLY
     */
    NUM_MULTIPLY: 106,
    /**
     * NUM_PLUS
     */
    NUM_PLUS: 107,
    /**
     * NUM_MINUS
     */
    NUM_MINUS: 109,
    /**
     * NUM_PERIOD
     */
    NUM_PERIOD: 110,
    /**
     * NUM_DIVISION
     */
    NUM_DIVISION: 111,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * NUMLOCK
     */
    NUMLOCK: 144,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186,
    // needs localization
    /**
     * DASH
     */
    DASH: 189,
    // needs localization
    /**
     * EQUALS
     */
    EQUALS: 187,
    // needs localization
    /**
     * COMMA
     */
    COMMA: 188,
    // needs localization
    /**
     * PERIOD
     */
    PERIOD: 190,
    // needs localization
    /**
     * SLASH
     */
    SLASH: 191,
    // needs localization
    /**
     * APOSTROPHE
     */
    APOSTROPHE: 192,
    // needs localization
    /**
     * SINGLE_QUOTE
     */
    SINGLE_QUOTE: 222,
    // needs localization
    /**
     * OPEN_SQUARE_BRACKET
     */
    OPEN_SQUARE_BRACKET: 219,
    // needs localization
    /**
     * BACKSLASH
     */
    BACKSLASH: 220,
    // needs localization
    /**
     * CLOSE_SQUARE_BRACKET
     */
    CLOSE_SQUARE_BRACKET: 221,
    // needs localization
    /**
     * WIN_KEY
     */
    WIN_KEY: 224,
    /**
     * MAC_FF_META
     */
    MAC_FF_META: 224,
    // Firefox (Gecko) fires this for the meta key instead of 91
    /**
     * WIN_IME
     */
    WIN_IME: 229,
    // ======================== Function ========================
    /**
     * whether text and modified key is entered at the same time.
     */
    isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e3) {
      var keyCode = e3.keyCode;
      if (e3.altKey && !e3.ctrlKey || e3.metaKey || // Function keys don't generate text
      keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
        return false;
      }
      switch (keyCode) {
        case KeyCode.ALT:
        case KeyCode.CAPS_LOCK:
        case KeyCode.CONTEXT_MENU:
        case KeyCode.CTRL:
        case KeyCode.DOWN:
        case KeyCode.END:
        case KeyCode.ESC:
        case KeyCode.HOME:
        case KeyCode.INSERT:
        case KeyCode.LEFT:
        case KeyCode.MAC_FF_META:
        case KeyCode.META:
        case KeyCode.NUMLOCK:
        case KeyCode.NUM_CENTER:
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAUSE:
        case KeyCode.PRINT_SCREEN:
        case KeyCode.RIGHT:
        case KeyCode.SHIFT:
        case KeyCode.UP:
        case KeyCode.WIN_KEY:
        case KeyCode.WIN_KEY_RIGHT:
          return false;
        default:
          return true;
      }
    },
    /**
     * whether character is entered.
     */
    isCharacterKey: function isCharacterKey(keyCode) {
      if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
        return true;
      }
      if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
        return true;
      }
      if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
        return true;
      }
      if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
        return true;
      }
      switch (keyCode) {
        case KeyCode.SPACE:
        case KeyCode.QUESTION_MARK:
        case KeyCode.NUM_PLUS:
        case KeyCode.NUM_MINUS:
        case KeyCode.NUM_PERIOD:
        case KeyCode.NUM_DIVISION:
        case KeyCode.SEMICOLON:
        case KeyCode.DASH:
        case KeyCode.EQUALS:
        case KeyCode.COMMA:
        case KeyCode.PERIOD:
        case KeyCode.SLASH:
        case KeyCode.APOSTROPHE:
        case KeyCode.SINGLE_QUOTE:
        case KeyCode.OPEN_SQUARE_BRACKET:
        case KeyCode.BACKSLASH:
        case KeyCode.CLOSE_SQUARE_BRACKET:
          return true;
        default:
          return false;
      }
    }
  };
  var KeyCode_default = KeyCode;

  // node_modules/rc-notification/es/Notice.js
  var React48 = __toESM(require_react());
  var Notify = /* @__PURE__ */ React48.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, style2 = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, showProgress = props.showProgress, _props$pauseOnHover = props.pauseOnHover, pauseOnHover = _props$pauseOnHover === void 0 ? true : _props$pauseOnHover, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times, forcedHovering = props.hovering;
    var _React$useState = React48.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
    var _React$useState3 = React48.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), percent = _React$useState4[0], setPercent = _React$useState4[1];
    var _React$useState5 = React48.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), spentTime = _React$useState6[0], setSpentTime = _React$useState6[1];
    var mergedHovering = forcedHovering || hovering;
    var mergedShowProgress = duration > 0 && showProgress;
    var onInternalClose = function onInternalClose2() {
      onNoticeClose(eventKey);
    };
    var onCloseKeyDown = function onCloseKeyDown2(e3) {
      if (e3.key === "Enter" || e3.code === "Enter" || e3.keyCode === KeyCode_default.ENTER) {
        onInternalClose();
      }
    };
    React48.useEffect(function() {
      if (!mergedHovering && duration > 0) {
        var start = Date.now() - spentTime;
        var timeout = setTimeout(function() {
          onInternalClose();
        }, duration * 1e3 - spentTime);
        return function() {
          if (pauseOnHover) {
            clearTimeout(timeout);
          }
          setSpentTime(Date.now() - start);
        };
      }
    }, [duration, mergedHovering, times]);
    React48.useEffect(function() {
      if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
        var start = performance.now();
        var animationFrame;
        var calculate = function calculate2() {
          cancelAnimationFrame(animationFrame);
          animationFrame = requestAnimationFrame(function(timestamp) {
            var runtime = timestamp + spentTime - start;
            var progress = Math.min(runtime / (duration * 1e3), 1);
            setPercent(progress * 100);
            if (progress < 1) {
              calculate2();
            }
          });
        };
        calculate();
        return function() {
          if (pauseOnHover) {
            cancelAnimationFrame(animationFrame);
          }
        };
      }
    }, [duration, spentTime, mergedHovering, mergedShowProgress, times]);
    var closableObj = React48.useMemo(function() {
      if (_typeof(closable) === "object" && closable !== null) {
        return closable;
      }
      if (closable) {
        return {
          closeIcon
        };
      }
      return {};
    }, [closable, closeIcon]);
    var ariaProps = pickAttrs(closableObj, true);
    var validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
    var noticePrefixCls = "".concat(prefixCls, "-notice");
    return /* @__PURE__ */ React48.createElement("div", _extends({}, divProps, {
      ref,
      className: (0, import_classnames3.default)(noticePrefixCls, className, _defineProperty({}, "".concat(noticePrefixCls, "-closable"), closable)),
      style: style2,
      onMouseEnter: function onMouseEnter(e3) {
        var _divProps$onMouseEnte;
        setHovering(true);
        divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e3);
      },
      onMouseLeave: function onMouseLeave(e3) {
        var _divProps$onMouseLeav;
        setHovering(false);
        divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e3);
      },
      onClick
    }), /* @__PURE__ */ React48.createElement("div", {
      className: "".concat(noticePrefixCls, "-content")
    }, content), closable && /* @__PURE__ */ React48.createElement("a", _extends({
      tabIndex: 0,
      className: "".concat(noticePrefixCls, "-close"),
      onKeyDown: onCloseKeyDown,
      "aria-label": "Close"
    }, ariaProps, {
      onClick: function onClick2(e3) {
        e3.preventDefault();
        e3.stopPropagation();
        onInternalClose();
      }
    }), closableObj.closeIcon), mergedShowProgress && /* @__PURE__ */ React48.createElement("progress", {
      className: "".concat(noticePrefixCls, "-progress"),
      max: "100",
      value: validPercent
    }, validPercent + "%"));
  });
  var Notice_default = Notify;

  // node_modules/rc-notification/es/NotificationProvider.js
  var import_react21 = __toESM(require_react());
  var NotificationContext = /* @__PURE__ */ import_react21.default.createContext({});
  var NotificationProvider = function NotificationProvider2(_ref) {
    var children = _ref.children, classNames146 = _ref.classNames;
    return /* @__PURE__ */ import_react21.default.createElement(NotificationContext.Provider, {
      value: {
        classNames: classNames146
      }
    }, children);
  };
  var NotificationProvider_default = NotificationProvider;

  // node_modules/rc-notification/es/hooks/useStack.js
  var DEFAULT_OFFSET = 8;
  var DEFAULT_THRESHOLD = 3;
  var DEFAULT_GAP = 16;
  var useStack = function useStack2(config) {
    var result = {
      offset: DEFAULT_OFFSET,
      threshold: DEFAULT_THRESHOLD,
      gap: DEFAULT_GAP
    };
    if (config && _typeof(config) === "object") {
      var _config$offset, _config$threshold, _config$gap;
      result.offset = (_config$offset = config.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET;
      result.threshold = (_config$threshold = config.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;
      result.gap = (_config$gap = config.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;
    }
    return [!!config, result];
  };
  var useStack_default = useStack;

  // node_modules/rc-notification/es/NoticeList.js
  var _excluded5 = ["className", "style", "classNames", "styles"];
  var NoticeList = function NoticeList2(props) {
    var configList = props.configList, placement = props.placement, prefixCls = props.prefixCls, className = props.className, style2 = props.style, motion2 = props.motion, onAllNoticeRemoved = props.onAllNoticeRemoved, onNoticeClose = props.onNoticeClose, stackConfig = props.stack;
    var _useContext = (0, import_react22.useContext)(NotificationContext), ctxCls = _useContext.classNames;
    var dictRef = (0, import_react22.useRef)({});
    var _useState = (0, import_react22.useState)(null), _useState2 = _slicedToArray(_useState, 2), latestNotice = _useState2[0], setLatestNotice = _useState2[1];
    var _useState3 = (0, import_react22.useState)([]), _useState4 = _slicedToArray(_useState3, 2), hoverKeys = _useState4[0], setHoverKeys = _useState4[1];
    var keys2 = configList.map(function(config) {
      return {
        config,
        key: String(config.key)
      };
    });
    var _useStack = useStack_default(stackConfig), _useStack2 = _slicedToArray(_useStack, 2), stack = _useStack2[0], _useStack2$ = _useStack2[1], offset3 = _useStack2$.offset, threshold = _useStack2$.threshold, gap = _useStack2$.gap;
    var expanded = stack && (hoverKeys.length > 0 || keys2.length <= threshold);
    var placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
    (0, import_react22.useEffect)(function() {
      if (stack && hoverKeys.length > 1) {
        setHoverKeys(function(prev2) {
          return prev2.filter(function(key) {
            return keys2.some(function(_ref) {
              var dataKey = _ref.key;
              return key === dataKey;
            });
          });
        });
      }
    }, [hoverKeys, keys2, stack]);
    (0, import_react22.useEffect)(function() {
      var _keys;
      if (stack && dictRef.current[(_keys = keys2[keys2.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {
        var _keys2;
        setLatestNotice(dictRef.current[(_keys2 = keys2[keys2.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);
      }
    }, [keys2, stack]);
    return /* @__PURE__ */ import_react22.default.createElement(CSSMotionList_default, _extends({
      key: placement,
      className: (0, import_classnames4.default)(prefixCls, "".concat(prefixCls, "-").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-stack"), !!stack), "".concat(prefixCls, "-stack-expanded"), expanded)),
      style: style2,
      keys: keys2,
      motionAppear: true
    }, placementMotion, {
      onAllRemoved: function onAllRemoved() {
        onAllNoticeRemoved(placement);
      }
    }), function(_ref2, nodeRef) {
      var config = _ref2.config, motionClassName = _ref2.className, motionStyle = _ref2.style, motionIndex = _ref2.index;
      var _ref3 = config, key = _ref3.key, times = _ref3.times;
      var strKey = String(key);
      var _ref4 = config, configClassName = _ref4.className, configStyle = _ref4.style, configClassNames = _ref4.classNames, configStyles = _ref4.styles, restConfig = _objectWithoutProperties(_ref4, _excluded5);
      var dataIndex = keys2.findIndex(function(item) {
        return item.key === strKey;
      });
      var stackStyle = {};
      if (stack) {
        var index3 = keys2.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
        var transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
        if (index3 > 0) {
          var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;
          stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;
          var verticalOffset = 0;
          for (var i = 0; i < index3; i++) {
            var _dictRef$current$keys;
            verticalOffset += ((_dictRef$current$keys = dictRef.current[keys2[keys2.length - 1 - i].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;
          }
          var transformY = (expanded ? verticalOffset : index3 * offset3) * (placement.startsWith("top") ? 1 : -1);
          var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset3 * 2 * (index3 < 3 ? index3 : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;
          stackStyle.transform = "translate3d(".concat(transformX, ", ").concat(transformY, "px, 0) scaleX(").concat(scaleX, ")");
        } else {
          stackStyle.transform = "translate3d(".concat(transformX, ", 0, 0)");
        }
      }
      return /* @__PURE__ */ import_react22.default.createElement("div", {
        ref: nodeRef,
        className: (0, import_classnames4.default)("".concat(prefixCls, "-notice-wrapper"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),
        style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),
        onMouseEnter: function onMouseEnter() {
          return setHoverKeys(function(prev2) {
            return prev2.includes(strKey) ? prev2 : [].concat(_toConsumableArray(prev2), [strKey]);
          });
        },
        onMouseLeave: function onMouseLeave() {
          return setHoverKeys(function(prev2) {
            return prev2.filter(function(k) {
              return k !== strKey;
            });
          });
        }
      }, /* @__PURE__ */ import_react22.default.createElement(Notice_default, _extends({}, restConfig, {
        ref: function ref(node2) {
          if (dataIndex > -1) {
            dictRef.current[strKey] = node2;
          } else {
            delete dictRef.current[strKey];
          }
        },
        prefixCls,
        classNames: configClassNames,
        styles: configStyles,
        className: (0, import_classnames4.default)(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),
        style: configStyle,
        times,
        key,
        eventKey: key,
        onNoticeClose,
        hovering: stack && hoverKeys.length > 0
      })));
    });
  };
  if (true) {
    NoticeList.displayName = "NoticeList";
  }
  var NoticeList_default = NoticeList;

  // node_modules/rc-notification/es/Notifications.js
  var Notifications = /* @__PURE__ */ React51.forwardRef(function(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container = props.container, motion2 = props.motion, maxCount = props.maxCount, className = props.className, style2 = props.style, onAllRemoved = props.onAllRemoved, stack = props.stack, renderNotifications2 = props.renderNotifications;
    var _React$useState = React51.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
    var onNoticeClose = function onNoticeClose2(key) {
      var _config$onClose;
      var config = configList.find(function(item) {
        return item.key === key;
      });
      config === null || config === void 0 || (_config$onClose = config.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config);
      setConfigList(function(list) {
        return list.filter(function(item) {
          return item.key !== key;
        });
      });
    };
    React51.useImperativeHandle(ref, function() {
      return {
        open: function open2(config) {
          setConfigList(function(list) {
            var clone = _toConsumableArray(list);
            var index3 = clone.findIndex(function(item) {
              return item.key === config.key;
            });
            var innerConfig = _objectSpread2({}, config);
            if (index3 >= 0) {
              var _list$index;
              innerConfig.times = (((_list$index = list[index3]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
              clone[index3] = innerConfig;
            } else {
              innerConfig.times = 0;
              clone.push(innerConfig);
            }
            if (maxCount > 0 && clone.length > maxCount) {
              clone = clone.slice(-maxCount);
            }
            return clone;
          });
        },
        close: function close(key) {
          onNoticeClose(key);
        },
        destroy: function destroy2() {
          setConfigList([]);
        }
      };
    });
    var _React$useState3 = React51.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements4 = _React$useState4[0], setPlacements = _React$useState4[1];
    React51.useEffect(function() {
      var nextPlacements = {};
      configList.forEach(function(config) {
        var _config$placement = config.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
        if (placement) {
          nextPlacements[placement] = nextPlacements[placement] || [];
          nextPlacements[placement].push(config);
        }
      });
      Object.keys(placements4).forEach(function(placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
      });
      setPlacements(nextPlacements);
    }, [configList]);
    var onAllNoticeRemoved = function onAllNoticeRemoved2(placement) {
      setPlacements(function(originPlacements) {
        var clone = _objectSpread2({}, originPlacements);
        var list = clone[placement] || [];
        if (!list.length) {
          delete clone[placement];
        }
        return clone;
      });
    };
    var emptyRef = React51.useRef(false);
    React51.useEffect(function() {
      if (Object.keys(placements4).length > 0) {
        emptyRef.current = true;
      } else if (emptyRef.current) {
        onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();
        emptyRef.current = false;
      }
    }, [placements4]);
    if (!container) {
      return null;
    }
    var placementList = Object.keys(placements4);
    return /* @__PURE__ */ (0, import_react_dom2.createPortal)(/* @__PURE__ */ React51.createElement(React51.Fragment, null, placementList.map(function(placement) {
      var placementConfigList = placements4[placement];
      var list = /* @__PURE__ */ React51.createElement(NoticeList_default, {
        key: placement,
        configList: placementConfigList,
        placement,
        prefixCls,
        className: className === null || className === void 0 ? void 0 : className(placement),
        style: style2 === null || style2 === void 0 ? void 0 : style2(placement),
        motion: motion2,
        onNoticeClose,
        onAllNoticeRemoved,
        stack
      });
      return renderNotifications2 ? renderNotifications2(list, {
        prefixCls,
        key: placement
      }) : list;
    })), container);
  });
  if (true) {
    Notifications.displayName = "Notifications";
  }
  var Notifications_default = Notifications;

  // node_modules/rc-notification/es/hooks/useNotification.js
  var _excluded6 = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"];
  var defaultGetContainer = function defaultGetContainer2() {
    return document.body;
  };
  var uniqueKey = 0;
  function mergeConfig() {
    var clone = {};
    for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
      objList[_key] = arguments[_key];
    }
    objList.forEach(function(obj) {
      if (obj) {
        Object.keys(obj).forEach(function(key) {
          var val = obj[key];
          if (val !== void 0) {
            clone[key] = val;
          }
        });
      }
    });
    return clone;
  }
  function useNotification() {
    var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _rootConfig$getContai = rootConfig.getContainer, getContainer2 = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion2 = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style2 = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, stack = rootConfig.stack, renderNotifications2 = rootConfig.renderNotifications, shareConfig = _objectWithoutProperties(rootConfig, _excluded6);
    var _React$useState = React52.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];
    var notificationsRef = React52.useRef();
    var contextHolder = /* @__PURE__ */ React52.createElement(Notifications_default, {
      container,
      ref: notificationsRef,
      prefixCls,
      motion: motion2,
      maxCount,
      className,
      style: style2,
      onAllRemoved,
      stack,
      renderNotifications: renderNotifications2
    });
    var _React$useState3 = React52.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue2 = _React$useState4[0], setTaskQueue = _React$useState4[1];
    var open2 = useEvent(function(config) {
      var mergedConfig = mergeConfig(shareConfig, config);
      if (mergedConfig.key === null || mergedConfig.key === void 0) {
        mergedConfig.key = "rc-notification-".concat(uniqueKey);
        uniqueKey += 1;
      }
      setTaskQueue(function(queue) {
        return [].concat(_toConsumableArray(queue), [{
          type: "open",
          config: mergedConfig
        }]);
      });
    });
    var api = React52.useMemo(function() {
      return {
        open: open2,
        close: function close(key) {
          setTaskQueue(function(queue) {
            return [].concat(_toConsumableArray(queue), [{
              type: "close",
              key
            }]);
          });
        },
        destroy: function destroy2() {
          setTaskQueue(function(queue) {
            return [].concat(_toConsumableArray(queue), [{
              type: "destroy"
            }]);
          });
        }
      };
    }, []);
    React52.useEffect(function() {
      setContainer(getContainer2());
    });
    React52.useEffect(function() {
      if (notificationsRef.current && taskQueue2.length) {
        taskQueue2.forEach(function(task) {
          switch (task.type) {
            case "open":
              notificationsRef.current.open(task.config);
              break;
            case "close":
              notificationsRef.current.close(task.key);
              break;
            case "destroy":
              notificationsRef.current.destroy();
              break;
          }
        });
        var oriTaskQueue;
        var tgtTaskQueue;
        setTaskQueue(function(oriQueue) {
          if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
            oriTaskQueue = oriQueue;
            tgtTaskQueue = oriQueue.filter(function(task) {
              return !taskQueue2.includes(task);
            });
          }
          return tgtTaskQueue;
        });
      }
    }, [taskQueue2]);
    return [api, contextHolder];
  }

  // node_modules/antd/es/message/PurePanel.js
  var React56 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/LoadingOutlined.js
  var React53 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/LoadingOutlined.js
  var LoadingOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
  var LoadingOutlined_default = LoadingOutlined;

  // node_modules/@ant-design/icons/es/icons/LoadingOutlined.js
  var LoadingOutlined2 = function LoadingOutlined3(props, ref) {
    return /* @__PURE__ */ React53.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: LoadingOutlined_default
    }));
  };
  var RefIcon6 = /* @__PURE__ */ React53.forwardRef(LoadingOutlined2);
  if (true) {
    RefIcon6.displayName = "LoadingOutlined";
  }
  var LoadingOutlined_default2 = RefIcon6;

  // node_modules/antd/es/message/PurePanel.js
  var import_classnames5 = __toESM(require_classnames());

  // node_modules/antd/es/_util/hooks/useZIndex.js
  var import_react24 = __toESM(require_react());

  // node_modules/antd/es/_util/zindexContext.js
  var import_react23 = __toESM(require_react());
  var zIndexContext = /* @__PURE__ */ import_react23.default.createContext(void 0);
  if (true) {
    zIndexContext.displayName = "zIndexContext";
  }
  var zindexContext_default = zIndexContext;

  // node_modules/antd/es/_util/hooks/useZIndex.js
  var CONTAINER_OFFSET = 100;
  var CONTAINER_OFFSET_MAX_COUNT = 10;
  var CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
  var CONTAINER_MAX_OFFSET_WITH_CHILDREN = CONTAINER_MAX_OFFSET + CONTAINER_OFFSET;
  var containerBaseZIndexOffset = {
    Modal: CONTAINER_OFFSET,
    Drawer: CONTAINER_OFFSET,
    Popover: CONTAINER_OFFSET,
    Popconfirm: CONTAINER_OFFSET,
    Tooltip: CONTAINER_OFFSET,
    Tour: CONTAINER_OFFSET,
    FloatButton: CONTAINER_OFFSET
  };
  var consumerBaseZIndexOffset = {
    SelectLike: 50,
    Dropdown: 50,
    DatePicker: 50,
    Menu: 50,
    ImagePreview: 1
  };
  function isContainerType(type5) {
    return type5 in containerBaseZIndexOffset;
  }
  var useZIndex = (componentType, customZIndex) => {
    const [, token2] = useToken();
    const parentZIndex = import_react24.default.useContext(zindexContext_default);
    const isContainer = isContainerType(componentType);
    let result;
    if (customZIndex !== void 0) {
      result = [customZIndex, customZIndex];
    } else {
      let zIndex = parentZIndex !== null && parentZIndex !== void 0 ? parentZIndex : 0;
      if (isContainer) {
        zIndex += // Use preset token zIndex by default but not stack when has parent container
        (parentZIndex ? 0 : token2.zIndexPopupBase) + // Container offset
        containerBaseZIndexOffset[componentType];
      } else {
        zIndex += consumerBaseZIndexOffset[componentType];
      }
      result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
    }
    if (true) {
      const warning6 = devUseWarning(componentType);
      const maxZIndex = token2.zIndexPopupBase + CONTAINER_MAX_OFFSET_WITH_CHILDREN;
      const currentZIndex = result[0] || 0;
      true ? warning6(customZIndex !== void 0 || currentZIndex <= maxZIndex, "usage", "`zIndex` is over design token `zIndexPopupBase` too much. It may cause unexpected override.") : void 0;
    }
    return result;
  };

  // node_modules/antd/es/message/style/index.js
  var genMessageStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      boxShadow,
      colorText,
      colorSuccess,
      colorError,
      colorWarning,
      colorInfo,
      fontSizeLG,
      motionEaseInOutCirc,
      motionDurationSlow,
      marginXS,
      paddingXS,
      borderRadiusLG,
      zIndexPopup,
      // Custom token
      contentPadding,
      contentBg
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    const messageMoveIn = new Keyframes_default("MessageMoveIn", {
      "0%": {
        padding: 0,
        transform: "translateY(-100%)",
        opacity: 0
      },
      "100%": {
        padding: paddingXS,
        transform: "translateY(0)",
        opacity: 1
      }
    });
    const messageMoveOut = new Keyframes_default("MessageMoveOut", {
      "0%": {
        maxHeight: token2.height,
        padding: paddingXS,
        opacity: 1
      },
      "100%": {
        maxHeight: 0,
        padding: 0,
        opacity: 0
      }
    });
    const noticeStyle = {
      padding: paddingXS,
      textAlign: "center",
      [`${componentCls}-custom-content`]: {
        display: "flex",
        alignItems: "center"
      },
      [`${componentCls}-custom-content > ${iconCls}`]: {
        marginInlineEnd: marginXS,
        // affected by ltr or rtl
        fontSize: fontSizeLG
      },
      [`${noticeCls}-content`]: {
        display: "inline-block",
        padding: contentPadding,
        background: contentBg,
        borderRadius: borderRadiusLG,
        boxShadow,
        pointerEvents: "all"
      },
      [`${componentCls}-success > ${iconCls}`]: {
        color: colorSuccess
      },
      [`${componentCls}-error > ${iconCls}`]: {
        color: colorError
      },
      [`${componentCls}-warning > ${iconCls}`]: {
        color: colorWarning
      },
      [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
        color: colorInfo
      }
    };
    return [
      // ============================ Holder ============================
      {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          color: colorText,
          position: "fixed",
          top: marginXS,
          width: "100%",
          pointerEvents: "none",
          zIndex: zIndexPopup,
          [`${componentCls}-move-up`]: {
            animationFillMode: "forwards"
          },
          [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
            animationName: messageMoveIn,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
            animationPlayState: "running"
          },
          [`${componentCls}-move-up-leave`]: {
            animationName: messageMoveOut,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
            animationPlayState: "running"
          },
          "&-rtl": {
            direction: "rtl",
            span: {
              direction: "rtl"
            }
          }
        })
      },
      // ============================ Notice ============================
      {
        [componentCls]: {
          [`${noticeCls}-wrapper`]: Object.assign({}, noticeStyle)
        }
      },
      // ============================= Pure =============================
      {
        [`${componentCls}-notice-pure-panel`]: Object.assign(Object.assign({}, noticeStyle), {
          padding: 0,
          textAlign: "start"
        })
      }
    ];
  };
  var prepareComponentToken = (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
    contentBg: token2.colorBgElevated,
    contentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
  });
  var style_default = genStyleHooks("Message", (token2) => {
    const combinedToken = merge2(token2, {
      height: 150
    });
    return [genMessageStyle(combinedToken)];
  }, prepareComponentToken);

  // node_modules/antd/es/message/PurePanel.js
  var __rest4 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var TypeIcon = {
    info: /* @__PURE__ */ React56.createElement(InfoCircleFilled_default2, null),
    success: /* @__PURE__ */ React56.createElement(CheckCircleFilled_default2, null),
    error: /* @__PURE__ */ React56.createElement(CloseCircleFilled_default2, null),
    warning: /* @__PURE__ */ React56.createElement(ExclamationCircleFilled_default2, null),
    loading: /* @__PURE__ */ React56.createElement(LoadingOutlined_default2, null)
  };
  var PureContent = ({
    prefixCls,
    type: type5,
    icon,
    children
  }) => /* @__PURE__ */ React56.createElement("div", {
    className: (0, import_classnames5.default)(`${prefixCls}-custom-content`, `${prefixCls}-${type5}`)
  }, icon || TypeIcon[type5], /* @__PURE__ */ React56.createElement("span", null, children));
  var PurePanel = (props) => {
    const {
      prefixCls: staticPrefixCls,
      className,
      type: type5,
      icon,
      content
    } = props, restProps = __rest4(props, ["prefixCls", "className", "type", "icon", "content"]);
    const {
      getPrefixCls
    } = React56.useContext(ConfigContext);
    const prefixCls = staticPrefixCls || getPrefixCls("message");
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default(prefixCls, rootCls);
    return wrapCSSVar(/* @__PURE__ */ React56.createElement(Notice_default, Object.assign({}, restProps, {
      prefixCls,
      className: (0, import_classnames5.default)(className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
      eventKey: "pure",
      duration: null,
      content: /* @__PURE__ */ React56.createElement(PureContent, {
        prefixCls,
        type: type5,
        icon
      }, content)
    })));
  };
  var PurePanel_default = PurePanel;

  // node_modules/antd/es/message/util.js
  function getMotion(prefixCls, transitionName) {
    return {
      motionName: transitionName !== null && transitionName !== void 0 ? transitionName : `${prefixCls}-move-up`
    };
  }
  function wrapPromiseFn(openFn) {
    let closeFn;
    const closePromise = new Promise((resolve) => {
      closeFn = openFn(() => {
        resolve(true);
      });
    });
    const result = () => {
      closeFn === null || closeFn === void 0 ? void 0 : closeFn();
    };
    result.then = (filled, rejected) => closePromise.then(filled, rejected);
    result.promise = closePromise;
    return result;
  }

  // node_modules/antd/es/message/useMessage.js
  var __rest5 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var DEFAULT_OFFSET2 = 8;
  var DEFAULT_DURATION = 3;
  var Wrapper = ({
    children,
    prefixCls
  }) => {
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default(prefixCls, rootCls);
    return wrapCSSVar(/* @__PURE__ */ React57.createElement(NotificationProvider_default, {
      classNames: {
        list: (0, import_classnames6.default)(hashId, cssVarCls, rootCls)
      }
    }, children));
  };
  var renderNotifications = (node2, {
    prefixCls,
    key
  }) => /* @__PURE__ */ React57.createElement(Wrapper, {
    prefixCls,
    key
  }, node2);
  var Holder = /* @__PURE__ */ React57.forwardRef((props, ref) => {
    const {
      top,
      prefixCls: staticPrefixCls,
      getContainer: staticGetContainer,
      maxCount,
      duration = DEFAULT_DURATION,
      rtl,
      transitionName,
      onAllRemoved
    } = props;
    const {
      getPrefixCls,
      getPopupContainer,
      message: message2,
      direction
    } = React57.useContext(ConfigContext);
    const prefixCls = staticPrefixCls || getPrefixCls("message");
    const getStyle3 = () => ({
      left: "50%",
      transform: "translateX(-50%)",
      top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET2
    });
    const getClassName = () => (0, import_classnames6.default)({
      [`${prefixCls}-rtl`]: rtl !== null && rtl !== void 0 ? rtl : direction === "rtl"
    });
    const getNotificationMotion = () => getMotion(prefixCls, transitionName);
    const mergedCloseIcon = /* @__PURE__ */ React57.createElement("span", {
      className: `${prefixCls}-close-x`
    }, /* @__PURE__ */ React57.createElement(CloseOutlined_default2, {
      className: `${prefixCls}-close-icon`
    }));
    const [api, holder] = useNotification({
      prefixCls,
      style: getStyle3,
      className: getClassName,
      motion: getNotificationMotion,
      closable: false,
      closeIcon: mergedCloseIcon,
      duration,
      getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
      maxCount,
      onAllRemoved,
      renderNotifications
    });
    React57.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
      prefixCls,
      message: message2
    }));
    return holder;
  });
  var keyIndex = 0;
  function useInternalMessage(messageConfig) {
    const holderRef = React57.useRef(null);
    const warning6 = devUseWarning("Message");
    const wrapAPI = React57.useMemo(() => {
      const close = (key) => {
        var _a;
        (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
      };
      const open2 = (config) => {
        if (!holderRef.current) {
          true ? warning6(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.") : void 0;
          const fakeResult = () => {
          };
          fakeResult.then = () => {
          };
          return fakeResult;
        }
        const {
          open: originOpen,
          prefixCls,
          message: message2
        } = holderRef.current;
        const noticePrefixCls = `${prefixCls}-notice`;
        const {
          content,
          icon,
          type: type5,
          key,
          className,
          style: style2,
          onClose
        } = config, restConfig = __rest5(config, ["content", "icon", "type", "key", "className", "style", "onClose"]);
        let mergedKey = key;
        if (mergedKey === void 0 || mergedKey === null) {
          keyIndex += 1;
          mergedKey = `antd-message-${keyIndex}`;
        }
        return wrapPromiseFn((resolve) => {
          originOpen(Object.assign(Object.assign({}, restConfig), {
            key: mergedKey,
            content: /* @__PURE__ */ React57.createElement(PureContent, {
              prefixCls,
              type: type5,
              icon
            }, content),
            placement: "top",
            className: (0, import_classnames6.default)(type5 && `${noticePrefixCls}-${type5}`, className, message2 === null || message2 === void 0 ? void 0 : message2.className),
            style: Object.assign(Object.assign({}, message2 === null || message2 === void 0 ? void 0 : message2.style), style2),
            onClose: () => {
              onClose === null || onClose === void 0 ? void 0 : onClose();
              resolve();
            }
          }));
          return () => {
            close(mergedKey);
          };
        });
      };
      const destroy2 = (key) => {
        var _a;
        if (key !== void 0) {
          close(key);
        } else {
          (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
        }
      };
      const clone = {
        open: open2,
        destroy: destroy2
      };
      const keys2 = ["info", "success", "warning", "error", "loading"];
      keys2.forEach((type5) => {
        const typeOpen2 = (jointContent, duration, onClose) => {
          let config;
          if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
            config = jointContent;
          } else {
            config = {
              content: jointContent
            };
          }
          let mergedDuration;
          let mergedOnClose;
          if (typeof duration === "function") {
            mergedOnClose = duration;
          } else {
            mergedDuration = duration;
            mergedOnClose = onClose;
          }
          const mergedConfig = Object.assign(Object.assign({
            onClose: mergedOnClose,
            duration: mergedDuration
          }, config), {
            type: type5
          });
          return open2(mergedConfig);
        };
        clone[type5] = typeOpen2;
      });
      return clone;
    }, []);
    return [wrapAPI, /* @__PURE__ */ React57.createElement(Holder, Object.assign({
      key: "message-holder"
    }, messageConfig, {
      ref: holderRef
    }))];
  }
  function useMessage(messageConfig) {
    return useInternalMessage(messageConfig);
  }

  // node_modules/antd/es/modal/useModal/index.js
  var React126 = __toESM(require_react());

  // node_modules/antd/es/_util/hooks/usePatchElement.js
  var React58 = __toESM(require_react());
  function usePatchElement() {
    const [elements, setElements] = React58.useState([]);
    const patchElement = React58.useCallback((element) => {
      setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
      return () => {
        setElements((originElements) => originElements.filter((ele) => ele !== element));
      };
    }, []);
    return [elements, patchElement];
  }

  // node_modules/antd/es/modal/confirm.js
  var import_react54 = __toESM(require_react());

  // node_modules/antd/es/config-provider/UnstableContext.js
  var React59 = __toESM(require_react());
  var ReactDOM3 = __toESM(require_react_dom());

  // node_modules/@babel/runtime/helpers/esm/OverloadYield.js
  function _OverloadYield(e3, d) {
    this.v = e3, this.k = d;
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorDefine.js
  function _regeneratorDefine(e3, r2, n2, t2) {
    var i = Object.defineProperty;
    try {
      i({}, "", {});
    } catch (e4) {
      i = 0;
    }
    _regeneratorDefine = function regeneratorDefine(e4, r3, n3, t3) {
      function o3(r4, n4) {
        _regeneratorDefine(e4, r4, function(e5) {
          return this._invoke(r4, n4, e5);
        });
      }
      r3 ? i ? i(e4, r3, {
        value: n3,
        enumerable: !t3,
        configurable: !t3,
        writable: !t3
      }) : e4[r3] = n3 : (o3("next", 0), o3("throw", 1), o3("return", 2));
    }, _regeneratorDefine(e3, r2, n2, t2);
  }

  // node_modules/@babel/runtime/helpers/esm/regenerator.js
  function _regenerator() {
    var e3, t2, r2 = "function" == typeof Symbol ? Symbol : {}, n2 = r2.iterator || "@@iterator", o3 = r2.toStringTag || "@@toStringTag";
    function i(r3, n3, o4, i2) {
      var c2 = n3 && n3.prototype instanceof Generator ? n3 : Generator, u2 = Object.create(c2.prototype);
      return _regeneratorDefine(u2, "_invoke", function(r4, n4, o5) {
        var i3, c3, u3, f2 = 0, p = o5 || [], y = false, G = {
          p: 0,
          n: 0,
          v: e3,
          a: d,
          f: d.bind(e3, 4),
          d: function d2(t3, r5) {
            return i3 = t3, c3 = 0, u3 = e3, G.n = r5, a;
          }
        };
        function d(r5, n5) {
          for (c3 = r5, u3 = n5, t2 = 0; !y && f2 && !o6 && t2 < p.length; t2++) {
            var o6, i4 = p[t2], d2 = G.p, l2 = i4[2];
            r5 > 3 ? (o6 = l2 === n5) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e3) : i4[0] <= d2 && ((o6 = r5 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n5, G.n = i4[1]) : d2 < l2 && (o6 = r5 < 3 || i4[0] > n5 || n5 > l2) && (i4[4] = r5, i4[5] = n5, G.n = l2, c3 = 0));
          }
          if (o6 || r5 > 1) return a;
          throw y = true, n5;
        }
        return function(o6, p2, l2) {
          if (f2 > 1) throw TypeError("Generator is already running");
          for (y && 1 === p2 && d(p2, l2), c3 = p2, u3 = l2; (t2 = c3 < 2 ? e3 : u3) || !y; ) {
            i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
            try {
              if (f2 = 2, i3) {
                if (c3 || (o6 = "next"), t2 = i3[o6]) {
                  if (!(t2 = t2.call(i3, u3))) throw TypeError("iterator result is not an object");
                  if (!t2.done) return t2;
                  u3 = t2.value, c3 < 2 && (c3 = 0);
                } else 1 === c3 && (t2 = i3["return"]) && t2.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o6 + "' method"), c3 = 1);
                i3 = e3;
              } else if ((t2 = (y = G.n < 0) ? u3 : r4.call(n4, G)) !== a) break;
            } catch (t3) {
              i3 = e3, c3 = 1, u3 = t3;
            } finally {
              f2 = 1;
            }
          }
          return {
            value: t2,
            done: y
          };
        };
      }(r3, o4, i2), true), u2;
    }
    var a = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    t2 = Object.getPrototypeOf;
    var c = [][n2] ? t2(t2([][n2]())) : (_regeneratorDefine(t2 = {}, n2, function() {
      return this;
    }), t2), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
    function f(e4) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(e4, GeneratorFunctionPrototype) : (e4.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e4, o3, "GeneratorFunction")), e4.prototype = Object.create(u), e4;
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o3, "GeneratorFunction"), _regeneratorDefine(u), _regeneratorDefine(u, o3, "Generator"), _regeneratorDefine(u, n2, function() {
      return this;
    }), _regeneratorDefine(u, "toString", function() {
      return "[object Generator]";
    }), (_regenerator = function _regenerator2() {
      return {
        w: i,
        m: f
      };
    })();
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorAsyncIterator.js
  function AsyncIterator(t2, e3) {
    function n2(r3, o3, i, f) {
      try {
        var c = t2[r3](o3), u = c.value;
        return u instanceof _OverloadYield ? e3.resolve(u.v).then(function(t3) {
          n2("next", t3, i, f);
        }, function(t3) {
          n2("throw", t3, i, f);
        }) : e3.resolve(u).then(function(t3) {
          c.value = t3, i(c);
        }, function(t3) {
          return n2("throw", t3, i, f);
        });
      } catch (t3) {
        f(t3);
      }
    }
    var r2;
    this.next || (_regeneratorDefine(AsyncIterator.prototype), _regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
      return this;
    })), _regeneratorDefine(this, "_invoke", function(t3, o3, i) {
      function f() {
        return new e3(function(e4, r3) {
          n2(t3, i, e4, r3);
        });
      }
      return r2 = r2 ? r2.then(f, f) : f();
    }, true);
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorAsyncGen.js
  function _regeneratorAsyncGen(r2, e3, t2, o3, n2) {
    return new AsyncIterator(_regenerator().w(r2, e3, t2, o3), n2 || Promise);
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorAsync.js
  function _regeneratorAsync(n2, e3, r2, t2, o3) {
    var a = _regeneratorAsyncGen(n2, e3, r2, t2, o3);
    return a.next().then(function(n3) {
      return n3.done ? n3.value : a.next();
    });
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorKeys.js
  function _regeneratorKeys(e3) {
    var n2 = Object(e3), r2 = [];
    for (var t2 in n2) r2.unshift(t2);
    return function e4() {
      for (; r2.length; ) if ((t2 = r2.pop()) in n2) return e4.value = t2, e4.done = false, e4;
      return e4.done = true, e4;
    };
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorValues.js
  function _regeneratorValues(e3) {
    if (null != e3) {
      var t2 = e3["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r2 = 0;
      if (t2) return t2.call(e3);
      if ("function" == typeof e3.next) return e3;
      if (!isNaN(e3.length)) return {
        next: function next2() {
          return e3 && r2 >= e3.length && (e3 = void 0), {
            value: e3 && e3[r2++],
            done: !e3
          };
        }
      };
    }
    throw new TypeError(_typeof(e3) + " is not iterable");
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
  function _regeneratorRuntime() {
    "use strict";
    var r2 = _regenerator(), e3 = r2.m(_regeneratorRuntime), t2 = (Object.getPrototypeOf ? Object.getPrototypeOf(e3) : e3.__proto__).constructor;
    function n2(r3) {
      var e4 = "function" == typeof r3 && r3.constructor;
      return !!e4 && (e4 === t2 || "GeneratorFunction" === (e4.displayName || e4.name));
    }
    var o3 = {
      "throw": 1,
      "return": 2,
      "break": 3,
      "continue": 3
    };
    function a(r3) {
      var e4, t3;
      return function(n3) {
        e4 || (e4 = {
          stop: function stop() {
            return t3(n3.a, 2);
          },
          "catch": function _catch() {
            return n3.v;
          },
          abrupt: function abrupt(r4, e5) {
            return t3(n3.a, o3[r4], e5);
          },
          delegateYield: function delegateYield(r4, o4, a2) {
            return e4.resultName = o4, t3(n3.d, _regeneratorValues(r4), a2);
          },
          finish: function finish(r4) {
            return t3(n3.f, r4);
          }
        }, t3 = function t4(r4, _t, o4) {
          n3.p = e4.prev, n3.n = e4.next;
          try {
            return r4(_t, o4);
          } finally {
            e4.next = n3.n;
          }
        }), e4.resultName && (e4[e4.resultName] = n3.v, e4.resultName = void 0), e4.sent = n3.v, e4.next = n3.n;
        try {
          return r3.call(this, e4);
        } finally {
          n3.p = e4.prev, n3.n = e4.next;
        }
      };
    }
    return (_regeneratorRuntime = function _regeneratorRuntime2() {
      return {
        wrap: function wrap(e4, t3, n3, o4) {
          return r2.w(a(e4), t3, n3, o4 && o4.reverse());
        },
        isGeneratorFunction: n2,
        mark: r2.m,
        awrap: function awrap(r3, e4) {
          return new _OverloadYield(r3, e4);
        },
        AsyncIterator,
        async: function async(r3, e4, t3, o4, u) {
          return (n2(e4) ? _regeneratorAsyncGen : _regeneratorAsync)(a(r3), e4, t3, o4, u);
        },
        keys: _regeneratorKeys,
        values: _regeneratorValues
      };
    })();
  }

  // node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
  function asyncGeneratorStep(n2, t2, e3, r2, o3, a, c) {
    try {
      var i = n2[a](c), u = i.value;
    } catch (n3) {
      return void e3(n3);
    }
    i.done ? t2(u) : Promise.resolve(u).then(r2, o3);
  }
  function _asyncToGenerator(n2) {
    return function() {
      var t2 = this, e3 = arguments;
      return new Promise(function(r2, o3) {
        var a = n2.apply(t2, e3);
        function _next(n3) {
          asyncGeneratorStep(a, r2, o3, _next, _throw, "next", n3);
        }
        function _throw(n3) {
          asyncGeneratorStep(a, r2, o3, _next, _throw, "throw", n3);
        }
        _next(void 0);
      });
    };
  }

  // node_modules/rc-util/es/React/render.js
  var ReactDOM2 = __toESM(require_react_dom());
  var fullClone4 = _objectSpread2({}, ReactDOM2);
  var version2 = fullClone4.version;
  var reactRender = fullClone4.render;
  var unmountComponentAtNode = fullClone4.unmountComponentAtNode;
  var createRoot;
  try {
    mainVersion = Number((version2 || "").split(".")[0]);
    if (mainVersion >= 18) {
      createRoot = fullClone4.createRoot;
    }
  } catch (e3) {
  }
  var mainVersion;
  function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
  }
  var MARK = "__rc_react_root__";
  function modernRender(node2, container) {
    toggleWarning(true);
    var root2 = container[MARK] || createRoot(container);
    toggleWarning(false);
    root2.render(node2);
    container[MARK] = root2;
  }
  function legacyRender(node2, container) {
    reactRender === null || reactRender === void 0 || reactRender(node2, container);
  }
  function render(node2, container) {
    if (createRoot) {
      modernRender(node2, container);
      return;
    }
    legacyRender(node2, container);
  }
  function modernUnmount(_x) {
    return _modernUnmount.apply(this, arguments);
  }
  function _modernUnmount() {
    _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve().then(function() {
              var _container$MARK;
              (_container$MARK = container[MARK]) === null || _container$MARK === void 0 || _container$MARK.unmount();
              delete container[MARK];
            }));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _modernUnmount.apply(this, arguments);
  }
  function legacyUnmount(container) {
    unmountComponentAtNode(container);
  }
  function unmount(_x2) {
    return _unmount.apply(this, arguments);
  }
  function _unmount() {
    _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (!(createRoot !== void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", modernUnmount(container));
          case 2:
            legacyUnmount(container);
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _unmount.apply(this, arguments);
  }

  // node_modules/antd/es/config-provider/UnstableContext.js
  var defaultReactRender = (node2, container) => {
    if (true) {
      const majorVersion = parseInt(React59.version.split(".")[0], 10);
      const fullKeys = Object.keys(ReactDOM3);
      true ? warning_default2(majorVersion < 19 || fullKeys.includes("createRoot"), "compatible", "antd v5 support React is 16 ~ 18. see https://u.ant.design/v5-for-19 for compatible.") : void 0;
    }
    render(node2, container);
    return () => {
      return unmount(container);
    };
  };
  var unstableRender = defaultReactRender;
  function unstableSetRender(render4) {
    if (render4) {
      unstableRender = render4;
    }
    return unstableRender;
  }

  // node_modules/antd/es/modal/ConfirmDialog.js
  var React123 = __toESM(require_react());
  var import_classnames33 = __toESM(require_classnames());

  // node_modules/antd/es/_util/motion.js
  var getCollapsedHeight = () => ({
    height: 0,
    opacity: 0
  });
  var getRealHeight = (node2) => {
    const {
      scrollHeight
    } = node2;
    return {
      height: scrollHeight,
      opacity: 1
    };
  };
  var getCurrentHeight = (node2) => ({
    height: node2 ? node2.offsetHeight : 0
  });
  var skipOpacityTransition = (_, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
  var initCollapseMotion = (rootCls = defaultPrefixCls) => ({
    motionName: `${rootCls}-motion-collapse`,
    onAppearStart: getCollapsedHeight,
    onEnterStart: getCollapsedHeight,
    onAppearActive: getRealHeight,
    onEnterActive: getRealHeight,
    onLeaveStart: getCurrentHeight,
    onLeaveActive: getCollapsedHeight,
    onAppearEnd: skipOpacityTransition,
    onEnterEnd: skipOpacityTransition,
    onLeaveEnd: skipOpacityTransition,
    motionDeadline: 500
  });
  var getTransitionName2 = (rootPrefixCls, motion2, transitionName) => {
    if (transitionName !== void 0) {
      return transitionName;
    }
    return `${rootPrefixCls}-${motion2}`;
  };
  var motion_default = initCollapseMotion;

  // node_modules/antd/es/modal/components/ConfirmCancelBtn.js
  var import_react43 = __toESM(require_react());

  // node_modules/antd/es/_util/ActionButton.js
  var React81 = __toESM(require_react());

  // node_modules/antd/es/button/button.js
  var import_react41 = __toESM(require_react());
  var import_classnames18 = __toESM(require_classnames());

  // node_modules/rc-util/es/omit.js
  function omit(obj, fields) {
    var clone = Object.assign({}, obj);
    if (Array.isArray(fields)) {
      fields.forEach(function(key) {
        delete clone[key];
      });
    }
    return clone;
  }

  // node_modules/antd/es/_util/wave/index.js
  var import_react25 = __toESM(require_react());
  var import_classnames8 = __toESM(require_classnames());

  // node_modules/rc-util/es/Dom/isVisible.js
  var isVisible_default = function(element) {
    if (!element) {
      return false;
    }
    if (element instanceof Element) {
      if (element.offsetParent) {
        return true;
      }
      if (element.getBBox) {
        var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
        if (width || height) {
          return true;
        }
      }
      if (element.getBoundingClientRect) {
        var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
        if (_width || _height) {
          return true;
        }
      }
    }
    return false;
  };

  // node_modules/antd/es/_util/wave/style.js
  var genWaveStyle = (token2) => {
    const {
      componentCls,
      colorPrimary
    } = token2;
    return {
      [componentCls]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${colorPrimary})`,
        boxShadow: `0 0 0 0 currentcolor`,
        opacity: 0.2,
        // =================== Motion ===================
        "&.wave-motion-appear": {
          transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
          "&-active": {
            boxShadow: `0 0 0 6px currentcolor`,
            opacity: 0
          },
          "&.wave-quick": {
            transition: [`box-shadow ${token2.motionDurationSlow} ${token2.motionEaseInOut}`, `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`].join(",")
          }
        }
      }
    };
  };
  var style_default2 = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);

  // node_modules/antd/es/_util/wave/useWave.js
  var React61 = __toESM(require_react());

  // node_modules/antd/es/_util/wave/interface.js
  var TARGET_CLS = `${defaultPrefixCls}-wave-target`;

  // node_modules/antd/es/_util/wave/WaveEffect.js
  var React60 = __toESM(require_react());
  var import_classnames7 = __toESM(require_classnames());

  // node_modules/antd/es/_util/wave/util.js
  function isValidWaveColor(color) {
    return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
    color !== "transparent";
  }
  function getTargetWaveColor(node2) {
    const {
      borderTopColor,
      borderColor,
      backgroundColor
    } = getComputedStyle(node2);
    if (isValidWaveColor(borderTopColor)) {
      return borderTopColor;
    }
    if (isValidWaveColor(borderColor)) {
      return borderColor;
    }
    if (isValidWaveColor(backgroundColor)) {
      return backgroundColor;
    }
    return null;
  }

  // node_modules/antd/es/_util/wave/WaveEffect.js
  function validateNum(value) {
    return Number.isNaN(value) ? 0 : value;
  }
  var WaveEffect = (props) => {
    const {
      className,
      target,
      component,
      registerUnmount
    } = props;
    const divRef = React60.useRef(null);
    const unmountRef = React60.useRef(null);
    React60.useEffect(() => {
      unmountRef.current = registerUnmount();
    }, []);
    const [color, setWaveColor] = React60.useState(null);
    const [borderRadius, setBorderRadius] = React60.useState([]);
    const [left, setLeft] = React60.useState(0);
    const [top, setTop] = React60.useState(0);
    const [width, setWidth] = React60.useState(0);
    const [height, setHeight] = React60.useState(0);
    const [enabled, setEnabled] = React60.useState(false);
    const waveStyle = {
      left,
      top,
      width,
      height,
      borderRadius: borderRadius.map((radius2) => `${radius2}px`).join(" ")
    };
    if (color) {
      waveStyle["--wave-color"] = color;
    }
    function syncPos() {
      const nodeStyle = getComputedStyle(target);
      setWaveColor(getTargetWaveColor(target));
      const isStatic = nodeStyle.position === "static";
      const {
        borderLeftWidth,
        borderTopWidth
      } = nodeStyle;
      setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
      setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
      setWidth(target.offsetWidth);
      setHeight(target.offsetHeight);
      const {
        borderTopLeftRadius,
        borderTopRightRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius
      } = nodeStyle;
      setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius2) => validateNum(parseFloat(radius2))));
    }
    React60.useEffect(() => {
      if (target) {
        const id = raf_default(() => {
          syncPos();
          setEnabled(true);
        });
        let resizeObserver2;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver2 = new ResizeObserver(syncPos);
          resizeObserver2.observe(target);
        }
        return () => {
          raf_default.cancel(id);
          resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
        };
      }
    }, []);
    if (!enabled) {
      return null;
    }
    const isSmallComponent = (component === "Checkbox" || component === "Radio") && (target === null || target === void 0 ? void 0 : target.classList.contains(TARGET_CLS));
    return /* @__PURE__ */ React60.createElement(es_default2, {
      visible: true,
      motionAppear: true,
      motionName: "wave-motion",
      motionDeadline: 5e3,
      onAppearEnd: (_, event) => {
        var _a, _b;
        if (event.deadline || event.propertyName === "opacity") {
          const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
          (_b = unmountRef.current) === null || _b === void 0 ? void 0 : _b.call(unmountRef).then(() => {
            holder === null || holder === void 0 ? void 0 : holder.remove();
          });
        }
        return false;
      }
    }, ({
      className: motionClassName
    }, ref) => /* @__PURE__ */ React60.createElement("div", {
      ref: composeRef(divRef, ref),
      className: (0, import_classnames7.default)(className, motionClassName, {
        "wave-quick": isSmallComponent
      }),
      style: waveStyle
    }));
  };
  var showWaveEffect = (target, info) => {
    var _a;
    const {
      component
    } = info;
    if (component === "Checkbox" && !((_a = target.querySelector("input")) === null || _a === void 0 ? void 0 : _a.checked)) {
      return;
    }
    const holder = document.createElement("div");
    holder.style.position = "absolute";
    holder.style.left = "0px";
    holder.style.top = "0px";
    target === null || target === void 0 ? void 0 : target.insertBefore(holder, target === null || target === void 0 ? void 0 : target.firstChild);
    const reactRender2 = unstableSetRender();
    let unmountCallback = null;
    function registerUnmount() {
      return unmountCallback;
    }
    unmountCallback = reactRender2(/* @__PURE__ */ React60.createElement(WaveEffect, Object.assign({}, info, {
      target,
      registerUnmount
    })), holder);
  };
  var WaveEffect_default = showWaveEffect;

  // node_modules/antd/es/_util/wave/useWave.js
  var useWave = (nodeRef, className, component) => {
    const {
      wave
    } = React61.useContext(ConfigContext);
    const [, token2, hashId] = useToken();
    const showWave = useEvent((event) => {
      const node2 = nodeRef.current;
      if ((wave === null || wave === void 0 ? void 0 : wave.disabled) || !node2) {
        return;
      }
      const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2;
      const {
        showEffect
      } = wave || {};
      (showEffect || WaveEffect_default)(targetNode, {
        className,
        token: token2,
        component,
        event,
        hashId
      });
    });
    const rafId = React61.useRef(null);
    const showDebounceWave = (event) => {
      raf_default.cancel(rafId.current);
      rafId.current = raf_default(() => {
        showWave(event);
      });
    };
    return showDebounceWave;
  };
  var useWave_default = useWave;

  // node_modules/antd/es/_util/wave/index.js
  var Wave = (props) => {
    const {
      children,
      disabled,
      component
    } = props;
    const {
      getPrefixCls
    } = (0, import_react25.useContext)(ConfigContext);
    const containerRef = (0, import_react25.useRef)(null);
    const prefixCls = getPrefixCls("wave");
    const [, hashId] = style_default2(prefixCls);
    const showWave = useWave_default(containerRef, (0, import_classnames8.default)(prefixCls, hashId), component);
    import_react25.default.useEffect(() => {
      const node2 = containerRef.current;
      if (!node2 || node2.nodeType !== 1 || disabled) {
        return;
      }
      const onClick = (e3) => {
        if (!isVisible_default(e3.target) || // No need wave
        !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
          return;
        }
        showWave(e3);
      };
      node2.addEventListener("click", onClick, true);
      return () => {
        node2.removeEventListener("click", onClick, true);
      };
    }, [disabled]);
    if (!/* @__PURE__ */ import_react25.default.isValidElement(children)) {
      return children !== null && children !== void 0 ? children : null;
    }
    const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
    return cloneElement3(children, {
      ref
    });
  };
  if (true) {
    Wave.displayName = "Wave";
  }
  var wave_default = Wave;

  // node_modules/antd/es/config-provider/hooks/useSize.js
  var import_react26 = __toESM(require_react());
  var useSize = (customSize) => {
    const size = import_react26.default.useContext(SizeContext_default);
    const mergedSize = import_react26.default.useMemo(() => {
      if (!customSize) {
        return size;
      }
      if (typeof customSize === "string") {
        return customSize !== null && customSize !== void 0 ? customSize : size;
      }
      if (typeof customSize === "function") {
        return customSize(size);
      }
      return size;
    }, [customSize, size]);
    return mergedSize;
  };
  var useSize_default = useSize;

  // node_modules/antd/es/space/Compact.js
  var React64 = __toESM(require_react());
  var import_classnames9 = __toESM(require_classnames());

  // node_modules/antd/es/space/style/compact.js
  var genSpaceCompactStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        "&-block": {
          display: "flex",
          width: "100%"
        },
        "&-vertical": {
          flexDirection: "column"
        }
      }
    };
  };
  var compact_default = genSpaceCompactStyle;

  // node_modules/antd/es/space/style/index.js
  var genSpaceStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        "&-rtl": {
          direction: "rtl"
        },
        "&-vertical": {
          flexDirection: "column"
        },
        "&-align": {
          flexDirection: "column",
          "&-center": {
            alignItems: "center"
          },
          "&-start": {
            alignItems: "flex-start"
          },
          "&-end": {
            alignItems: "flex-end"
          },
          "&-baseline": {
            alignItems: "baseline"
          }
        },
        [`${componentCls}-item:empty`]: {
          display: "none"
        },
        // https://github.com/ant-design/ant-design/issues/47875
        [`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: {
          display: "block"
        }
      }
    };
  };
  var genSpaceGapStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        "&-gap-row-small": {
          rowGap: token2.spaceGapSmallSize
        },
        "&-gap-row-middle": {
          rowGap: token2.spaceGapMiddleSize
        },
        "&-gap-row-large": {
          rowGap: token2.spaceGapLargeSize
        },
        "&-gap-col-small": {
          columnGap: token2.spaceGapSmallSize
        },
        "&-gap-col-middle": {
          columnGap: token2.spaceGapMiddleSize
        },
        "&-gap-col-large": {
          columnGap: token2.spaceGapLargeSize
        }
      }
    };
  };
  var style_default3 = genStyleHooks("Space", (token2) => {
    const spaceToken = merge2(token2, {
      spaceGapSmallSize: token2.paddingXS,
      spaceGapMiddleSize: token2.padding,
      spaceGapLargeSize: token2.paddingLG
    });
    return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken), compact_default(spaceToken)];
  }, () => ({}), {
    // Space component don't apply extra font style
    // https://github.com/ant-design/ant-design/issues/40315
    resetStyle: false
  });

  // node_modules/antd/es/space/Compact.js
  var __rest6 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var SpaceCompactItemContext = /* @__PURE__ */ React64.createContext(null);
  var useCompactItemContext = (prefixCls, direction) => {
    const compactItemContext = React64.useContext(SpaceCompactItemContext);
    const compactItemClassnames = React64.useMemo(() => {
      if (!compactItemContext) {
        return "";
      }
      const {
        compactDirection,
        isFirstItem,
        isLastItem
      } = compactItemContext;
      const separator = compactDirection === "vertical" ? "-vertical-" : "-";
      return (0, import_classnames9.default)(`${prefixCls}-compact${separator}item`, {
        [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
        [`${prefixCls}-compact${separator}last-item`]: isLastItem,
        [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
      });
    }, [prefixCls, direction, compactItemContext]);
    return {
      compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
      compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
      compactItemClassnames
    };
  };
  var NoCompactStyle = (props) => {
    const {
      children
    } = props;
    return /* @__PURE__ */ React64.createElement(SpaceCompactItemContext.Provider, {
      value: null
    }, children);
  };
  var CompactItem = (props) => {
    const {
      children
    } = props, others = __rest6(props, ["children"]);
    return /* @__PURE__ */ React64.createElement(SpaceCompactItemContext.Provider, {
      value: React64.useMemo(() => others, [others])
    }, children);
  };
  var Compact = (props) => {
    const {
      getPrefixCls,
      direction: directionConfig
    } = React64.useContext(ConfigContext);
    const {
      size,
      direction,
      block,
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      children
    } = props, restProps = __rest6(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]);
    const mergedSize = useSize_default((ctx) => size !== null && size !== void 0 ? size : ctx);
    const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
    const [wrapCSSVar, hashId] = style_default3(prefixCls);
    const clx = (0, import_classnames9.default)(prefixCls, hashId, {
      [`${prefixCls}-rtl`]: directionConfig === "rtl",
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-vertical`]: direction === "vertical"
    }, className, rootClassName);
    const compactItemContext = React64.useContext(SpaceCompactItemContext);
    const childNodes = toArray(children);
    const nodes = React64.useMemo(() => childNodes.map((child, i) => {
      const key = (child === null || child === void 0 ? void 0 : child.key) || `${prefixCls}-item-${i}`;
      return /* @__PURE__ */ React64.createElement(CompactItem, {
        key,
        compactSize: mergedSize,
        compactDirection: direction,
        isFirstItem: i === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
        isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
      }, child);
    }), [size, childNodes, compactItemContext]);
    if (childNodes.length === 0) {
      return null;
    }
    return wrapCSSVar(/* @__PURE__ */ React64.createElement("div", Object.assign({
      className: clx
    }, restProps), nodes));
  };
  var Compact_default = Compact;

  // node_modules/antd/es/button/button-group.js
  var React65 = __toESM(require_react());
  var import_classnames10 = __toESM(require_classnames());
  var __rest7 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var GroupSizeContext = /* @__PURE__ */ React65.createContext(void 0);
  var ButtonGroup = (props) => {
    const {
      getPrefixCls,
      direction
    } = React65.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      size,
      className
    } = props, others = __rest7(props, ["prefixCls", "size", "className"]);
    const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
    const [, , hashId] = useToken();
    const sizeCls = React65.useMemo(() => {
      switch (size) {
        case "large":
          return "lg";
        case "small":
          return "sm";
        default:
          return "";
      }
    }, [size]);
    if (true) {
      const warning6 = devUseWarning("Button.Group");
      warning6.deprecated(false, "Button.Group", "Space.Compact");
      true ? warning6(!size || ["large", "small", "middle"].includes(size), "usage", "Invalid prop `size`.") : void 0;
    }
    const classes = (0, import_classnames10.default)(prefixCls, {
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, hashId);
    return /* @__PURE__ */ React65.createElement(GroupSizeContext.Provider, {
      value: size
    }, /* @__PURE__ */ React65.createElement("div", Object.assign({}, others, {
      className: classes
    })));
  };
  var button_group_default = ButtonGroup;

  // node_modules/antd/es/button/buttonHelpers.js
  var import_react27 = __toESM(require_react());
  var rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
  var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
  function convertLegacyProps(type5) {
    if (type5 === "danger") {
      return {
        danger: true
      };
    }
    return {
      type: type5
    };
  }
  function isString(str) {
    return typeof str === "string";
  }
  function isUnBorderedButtonVariant(type5) {
    return type5 === "text" || type5 === "link";
  }
  function splitCNCharsBySpace(child, needInserted) {
    if (child === null || child === void 0) {
      return;
    }
    const SPACE = needInserted ? " " : "";
    if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
      return cloneElement3(child, {
        children: child.props.children.split("").join(SPACE)
      });
    }
    if (isString(child)) {
      return isTwoCNChar(child) ? /* @__PURE__ */ import_react27.default.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ import_react27.default.createElement("span", null, child);
    }
    if (isFragment2(child)) {
      return /* @__PURE__ */ import_react27.default.createElement("span", null, child);
    }
    return child;
  }
  function spaceChildren(children, needInserted) {
    let isPrevChildPure = false;
    const childList = [];
    import_react27.default.Children.forEach(children, (child) => {
      const type5 = typeof child;
      const isCurrentChildPure = type5 === "string" || type5 === "number";
      if (isPrevChildPure && isCurrentChildPure) {
        const lastIndex = childList.length - 1;
        const lastChild = childList[lastIndex];
        childList[lastIndex] = `${lastChild}${child}`;
      } else {
        childList.push(child);
      }
      isPrevChildPure = isCurrentChildPure;
    });
    return import_react27.default.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
  }
  var _ButtonColorTypes = ["default", "primary", "danger"].concat(_toConsumableArray(PresetColors));

  // node_modules/antd/es/button/DefaultLoadingIcon.js
  var import_react29 = __toESM(require_react());
  var import_classnames12 = __toESM(require_classnames());

  // node_modules/antd/es/button/IconWrapper.js
  var import_react28 = __toESM(require_react());
  var import_classnames11 = __toESM(require_classnames());
  var IconWrapper = /* @__PURE__ */ (0, import_react28.forwardRef)((props, ref) => {
    const {
      className,
      style: style2,
      children,
      prefixCls
    } = props;
    const iconWrapperCls = (0, import_classnames11.default)(`${prefixCls}-icon`, className);
    return /* @__PURE__ */ import_react28.default.createElement("span", {
      ref,
      className: iconWrapperCls,
      style: style2
    }, children);
  });
  var IconWrapper_default = IconWrapper;

  // node_modules/antd/es/button/DefaultLoadingIcon.js
  var InnerLoadingIcon = /* @__PURE__ */ (0, import_react29.forwardRef)((props, ref) => {
    const {
      prefixCls,
      className,
      style: style2,
      iconClassName
    } = props;
    const mergedIconCls = (0, import_classnames12.default)(`${prefixCls}-loading-icon`, className);
    return /* @__PURE__ */ import_react29.default.createElement(IconWrapper_default, {
      prefixCls,
      className: mergedIconCls,
      style: style2,
      ref
    }, /* @__PURE__ */ import_react29.default.createElement(LoadingOutlined_default2, {
      className: iconClassName
    }));
  });
  var getCollapsedWidth = () => ({
    width: 0,
    opacity: 0,
    transform: "scale(0)"
  });
  var getRealWidth = (node2) => ({
    width: node2.scrollWidth,
    opacity: 1,
    transform: "scale(1)"
  });
  var DefaultLoadingIcon = (props) => {
    const {
      prefixCls,
      loading,
      existIcon,
      className,
      style: style2,
      mount
    } = props;
    const visible = !!loading;
    if (existIcon) {
      return /* @__PURE__ */ import_react29.default.createElement(InnerLoadingIcon, {
        prefixCls,
        className,
        style: style2
      });
    }
    return /* @__PURE__ */ import_react29.default.createElement(es_default2, {
      visible,
      // Used for minus flex gap style only
      motionName: `${prefixCls}-loading-icon-motion`,
      motionAppear: !mount,
      motionEnter: !mount,
      motionLeave: !mount,
      removeOnLeave: true,
      onAppearStart: getCollapsedWidth,
      onAppearActive: getRealWidth,
      onEnterStart: getCollapsedWidth,
      onEnterActive: getRealWidth,
      onLeaveStart: getRealWidth,
      onLeaveActive: getCollapsedWidth
    }, ({
      className: motionCls,
      style: motionStyle
    }, ref) => {
      const mergedStyle = Object.assign(Object.assign({}, style2), motionStyle);
      return /* @__PURE__ */ import_react29.default.createElement(InnerLoadingIcon, {
        prefixCls,
        className: (0, import_classnames12.default)(className, motionCls),
        style: mergedStyle,
        ref
      });
    });
  };
  var DefaultLoadingIcon_default = DefaultLoadingIcon;

  // node_modules/antd/es/button/style/group.js
  var genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
    // Border
    [`> span, > ${buttonTypeCls}`]: {
      "&:not(:last-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineEndColor: borderColor
          }
        }
      },
      "&:not(:first-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineStartColor: borderColor
          }
        }
      }
    }
  });
  var genGroupStyle = (token2) => {
    const {
      componentCls,
      fontSize,
      lineWidth,
      groupBorderColor,
      colorErrorHover
    } = token2;
    return {
      [`${componentCls}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          // Border
          [`> span, > ${componentCls}`]: {
            "&:not(:last-child)": {
              [`&, & > ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            "&:not(:first-child)": {
              marginInlineStart: token2.calc(lineWidth).mul(-1).equal(),
              [`&, & > ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          },
          [componentCls]: {
            position: "relative",
            zIndex: 1,
            "&:hover, &:focus, &:active": {
              zIndex: 2
            },
            "&[disabled]": {
              zIndex: 0
            }
          },
          [`${componentCls}-icon-only`]: {
            fontSize
          }
        },
        // Border Color
        genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
        genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
      ]
    };
  };
  var group_default = genGroupStyle;

  // node_modules/@rc-component/color-picker/es/ColorPicker.js
  var import_react39 = __toESM(require_react());

  // node_modules/@rc-component/color-picker/es/color.js
  var _excluded7 = ["b"];
  var _excluded23 = ["v"];
  var getRoundNumber = function getRoundNumber2(value) {
    return Math.round(Number(value || 0));
  };
  var convertHsb2Hsv = function convertHsb2Hsv2(color) {
    if (color instanceof FastColor) {
      return color;
    }
    if (color && _typeof(color) === "object" && "h" in color && "b" in color) {
      var _ref = color, b = _ref.b, resets = _objectWithoutProperties(_ref, _excluded7);
      return _objectSpread2(_objectSpread2({}, resets), {}, {
        v: b
      });
    }
    if (typeof color === "string" && /hsb/.test(color)) {
      return color.replace(/hsb/, "hsv");
    }
    return color;
  };
  var Color = /* @__PURE__ */ function(_FastColor) {
    _inherits(Color2, _FastColor);
    var _super = _createSuper(Color2);
    function Color2(color) {
      _classCallCheck(this, Color2);
      return _super.call(this, convertHsb2Hsv(color));
    }
    _createClass(Color2, [{
      key: "toHsbString",
      value: function toHsbString() {
        var hsb = this.toHsb();
        var saturation = getRoundNumber(hsb.s * 100);
        var lightness = getRoundNumber(hsb.b * 100);
        var hue = getRoundNumber(hsb.h);
        var alpha = hsb.a;
        var hsbString = "hsb(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%)");
        var hsbaString = "hsba(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%, ").concat(alpha.toFixed(alpha === 0 ? 0 : 2), ")");
        return alpha === 1 ? hsbString : hsbaString;
      }
    }, {
      key: "toHsb",
      value: function toHsb() {
        var _this$toHsv = this.toHsv(), v = _this$toHsv.v, resets = _objectWithoutProperties(_this$toHsv, _excluded23);
        return _objectSpread2(_objectSpread2({}, resets), {}, {
          b: v,
          a: this.a
        });
      }
    }]);
    return Color2;
  }(FastColor);

  // node_modules/@rc-component/color-picker/es/util.js
  var ColorPickerPrefixCls = "rc-color-picker";
  var generateColor = function generateColor2(color) {
    if (color instanceof Color) {
      return color;
    }
    return new Color(color);
  };
  var defaultColor = generateColor("#1677ff");
  var calculateColor = function calculateColor2(props) {
    var offset3 = props.offset, targetRef = props.targetRef, containerRef = props.containerRef, color = props.color, type5 = props.type;
    var _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height;
    var _targetRef$current$ge = targetRef.current.getBoundingClientRect(), targetWidth = _targetRef$current$ge.width, targetHeight = _targetRef$current$ge.height;
    var centerOffsetX = targetWidth / 2;
    var centerOffsetY = targetHeight / 2;
    var saturation = (offset3.x + centerOffsetX) / width;
    var bright = 1 - (offset3.y + centerOffsetY) / height;
    var hsb = color.toHsb();
    var alphaOffset = saturation;
    var hueOffset = (offset3.x + centerOffsetX) / width * 360;
    if (type5) {
      switch (type5) {
        case "hue":
          return generateColor(_objectSpread2(_objectSpread2({}, hsb), {}, {
            h: hueOffset <= 0 ? 0 : hueOffset
          }));
        case "alpha":
          return generateColor(_objectSpread2(_objectSpread2({}, hsb), {}, {
            a: alphaOffset <= 0 ? 0 : alphaOffset
          }));
      }
    }
    return generateColor({
      h: hsb.h,
      s: saturation <= 0 ? 0 : saturation,
      b: bright >= 1 ? 1 : bright,
      a: hsb.a
    });
  };
  var calcOffset = function calcOffset2(color, type5) {
    var hsb = color.toHsb();
    switch (type5) {
      case "hue":
        return {
          x: hsb.h / 360 * 100,
          y: 50
        };
      case "alpha":
        return {
          x: color.a * 100,
          y: 50
        };
      // Picker panel
      default:
        return {
          x: hsb.s * 100,
          y: (1 - hsb.b) * 100
        };
    }
  };

  // node_modules/@rc-component/color-picker/es/ColorPicker.js
  var import_classnames16 = __toESM(require_classnames());

  // node_modules/@rc-component/color-picker/es/components/ColorBlock.js
  var import_classnames13 = __toESM(require_classnames());
  var import_react30 = __toESM(require_react());
  var ColorBlock = function ColorBlock2(_ref) {
    var color = _ref.color, prefixCls = _ref.prefixCls, className = _ref.className, style2 = _ref.style, onClick = _ref.onClick;
    var colorBlockCls = "".concat(prefixCls, "-color-block");
    return /* @__PURE__ */ import_react30.default.createElement("div", {
      className: (0, import_classnames13.default)(colorBlockCls, className),
      style: style2,
      onClick
    }, /* @__PURE__ */ import_react30.default.createElement("div", {
      className: "".concat(colorBlockCls, "-inner"),
      style: {
        background: color
      }
    }));
  };
  var ColorBlock_default = ColorBlock;

  // node_modules/@rc-component/color-picker/es/components/Picker.js
  var import_react35 = __toESM(require_react());

  // node_modules/@rc-component/color-picker/es/hooks/useColorDrag.js
  var import_react31 = __toESM(require_react());
  function getPosition(e3) {
    var obj = "touches" in e3 ? e3.touches[0] : e3;
    var scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;
    var scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
    return {
      pageX: obj.pageX - scrollXOffset,
      pageY: obj.pageY - scrollYOffset
    };
  }
  function useColorDrag(props) {
    var targetRef = props.targetRef, containerRef = props.containerRef, direction = props.direction, onDragChange = props.onDragChange, onDragChangeComplete = props.onDragChangeComplete, calculate = props.calculate, color = props.color, disabledDrag = props.disabledDrag;
    var _useState = (0, import_react31.useState)({
      x: 0,
      y: 0
    }), _useState2 = _slicedToArray(_useState, 2), offsetValue = _useState2[0], setOffsetValue = _useState2[1];
    var mouseMoveRef = (0, import_react31.useRef)(null);
    var mouseUpRef = (0, import_react31.useRef)(null);
    (0, import_react31.useEffect)(function() {
      setOffsetValue(calculate());
    }, [color]);
    (0, import_react31.useEffect)(function() {
      return function() {
        document.removeEventListener("mousemove", mouseMoveRef.current);
        document.removeEventListener("mouseup", mouseUpRef.current);
        document.removeEventListener("touchmove", mouseMoveRef.current);
        document.removeEventListener("touchend", mouseUpRef.current);
        mouseMoveRef.current = null;
        mouseUpRef.current = null;
      };
    }, []);
    var updateOffset = function updateOffset2(e3) {
      var _getPosition = getPosition(e3), pageX = _getPosition.pageX, pageY = _getPosition.pageY;
      var _containerRef$current = containerRef.current.getBoundingClientRect(), rectX = _containerRef$current.x, rectY = _containerRef$current.y, width = _containerRef$current.width, height = _containerRef$current.height;
      var _targetRef$current$ge = targetRef.current.getBoundingClientRect(), targetWidth = _targetRef$current$ge.width, targetHeight = _targetRef$current$ge.height;
      var centerOffsetX = targetWidth / 2;
      var centerOffsetY = targetHeight / 2;
      var offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;
      var offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;
      var calcOffset3 = {
        x: offsetX,
        y: direction === "x" ? offsetValue.y : offsetY
      };
      if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {
        return false;
      }
      onDragChange === null || onDragChange === void 0 || onDragChange(calcOffset3);
    };
    var onDragMove = function onDragMove2(e3) {
      e3.preventDefault();
      updateOffset(e3);
    };
    var onDragStop = function onDragStop2(e3) {
      e3.preventDefault();
      document.removeEventListener("mousemove", mouseMoveRef.current);
      document.removeEventListener("mouseup", mouseUpRef.current);
      document.removeEventListener("touchmove", mouseMoveRef.current);
      document.removeEventListener("touchend", mouseUpRef.current);
      mouseMoveRef.current = null;
      mouseUpRef.current = null;
      onDragChangeComplete === null || onDragChangeComplete === void 0 || onDragChangeComplete();
    };
    var onDragStart = function onDragStart2(e3) {
      document.removeEventListener("mousemove", mouseMoveRef.current);
      document.removeEventListener("mouseup", mouseUpRef.current);
      if (disabledDrag) {
        return;
      }
      updateOffset(e3);
      document.addEventListener("mousemove", onDragMove);
      document.addEventListener("mouseup", onDragStop);
      document.addEventListener("touchmove", onDragMove);
      document.addEventListener("touchend", onDragStop);
      mouseMoveRef.current = onDragMove;
      mouseUpRef.current = onDragStop;
    };
    return [offsetValue, onDragStart];
  }
  var useColorDrag_default = useColorDrag;

  // node_modules/@rc-component/color-picker/es/components/Handler.js
  var import_classnames14 = __toESM(require_classnames());
  var import_react32 = __toESM(require_react());
  var Handler = function Handler2(_ref) {
    var _ref$size = _ref.size, size = _ref$size === void 0 ? "default" : _ref$size, color = _ref.color, prefixCls = _ref.prefixCls;
    return /* @__PURE__ */ import_react32.default.createElement("div", {
      className: (0, import_classnames14.default)("".concat(prefixCls, "-handler"), _defineProperty({}, "".concat(prefixCls, "-handler-sm"), size === "small")),
      style: {
        backgroundColor: color
      }
    });
  };
  var Handler_default = Handler;

  // node_modules/@rc-component/color-picker/es/components/Palette.js
  var import_react33 = __toESM(require_react());
  var Palette = function Palette2(_ref) {
    var children = _ref.children, style2 = _ref.style, prefixCls = _ref.prefixCls;
    return /* @__PURE__ */ import_react33.default.createElement("div", {
      className: "".concat(prefixCls, "-palette"),
      style: _objectSpread2({
        position: "relative"
      }, style2)
    }, children);
  };
  var Palette_default = Palette;

  // node_modules/@rc-component/color-picker/es/components/Transform.js
  var import_react34 = __toESM(require_react());
  var Transform = /* @__PURE__ */ (0, import_react34.forwardRef)(function(props, ref) {
    var children = props.children, x = props.x, y = props.y;
    return /* @__PURE__ */ import_react34.default.createElement("div", {
      ref,
      style: {
        position: "absolute",
        left: "".concat(x, "%"),
        top: "".concat(y, "%"),
        zIndex: 1,
        transform: "translate(-50%, -50%)"
      }
    }, children);
  });
  var Transform_default = Transform;

  // node_modules/@rc-component/color-picker/es/components/Picker.js
  var Picker = function Picker2(_ref) {
    var color = _ref.color, onChange = _ref.onChange, prefixCls = _ref.prefixCls, onChangeComplete = _ref.onChangeComplete, disabled = _ref.disabled;
    var pickerRef = (0, import_react35.useRef)();
    var transformRef = (0, import_react35.useRef)();
    var colorRef = (0, import_react35.useRef)(color);
    var onDragChange = useEvent(function(offsetValue) {
      var calcColor = calculateColor({
        offset: offsetValue,
        targetRef: transformRef,
        containerRef: pickerRef,
        color
      });
      colorRef.current = calcColor;
      onChange(calcColor);
    });
    var _useColorDrag = useColorDrag_default({
      color,
      containerRef: pickerRef,
      targetRef: transformRef,
      calculate: function calculate() {
        return calcOffset(color);
      },
      onDragChange,
      onDragChangeComplete: function onDragChangeComplete() {
        return onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(colorRef.current);
      },
      disabledDrag: disabled
    }), _useColorDrag2 = _slicedToArray(_useColorDrag, 2), offset3 = _useColorDrag2[0], dragStartHandle = _useColorDrag2[1];
    return /* @__PURE__ */ import_react35.default.createElement("div", {
      ref: pickerRef,
      className: "".concat(prefixCls, "-select"),
      onMouseDown: dragStartHandle,
      onTouchStart: dragStartHandle
    }, /* @__PURE__ */ import_react35.default.createElement(Palette_default, {
      prefixCls
    }, /* @__PURE__ */ import_react35.default.createElement(Transform_default, {
      x: offset3.x,
      y: offset3.y,
      ref: transformRef
    }, /* @__PURE__ */ import_react35.default.createElement(Handler_default, {
      color: color.toRgbString(),
      prefixCls
    })), /* @__PURE__ */ import_react35.default.createElement("div", {
      className: "".concat(prefixCls, "-saturation"),
      style: {
        backgroundColor: "hsl(".concat(color.toHsb().h, ",100%, 50%)"),
        backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
      }
    })));
  };
  var Picker_default = Picker;

  // node_modules/@rc-component/color-picker/es/hooks/useColorState.js
  var import_react36 = __toESM(require_react());
  var useColorState = function useColorState2(defaultValue, value) {
    var _useMergedState = useMergedState(defaultValue, {
      value
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setValue = _useMergedState2[1];
    var color = (0, import_react36.useMemo)(function() {
      return generateColor(mergedValue);
    }, [mergedValue]);
    return [color, setValue];
  };
  var useColorState_default = useColorState;

  // node_modules/@rc-component/color-picker/es/hooks/useComponent.js
  var React76 = __toESM(require_react());

  // node_modules/@rc-component/color-picker/es/components/Slider.js
  var import_react38 = __toESM(require_react());
  var import_classnames15 = __toESM(require_classnames());

  // node_modules/@rc-component/color-picker/es/components/Gradient.js
  var import_react37 = __toESM(require_react());
  var Gradient = function Gradient2(_ref) {
    var colors = _ref.colors, children = _ref.children, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "to right" : _ref$direction, type5 = _ref.type, prefixCls = _ref.prefixCls;
    var gradientColors = (0, import_react37.useMemo)(function() {
      return colors.map(function(color, idx) {
        var result = generateColor(color);
        if (type5 === "alpha" && idx === colors.length - 1) {
          result = new Color(result.setA(1));
        }
        return result.toRgbString();
      }).join(",");
    }, [colors, type5]);
    return /* @__PURE__ */ import_react37.default.createElement("div", {
      className: "".concat(prefixCls, "-gradient"),
      style: {
        position: "absolute",
        inset: 0,
        background: "linear-gradient(".concat(direction, ", ").concat(gradientColors, ")")
      }
    }, children);
  };
  var Gradient_default = Gradient;

  // node_modules/@rc-component/color-picker/es/components/Slider.js
  var Slider = function Slider2(props) {
    var prefixCls = props.prefixCls, colors = props.colors, disabled = props.disabled, onChange = props.onChange, onChangeComplete = props.onChangeComplete, color = props.color, type5 = props.type;
    var sliderRef = (0, import_react38.useRef)();
    var transformRef = (0, import_react38.useRef)();
    var colorRef = (0, import_react38.useRef)(color);
    var getValue3 = function getValue4(c) {
      return type5 === "hue" ? c.getHue() : c.a * 100;
    };
    var onDragChange = useEvent(function(offsetValue) {
      var calcColor = calculateColor({
        offset: offsetValue,
        targetRef: transformRef,
        containerRef: sliderRef,
        color,
        type: type5
      });
      colorRef.current = calcColor;
      onChange(getValue3(calcColor));
    });
    var _useColorDrag = useColorDrag_default({
      color,
      targetRef: transformRef,
      containerRef: sliderRef,
      calculate: function calculate() {
        return calcOffset(color, type5);
      },
      onDragChange,
      onDragChangeComplete: function onDragChangeComplete() {
        onChangeComplete(getValue3(colorRef.current));
      },
      direction: "x",
      disabledDrag: disabled
    }), _useColorDrag2 = _slicedToArray(_useColorDrag, 2), offset3 = _useColorDrag2[0], dragStartHandle = _useColorDrag2[1];
    var handleColor = import_react38.default.useMemo(function() {
      if (type5 === "hue") {
        var hsb = color.toHsb();
        hsb.s = 1;
        hsb.b = 1;
        hsb.a = 1;
        var lightColor = new Color(hsb);
        return lightColor;
      }
      return color;
    }, [color, type5]);
    var gradientList = import_react38.default.useMemo(function() {
      return colors.map(function(info) {
        return "".concat(info.color, " ").concat(info.percent, "%");
      });
    }, [colors]);
    return /* @__PURE__ */ import_react38.default.createElement("div", {
      ref: sliderRef,
      className: (0, import_classnames15.default)("".concat(prefixCls, "-slider"), "".concat(prefixCls, "-slider-").concat(type5)),
      onMouseDown: dragStartHandle,
      onTouchStart: dragStartHandle
    }, /* @__PURE__ */ import_react38.default.createElement(Palette_default, {
      prefixCls
    }, /* @__PURE__ */ import_react38.default.createElement(Transform_default, {
      x: offset3.x,
      y: offset3.y,
      ref: transformRef
    }, /* @__PURE__ */ import_react38.default.createElement(Handler_default, {
      size: "small",
      color: handleColor.toHexString(),
      prefixCls
    })), /* @__PURE__ */ import_react38.default.createElement(Gradient_default, {
      colors: gradientList,
      type: type5,
      prefixCls
    })));
  };
  var Slider_default = Slider;

  // node_modules/@rc-component/color-picker/es/hooks/useComponent.js
  function useComponent(components) {
    return React76.useMemo(function() {
      var _ref = components || {}, slider = _ref.slider;
      return [slider || Slider_default];
    }, [components]);
  }

  // node_modules/@rc-component/color-picker/es/ColorPicker.js
  var HUE_COLORS = [{
    color: "rgb(255, 0, 0)",
    percent: 0
  }, {
    color: "rgb(255, 255, 0)",
    percent: 17
  }, {
    color: "rgb(0, 255, 0)",
    percent: 33
  }, {
    color: "rgb(0, 255, 255)",
    percent: 50
  }, {
    color: "rgb(0, 0, 255)",
    percent: 67
  }, {
    color: "rgb(255, 0, 255)",
    percent: 83
  }, {
    color: "rgb(255, 0, 0)",
    percent: 100
  }];
  var ColorPicker = /* @__PURE__ */ (0, import_react39.forwardRef)(function(props, ref) {
    var value = props.value, defaultValue = props.defaultValue, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? ColorPickerPrefixCls : _props$prefixCls, onChange = props.onChange, onChangeComplete = props.onChangeComplete, className = props.className, style2 = props.style, panelRender = props.panelRender, _props$disabledAlpha = props.disabledAlpha, disabledAlpha = _props$disabledAlpha === void 0 ? false : _props$disabledAlpha, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, components = props.components;
    var _useComponent = useComponent(components), _useComponent2 = _slicedToArray(_useComponent, 1), Slider3 = _useComponent2[0];
    var _useColorState = useColorState_default(defaultValue || defaultColor, value), _useColorState2 = _slicedToArray(_useColorState, 2), colorValue = _useColorState2[0], setColorValue = _useColorState2[1];
    var alphaColor = (0, import_react39.useMemo)(function() {
      return colorValue.setA(1).toRgbString();
    }, [colorValue]);
    var handleChange = function handleChange2(data, type5) {
      if (!value) {
        setColorValue(data);
      }
      onChange === null || onChange === void 0 || onChange(data, type5);
    };
    var getHueColor = function getHueColor2(hue) {
      return new Color(colorValue.setHue(hue));
    };
    var getAlphaColor3 = function getAlphaColor4(alpha) {
      return new Color(colorValue.setA(alpha / 100));
    };
    var onHueChange = function onHueChange2(hue) {
      handleChange(getHueColor(hue), {
        type: "hue",
        value: hue
      });
    };
    var onAlphaChange = function onAlphaChange2(alpha) {
      handleChange(getAlphaColor3(alpha), {
        type: "alpha",
        value: alpha
      });
    };
    var onHueChangeComplete = function onHueChangeComplete2(hue) {
      if (onChangeComplete) {
        onChangeComplete(getHueColor(hue));
      }
    };
    var onAlphaChangeComplete = function onAlphaChangeComplete2(alpha) {
      if (onChangeComplete) {
        onChangeComplete(getAlphaColor3(alpha));
      }
    };
    var mergeCls = (0, import_classnames16.default)("".concat(prefixCls, "-panel"), className, _defineProperty({}, "".concat(prefixCls, "-panel-disabled"), disabled));
    var sharedSliderProps = {
      prefixCls,
      disabled,
      color: colorValue
    };
    var defaultPanel = /* @__PURE__ */ import_react39.default.createElement(import_react39.default.Fragment, null, /* @__PURE__ */ import_react39.default.createElement(Picker_default, _extends({
      onChange: handleChange
    }, sharedSliderProps, {
      onChangeComplete
    })), /* @__PURE__ */ import_react39.default.createElement("div", {
      className: "".concat(prefixCls, "-slider-container")
    }, /* @__PURE__ */ import_react39.default.createElement("div", {
      className: (0, import_classnames16.default)("".concat(prefixCls, "-slider-group"), _defineProperty({}, "".concat(prefixCls, "-slider-group-disabled-alpha"), disabledAlpha))
    }, /* @__PURE__ */ import_react39.default.createElement(Slider3, _extends({}, sharedSliderProps, {
      type: "hue",
      colors: HUE_COLORS,
      min: 0,
      max: 359,
      value: colorValue.getHue(),
      onChange: onHueChange,
      onChangeComplete: onHueChangeComplete
    })), !disabledAlpha && /* @__PURE__ */ import_react39.default.createElement(Slider3, _extends({}, sharedSliderProps, {
      type: "alpha",
      colors: [{
        percent: 0,
        color: "rgba(255, 0, 4, 0)"
      }, {
        percent: 100,
        color: alphaColor
      }],
      min: 0,
      max: 100,
      value: colorValue.a * 100,
      onChange: onAlphaChange,
      onChangeComplete: onAlphaChangeComplete
    }))), /* @__PURE__ */ import_react39.default.createElement(ColorBlock_default, {
      color: colorValue.toRgbString(),
      prefixCls
    })));
    return /* @__PURE__ */ import_react39.default.createElement("div", {
      className: mergeCls,
      style: style2,
      ref
    }, typeof panelRender === "function" ? panelRender(defaultPanel) : defaultPanel);
  });
  if (true) {
    ColorPicker.displayName = "ColorPicker";
  }

  // node_modules/antd/es/color-picker/color.js
  var toHexFormat = (value, alpha) => (value === null || value === void 0 ? void 0 : value.replace(/[^\w/]/g, "").slice(0, alpha ? 8 : 6)) || "";
  var getHex = (value, alpha) => value ? toHexFormat(value, alpha) : "";
  var AggregationColor = /* @__PURE__ */ function() {
    function AggregationColor2(color) {
      _classCallCheck(this, AggregationColor2);
      var _a;
      this.cleared = false;
      if (color instanceof AggregationColor2) {
        this.metaColor = color.metaColor.clone();
        this.colors = (_a = color.colors) === null || _a === void 0 ? void 0 : _a.map((info) => ({
          color: new AggregationColor2(info.color),
          percent: info.percent
        }));
        this.cleared = color.cleared;
        return;
      }
      const isArray2 = Array.isArray(color);
      if (isArray2 && color.length) {
        this.colors = color.map(({
          color: c,
          percent
        }) => ({
          color: new AggregationColor2(c),
          percent
        }));
        this.metaColor = new Color(this.colors[0].color.metaColor);
      } else {
        this.metaColor = new Color(isArray2 ? "" : color);
      }
      if (!color || isArray2 && !this.colors) {
        this.metaColor = this.metaColor.setA(0);
        this.cleared = true;
      }
    }
    return _createClass(AggregationColor2, [{
      key: "toHsb",
      value: function toHsb() {
        return this.metaColor.toHsb();
      }
    }, {
      key: "toHsbString",
      value: function toHsbString() {
        return this.metaColor.toHsbString();
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return getHex(this.toHexString(), this.metaColor.a < 1);
      }
    }, {
      key: "toHexString",
      value: function toHexString() {
        return this.metaColor.toHexString();
      }
    }, {
      key: "toRgb",
      value: function toRgb() {
        return this.metaColor.toRgb();
      }
    }, {
      key: "toRgbString",
      value: function toRgbString() {
        return this.metaColor.toRgbString();
      }
    }, {
      key: "isGradient",
      value: function isGradient() {
        return !!this.colors && !this.cleared;
      }
    }, {
      key: "getColors",
      value: function getColors() {
        return this.colors || [{
          color: this,
          percent: 0
        }];
      }
    }, {
      key: "toCssString",
      value: function toCssString() {
        const {
          colors
        } = this;
        if (colors) {
          const colorsStr = colors.map((c) => `${c.color.toRgbString()} ${c.percent}%`).join(", ");
          return `linear-gradient(90deg, ${colorsStr})`;
        }
        return this.metaColor.toRgbString();
      }
    }, {
      key: "equals",
      value: function equals(color) {
        if (!color || this.isGradient() !== color.isGradient()) {
          return false;
        }
        if (!this.isGradient()) {
          return this.toHexString() === color.toHexString();
        }
        return this.colors.length === color.colors.length && this.colors.every((c, i) => {
          const target = color.colors[i];
          return c.percent === target.percent && c.color.equals(target.color);
        });
      }
    }]);
  }();

  // node_modules/antd/es/color-picker/components/ColorPresets.js
  var import_react40 = __toESM(require_react());
  var import_classnames17 = __toESM(require_classnames());

  // node_modules/@ant-design/icons/es/icons/RightOutlined.js
  var React78 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/RightOutlined.js
  var RightOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
  var RightOutlined_default = RightOutlined;

  // node_modules/@ant-design/icons/es/icons/RightOutlined.js
  var RightOutlined2 = function RightOutlined3(props, ref) {
    return /* @__PURE__ */ React78.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: RightOutlined_default
    }));
  };
  var RefIcon7 = /* @__PURE__ */ React78.forwardRef(RightOutlined2);
  if (true) {
    RefIcon7.displayName = "RightOutlined";
  }
  var RightOutlined_default2 = RefIcon7;

  // node_modules/antd/es/style/motion/collapse.js
  var genCollapseMotion = (token2) => ({
    [token2.componentCls]: {
      // For common/openAnimation
      [`${token2.antCls}-motion-collapse-legacy`]: {
        overflow: "hidden",
        "&-active": {
          transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
        }
      },
      [`${token2.antCls}-motion-collapse`]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    }
  });
  var collapse_default = genCollapseMotion;

  // node_modules/antd/es/style/motion/motion.js
  var initMotionCommon = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  var initMotionCommonLeave = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  var initMotion = (motionCls, inKeyframes, outKeyframes, duration, sameLevel = false) => {
    const sameLevelPrefix = sameLevel ? "&" : "";
    return {
      [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
        animationPlayState: "paused"
      }),
      [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
        animationPlayState: "paused"
      }),
      [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
        animationName: inKeyframes,
        animationPlayState: "running"
      },
      [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
        animationName: outKeyframes,
        animationPlayState: "running",
        pointerEvents: "none"
      }
    };
  };

  // node_modules/antd/es/style/motion/fade.js
  var fadeIn = new Keyframes_default("antFadeIn", {
    "0%": {
      opacity: 0
    },
    "100%": {
      opacity: 1
    }
  });
  var fadeOut = new Keyframes_default("antFadeOut", {
    "0%": {
      opacity: 1
    },
    "100%": {
      opacity: 0
    }
  });
  var initFadeMotion = (token2, sameLevel = false) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-fade`;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
      [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: "linear"
      },
      [`${sameLevelPrefix}${motionCls}-leave`]: {
        animationTimingFunction: "linear"
      }
    }];
  };

  // node_modules/antd/es/style/motion/move.js
  var moveDownIn = new Keyframes_default("antMoveDownIn", {
    "0%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  var moveDownOut = new Keyframes_default("antMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  var moveLeftIn = new Keyframes_default("antMoveLeftIn", {
    "0%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  var moveLeftOut = new Keyframes_default("antMoveLeftOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  var moveRightIn = new Keyframes_default("antMoveRightIn", {
    "0%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  var moveRightOut = new Keyframes_default("antMoveRightOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  var moveUpIn = new Keyframes_default("antMoveUpIn", {
    "0%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  var moveUpOut = new Keyframes_default("antMoveUpOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  var moveMotion = {
    "move-up": {
      inKeyframes: moveUpIn,
      outKeyframes: moveUpOut
    },
    "move-down": {
      inKeyframes: moveDownIn,
      outKeyframes: moveDownOut
    },
    "move-left": {
      inKeyframes: moveLeftIn,
      outKeyframes: moveLeftOut
    },
    "move-right": {
      inKeyframes: moveRightIn,
      outKeyframes: moveRightOut
    }
  };
  var initMoveMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = moveMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };

  // node_modules/antd/es/style/motion/slide.js
  var slideUpIn = new Keyframes_default("antSlideUpIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  var slideUpOut = new Keyframes_default("antSlideUpOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  var slideDownIn = new Keyframes_default("antSlideDownIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    }
  });
  var slideDownOut = new Keyframes_default("antSlideDownOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    }
  });
  var slideLeftIn = new Keyframes_default("antSlideLeftIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  var slideLeftOut = new Keyframes_default("antSlideLeftOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  var slideRightIn = new Keyframes_default("antSlideRightIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    }
  });
  var slideRightOut = new Keyframes_default("antSlideRightOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    }
  });
  var slideMotion = {
    "slide-up": {
      inKeyframes: slideUpIn,
      outKeyframes: slideUpOut
    },
    "slide-down": {
      inKeyframes: slideDownIn,
      outKeyframes: slideDownOut
    },
    "slide-left": {
      inKeyframes: slideLeftIn,
      outKeyframes: slideLeftOut
    },
    "slide-right": {
      inKeyframes: slideRightIn,
      outKeyframes: slideRightOut
    }
  };
  var initSlideMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = slideMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
        transform: "scale(0)",
        transformOrigin: "0% 0%",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutQuint,
        "&-prepare": {
          transform: "scale(1)"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInQuint
      }
    }];
  };

  // node_modules/antd/es/style/motion/zoom.js
  var zoomIn = new Keyframes_default("antZoomIn", {
    "0%": {
      transform: "scale(0.2)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  var zoomOut = new Keyframes_default("antZoomOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.2)",
      opacity: 0
    }
  });
  var zoomBigIn = new Keyframes_default("antZoomBigIn", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  var zoomBigOut = new Keyframes_default("antZoomBigOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.8)",
      opacity: 0
    }
  });
  var zoomUpIn = new Keyframes_default("antZoomUpIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    }
  });
  var zoomUpOut = new Keyframes_default("antZoomUpOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    }
  });
  var zoomLeftIn = new Keyframes_default("antZoomLeftIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    }
  });
  var zoomLeftOut = new Keyframes_default("antZoomLeftOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    }
  });
  var zoomRightIn = new Keyframes_default("antZoomRightIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    }
  });
  var zoomRightOut = new Keyframes_default("antZoomRightOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    }
  });
  var zoomDownIn = new Keyframes_default("antZoomDownIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    }
  });
  var zoomDownOut = new Keyframes_default("antZoomDownOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    }
  });
  var zoomMotion = {
    zoom: {
      inKeyframes: zoomIn,
      outKeyframes: zoomOut
    },
    "zoom-big": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-big-fast": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-left": {
      inKeyframes: zoomLeftIn,
      outKeyframes: zoomLeftOut
    },
    "zoom-right": {
      inKeyframes: zoomRightIn,
      outKeyframes: zoomRightOut
    },
    "zoom-up": {
      inKeyframes: zoomUpIn,
      outKeyframes: zoomUpOut
    },
    "zoom-down": {
      inKeyframes: zoomDownIn,
      outKeyframes: zoomDownOut
    }
  };
  var initZoomMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = zoomMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        transform: "scale(0)",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc,
        "&-prepare": {
          transform: "none"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };

  // node_modules/antd/es/color-picker/components/ColorPresets.js
  var isBright = (value, bgColorToken) => {
    const {
      r: r2,
      g,
      b,
      a
    } = value.toRgb();
    const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
    if (a <= 0.5) {
      return hsv.v > 0.5;
    }
    return r2 * 0.299 + g * 0.587 + b * 0.114 > 192;
  };

  // node_modules/antd/es/button/style/token.js
  var prepareToken = (token2) => {
    const {
      paddingInline,
      onlyIconSize
    } = token2;
    const buttonToken = merge2(token2, {
      buttonPaddingHorizontal: paddingInline,
      buttonPaddingVertical: 0,
      buttonIconOnlyFontSize: onlyIconSize
    });
    return buttonToken;
  };
  var prepareComponentToken2 = (token2) => {
    var _a, _b, _c, _d, _e, _f;
    const contentFontSize = (_a = token2.contentFontSize) !== null && _a !== void 0 ? _a : token2.fontSize;
    const contentFontSizeSM = (_b = token2.contentFontSizeSM) !== null && _b !== void 0 ? _b : token2.fontSize;
    const contentFontSizeLG = (_c = token2.contentFontSizeLG) !== null && _c !== void 0 ? _c : token2.fontSizeLG;
    const contentLineHeight = (_d = token2.contentLineHeight) !== null && _d !== void 0 ? _d : getLineHeight(contentFontSize);
    const contentLineHeightSM = (_e = token2.contentLineHeightSM) !== null && _e !== void 0 ? _e : getLineHeight(contentFontSizeSM);
    const contentLineHeightLG = (_f = token2.contentLineHeightLG) !== null && _f !== void 0 ? _f : getLineHeight(contentFontSizeLG);
    const solidTextColor = isBright(new AggregationColor(token2.colorBgSolid), "#fff") ? "#000" : "#fff";
    const shadowColorTokens = PresetColors.reduce((prev2, colorKey) => Object.assign(Object.assign({}, prev2), {
      [`${colorKey}ShadowColor`]: `0 ${unit(token2.controlOutlineWidth)} 0 ${getAlphaColor_default(token2[`${colorKey}1`], token2.colorBgContainer)}`
    }), {});
    return Object.assign(Object.assign({}, shadowColorTokens), {
      fontWeight: 400,
      defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
      primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
      dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
      primaryColor: token2.colorTextLightSolid,
      dangerColor: token2.colorTextLightSolid,
      borderColorDisabled: token2.colorBorder,
      defaultGhostColor: token2.colorBgContainer,
      ghostBg: "transparent",
      defaultGhostBorderColor: token2.colorBgContainer,
      paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
      paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
      paddingInlineSM: 8 - token2.lineWidth,
      onlyIconSize: "inherit",
      onlyIconSizeSM: "inherit",
      onlyIconSizeLG: "inherit",
      groupBorderColor: token2.colorPrimaryHover,
      linkHoverBg: "transparent",
      textTextColor: token2.colorText,
      textTextHoverColor: token2.colorText,
      textTextActiveColor: token2.colorText,
      textHoverBg: token2.colorFillTertiary,
      defaultColor: token2.colorText,
      defaultBg: token2.colorBgContainer,
      defaultBorderColor: token2.colorBorder,
      defaultBorderColorDisabled: token2.colorBorder,
      defaultHoverBg: token2.colorBgContainer,
      defaultHoverColor: token2.colorPrimaryHover,
      defaultHoverBorderColor: token2.colorPrimaryHover,
      defaultActiveBg: token2.colorBgContainer,
      defaultActiveColor: token2.colorPrimaryActive,
      defaultActiveBorderColor: token2.colorPrimaryActive,
      solidTextColor,
      contentFontSize,
      contentFontSizeSM,
      contentFontSizeLG,
      contentLineHeight,
      contentLineHeightSM,
      contentLineHeightLG,
      paddingBlock: Math.max((token2.controlHeight - contentFontSize * contentLineHeight) / 2 - token2.lineWidth, 0),
      paddingBlockSM: Math.max((token2.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token2.lineWidth, 0),
      paddingBlockLG: Math.max((token2.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token2.lineWidth, 0)
    });
  };

  // node_modules/antd/es/button/style/index.js
  var genSharedButtonStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      fontWeight,
      opacityLoading,
      motionDurationSlow,
      motionEaseInOut,
      marginXS,
      calc
    } = token2;
    return {
      [componentCls]: {
        outline: "none",
        position: "relative",
        display: "inline-flex",
        gap: token2.marginXS,
        alignItems: "center",
        justifyContent: "center",
        fontWeight,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        background: "transparent",
        border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        color: token2.colorText,
        "&:disabled > *": {
          pointerEvents: "none"
        },
        // https://github.com/ant-design/ant-design/issues/51380
        [`${componentCls}-icon > svg`]: resetIcon(),
        "> a": {
          color: "currentColor"
        },
        "&:not(:disabled)": genFocusStyle(token2),
        [`&${componentCls}-two-chinese-chars::first-letter`]: {
          letterSpacing: "0.34em"
        },
        [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
          marginInlineEnd: "-0.34em",
          letterSpacing: "0.34em"
        },
        [`&${componentCls}-icon-only`]: {
          paddingInline: 0,
          // make `btn-icon-only` not too narrow
          [`&${componentCls}-compact-item`]: {
            flex: "none"
          },
          [`&${componentCls}-round`]: {
            width: "auto"
          }
        },
        // Loading
        [`&${componentCls}-loading`]: {
          opacity: opacityLoading,
          cursor: "default"
        },
        [`${componentCls}-loading-icon`]: {
          transition: ["width", "opacity", "margin"].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
        },
        // iconPosition
        [`&:not(${componentCls}-icon-end)`]: {
          [`${componentCls}-loading-icon-motion`]: {
            "&-appear-start, &-enter-start": {
              marginInlineEnd: calc(marginXS).mul(-1).equal()
            },
            "&-appear-active, &-enter-active": {
              marginInlineEnd: 0
            },
            "&-leave-start": {
              marginInlineEnd: 0
            },
            "&-leave-active": {
              marginInlineEnd: calc(marginXS).mul(-1).equal()
            }
          }
        },
        "&-icon-end": {
          flexDirection: "row-reverse",
          [`${componentCls}-loading-icon-motion`]: {
            "&-appear-start, &-enter-start": {
              marginInlineStart: calc(marginXS).mul(-1).equal()
            },
            "&-appear-active, &-enter-active": {
              marginInlineStart: 0
            },
            "&-leave-start": {
              marginInlineStart: 0
            },
            "&-leave-active": {
              marginInlineStart: calc(marginXS).mul(-1).equal()
            }
          }
        }
      }
    };
  };
  var genHoverActiveButtonStyle = (btnCls, hoverStyle, activeStyle) => ({
    [`&:not(:disabled):not(${btnCls}-disabled)`]: {
      "&:hover": hoverStyle,
      "&:active": activeStyle
    }
  });
  var genCircleButtonStyle = (token2) => ({
    minWidth: token2.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: "50%"
  });
  var genRoundButtonStyle = (token2) => ({
    borderRadius: token2.controlHeight,
    paddingInlineStart: token2.calc(token2.controlHeight).div(2).equal(),
    paddingInlineEnd: token2.calc(token2.controlHeight).div(2).equal()
  });
  var genDisabledStyle = (token2) => ({
    cursor: "not-allowed",
    borderColor: token2.borderColorDisabled,
    color: token2.colorTextDisabled,
    background: token2.colorBgContainerDisabled,
    boxShadow: "none"
  });
  var genGhostButtonStyle = (btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
    [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
      color: textColor || void 0,
      background,
      borderColor: borderColor || void 0,
      boxShadow: "none"
    }, genHoverActiveButtonStyle(btnCls, Object.assign({
      background
    }, hoverStyle), Object.assign({
      background
    }, activeStyle))), {
      "&:disabled": {
        cursor: "not-allowed",
        color: textColorDisabled || void 0,
        borderColor: borderColorDisabled || void 0
      }
    })
  });
  var genSolidDisabledButtonStyle = (token2) => ({
    [`&:disabled, &${token2.componentCls}-disabled`]: Object.assign({}, genDisabledStyle(token2))
  });
  var genPureDisabledButtonStyle = (token2) => ({
    [`&:disabled, &${token2.componentCls}-disabled`]: {
      cursor: "not-allowed",
      color: token2.colorTextDisabled
    }
  });
  var genVariantButtonStyle = (token2, hoverStyle, activeStyle, variant) => {
    const isPureDisabled = variant && ["link", "text"].includes(variant);
    const genDisabledButtonStyle = isPureDisabled ? genPureDisabledButtonStyle : genSolidDisabledButtonStyle;
    return Object.assign(Object.assign({}, genDisabledButtonStyle(token2)), genHoverActiveButtonStyle(token2.componentCls, hoverStyle, activeStyle));
  };
  var genSolidButtonStyle = (token2, textColor, background, hoverStyle, activeStyle) => ({
    [`&${token2.componentCls}-variant-solid`]: Object.assign({
      color: textColor,
      background
    }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
  });
  var genOutlinedDashedButtonStyle = (token2, borderColor, background, hoverStyle, activeStyle) => ({
    [`&${token2.componentCls}-variant-outlined, &${token2.componentCls}-variant-dashed`]: Object.assign({
      borderColor,
      background
    }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
  });
  var genDashedButtonStyle = (token2) => ({
    [`&${token2.componentCls}-variant-dashed`]: {
      borderStyle: "dashed"
    }
  });
  var genFilledButtonStyle = (token2, background, hoverStyle, activeStyle) => ({
    [`&${token2.componentCls}-variant-filled`]: Object.assign({
      boxShadow: "none",
      background
    }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
  });
  var genTextLinkButtonStyle = (token2, textColor, variant, hoverStyle, activeStyle) => ({
    [`&${token2.componentCls}-variant-${variant}`]: Object.assign({
      color: textColor,
      boxShadow: "none"
    }, genVariantButtonStyle(token2, hoverStyle, activeStyle, variant))
  });
  var genPresetColorStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return PresetColors.reduce((prev2, colorKey) => {
      const darkColor = token2[`${colorKey}6`];
      const lightColor = token2[`${colorKey}1`];
      const hoverColor = token2[`${colorKey}5`];
      const lightHoverColor = token2[`${colorKey}2`];
      const lightBorderColor = token2[`${colorKey}3`];
      const activeColor = token2[`${colorKey}7`];
      return Object.assign(Object.assign({}, prev2), {
        [`&${componentCls}-color-${colorKey}`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
          color: darkColor,
          boxShadow: token2[`${colorKey}ShadowColor`]
        }, genSolidButtonStyle(token2, token2.colorTextLightSolid, darkColor, {
          background: hoverColor
        }, {
          background: activeColor
        })), genOutlinedDashedButtonStyle(token2, darkColor, token2.colorBgContainer, {
          color: hoverColor,
          borderColor: hoverColor,
          background: token2.colorBgContainer
        }, {
          color: activeColor,
          borderColor: activeColor,
          background: token2.colorBgContainer
        })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, lightColor, {
          background: lightHoverColor
        }, {
          background: lightBorderColor
        })), genTextLinkButtonStyle(token2, darkColor, "link", {
          color: hoverColor
        }, {
          color: activeColor
        })), genTextLinkButtonStyle(token2, darkColor, "text", {
          color: hoverColor,
          background: lightColor
        }, {
          color: activeColor,
          background: lightBorderColor
        }))
      });
    }, {});
  };
  var genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    color: token2.defaultColor,
    boxShadow: token2.defaultShadow
  }, genSolidButtonStyle(token2, token2.solidTextColor, token2.colorBgSolid, {
    color: token2.solidTextColor,
    background: token2.colorBgSolidHover
  }, {
    color: token2.solidTextColor,
    background: token2.colorBgSolidActive
  })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorFillTertiary, {
    background: token2.colorFillSecondary
  }, {
    background: token2.colorFill
  })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.defaultGhostColor, token2.defaultGhostBorderColor, token2.colorTextDisabled, token2.colorBorder)), genTextLinkButtonStyle(token2, token2.textTextColor, "link", {
    color: token2.colorLinkHover,
    background: token2.linkHoverBg
  }, {
    color: token2.colorLinkActive
  }));
  var genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    color: token2.colorPrimary,
    boxShadow: token2.primaryShadow
  }, genOutlinedDashedButtonStyle(token2, token2.colorPrimary, token2.colorBgContainer, {
    color: token2.colorPrimaryTextHover,
    borderColor: token2.colorPrimaryHover,
    background: token2.colorBgContainer
  }, {
    color: token2.colorPrimaryTextActive,
    borderColor: token2.colorPrimaryActive,
    background: token2.colorBgContainer
  })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorPrimaryBg, {
    background: token2.colorPrimaryBgHover
  }, {
    background: token2.colorPrimaryBorder
  })), genTextLinkButtonStyle(token2, token2.colorPrimaryText, "text", {
    color: token2.colorPrimaryTextHover,
    background: token2.colorPrimaryBg
  }, {
    color: token2.colorPrimaryTextActive,
    background: token2.colorPrimaryBorder
  })), genTextLinkButtonStyle(token2, token2.colorPrimaryText, "link", {
    color: token2.colorPrimaryTextHover,
    background: token2.linkHoverBg
  }, {
    color: token2.colorPrimaryTextActive
  })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  }));
  var genDangerousStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    color: token2.colorError,
    boxShadow: token2.dangerShadow
  }, genSolidButtonStyle(token2, token2.dangerColor, token2.colorError, {
    background: token2.colorErrorHover
  }, {
    background: token2.colorErrorActive
  })), genOutlinedDashedButtonStyle(token2, token2.colorError, token2.colorBgContainer, {
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorBorderHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorErrorBg, {
    background: token2.colorErrorBgFilledHover
  }, {
    background: token2.colorErrorBgActive
  })), genTextLinkButtonStyle(token2, token2.colorError, "text", {
    color: token2.colorErrorHover,
    background: token2.colorErrorBg
  }, {
    color: token2.colorErrorHover,
    background: token2.colorErrorBgActive
  })), genTextLinkButtonStyle(token2, token2.colorError, "link", {
    color: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive
  })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  }));
  var genLinkStyle2 = (token2) => Object.assign(Object.assign({}, genTextLinkButtonStyle(token2, token2.colorLink, "link", {
    color: token2.colorLinkHover
  }, {
    color: token2.colorLinkActive
  })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorInfo, token2.colorInfo, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorInfoHover,
    borderColor: token2.colorInfoHover
  }, {
    color: token2.colorInfoActive,
    borderColor: token2.colorInfoActive
  }));
  var genColorButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return Object.assign({
      [`${componentCls}-color-default`]: genDefaultButtonStyle(token2),
      [`${componentCls}-color-primary`]: genPrimaryButtonStyle(token2),
      [`${componentCls}-color-dangerous`]: genDangerousStyle(token2),
      [`${componentCls}-color-link`]: genLinkStyle2(token2)
    }, genPresetColorStyle(token2));
  };
  var genCompatibleButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedDashedButtonStyle(token2, token2.defaultBorderColor, token2.defaultBg, {
    color: token2.defaultHoverColor,
    borderColor: token2.defaultHoverBorderColor,
    background: token2.defaultHoverBg
  }, {
    color: token2.defaultActiveColor,
    borderColor: token2.defaultActiveBorderColor,
    background: token2.defaultActiveBg
  })), genTextLinkButtonStyle(token2, token2.textTextColor, "text", {
    color: token2.textTextHoverColor,
    background: token2.textHoverBg
  }, {
    color: token2.textTextActiveColor,
    background: token2.colorBgTextActive
  })), genSolidButtonStyle(token2, token2.primaryColor, token2.colorPrimary, {
    background: token2.colorPrimaryHover,
    color: token2.primaryColor
  }, {
    background: token2.colorPrimaryActive,
    color: token2.primaryColor
  })), genTextLinkButtonStyle(token2, token2.colorLink, "link", {
    color: token2.colorLinkHover,
    background: token2.linkHoverBg
  }, {
    color: token2.colorLinkActive
  }));
  var genButtonStyle = (token2, prefixCls = "") => {
    const {
      componentCls,
      controlHeight,
      fontSize,
      borderRadius,
      buttonPaddingHorizontal,
      iconCls,
      buttonPaddingVertical,
      buttonIconOnlyFontSize
    } = token2;
    return [
      {
        [prefixCls]: {
          fontSize,
          height: controlHeight,
          padding: `${unit(buttonPaddingVertical)} ${unit(buttonPaddingHorizontal)}`,
          borderRadius,
          [`&${componentCls}-icon-only`]: {
            width: controlHeight,
            [iconCls]: {
              fontSize: buttonIconOnlyFontSize
            }
          }
        }
      },
      // Shape - patch prefixCls again to override solid border radius style
      {
        [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token2)
      },
      {
        [`${componentCls}${componentCls}-round${prefixCls}`]: genRoundButtonStyle(token2)
      }
    ];
  };
  var genSizeBaseButtonStyle = (token2) => {
    const baseToken = merge2(token2, {
      fontSize: token2.contentFontSize
    });
    return genButtonStyle(baseToken, token2.componentCls);
  };
  var genSizeSmallButtonStyle = (token2) => {
    const smallToken = merge2(token2, {
      controlHeight: token2.controlHeightSM,
      fontSize: token2.contentFontSizeSM,
      padding: token2.paddingXS,
      buttonPaddingHorizontal: token2.paddingInlineSM,
      buttonPaddingVertical: 0,
      borderRadius: token2.borderRadiusSM,
      buttonIconOnlyFontSize: token2.onlyIconSizeSM
    });
    return genButtonStyle(smallToken, `${token2.componentCls}-sm`);
  };
  var genSizeLargeButtonStyle = (token2) => {
    const largeToken = merge2(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.contentFontSizeLG,
      buttonPaddingHorizontal: token2.paddingInlineLG,
      buttonPaddingVertical: 0,
      borderRadius: token2.borderRadiusLG,
      buttonIconOnlyFontSize: token2.onlyIconSizeLG
    });
    return genButtonStyle(largeToken, `${token2.componentCls}-lg`);
  };
  var genBlockButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        [`&${componentCls}-block`]: {
          width: "100%"
        }
      }
    };
  };
  var style_default4 = genStyleHooks("Button", (token2) => {
    const buttonToken = prepareToken(token2);
    return [
      // Shared
      genSharedButtonStyle(buttonToken),
      // Size
      genSizeBaseButtonStyle(buttonToken),
      genSizeSmallButtonStyle(buttonToken),
      genSizeLargeButtonStyle(buttonToken),
      // Block
      genBlockButtonStyle(buttonToken),
      // Color
      genColorButtonStyle(buttonToken),
      // https://github.com/ant-design/ant-design/issues/50969
      genCompatibleButtonStyle(buttonToken),
      // Button Group
      group_default(buttonToken)
    ];
  }, prepareComponentToken2, {
    unitless: {
      fontWeight: true,
      contentLineHeight: true,
      contentLineHeightSM: true,
      contentLineHeightLG: true
    }
  });

  // node_modules/antd/es/style/compact-item.js
  function compactItemBorder(token2, parentCls, options) {
    const {
      focusElCls,
      focus,
      borderElCls
    } = options;
    const childCombinator = borderElCls ? "> *" : "";
    const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
    return {
      [`&-item:not(${parentCls}-last-item)`]: {
        marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
      },
      "&-item": Object.assign(Object.assign({
        [hoverEffects]: {
          zIndex: 2
        }
      }, focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 2
        }
      } : {}), {
        [`&[disabled] ${childCombinator}`]: {
          zIndex: 0
        }
      })
    };
  }
  function compactItemBorderRadius(prefixCls, parentCls, options) {
    const {
      borderElCls
    } = options;
    const childCombinator = borderElCls ? `> ${borderElCls}` : "";
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
        borderRadius: 0
      },
      [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      }
    };
  }
  function genCompactItemStyle(token2, options = {
    focus: true
  }) {
    const {
      componentCls
    } = token2;
    const compactCls = `${componentCls}-compact`;
    return {
      [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
    };
  }

  // node_modules/antd/es/style/compact-item-vertical.js
  function compactItemVerticalBorder(token2, parentCls) {
    return {
      // border collapse
      [`&-item:not(${parentCls}-last-item)`]: {
        marginBottom: token2.calc(token2.lineWidth).mul(-1).equal()
      },
      "&-item": {
        "&:hover,&:focus,&:active": {
          zIndex: 2
        },
        "&[disabled]": {
          zIndex: 0
        }
      }
    };
  }
  function compactItemBorderVerticalRadius(prefixCls, parentCls) {
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
        borderRadius: 0
      },
      [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderEndEndRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0
        }
      }
    };
  }
  function genCompactItemVerticalStyle(token2) {
    const compactCls = `${token2.componentCls}-compact-vertical`;
    return {
      [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
    };
  }

  // node_modules/antd/es/button/style/compact.js
  var genButtonCompactStyle = (token2) => {
    const {
      componentCls,
      colorPrimaryHover,
      lineWidth,
      calc
    } = token2;
    const insetOffset = calc(lineWidth).mul(-1).equal();
    const getCompactBorderStyle = (vertical) => {
      const selector = `${componentCls}-compact${vertical ? "-vertical" : ""}-item${componentCls}-primary:not([disabled])`;
      return {
        [`${selector} + ${selector}::before`]: {
          position: "absolute",
          top: vertical ? insetOffset : 0,
          insetInlineStart: vertical ? 0 : insetOffset,
          backgroundColor: colorPrimaryHover,
          content: '""',
          width: vertical ? "100%" : lineWidth,
          height: vertical ? lineWidth : "100%"
        }
      };
    };
    return Object.assign(Object.assign({}, getCompactBorderStyle()), getCompactBorderStyle(true));
  };
  var compact_default2 = genSubStyleComponent(["Button", "compact"], (token2) => {
    const buttonToken = prepareToken(token2);
    return [
      // Space Compact
      genCompactItemStyle(buttonToken),
      genCompactItemVerticalStyle(buttonToken),
      genButtonCompactStyle(buttonToken)
    ];
  }, prepareComponentToken2);

  // node_modules/antd/es/button/button.js
  var __rest8 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function getLoadingConfig(loading) {
    if (typeof loading === "object" && loading) {
      let delay = loading === null || loading === void 0 ? void 0 : loading.delay;
      delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
      return {
        loading: delay <= 0,
        delay
      };
    }
    return {
      loading: !!loading,
      delay: 0
    };
  }
  var ButtonTypeMap = {
    default: ["default", "outlined"],
    primary: ["primary", "solid"],
    dashed: ["default", "dashed"],
    // `link` is not a real color but we should compatible with it
    link: ["link", "link"],
    text: ["default", "text"]
  };
  var InternalCompoundedButton = /* @__PURE__ */ import_react41.default.forwardRef((props, ref) => {
    var _a, _b;
    const {
      loading = false,
      prefixCls: customizePrefixCls,
      color,
      variant,
      type: type5,
      danger = false,
      shape = "default",
      size: customizeSize,
      styles,
      disabled: customDisabled,
      className,
      rootClassName,
      children,
      icon,
      iconPosition = "start",
      ghost = false,
      block = false,
      // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
      htmlType = "button",
      classNames: customClassNames,
      style: customStyle = {},
      autoInsertSpace,
      autoFocus
    } = props, rest = __rest8(props, ["loading", "prefixCls", "color", "variant", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace", "autoFocus"]);
    const mergedType = type5 || "default";
    const {
      button
    } = import_react41.default.useContext(ConfigContext);
    const [mergedColor, mergedVariant] = (0, import_react41.useMemo)(() => {
      if (color && variant) {
        return [color, variant];
      }
      if (type5 || danger) {
        const colorVariantPair = ButtonTypeMap[mergedType] || [];
        if (danger) {
          return ["danger", colorVariantPair[1]];
        }
        return colorVariantPair;
      }
      if ((button === null || button === void 0 ? void 0 : button.color) && (button === null || button === void 0 ? void 0 : button.variant)) {
        return [button.color, button.variant];
      }
      return ["default", "outlined"];
    }, [type5, color, variant, danger, button === null || button === void 0 ? void 0 : button.variant, button === null || button === void 0 ? void 0 : button.color]);
    const isDanger = mergedColor === "danger";
    const mergedColorText = isDanger ? "dangerous" : mergedColor;
    const {
      getPrefixCls,
      direction,
      autoInsertSpace: contextAutoInsertSpace,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("button");
    const mergedInsertSpace = (_a = autoInsertSpace !== null && autoInsertSpace !== void 0 ? autoInsertSpace : contextAutoInsertSpace) !== null && _a !== void 0 ? _a : true;
    const prefixCls = getPrefixCls("btn", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default4(prefixCls);
    const disabled = (0, import_react41.useContext)(DisabledContext_default);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const groupSize = (0, import_react41.useContext)(GroupSizeContext);
    const loadingOrDelay = (0, import_react41.useMemo)(() => getLoadingConfig(loading), [loading]);
    const [innerLoading, setLoading] = (0, import_react41.useState)(loadingOrDelay.loading);
    const [hasTwoCNChar, setHasTwoCNChar] = (0, import_react41.useState)(false);
    const buttonRef = (0, import_react41.useRef)(null);
    const mergedRef = useComposeRef(ref, buttonRef);
    const needInserted = import_react41.Children.count(children) === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
    const isMountRef = (0, import_react41.useRef)(true);
    import_react41.default.useEffect(() => {
      isMountRef.current = false;
      return () => {
        isMountRef.current = true;
      };
    }, []);
    (0, import_react41.useLayoutEffect)(() => {
      let delayTimer = null;
      if (loadingOrDelay.delay > 0) {
        delayTimer = setTimeout(() => {
          delayTimer = null;
          setLoading(true);
        }, loadingOrDelay.delay);
      } else {
        setLoading(loadingOrDelay.loading);
      }
      function cleanupTimer() {
        if (delayTimer) {
          clearTimeout(delayTimer);
          delayTimer = null;
        }
      }
      return cleanupTimer;
    }, [loadingOrDelay.delay, loadingOrDelay.loading]);
    (0, import_react41.useEffect)(() => {
      if (!buttonRef.current || !mergedInsertSpace) {
        return;
      }
      const buttonText = buttonRef.current.textContent || "";
      if (needInserted && isTwoCNChar(buttonText)) {
        if (!hasTwoCNChar) {
          setHasTwoCNChar(true);
        }
      } else if (hasTwoCNChar) {
        setHasTwoCNChar(false);
      }
    });
    (0, import_react41.useEffect)(() => {
      if (autoFocus && buttonRef.current) {
        buttonRef.current.focus();
      }
    }, []);
    const handleClick = import_react41.default.useCallback((e3) => {
      var _a2;
      if (innerLoading || mergedDisabled) {
        e3.preventDefault();
        return;
      }
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props, "href" in props ? e3 : e3);
    }, [props.onClick, innerLoading, mergedDisabled]);
    if (true) {
      const warning6 = devUseWarning("Button");
      true ? warning6(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
      true ? warning6(!(ghost && isUnBorderedButtonVariant(mergedVariant)), "usage", "`link` or `text` button can't be a `ghost` button.") : void 0;
    }
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const sizeClassNameMap = {
      large: "lg",
      small: "sm",
      middle: void 0
    };
    const sizeFullName = useSize_default((ctxSize) => {
      var _a2, _b2;
      return (_b2 = (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : groupSize) !== null && _b2 !== void 0 ? _b2 : ctxSize;
    });
    const sizeCls = sizeFullName ? (_b = sizeClassNameMap[sizeFullName]) !== null && _b !== void 0 ? _b : "" : "";
    const iconType = innerLoading ? "loading" : icon;
    const linkButtonRestProps = omit(rest, ["navigate"]);
    const classes = (0, import_classnames18.default)(prefixCls, hashId, cssVarCls, {
      [`${prefixCls}-${shape}`]: shape !== "default" && shape,
      // Compatible with versions earlier than 5.21.0
      [`${prefixCls}-${mergedType}`]: mergedType,
      [`${prefixCls}-dangerous`]: danger,
      [`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
      [`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
      [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
      [`${prefixCls}-loading`]: innerLoading,
      [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-icon-end`]: iconPosition === "end"
    }, compactItemClassnames, className, rootClassName, contextClassName);
    const fullStyle = Object.assign(Object.assign({}, contextStyle), customStyle);
    const iconClasses = (0, import_classnames18.default)(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, contextClassNames.icon);
    const iconStyle = Object.assign(Object.assign({}, (styles === null || styles === void 0 ? void 0 : styles.icon) || {}), contextStyles.icon || {});
    const iconNode = icon && !innerLoading ? /* @__PURE__ */ import_react41.default.createElement(IconWrapper_default, {
      prefixCls,
      className: iconClasses,
      style: iconStyle
    }, icon) : loading && typeof loading === "object" && loading.icon ? /* @__PURE__ */ import_react41.default.createElement(IconWrapper_default, {
      prefixCls,
      className: iconClasses,
      style: iconStyle
    }, loading.icon) : /* @__PURE__ */ import_react41.default.createElement(DefaultLoadingIcon_default, {
      existIcon: !!icon,
      prefixCls,
      loading: innerLoading,
      mount: isMountRef.current
    });
    const kids = children || children === 0 ? spaceChildren(children, needInserted && mergedInsertSpace) : null;
    if (linkButtonRestProps.href !== void 0) {
      return wrapCSSVar(/* @__PURE__ */ import_react41.default.createElement("a", Object.assign({}, linkButtonRestProps, {
        className: (0, import_classnames18.default)(classes, {
          [`${prefixCls}-disabled`]: mergedDisabled
        }),
        href: mergedDisabled ? void 0 : linkButtonRestProps.href,
        style: fullStyle,
        onClick: handleClick,
        ref: mergedRef,
        tabIndex: mergedDisabled ? -1 : 0
      }), iconNode, kids));
    }
    let buttonNode = /* @__PURE__ */ import_react41.default.createElement("button", Object.assign({}, rest, {
      type: htmlType,
      className: classes,
      style: fullStyle,
      onClick: handleClick,
      disabled: mergedDisabled,
      ref: mergedRef
    }), iconNode, kids, compactItemClassnames && /* @__PURE__ */ import_react41.default.createElement(compact_default2, {
      prefixCls
    }));
    if (!isUnBorderedButtonVariant(mergedVariant)) {
      buttonNode = /* @__PURE__ */ import_react41.default.createElement(wave_default, {
        component: "Button",
        disabled: innerLoading
      }, buttonNode);
    }
    return wrapCSSVar(buttonNode);
  });
  var Button = InternalCompoundedButton;
  Button.Group = button_group_default;
  Button.__ANT_BUTTON = true;
  if (true) {
    Button.displayName = "Button";
  }
  var button_default = Button;

  // node_modules/antd/es/button/index.js
  var button_default2 = button_default;

  // node_modules/antd/es/_util/ActionButton.js
  function isThenable(thing) {
    return !!(thing === null || thing === void 0 ? void 0 : thing.then);
  }
  var ActionButton = (props) => {
    const {
      type: type5,
      children,
      prefixCls,
      buttonProps,
      close,
      autoFocus,
      emitEvent,
      isSilent,
      quitOnNullishReturnValue,
      actionFn
    } = props;
    const clickedRef = React81.useRef(false);
    const buttonRef = React81.useRef(null);
    const [loading, setLoading] = useSafeState(false);
    const onInternalClose = (...args) => {
      close === null || close === void 0 ? void 0 : close.apply(void 0, args);
    };
    React81.useEffect(() => {
      let timeoutId = null;
      if (autoFocus) {
        timeoutId = setTimeout(() => {
          var _a;
          (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus({
            preventScroll: true
          });
        });
      }
      return () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      };
    }, []);
    const handlePromiseOnOk = (returnValueOfOnOk) => {
      if (!isThenable(returnValueOfOnOk)) {
        return;
      }
      setLoading(true);
      returnValueOfOnOk.then((...args) => {
        setLoading(false, true);
        onInternalClose.apply(void 0, args);
        clickedRef.current = false;
      }, (e3) => {
        setLoading(false, true);
        clickedRef.current = false;
        if (isSilent === null || isSilent === void 0 ? void 0 : isSilent()) {
          return;
        }
        return Promise.reject(e3);
      });
    };
    const onClick = (e3) => {
      if (clickedRef.current) {
        return;
      }
      clickedRef.current = true;
      if (!actionFn) {
        onInternalClose();
        return;
      }
      let returnValueOfOnOk;
      if (emitEvent) {
        returnValueOfOnOk = actionFn(e3);
        if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
          clickedRef.current = false;
          onInternalClose(e3);
          return;
        }
      } else if (actionFn.length) {
        returnValueOfOnOk = actionFn(close);
        clickedRef.current = false;
      } else {
        returnValueOfOnOk = actionFn();
        if (!isThenable(returnValueOfOnOk)) {
          onInternalClose();
          return;
        }
      }
      handlePromiseOnOk(returnValueOfOnOk);
    };
    return /* @__PURE__ */ React81.createElement(button_default2, Object.assign({}, convertLegacyProps(type5), {
      onClick,
      loading,
      prefixCls
    }, buttonProps, {
      ref: buttonRef
    }), children);
  };
  var ActionButton_default = ActionButton;

  // node_modules/antd/es/modal/context.js
  var import_react42 = __toESM(require_react());
  var ModalContext = /* @__PURE__ */ import_react42.default.createContext({});
  var {
    Provider: ModalContextProvider
  } = ModalContext;

  // node_modules/antd/es/modal/components/ConfirmCancelBtn.js
  var ConfirmCancelBtn = () => {
    const {
      autoFocusButton,
      cancelButtonProps,
      cancelTextLocale,
      isSilent,
      mergedOkCancel,
      rootPrefixCls,
      close,
      onCancel,
      onConfirm
    } = (0, import_react43.useContext)(ModalContext);
    return mergedOkCancel ? /* @__PURE__ */ import_react43.default.createElement(ActionButton_default, {
      isSilent,
      actionFn: onCancel,
      close: (...args) => {
        close === null || close === void 0 ? void 0 : close.apply(void 0, args);
        onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(false);
      },
      autoFocus: autoFocusButton === "cancel",
      buttonProps: cancelButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    }, cancelTextLocale) : null;
  };
  var ConfirmCancelBtn_default = ConfirmCancelBtn;

  // node_modules/antd/es/modal/components/ConfirmOkBtn.js
  var import_react44 = __toESM(require_react());
  var ConfirmOkBtn = () => {
    const {
      autoFocusButton,
      close,
      isSilent,
      okButtonProps,
      rootPrefixCls,
      okTextLocale,
      okType,
      onConfirm,
      onOk
    } = (0, import_react44.useContext)(ModalContext);
    return /* @__PURE__ */ import_react44.default.createElement(ActionButton_default, {
      isSilent,
      type: okType || "primary",
      actionFn: onOk,
      close: (...args) => {
        close === null || close === void 0 ? void 0 : close.apply(void 0, args);
        onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(true);
      },
      autoFocus: autoFocusButton === "ok",
      buttonProps: okButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    }, okTextLocale);
  };
  var ConfirmOkBtn_default = ConfirmOkBtn;

  // node_modules/antd/es/modal/Modal.js
  var React122 = __toESM(require_react());
  var import_classnames32 = __toESM(require_classnames());

  // node_modules/@rc-component/portal/es/Portal.js
  var React88 = __toESM(require_react());
  var import_react_dom3 = __toESM(require_react_dom());

  // node_modules/@rc-component/portal/es/Context.js
  var React85 = __toESM(require_react());
  var OrderContext = /* @__PURE__ */ React85.createContext(null);
  var Context_default2 = OrderContext;

  // node_modules/@rc-component/portal/es/useDom.js
  var React86 = __toESM(require_react());
  var EMPTY_LIST = [];
  function useDom(render4, debug) {
    var _React$useState = React86.useState(function() {
      if (!canUseDom()) {
        return null;
      }
      var defaultEle = document.createElement("div");
      if (debug) {
        defaultEle.setAttribute("data-debug", debug);
      }
      return defaultEle;
    }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
    var appendedRef = React86.useRef(false);
    var queueCreate = React86.useContext(Context_default2);
    var _React$useState3 = React86.useState(EMPTY_LIST), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
    var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
      setQueue(function(origin2) {
        var newQueue = [appendFn].concat(_toConsumableArray(origin2));
        return newQueue;
      });
    });
    function append3() {
      if (!ele.parentElement) {
        document.body.appendChild(ele);
      }
      appendedRef.current = true;
    }
    function cleanup2() {
      var _ele$parentElement;
      (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
      appendedRef.current = false;
    }
    useLayoutEffect_default(function() {
      if (render4) {
        if (queueCreate) {
          queueCreate(append3);
        } else {
          append3();
        }
      } else {
        cleanup2();
      }
      return cleanup2;
    }, [render4]);
    useLayoutEffect_default(function() {
      if (queue.length) {
        queue.forEach(function(appendFn) {
          return appendFn();
        });
        setQueue(EMPTY_LIST);
      }
    }, [queue]);
    return [ele, mergedQueueCreate];
  }

  // node_modules/@rc-component/portal/es/useScrollLocker.js
  var React87 = __toESM(require_react());

  // node_modules/rc-util/es/getScrollBarSize.js
  var cached;
  function measureScrollbarSize(ele) {
    var randomId = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7));
    var measureEle = document.createElement("div");
    measureEle.id = randomId;
    var measureStyle = measureEle.style;
    measureStyle.position = "absolute";
    measureStyle.left = "0";
    measureStyle.top = "0";
    measureStyle.width = "100px";
    measureStyle.height = "100px";
    measureStyle.overflow = "scroll";
    var fallbackWidth;
    var fallbackHeight;
    if (ele) {
      var targetStyle = getComputedStyle(ele);
      measureStyle.scrollbarColor = targetStyle.scrollbarColor;
      measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
      var webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
      var width = parseInt(webkitScrollbarStyle.width, 10);
      var height = parseInt(webkitScrollbarStyle.height, 10);
      try {
        var widthStyle = width ? "width: ".concat(webkitScrollbarStyle.width, ";") : "";
        var heightStyle = height ? "height: ".concat(webkitScrollbarStyle.height, ";") : "";
        updateCSS("\n#".concat(randomId, "::-webkit-scrollbar {\n").concat(widthStyle, "\n").concat(heightStyle, "\n}"), randomId);
      } catch (e3) {
        console.error(e3);
        fallbackWidth = width;
        fallbackHeight = height;
      }
    }
    document.body.appendChild(measureEle);
    var scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
    var scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
    document.body.removeChild(measureEle);
    removeCSS(randomId);
    return {
      width: scrollWidth,
      height: scrollHeight
    };
  }
  function getScrollBarSize(fresh) {
    if (typeof document === "undefined") {
      return 0;
    }
    if (fresh || cached === void 0) {
      cached = measureScrollbarSize();
    }
    return cached.width;
  }
  function getTargetScrollBarSize(target) {
    if (typeof document === "undefined" || !target || !(target instanceof Element)) {
      return {
        width: 0,
        height: 0
      };
    }
    return measureScrollbarSize(target);
  }

  // node_modules/@rc-component/portal/es/util.js
  function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
  }

  // node_modules/@rc-component/portal/es/useScrollLocker.js
  var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
  var uuid2 = 0;
  function useScrollLocker(lock) {
    var mergedLock = !!lock;
    var _React$useState = React87.useState(function() {
      uuid2 += 1;
      return "".concat(UNIQUE_ID, "_").concat(uuid2);
    }), _React$useState2 = _slicedToArray(_React$useState, 1), id = _React$useState2[0];
    useLayoutEffect_default(function() {
      if (mergedLock) {
        var scrollbarSize = getTargetScrollBarSize(document.body).width;
        var isOverflow = isBodyOverflowing();
        updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
      } else {
        removeCSS(id);
      }
      return function() {
        removeCSS(id);
      };
    }, [mergedLock, id]);
  }

  // node_modules/@rc-component/portal/es/mock.js
  var inline = false;
  function inlineMock(nextInline) {
    if (typeof nextInline === "boolean") {
      inline = nextInline;
    }
    return inline;
  }

  // node_modules/@rc-component/portal/es/Portal.js
  var getPortalContainer = function getPortalContainer2(getContainer2) {
    if (getContainer2 === false) {
      return false;
    }
    if (!canUseDom() || !getContainer2) {
      return null;
    }
    if (typeof getContainer2 === "string") {
      return document.querySelector(getContainer2);
    }
    if (typeof getContainer2 === "function") {
      return getContainer2();
    }
    return getContainer2;
  };
  var Portal = /* @__PURE__ */ React88.forwardRef(function(props, ref) {
    var open2 = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer, debug = props.debug, _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
    var _React$useState = React88.useState(open2), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
    var mergedRender = shouldRender || open2;
    if (true) {
      warning_default(canUseDom() || !open2, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.");
    }
    React88.useEffect(function() {
      if (autoDestroy || open2) {
        setShouldRender(open2);
      }
    }, [open2, autoDestroy]);
    var _React$useState3 = React88.useState(function() {
      return getPortalContainer(getContainer2);
    }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
    React88.useEffect(function() {
      var customizeContainer = getPortalContainer(getContainer2);
      setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
    });
    var _useDom = useDom(mergedRender && !innerContainer, debug), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer2 = _useDom2[0], queueCreate = _useDom2[1];
    var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer2;
    useScrollLocker(autoLock && open2 && canUseDom() && (mergedContainer === defaultContainer2 || mergedContainer === document.body));
    var childRef = null;
    if (children && supportRef(children) && ref) {
      var _ref = children;
      childRef = _ref.ref;
    }
    var mergedRef = useComposeRef(childRef, ref);
    if (!mergedRender || !canUseDom() || innerContainer === void 0) {
      return null;
    }
    var renderInline = mergedContainer === false || inlineMock();
    var reffedChildren = children;
    if (ref) {
      reffedChildren = /* @__PURE__ */ React88.cloneElement(children, {
        ref: mergedRef
      });
    }
    return /* @__PURE__ */ React88.createElement(Context_default2.Provider, {
      value: queueCreate
    }, renderInline ? reffedChildren : /* @__PURE__ */ (0, import_react_dom3.createPortal)(reffedChildren, mergedContainer));
  });
  if (true) {
    Portal.displayName = "Portal";
  }
  var Portal_default = Portal;

  // node_modules/@rc-component/portal/es/index.js
  var es_default3 = Portal_default;

  // node_modules/rc-dialog/es/DialogWrap.js
  var React96 = __toESM(require_react());

  // node_modules/rc-dialog/es/context.js
  var React89 = __toESM(require_react());
  var RefContext = /* @__PURE__ */ React89.createContext({});

  // node_modules/rc-dialog/es/Dialog/index.js
  var import_classnames22 = __toESM(require_classnames());

  // node_modules/rc-util/es/hooks/useId.js
  var React90 = __toESM(require_react());
  function getUseId() {
    var fullClone5 = _objectSpread2({}, React90);
    return fullClone5.useId;
  }
  var uuid3 = 0;
  var useOriginId = getUseId();
  var useId_default = useOriginId ? (
    // Use React `useId`
    function useId2(id) {
      var reactId = useOriginId();
      if (id) {
        return id;
      }
      if (false) {
        return "test-id";
      }
      return reactId;
    }
  ) : (
    // Use compatible of `useId`
    function useCompatId(id) {
      var _React$useState = React90.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      React90.useEffect(function() {
        var nextId = uuid3;
        uuid3 += 1;
        setInnerId("rc_unique_".concat(nextId));
      }, []);
      if (id) {
        return id;
      }
      if (false) {
        return "test-id";
      }
      return innerId;
    }
  );

  // node_modules/rc-dialog/es/Dialog/index.js
  var React95 = __toESM(require_react());
  var import_react47 = __toESM(require_react());

  // node_modules/rc-dialog/es/util.js
  function getMotionName(prefixCls, transitionName, animationName) {
    var motionName = transitionName;
    if (!motionName && animationName) {
      motionName = "".concat(prefixCls, "-").concat(animationName);
    }
    return motionName;
  }
  function getScroll2(w, top) {
    var ret = w["page".concat(top ? "Y" : "X", "Offset")];
    var method4 = "scroll".concat(top ? "Top" : "Left");
    if (typeof ret !== "number") {
      var d = w.document;
      ret = d.documentElement[method4];
      if (typeof ret !== "number") {
        ret = d.body[method4];
      }
    }
    return ret;
  }
  function offset(el) {
    var rect = el.getBoundingClientRect();
    var pos = {
      left: rect.left,
      top: rect.top
    };
    var doc = el.ownerDocument;
    var w = doc.defaultView || doc.parentWindow;
    pos.left += getScroll2(w);
    pos.top += getScroll2(w, true);
    return pos;
  }

  // node_modules/rc-dialog/es/Dialog/Content/index.js
  var React93 = __toESM(require_react());
  var import_react46 = __toESM(require_react());
  var import_classnames20 = __toESM(require_classnames());

  // node_modules/rc-dialog/es/Dialog/Content/Panel.js
  var import_classnames19 = __toESM(require_classnames());
  var import_react45 = __toESM(require_react());

  // node_modules/rc-dialog/es/Dialog/Content/MemoChildren.js
  var React91 = __toESM(require_react());
  var MemoChildren_default = /* @__PURE__ */ React91.memo(function(_ref) {
    var children = _ref.children;
    return children;
  }, function(_, _ref2) {
    var shouldUpdate = _ref2.shouldUpdate;
    return !shouldUpdate;
  });

  // node_modules/rc-dialog/es/Dialog/Content/Panel.js
  var sentinelStyle = {
    width: 0,
    height: 0,
    overflow: "hidden",
    outline: "none"
  };
  var entityStyle = {
    outline: "none"
  };
  var Panel = /* @__PURE__ */ import_react45.default.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height, modalClassNames = props.classNames, modalStyles = props.styles;
    var _React$useContext = import_react45.default.useContext(RefContext), panelRef = _React$useContext.panel;
    var mergedRef = useComposeRef(holderRef, panelRef);
    var sentinelStartRef = (0, import_react45.useRef)();
    var sentinelEndRef = (0, import_react45.useRef)();
    import_react45.default.useImperativeHandle(ref, function() {
      return {
        focus: function focus() {
          var _sentinelStartRef$cur;
          (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 || _sentinelStartRef$cur.focus({
            preventScroll: true
          });
        },
        changeActive: function changeActive(next2) {
          var _document = document, activeElement = _document.activeElement;
          if (next2 && activeElement === sentinelEndRef.current) {
            sentinelStartRef.current.focus({
              preventScroll: true
            });
          } else if (!next2 && activeElement === sentinelStartRef.current) {
            sentinelEndRef.current.focus({
              preventScroll: true
            });
          }
        }
      };
    });
    var contentStyle = {};
    if (width !== void 0) {
      contentStyle.width = width;
    }
    if (height !== void 0) {
      contentStyle.height = height;
    }
    var footerNode = footer ? /* @__PURE__ */ import_react45.default.createElement("div", {
      className: (0, import_classnames19.default)("".concat(prefixCls, "-footer"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.footer),
      style: _objectSpread2({}, modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.footer)
    }, footer) : null;
    var headerNode = title ? /* @__PURE__ */ import_react45.default.createElement("div", {
      className: (0, import_classnames19.default)("".concat(prefixCls, "-header"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.header),
      style: _objectSpread2({}, modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.header)
    }, /* @__PURE__ */ import_react45.default.createElement("div", {
      className: "".concat(prefixCls, "-title"),
      id: ariaId
    }, title)) : null;
    var closableObj = (0, import_react45.useMemo)(function() {
      if (_typeof(closable) === "object" && closable !== null) {
        return closable;
      }
      if (closable) {
        return {
          closeIcon: closeIcon !== null && closeIcon !== void 0 ? closeIcon : /* @__PURE__ */ import_react45.default.createElement("span", {
            className: "".concat(prefixCls, "-close-x")
          })
        };
      }
      return {};
    }, [closable, closeIcon, prefixCls]);
    var ariaProps = pickAttrs(closableObj, true);
    var closeBtnIsDisabled = _typeof(closable) === "object" && closable.disabled;
    var closerNode = closable ? /* @__PURE__ */ import_react45.default.createElement("button", _extends({
      type: "button",
      onClick: onClose,
      "aria-label": "Close"
    }, ariaProps, {
      className: "".concat(prefixCls, "-close"),
      disabled: closeBtnIsDisabled
    }), closableObj.closeIcon) : null;
    var content = /* @__PURE__ */ import_react45.default.createElement("div", {
      className: (0, import_classnames19.default)("".concat(prefixCls, "-content"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.content),
      style: modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.content
    }, closerNode, headerNode, /* @__PURE__ */ import_react45.default.createElement("div", _extends({
      className: (0, import_classnames19.default)("".concat(prefixCls, "-body"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.body),
      style: _objectSpread2(_objectSpread2({}, bodyStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.body)
    }, bodyProps), children), footerNode);
    return /* @__PURE__ */ import_react45.default.createElement("div", {
      key: "dialog-element",
      role: "dialog",
      "aria-labelledby": title ? ariaId : null,
      "aria-modal": "true",
      ref: mergedRef,
      style: _objectSpread2(_objectSpread2({}, style2), contentStyle),
      className: (0, import_classnames19.default)(prefixCls, className),
      onMouseDown,
      onMouseUp
    }, /* @__PURE__ */ import_react45.default.createElement("div", {
      ref: sentinelStartRef,
      tabIndex: 0,
      style: entityStyle
    }, /* @__PURE__ */ import_react45.default.createElement(MemoChildren_default, {
      shouldUpdate: visible || forceRender
    }, modalRender ? modalRender(content) : content)), /* @__PURE__ */ import_react45.default.createElement("div", {
      tabIndex: 0,
      ref: sentinelEndRef,
      style: sentinelStyle
    }));
  });
  if (true) {
    Panel.displayName = "Panel";
  }
  var Panel_default = Panel;

  // node_modules/rc-dialog/es/Dialog/Content/index.js
  var Content = /* @__PURE__ */ React93.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition2 = props.mousePosition;
    var dialogRef = (0, import_react46.useRef)();
    var _React$useState = React93.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
    var contentStyle = {};
    if (transformOrigin) {
      contentStyle.transformOrigin = transformOrigin;
    }
    function onPrepare() {
      var elementOffset = offset(dialogRef.current);
      setTransformOrigin(mousePosition2 && (mousePosition2.x || mousePosition2.y) ? "".concat(mousePosition2.x - elementOffset.left, "px ").concat(mousePosition2.y - elementOffset.top, "px") : "");
    }
    return /* @__PURE__ */ React93.createElement(es_default2, {
      visible,
      onVisibleChanged,
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      forceRender,
      motionName,
      removeOnLeave: destroyOnClose,
      ref: dialogRef
    }, function(_ref, motionRef) {
      var motionClassName = _ref.className, motionStyle = _ref.style;
      return /* @__PURE__ */ React93.createElement(Panel_default, _extends({}, props, {
        ref,
        title,
        ariaId,
        prefixCls,
        holderRef: motionRef,
        style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), style2), contentStyle),
        className: (0, import_classnames20.default)(className, motionClassName)
      }));
    });
  });
  Content.displayName = "Content";
  var Content_default = Content;

  // node_modules/rc-dialog/es/Dialog/Mask.js
  var React94 = __toESM(require_react());
  var import_classnames21 = __toESM(require_classnames());
  var Mask = function Mask2(props) {
    var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName, className = props.className;
    return /* @__PURE__ */ React94.createElement(es_default2, {
      key: "mask",
      visible,
      motionName,
      leavedClassName: "".concat(prefixCls, "-mask-hidden")
    }, function(_ref, ref) {
      var motionClassName = _ref.className, motionStyle = _ref.style;
      return /* @__PURE__ */ React94.createElement("div", _extends({
        ref,
        style: _objectSpread2(_objectSpread2({}, motionStyle), style2),
        className: (0, import_classnames21.default)("".concat(prefixCls, "-mask"), motionClassName, className)
      }, maskProps));
    });
  };
  var Mask_default = Mask;

  // node_modules/rc-dialog/es/Dialog/index.js
  var Dialog = function Dialog2(props) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterOpenChange = props.afterOpenChange, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName, modalClassNames = props.classNames, modalStyles = props.styles;
    if (true) {
      ["wrapStyle", "bodyStyle", "maskStyle"].forEach(function(prop) {
        warning(!(prop in props), "".concat(prop, " is deprecated, please use styles instead."));
      });
      if ("wrapClassName" in props) {
        warning(false, "wrapClassName is deprecated, please use classNames instead.");
      }
    }
    var lastOutSideActiveElementRef = (0, import_react47.useRef)();
    var wrapperRef = (0, import_react47.useRef)();
    var contentRef = (0, import_react47.useRef)();
    var _React$useState = React95.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
    var ariaId = useId_default();
    function saveLastOutSideActiveElementRef() {
      if (!contains(wrapperRef.current, document.activeElement)) {
        lastOutSideActiveElementRef.current = document.activeElement;
      }
    }
    function focusDialogContent() {
      if (!contains(wrapperRef.current, document.activeElement)) {
        var _contentRef$current;
        (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
      }
    }
    function onDialogVisibleChanged(newVisible) {
      if (newVisible) {
        focusDialogContent();
      } else {
        setAnimatedVisible(false);
        if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
          try {
            lastOutSideActiveElementRef.current.focus({
              preventScroll: true
            });
          } catch (e3) {
          }
          lastOutSideActiveElementRef.current = null;
        }
        if (animatedVisible) {
          afterClose === null || afterClose === void 0 || afterClose();
        }
      }
      afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(newVisible);
    }
    function onInternalClose(e3) {
      onClose === null || onClose === void 0 || onClose(e3);
    }
    var contentClickRef = (0, import_react47.useRef)(false);
    var contentTimeoutRef = (0, import_react47.useRef)();
    var onContentMouseDown = function onContentMouseDown2() {
      clearTimeout(contentTimeoutRef.current);
      contentClickRef.current = true;
    };
    var onContentMouseUp = function onContentMouseUp2() {
      contentTimeoutRef.current = setTimeout(function() {
        contentClickRef.current = false;
      });
    };
    var onWrapperClick = null;
    if (maskClosable) {
      onWrapperClick = function onWrapperClick2(e3) {
        if (contentClickRef.current) {
          contentClickRef.current = false;
        } else if (wrapperRef.current === e3.target) {
          onInternalClose(e3);
        }
      };
    }
    function onWrapperKeyDown(e3) {
      if (keyboard && e3.keyCode === KeyCode_default.ESC) {
        e3.stopPropagation();
        onInternalClose(e3);
        return;
      }
      if (visible && e3.keyCode === KeyCode_default.TAB) {
        contentRef.current.changeActive(!e3.shiftKey);
      }
    }
    (0, import_react47.useEffect)(function() {
      if (visible) {
        setAnimatedVisible(true);
        saveLastOutSideActiveElementRef();
      }
    }, [visible]);
    (0, import_react47.useEffect)(function() {
      return function() {
        clearTimeout(contentTimeoutRef.current);
      };
    }, []);
    var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2({
      zIndex
    }, wrapStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.wrapper), {}, {
      display: !animatedVisible ? "none" : null
    });
    return /* @__PURE__ */ React95.createElement("div", _extends({
      className: (0, import_classnames22.default)("".concat(prefixCls, "-root"), rootClassName)
    }, pickAttrs(props, {
      data: true
    })), /* @__PURE__ */ React95.createElement(Mask_default, {
      prefixCls,
      visible: mask && visible,
      motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
      style: _objectSpread2(_objectSpread2({
        zIndex
      }, maskStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.mask),
      maskProps,
      className: modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.mask
    }), /* @__PURE__ */ React95.createElement("div", _extends({
      tabIndex: -1,
      onKeyDown: onWrapperKeyDown,
      className: (0, import_classnames22.default)("".concat(prefixCls, "-wrap"), wrapClassName, modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.wrapper),
      ref: wrapperRef,
      onClick: onWrapperClick,
      style: mergedStyle
    }, wrapProps), /* @__PURE__ */ React95.createElement(Content_default, _extends({}, props, {
      onMouseDown: onContentMouseDown,
      onMouseUp: onContentMouseUp,
      ref: contentRef,
      closable,
      ariaId,
      prefixCls,
      visible: visible && animatedVisible,
      onClose: onInternalClose,
      onVisibleChanged: onDialogVisibleChanged,
      motionName: getMotionName(prefixCls, transitionName, animation)
    }))));
  };
  var Dialog_default = Dialog;

  // node_modules/rc-dialog/es/DialogWrap.js
  var DialogWrap = function DialogWrap2(props) {
    var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose, panelRef = props.panelRef;
    var _React$useState = React96.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
    var refContext = React96.useMemo(function() {
      return {
        panel: panelRef
      };
    }, [panelRef]);
    React96.useEffect(function() {
      if (visible) {
        setAnimatedVisible(true);
      }
    }, [visible]);
    if (!forceRender && destroyOnClose && !animatedVisible) {
      return null;
    }
    return /* @__PURE__ */ React96.createElement(RefContext.Provider, {
      value: refContext
    }, /* @__PURE__ */ React96.createElement(es_default3, {
      open: visible || forceRender || animatedVisible,
      autoDestroy: false,
      getContainer: getContainer2,
      autoLock: visible || animatedVisible
    }, /* @__PURE__ */ React96.createElement(Dialog_default, _extends({}, props, {
      destroyOnClose,
      afterClose: function afterClose() {
        _afterClose === null || _afterClose === void 0 || _afterClose();
        setAnimatedVisible(false);
      }
    }))));
  };
  DialogWrap.displayName = "Dialog";
  var DialogWrap_default = DialogWrap;

  // node_modules/rc-dialog/es/index.js
  var es_default4 = DialogWrap_default;

  // node_modules/antd/es/_util/ContextIsolator.js
  var import_react49 = __toESM(require_react());

  // node_modules/antd/es/form/context.js
  var React106 = __toESM(require_react());

  // node_modules/rc-field-form/es/index.js
  var React105 = __toESM(require_react());

  // node_modules/rc-field-form/es/Field.js
  var React100 = __toESM(require_react());

  // node_modules/rc-field-form/es/FieldContext.js
  var React97 = __toESM(require_react());
  var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
  var warningFunc = function warningFunc2() {
    warning_default(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
  };
  var Context2 = /* @__PURE__ */ React97.createContext({
    getFieldValue: warningFunc,
    getFieldsValue: warningFunc,
    getFieldError: warningFunc,
    getFieldWarning: warningFunc,
    getFieldsError: warningFunc,
    isFieldsTouched: warningFunc,
    isFieldTouched: warningFunc,
    isFieldValidating: warningFunc,
    isFieldsValidating: warningFunc,
    resetFields: warningFunc,
    setFields: warningFunc,
    setFieldValue: warningFunc,
    setFieldsValue: warningFunc,
    validateFields: warningFunc,
    submit: warningFunc,
    getInternalHooks: function getInternalHooks() {
      warningFunc();
      return {
        dispatch: warningFunc,
        initEntityValue: warningFunc,
        registerField: warningFunc,
        useSubscribe: warningFunc,
        setInitialValues: warningFunc,
        destroyForm: warningFunc,
        setCallbacks: warningFunc,
        registerWatch: warningFunc,
        getFields: warningFunc,
        setValidateMessages: warningFunc,
        setPreserve: warningFunc,
        getInitialValue: warningFunc
      };
    }
  });
  var FieldContext_default = Context2;

  // node_modules/rc-field-form/es/ListContext.js
  var React98 = __toESM(require_react());
  var ListContext = /* @__PURE__ */ React98.createContext(null);
  var ListContext_default = ListContext;

  // node_modules/rc-field-form/es/utils/typeUtil.js
  function toArray2(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function isFormInstance(form) {
    return form && !!form._init;
  }

  // node_modules/@rc-component/async-validator/es/messages.js
  function newMessages() {
    return {
      default: "Validation error on field %s",
      required: "%s is required",
      enum: "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        boolean: "%s is not a %s",
        integer: "%s is not an %s",
        float: "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();

  // node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
  function _isNativeFunction(t2) {
    try {
      return -1 !== Function.toString.call(t2).indexOf("[native code]");
    } catch (n2) {
      return "function" == typeof t2;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/construct.js
  function _construct(t2, e3, r2) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o3 = [null];
    o3.push.apply(o3, e3);
    var p = new (t2.bind.apply(t2, o3))();
    return r2 && _setPrototypeOf(p, r2.prototype), p;
  }

  // node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
  function _wrapNativeSuper(t2) {
    var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
      if (null === t3 || !_isNativeFunction(t3)) return t3;
      if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r2) {
        if (r2.has(t3)) return r2.get(t3);
        r2.set(t3, Wrapper2);
      }
      function Wrapper2() {
        return _construct(t3, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper2.prototype = Object.create(t3.prototype, {
        constructor: {
          value: Wrapper2,
          enumerable: false,
          writable: true,
          configurable: true
        }
      }), _setPrototypeOf(Wrapper2, t3);
    }, _wrapNativeSuper(t2);
  }

  // node_modules/@rc-component/async-validator/es/util.js
  var formatRegExp = /%[sdj%]/g;
  var warning4 = function warning5() {
  };
  if (typeof process !== "undefined" && process.env && true && typeof window !== "undefined" && typeof document !== "undefined") {
    warning4 = function warning6(type5, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e3) {
          return typeof e3 === "string";
        })) {
          console.warn(type5, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x) {
        if (x === "%%") {
          return "%";
        }
        if (i >= len) {
          return x;
        }
        switch (x) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
            break;
          default:
            return x;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type5) {
    return type5 === "string" || type5 === "url" || type5 === "hex" || type5 === "email" || type5 === "date" || type5 === "pattern";
  }
  function isEmptyValue(value, type5) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type5 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type5) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, _toConsumableArray(errors || []));
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a) {
      func(a, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index3 = 0;
    var arrLength = arr.length;
    function next2(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index3;
      index3 = index3 + 1;
      if (original < arrLength) {
        func(arr[original], next2);
      } else {
        callback([]);
      }
    }
    next2([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k) {
      ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inherits(AsyncValidationError2, _Error);
    var _super = _createSuper(AsyncValidationError2);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _classCallCheck(this, AsyncValidationError2);
      _this = _super.call(this, "Async Validation Error");
      _defineProperty(_assertThisInitialized(_this), "errors", void 0);
      _defineProperty(_assertThisInitialized(_this), "fields", void 0);
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return _createClass(AsyncValidationError2);
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next2 = function next3(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next2);
      });
      _pending.catch(function(e3) {
        return e3;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next2 = function next3(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key) {
        var arr = objArr[key];
        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next2);
        } else {
          asyncParallelArray(arr, func, next2);
        }
      });
    });
    pending.catch(function(e3) {
      return e3;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue2(value, path2) {
    var v = value;
    for (var i = 0; i < path2.length; i++) {
      if (v == void 0) {
        return v;
      }
      v = v[path2[i]];
    }
    return v;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue2(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];
          if (_typeof(value) === "object" && _typeof(target[s]) === "object") {
            target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
          } else {
            target[s] = value;
          }
        }
      }
    }
    return target;
  }

  // node_modules/@rc-component/async-validator/es/rule/enum.js
  var ENUM = "enum";
  var enumerable = function enumerable2(rule, value, source, errors, options) {
    rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
    if (rule[ENUM].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(", ")));
    }
  };
  var enum_default = enumerable;

  // node_modules/@rc-component/async-validator/es/rule/pattern.js
  var pattern = function pattern2(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var pattern_default = pattern;

  // node_modules/@rc-component/async-validator/es/rule/range.js
  var range = function range2(rule, value, source, errors, options) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    }
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };
  var range_default = range;

  // node_modules/@rc-component/async-validator/es/rule/required.js
  var required = function required2(rule, value, source, errors, options, type5) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type5 || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  };
  var required_default = required;

  // node_modules/@rc-component/async-validator/es/rule/url.js
  var urlReg;
  var url_default = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b = function b2(options) {
      return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6List = [
      "(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
      // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
      "(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
      // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
      "(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
      // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
      "(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
      // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
      "(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
      // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
      "(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
      // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
      "(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
      // 1::              1::3:4:5:6:7:8   1::8            1::
      "(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
      // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
    ];
    var v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?";
    var v6 = "(?:".concat(v6List.join("|"), ")").concat(v6Eth0);
    var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
    var v4exact = new RegExp("^".concat(v4, "$"));
    var v6exact = new RegExp("^".concat(v6, "$"));
    var ip = function ip2(options) {
      return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
    };
    ip.v4 = function(options) {
      return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
    };
    ip.v6 = function(options) {
      return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path2 = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path2);
    urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
    return urlReg;
  };

  // node_modules/@rc-component/async-validator/es/rule/type.js
  var pattern3 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    float: function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp3(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e3) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return _typeof(value) === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern3.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(url_default());
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern3.hex);
    }
  };
  var type = function type2(rule, value, source, errors, options) {
    if (rule.required && value === void 0) {
      required_default(rule, value, source, errors, options);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && _typeof(value) !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var type_default = type;

  // node_modules/@rc-component/async-validator/es/rule/whitespace.js
  var whitespace2 = function whitespace3(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  };
  var whitespace_default = whitespace2;

  // node_modules/@rc-component/async-validator/es/rule/index.js
  var rule_default = {
    required: required_default,
    whitespace: whitespace_default,
    type: type_default,
    range: range_default,
    enum: enum_default,
    pattern: pattern_default
  };

  // node_modules/@rc-component/async-validator/es/validator/any.js
  var any = function any2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
    }
    callback(errors);
  };
  var any_default = any;

  // node_modules/@rc-component/async-validator/es/validator/array.js
  var array2 = function array3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options, "array");
      if (value !== void 0 && value !== null) {
        rule_default.type(rule, value, source, errors, options);
        rule_default.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var array_default = array2;

  // node_modules/@rc-component/async-validator/es/validator/boolean.js
  var boolean = function boolean2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rule_default.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var boolean_default = boolean;

  // node_modules/@rc-component/async-validator/es/validator/date.js
  var date2 = function date3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rule_default.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rule_default.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var date_default = date2;

  // node_modules/@rc-component/async-validator/es/validator/enum.js
  var ENUM2 = "enum";
  var enumerable3 = function enumerable4(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rule_default[ENUM2](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var enum_default2 = enumerable3;

  // node_modules/@rc-component/async-validator/es/validator/float.js
  var floatFn = function floatFn2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rule_default.type(rule, value, source, errors, options);
        rule_default.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var float_default = floatFn;

  // node_modules/@rc-component/async-validator/es/validator/integer.js
  var integer2 = function integer3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rule_default.type(rule, value, source, errors, options);
        rule_default.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var integer_default = integer2;

  // node_modules/@rc-component/async-validator/es/validator/method.js
  var method2 = function method3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rule_default.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var method_default = method2;

  // node_modules/@rc-component/async-validator/es/validator/number.js
  var number2 = function number3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rule_default.type(rule, value, source, errors, options);
        rule_default.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var number_default = number2;

  // node_modules/@rc-component/async-validator/es/validator/object.js
  var object2 = function object3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rule_default.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var object_default = object2;

  // node_modules/@rc-component/async-validator/es/validator/pattern.js
  var pattern4 = function pattern5(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "string")) {
        rule_default.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var pattern_default2 = pattern4;

  // node_modules/@rc-component/async-validator/es/validator/regexp.js
  var regexp4 = function regexp5(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rule_default.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var regexp_default = regexp4;

  // node_modules/@rc-component/async-validator/es/validator/required.js
  var required3 = function required4(rule, value, callback, source, options) {
    var errors = [];
    var type5 = Array.isArray(value) ? "array" : _typeof(value);
    rule_default.required(rule, value, source, errors, options, type5);
    callback(errors);
  };
  var required_default2 = required3;

  // node_modules/@rc-component/async-validator/es/validator/string.js
  var string = function string2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options, "string");
      if (!isEmptyValue(value, "string")) {
        rule_default.type(rule, value, source, errors, options);
        rule_default.range(rule, value, source, errors, options);
        rule_default.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rule_default.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var string_default = string;

  // node_modules/@rc-component/async-validator/es/validator/type.js
  var type3 = function type4(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rule_default.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rule_default.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var type_default2 = type3;

  // node_modules/@rc-component/async-validator/es/validator/index.js
  var validator_default = {
    string: string_default,
    method: method_default,
    number: number_default,
    boolean: boolean_default,
    regexp: regexp_default,
    integer: integer_default,
    float: float_default,
    array: array_default,
    object: object_default,
    enum: enum_default2,
    pattern: pattern_default2,
    date: date_default,
    url: type_default2,
    hex: type_default2,
    email: type_default2,
    required: required_default2,
    any: any_default
  };

  // node_modules/@rc-component/async-validator/es/index.js
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      _classCallCheck(this, Schema2);
      _defineProperty(this, "rules", null);
      _defineProperty(this, "_messages", messages);
      this.define(descriptor);
    }
    _createClass(Schema2, [{
      key: "define",
      value: function define2(rules) {
        var _this = this;
        if (!rules) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (_typeof(rules) !== "object" || Array.isArray(rules)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules).forEach(function(name) {
          var item = rules[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      }
    }, {
      key: "messages",
      value: function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      }
    }, {
      key: "validate",
      value: function validate(source_) {
        var _this2 = this;
        var o3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
        };
        var source = source_;
        var options = o3;
        var callback = oc;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add(e3) {
            if (Array.isArray(e3)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e3));
            } else {
              errors.push(e3);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages2 = this.messages();
          if (messages2 === messages) {
            messages2 = newMessages();
          }
          deepMerge(messages2, options.messages);
          options.messages = messages2;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r2) {
            var rule = r2;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _objectSpread2({}, source);
              }
              value = source[z] = rule.transform(value);
              if (value !== void 0 && value !== null) {
                rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof(value));
              }
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _objectSpread2({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (_typeof(rule.fields) === "object" || _typeof(rule.defaultField) === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _objectSpread2(_objectSpread2({}, schema), {}, {
              fullField: "".concat(rule.fullField, ".").concat(key),
              fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
            });
          }
          function cb() {
            var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var errorList = Array.isArray(e3) ? e3 : [e3];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb, data.source, options);
            } catch (error) {
              var _console$error, _console;
              (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb(error.message);
            }
            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb();
            }, function(e3) {
              return cb(e3);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      }
    }, {
      key: "getType",
      value: function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validator_default.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      }
    }, {
      key: "getValidationMethod",
      value: function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validator_default.required;
        }
        return validator_default[this.getType(rule)] || void 0;
      }
    }]);
    return Schema2;
  }();
  _defineProperty(Schema, "register", function register(type5, validator) {
    if (typeof validator !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validator_default[type5] = validator;
  });
  _defineProperty(Schema, "warning", warning4);
  _defineProperty(Schema, "messages", messages);
  _defineProperty(Schema, "validators", validator_default);
  var es_default5 = Schema;

  // node_modules/rc-field-form/es/utils/validateUtil.js
  var React99 = __toESM(require_react());

  // node_modules/rc-field-form/es/utils/messages.js
  var typeTemplate2 = "'${name}' is not a valid ${type}";
  var defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate2,
      method: typeTemplate2,
      array: typeTemplate2,
      object: typeTemplate2,
      number: typeTemplate2,
      date: typeTemplate2,
      boolean: typeTemplate2,
      integer: typeTemplate2,
      float: typeTemplate2,
      regexp: typeTemplate2,
      email: typeTemplate2,
      url: typeTemplate2,
      hex: typeTemplate2
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };

  // node_modules/rc-field-form/es/utils/validateUtil.js
  var AsyncValidator = es_default5;
  function replaceMessage(template, kv) {
    return template.replace(/\\?\$\{\w+\}/g, function(str) {
      if (str.startsWith("\\")) {
        return str.slice(1);
      }
      var key = str.slice(2, -1);
      return kv[key];
    });
  }
  var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
  function validateRule(_x, _x2, _x3, _x4, _x5) {
    return _validateRule.apply(this, arguments);
  }
  function _validateRule() {
    _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
      var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            cloneRule = _objectSpread2({}, rule);
            delete cloneRule.ruleIndex;
            AsyncValidator.warning = function() {
              return void 0;
            };
            if (cloneRule.validator) {
              originValidator = cloneRule.validator;
              cloneRule.validator = function() {
                try {
                  return originValidator.apply(void 0, arguments);
                } catch (error) {
                  console.error(error);
                  return Promise.reject(CODE_LOGIC_ERROR);
                }
              };
            }
            subRuleField = null;
            if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
              subRuleField = cloneRule.defaultField;
              delete cloneRule.defaultField;
            }
            validator = new AsyncValidator(_defineProperty({}, name, [cloneRule]));
            messages2 = merge(defaultValidateMessages, options.validateMessages);
            validator.messages(messages2);
            result = [];
            _context2.prev = 10;
            _context2.next = 13;
            return Promise.resolve(validator.validate(_defineProperty({}, name, value), _objectSpread2({}, options)));
          case 13:
            _context2.next = 18;
            break;
          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](10);
            if (_context2.t0.errors) {
              result = _context2.t0.errors.map(function(_ref4, index3) {
                var message2 = _ref4.message;
                var mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
                return /* @__PURE__ */ React99.isValidElement(mergedMessage) ? (
                  // Wrap ReactNode with `key`
                  /* @__PURE__ */ React99.cloneElement(mergedMessage, {
                    key: "error_".concat(index3)
                  })
                ) : mergedMessage;
              });
            }
          case 18:
            if (!(!result.length && subRuleField)) {
              _context2.next = 23;
              break;
            }
            _context2.next = 21;
            return Promise.all(value.map(function(subValue, i) {
              return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
            }));
          case 21:
            subResults = _context2.sent;
            return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
              return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
            }, []));
          case 23:
            kv = _objectSpread2(_objectSpread2({}, rule), {}, {
              name,
              enum: (rule.enum || []).join(", ")
            }, messageVariables);
            fillVariableResult = result.map(function(error) {
              if (typeof error === "string") {
                return replaceMessage(error, kv);
              }
              return error;
            });
            return _context2.abrupt("return", fillVariableResult);
          case 26:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[10, 15]]);
    }));
    return _validateRule.apply(this, arguments);
  }
  function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
    var name = namePath.join(".");
    var filledRules = rules.map(function(currentRule, ruleIndex) {
      var originValidatorFunc = currentRule.validator;
      var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
        ruleIndex
      });
      if (originValidatorFunc) {
        cloneRule.validator = function(rule, val, callback) {
          var hasPromise = false;
          var wrappedCallback = function wrappedCallback2() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            Promise.resolve().then(function() {
              warning_default(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
              if (!hasPromise) {
                callback.apply(void 0, args);
              }
            });
          };
          var promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
          warning_default(hasPromise, "`callback` is deprecated. Please return a promise instead.");
          if (hasPromise) {
            promise.then(function() {
              callback();
            }).catch(function(err) {
              callback(err || " ");
            });
          }
        };
      }
      return cloneRule;
    }).sort(function(_ref, _ref2) {
      var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
      var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
      if (!!w1 === !!w2) {
        return i1 - i2;
      }
      if (w1) {
        return 1;
      }
      return -1;
    });
    var summaryPromise;
    if (validateFirst === true) {
      summaryPromise = new Promise(/* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
          var i, rule, errors;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                i = 0;
              case 1:
                if (!(i < filledRules.length)) {
                  _context.next = 12;
                  break;
                }
                rule = filledRules[i];
                _context.next = 5;
                return validateRule(name, value, rule, options, messageVariables);
              case 5:
                errors = _context.sent;
                if (!errors.length) {
                  _context.next = 9;
                  break;
                }
                reject([{
                  errors,
                  rule
                }]);
                return _context.abrupt("return");
              case 9:
                i += 1;
                _context.next = 1;
                break;
              case 12:
                resolve([]);
              case 13:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function(_x6, _x7) {
          return _ref3.apply(this, arguments);
        };
      }());
    } else {
      var rulePromises = filledRules.map(function(rule) {
        return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
          return {
            errors,
            rule
          };
        });
      });
      summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
        return Promise.reject(errors);
      });
    }
    summaryPromise.catch(function(e3) {
      return e3;
    });
    return summaryPromise;
  }
  function finishOnAllFailed(_x8) {
    return _finishOnAllFailed.apply(this, arguments);
  }
  function _finishOnAllFailed() {
    _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
              var _ref5;
              var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
              return errors;
            }));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _finishOnAllFailed.apply(this, arguments);
  }
  function finishOnFirstFailed(_x9) {
    return _finishOnFirstFailed.apply(this, arguments);
  }
  function _finishOnFirstFailed() {
    _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
      var count;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            count = 0;
            return _context4.abrupt("return", new Promise(function(resolve) {
              rulePromises.forEach(function(promise) {
                promise.then(function(ruleError) {
                  if (ruleError.errors.length) {
                    resolve([ruleError]);
                  }
                  count += 1;
                  if (count === rulePromises.length) {
                    resolve([]);
                  }
                });
              });
            }));
          case 2:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return _finishOnFirstFailed.apply(this, arguments);
  }

  // node_modules/rc-field-form/es/utils/valueUtil.js
  function getNamePath(path2) {
    return toArray2(path2);
  }
  function cloneByNamePathList(store, namePathList) {
    var newStore = {};
    namePathList.forEach(function(namePath) {
      var value = get(store, namePath);
      newStore = set(newStore, namePath, value);
    });
    return newStore;
  }
  function containsNamePath(namePathList, namePath) {
    var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return namePathList && namePathList.some(function(path2) {
      return matchNamePath(namePath, path2, partialMatch);
    });
  }
  function matchNamePath(namePath, subNamePath) {
    var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!namePath || !subNamePath) {
      return false;
    }
    if (!partialMatch && namePath.length !== subNamePath.length) {
      return false;
    }
    return subNamePath.every(function(nameUnit, i) {
      return namePath[i] === nameUnit;
    });
  }
  function isSimilar(source, target) {
    if (source === target) {
      return true;
    }
    if (!source && target || source && !target) {
      return false;
    }
    if (!source || !target || _typeof(source) !== "object" || _typeof(target) !== "object") {
      return false;
    }
    var sourceKeys = Object.keys(source);
    var targetKeys = Object.keys(target);
    var keys2 = new Set([].concat(sourceKeys, targetKeys));
    return _toConsumableArray(keys2).every(function(key) {
      var sourceValue = source[key];
      var targetValue = target[key];
      if (typeof sourceValue === "function" && typeof targetValue === "function") {
        return true;
      }
      return sourceValue === targetValue;
    });
  }
  function defaultGetValueFromEvent(valuePropName) {
    var event = arguments.length <= 1 ? void 0 : arguments[1];
    if (event && event.target && _typeof(event.target) === "object" && valuePropName in event.target) {
      return event.target[valuePropName];
    }
    return event;
  }
  function move(array4, moveIndex, toIndex) {
    var length2 = array4.length;
    if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
      return array4;
    }
    var item = array4[moveIndex];
    var diff = moveIndex - toIndex;
    if (diff > 0) {
      return [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length2)));
    }
    if (diff < 0) {
      return [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length2)));
    }
    return array4;
  }

  // node_modules/rc-field-form/es/Field.js
  var _excluded8 = ["name"];
  var EMPTY_ERRORS = [];
  function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
    if (typeof shouldUpdate === "function") {
      return shouldUpdate(prev2, next2, "source" in info ? {
        source: info.source
      } : {});
    }
    return prevValue !== nextValue;
  }
  var Field = /* @__PURE__ */ function(_React$Component) {
    _inherits(Field2, _React$Component);
    var _super = _createSuper(Field2);
    function Field2(props) {
      var _this;
      _classCallCheck(this, Field2);
      _this = _super.call(this, props);
      _defineProperty(_assertThisInitialized(_this), "state", {
        resetCount: 0
      });
      _defineProperty(_assertThisInitialized(_this), "cancelRegisterFunc", null);
      _defineProperty(_assertThisInitialized(_this), "mounted", false);
      _defineProperty(_assertThisInitialized(_this), "touched", false);
      _defineProperty(_assertThisInitialized(_this), "dirty", false);
      _defineProperty(_assertThisInitialized(_this), "validatePromise", void 0);
      _defineProperty(_assertThisInitialized(_this), "prevValidating", void 0);
      _defineProperty(_assertThisInitialized(_this), "errors", EMPTY_ERRORS);
      _defineProperty(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS);
      _defineProperty(_assertThisInitialized(_this), "cancelRegister", function() {
        var _this$props = _this.props, preserve2 = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
        if (_this.cancelRegisterFunc) {
          _this.cancelRegisterFunc(isListField, preserve2, getNamePath(name));
        }
        _this.cancelRegisterFunc = null;
      });
      _defineProperty(_assertThisInitialized(_this), "getNamePath", function() {
        var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
        var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
        return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
      });
      _defineProperty(_assertThisInitialized(_this), "getRules", function() {
        var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
        return rules.map(function(rule) {
          if (typeof rule === "function") {
            return rule(fieldContext);
          }
          return rule;
        });
      });
      _defineProperty(_assertThisInitialized(_this), "refresh", function() {
        if (!_this.mounted) return;
        _this.setState(function(_ref) {
          var resetCount = _ref.resetCount;
          return {
            resetCount: resetCount + 1
          };
        });
      });
      _defineProperty(_assertThisInitialized(_this), "metaCache", null);
      _defineProperty(_assertThisInitialized(_this), "triggerMetaEvent", function(destroy2) {
        var onMetaChange = _this.props.onMetaChange;
        if (onMetaChange) {
          var _meta = _objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
            destroy: destroy2
          });
          if (!isEqual_default(_this.metaCache, _meta)) {
            onMetaChange(_meta);
          }
          _this.metaCache = _meta;
        } else {
          _this.metaCache = null;
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onStoreChange", function(prevStore, namePathList, info) {
        var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
        var store = info.store;
        var namePath = _this.getNamePath();
        var prevValue = _this.getValue(prevStore);
        var curValue = _this.getValue(store);
        var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
        if (info.type === "valueUpdate" && info.source === "external" && !isEqual_default(prevValue, curValue)) {
          _this.touched = true;
          _this.dirty = true;
          _this.validatePromise = null;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
        }
        switch (info.type) {
          case "reset":
            if (!namePathList || namePathMatch) {
              _this.touched = false;
              _this.dirty = false;
              _this.validatePromise = void 0;
              _this.errors = EMPTY_ERRORS;
              _this.warnings = EMPTY_ERRORS;
              _this.triggerMetaEvent();
              onReset === null || onReset === void 0 || onReset();
              _this.refresh();
              return;
            }
            break;
          /**
           * In case field with `preserve = false` nest deps like:
           * - A = 1 => show B
           * - B = 1 => show C
           * - Reset A, need clean B, C
           */
          case "remove": {
            if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
              _this.reRender();
              return;
            }
            break;
          }
          case "setField": {
            var data = info.data;
            if (namePathMatch) {
              if ("touched" in data) {
                _this.touched = data.touched;
              }
              if ("validating" in data && !("originRCField" in data)) {
                _this.validatePromise = data.validating ? Promise.resolve([]) : null;
              }
              if ("errors" in data) {
                _this.errors = data.errors || EMPTY_ERRORS;
              }
              if ("warnings" in data) {
                _this.warnings = data.warnings || EMPTY_ERRORS;
              }
              _this.dirty = true;
              _this.triggerMetaEvent();
              _this.reRender();
              return;
            } else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
              _this.reRender();
              return;
            }
            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
              _this.reRender();
              return;
            }
            break;
          }
          case "dependenciesUpdate": {
            var dependencyList = dependencies.map(getNamePath);
            if (dependencyList.some(function(dependency) {
              return containsNamePath(info.relatedFields, dependency);
            })) {
              _this.reRender();
              return;
            }
            break;
          }
          default:
            if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
              _this.reRender();
              return;
            }
            break;
        }
        if (shouldUpdate === true) {
          _this.reRender();
        }
      });
      _defineProperty(_assertThisInitialized(_this), "validateRules", function(options) {
        var namePath = _this.getNamePath();
        var currentValue = _this.getValue();
        var _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;
        var rootPromise = Promise.resolve().then(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
          var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (_this.mounted) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return", []);
              case 2:
                _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables, validateDebounce = _this$props5.validateDebounce;
                filteredRules = _this.getRules();
                if (triggerName) {
                  filteredRules = filteredRules.filter(function(rule) {
                    return rule;
                  }).filter(function(rule) {
                    var validateTrigger = rule.validateTrigger;
                    if (!validateTrigger) {
                      return true;
                    }
                    var triggerList = toArray2(validateTrigger);
                    return triggerList.includes(triggerName);
                  });
                }
                if (!(validateDebounce && triggerName)) {
                  _context.next = 10;
                  break;
                }
                _context.next = 8;
                return new Promise(function(resolve) {
                  setTimeout(resolve, validateDebounce);
                });
              case 8:
                if (!(_this.validatePromise !== rootPromise)) {
                  _context.next = 10;
                  break;
                }
                return _context.abrupt("return", []);
              case 10:
                promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
                promise.catch(function(e3) {
                  return e3;
                }).then(function() {
                  var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
                  if (_this.validatePromise === rootPromise) {
                    var _ruleErrors$forEach;
                    _this.validatePromise = null;
                    var nextErrors = [];
                    var nextWarnings = [];
                    (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref4) {
                      var warningOnly = _ref4.rule.warningOnly, _ref4$errors = _ref4.errors, errors = _ref4$errors === void 0 ? EMPTY_ERRORS : _ref4$errors;
                      if (warningOnly) {
                        nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                      } else {
                        nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                      }
                    });
                    _this.errors = nextErrors;
                    _this.warnings = nextWarnings;
                    _this.triggerMetaEvent();
                    _this.reRender();
                  }
                });
                return _context.abrupt("return", promise);
              case 13:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        if (validateOnly) {
          return rootPromise;
        }
        _this.validatePromise = rootPromise;
        _this.dirty = true;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
        _this.reRender();
        return rootPromise;
      });
      _defineProperty(_assertThisInitialized(_this), "isFieldValidating", function() {
        return !!_this.validatePromise;
      });
      _defineProperty(_assertThisInitialized(_this), "isFieldTouched", function() {
        return _this.touched;
      });
      _defineProperty(_assertThisInitialized(_this), "isFieldDirty", function() {
        if (_this.dirty || _this.props.initialValue !== void 0) {
          return true;
        }
        var fieldContext = _this.props.fieldContext;
        var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
        if (getInitialValue(_this.getNamePath()) !== void 0) {
          return true;
        }
        return false;
      });
      _defineProperty(_assertThisInitialized(_this), "getErrors", function() {
        return _this.errors;
      });
      _defineProperty(_assertThisInitialized(_this), "getWarnings", function() {
        return _this.warnings;
      });
      _defineProperty(_assertThisInitialized(_this), "isListField", function() {
        return _this.props.isListField;
      });
      _defineProperty(_assertThisInitialized(_this), "isList", function() {
        return _this.props.isList;
      });
      _defineProperty(_assertThisInitialized(_this), "isPreserve", function() {
        return _this.props.preserve;
      });
      _defineProperty(_assertThisInitialized(_this), "getMeta", function() {
        _this.prevValidating = _this.isFieldValidating();
        var meta = {
          touched: _this.isFieldTouched(),
          validating: _this.prevValidating,
          errors: _this.errors,
          warnings: _this.warnings,
          name: _this.getNamePath(),
          validated: _this.validatePromise === null
        };
        return meta;
      });
      _defineProperty(_assertThisInitialized(_this), "getOnlyChild", function(children) {
        if (typeof children === "function") {
          var _meta2 = _this.getMeta();
          return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, {
            isFunction: true
          });
        }
        var childList = toArray(children);
        if (childList.length !== 1 || !/* @__PURE__ */ React100.isValidElement(childList[0])) {
          return {
            child: childList,
            isFunction: false
          };
        }
        return {
          child: childList[0],
          isFunction: false
        };
      });
      _defineProperty(_assertThisInitialized(_this), "getValue", function(store) {
        var getFieldsValue = _this.props.fieldContext.getFieldsValue;
        var namePath = _this.getNamePath();
        return get(store || getFieldsValue(true), namePath);
      });
      _defineProperty(_assertThisInitialized(_this), "getControlled", function() {
        var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this$props6 = _this.props, name = _this$props6.name, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
        var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
        var namePath = _this.getNamePath();
        var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
        var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
        var value = _this.getValue();
        var mergedGetValueProps = getValueProps || function(val) {
          return _defineProperty({}, valuePropName, val);
        };
        var originTriggerFunc = childProps[trigger];
        var valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
        if (valueProps) {
          Object.keys(valueProps).forEach(function(key) {
            warning_default(typeof valueProps[key] !== "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(key, ")"));
          });
        }
        var control = _objectSpread2(_objectSpread2({}, childProps), valueProps);
        control[trigger] = function() {
          _this.touched = true;
          _this.dirty = true;
          _this.triggerMetaEvent();
          var newValue;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (getValueFromEvent) {
            newValue = getValueFromEvent.apply(void 0, args);
          } else {
            newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
          }
          if (normalize2) {
            newValue = normalize2(newValue, value, getFieldsValue(true));
          }
          if (newValue !== value) {
            dispatch({
              type: "updateValue",
              namePath,
              value: newValue
            });
          }
          if (originTriggerFunc) {
            originTriggerFunc.apply(void 0, args);
          }
        };
        var validateTriggerList = toArray2(mergedValidateTrigger || []);
        validateTriggerList.forEach(function(triggerName) {
          var originTrigger = control[triggerName];
          control[triggerName] = function() {
            if (originTrigger) {
              originTrigger.apply(void 0, arguments);
            }
            var rules = _this.props.rules;
            if (rules && rules.length) {
              dispatch({
                type: "validateField",
                namePath,
                triggerName
              });
            }
          };
        });
        return control;
      });
      if (props.fieldContext) {
        var getInternalHooks2 = props.fieldContext.getInternalHooks;
        var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
        initEntityValue(_assertThisInitialized(_this));
      }
      return _this;
    }
    _createClass(Field2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
        this.mounted = true;
        if (fieldContext) {
          var getInternalHooks2 = fieldContext.getInternalHooks;
          var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
          this.cancelRegisterFunc = registerField(this);
        }
        if (shouldUpdate === true) {
          this.reRender();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.cancelRegister();
        this.triggerMetaEvent(true);
        this.mounted = false;
      }
    }, {
      key: "reRender",
      value: function reRender() {
        if (!this.mounted) return;
        this.forceUpdate();
      }
    }, {
      key: "render",
      value: function render4() {
        var resetCount = this.state.resetCount;
        var children = this.props.children;
        var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
        var returnChildNode;
        if (isFunction2) {
          returnChildNode = child;
        } else if (/* @__PURE__ */ React100.isValidElement(child)) {
          returnChildNode = /* @__PURE__ */ React100.cloneElement(child, this.getControlled(child.props));
        } else {
          warning_default(!child, "`children` of Field is not validate ReactElement.");
          returnChildNode = child;
        }
        return /* @__PURE__ */ React100.createElement(React100.Fragment, {
          key: resetCount
        }, returnChildNode);
      }
    }]);
    return Field2;
  }(React100.Component);
  _defineProperty(Field, "contextType", FieldContext_default);
  _defineProperty(Field, "defaultProps", {
    trigger: "onChange",
    valuePropName: "value"
  });
  function WrapperField(_ref6) {
    var _restProps$isListFiel;
    var name = _ref6.name, restProps = _objectWithoutProperties(_ref6, _excluded8);
    var fieldContext = React100.useContext(FieldContext_default);
    var listContext = React100.useContext(ListContext_default);
    var namePath = name !== void 0 ? getNamePath(name) : void 0;
    var isMergedListField = (_restProps$isListFiel = restProps.isListField) !== null && _restProps$isListFiel !== void 0 ? _restProps$isListFiel : !!listContext;
    var key = "keep";
    if (!isMergedListField) {
      key = "_".concat((namePath || []).join("_"));
    }
    if (restProps.preserve === false && isMergedListField && namePath.length <= 1) {
      warning_default(false, "`preserve` should not apply on Form.List fields.");
    }
    return /* @__PURE__ */ React100.createElement(Field, _extends({
      key,
      name: namePath,
      isListField: isMergedListField
    }, restProps, {
      fieldContext
    }));
  }
  var Field_default = WrapperField;

  // node_modules/rc-field-form/es/List.js
  var React101 = __toESM(require_react());
  function List(_ref) {
    var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField;
    var context = React101.useContext(FieldContext_default);
    var wrapperListContext = React101.useContext(ListContext_default);
    var keyRef = React101.useRef({
      keys: [],
      id: 0
    });
    var keyManager = keyRef.current;
    var prefixName = React101.useMemo(function() {
      var parentPrefixName = getNamePath(context.prefixName) || [];
      return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
    }, [context.prefixName, name]);
    var fieldContext = React101.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, context), {}, {
        prefixName
      });
    }, [context, prefixName]);
    var listContext = React101.useMemo(function() {
      return {
        getKey: function getKey3(namePath) {
          var len = prefixName.length;
          var pathName = namePath[len];
          return [keyManager.keys[pathName], namePath.slice(len + 1)];
        }
      };
    }, [prefixName]);
    if (typeof children !== "function") {
      warning_default(false, "Form.List only accepts function as children.");
      return null;
    }
    var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
      var source = _ref2.source;
      if (source === "internal") {
        return false;
      }
      return prevValue !== nextValue;
    };
    return /* @__PURE__ */ React101.createElement(ListContext_default.Provider, {
      value: listContext
    }, /* @__PURE__ */ React101.createElement(FieldContext_default.Provider, {
      value: fieldContext
    }, /* @__PURE__ */ React101.createElement(Field_default, {
      name: [],
      shouldUpdate,
      rules,
      validateTrigger,
      initialValue,
      isList: true,
      isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
    }, function(_ref3, meta) {
      var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
      var getFieldValue = context.getFieldValue;
      var getNewValue = function getNewValue2() {
        var values = getFieldValue(prefixName || []);
        return values || [];
      };
      var operations = {
        add: function add(defaultValue, index3) {
          var newValue = getNewValue();
          if (index3 >= 0 && index3 <= newValue.length) {
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index3)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index3)));
            onChange([].concat(_toConsumableArray(newValue.slice(0, index3)), [defaultValue], _toConsumableArray(newValue.slice(index3))));
          } else {
            if (index3 < 0 || index3 > newValue.length) {
              warning_default(false, "The second parameter of the add function should be a valid positive number.");
            }
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
            onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
          }
          keyManager.id += 1;
        },
        remove: function remove(index3) {
          var newValue = getNewValue();
          var indexSet = new Set(Array.isArray(index3) ? index3 : [index3]);
          if (indexSet.size <= 0) {
            return;
          }
          keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
            return !indexSet.has(keysIndex);
          });
          onChange(newValue.filter(function(_, valueIndex) {
            return !indexSet.has(valueIndex);
          }));
        },
        move: function move2(from2, to) {
          if (from2 === to) {
            return;
          }
          var newValue = getNewValue();
          if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
            return;
          }
          keyManager.keys = move(keyManager.keys, from2, to);
          onChange(move(newValue, from2, to));
        }
      };
      var listValue = value || [];
      if (!Array.isArray(listValue)) {
        listValue = [];
        if (true) {
          warning_default(false, "Current value of '".concat(prefixName.join(" > "), "' is not an array type."));
        }
      }
      return children(listValue.map(function(__, index3) {
        var key = keyManager.keys[index3];
        if (key === void 0) {
          keyManager.keys[index3] = keyManager.id;
          key = keyManager.keys[index3];
          keyManager.id += 1;
        }
        return {
          name: index3,
          key,
          isListField: true
        };
      }), operations, meta);
    })));
  }
  var List_default = List;

  // node_modules/rc-field-form/es/useForm.js
  var React102 = __toESM(require_react());

  // node_modules/rc-field-form/es/utils/asyncUtil.js
  function allPromiseFinish(promiseList) {
    var hasError = false;
    var count = promiseList.length;
    var results = [];
    if (!promiseList.length) {
      return Promise.resolve([]);
    }
    return new Promise(function(resolve, reject) {
      promiseList.forEach(function(promise, index3) {
        promise.catch(function(e3) {
          hasError = true;
          return e3;
        }).then(function(result) {
          count -= 1;
          results[index3] = result;
          if (count > 0) {
            return;
          }
          if (hasError) {
            reject(results);
          }
          resolve(results);
        });
      });
    });
  }

  // node_modules/rc-field-form/es/utils/NameMap.js
  var SPLIT2 = "__@field_split__";
  function normalize(namePath) {
    return namePath.map(function(cell) {
      return "".concat(_typeof(cell), ":").concat(cell);
    }).join(SPLIT2);
  }
  var NameMap = /* @__PURE__ */ function() {
    function NameMap2() {
      _classCallCheck(this, NameMap2);
      _defineProperty(this, "kvs", /* @__PURE__ */ new Map());
    }
    _createClass(NameMap2, [{
      key: "set",
      value: function set2(key, value) {
        this.kvs.set(normalize(key), value);
      }
    }, {
      key: "get",
      value: function get2(key) {
        return this.kvs.get(normalize(key));
      }
    }, {
      key: "update",
      value: function update(key, updater) {
        var origin2 = this.get(key);
        var next2 = updater(origin2);
        if (!next2) {
          this.delete(key);
        } else {
          this.set(key, next2);
        }
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        this.kvs.delete(normalize(key));
      }
      // Since we only use this in test, let simply realize this
    }, {
      key: "map",
      value: function map(callback) {
        return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
          var cells = key.split(SPLIT2);
          return callback({
            key: cells.map(function(cell) {
              var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type5 = _cell$match2[1], unit3 = _cell$match2[2];
              return type5 === "number" ? Number(unit3) : unit3;
            }),
            value
          });
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON2() {
        var json = {};
        this.map(function(_ref3) {
          var key = _ref3.key, value = _ref3.value;
          json[key.join(".")] = value;
          return null;
        });
        return json;
      }
    }]);
    return NameMap2;
  }();
  var NameMap_default = NameMap;

  // node_modules/rc-field-form/es/useForm.js
  var _excluded9 = ["name"];
  var FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {
    var _this = this;
    _classCallCheck(this, FormStore2);
    _defineProperty(this, "formHooked", false);
    _defineProperty(this, "forceRootUpdate", void 0);
    _defineProperty(this, "subscribable", true);
    _defineProperty(this, "store", {});
    _defineProperty(this, "fieldEntities", []);
    _defineProperty(this, "initialValues", {});
    _defineProperty(this, "callbacks", {});
    _defineProperty(this, "validateMessages", null);
    _defineProperty(this, "preserve", null);
    _defineProperty(this, "lastValidatePromise", null);
    _defineProperty(this, "getForm", function() {
      return {
        getFieldValue: _this.getFieldValue,
        getFieldsValue: _this.getFieldsValue,
        getFieldError: _this.getFieldError,
        getFieldWarning: _this.getFieldWarning,
        getFieldsError: _this.getFieldsError,
        isFieldsTouched: _this.isFieldsTouched,
        isFieldTouched: _this.isFieldTouched,
        isFieldValidating: _this.isFieldValidating,
        isFieldsValidating: _this.isFieldsValidating,
        resetFields: _this.resetFields,
        setFields: _this.setFields,
        setFieldValue: _this.setFieldValue,
        setFieldsValue: _this.setFieldsValue,
        validateFields: _this.validateFields,
        submit: _this.submit,
        _init: true,
        getInternalHooks: _this.getInternalHooks
      };
    });
    _defineProperty(this, "getInternalHooks", function(key) {
      if (key === HOOK_MARK) {
        _this.formHooked = true;
        return {
          dispatch: _this.dispatch,
          initEntityValue: _this.initEntityValue,
          registerField: _this.registerField,
          useSubscribe: _this.useSubscribe,
          setInitialValues: _this.setInitialValues,
          destroyForm: _this.destroyForm,
          setCallbacks: _this.setCallbacks,
          setValidateMessages: _this.setValidateMessages,
          getFields: _this.getFields,
          setPreserve: _this.setPreserve,
          getInitialValue: _this.getInitialValue,
          registerWatch: _this.registerWatch
        };
      }
      warning_default(false, "`getInternalHooks` is internal usage. Should not call directly.");
      return null;
    });
    _defineProperty(this, "useSubscribe", function(subscribable) {
      _this.subscribable = subscribable;
    });
    _defineProperty(this, "prevWithoutPreserves", null);
    _defineProperty(this, "setInitialValues", function(initialValues, init) {
      _this.initialValues = initialValues || {};
      if (init) {
        var _this$prevWithoutPres;
        var nextStore = merge(initialValues, _this.store);
        (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function(_ref) {
          var namePath = _ref.key;
          nextStore = set(nextStore, namePath, get(initialValues, namePath));
        });
        _this.prevWithoutPreserves = null;
        _this.updateStore(nextStore);
      }
    });
    _defineProperty(this, "destroyForm", function(clearOnDestroy) {
      if (clearOnDestroy) {
        _this.updateStore({});
      } else {
        var prevWithoutPreserves = new NameMap_default();
        _this.getFieldEntities(true).forEach(function(entity) {
          if (!_this.isMergedPreserve(entity.isPreserve())) {
            prevWithoutPreserves.set(entity.getNamePath(), true);
          }
        });
        _this.prevWithoutPreserves = prevWithoutPreserves;
      }
    });
    _defineProperty(this, "getInitialValue", function(namePath) {
      var initValue = get(_this.initialValues, namePath);
      return namePath.length ? merge(initValue) : initValue;
    });
    _defineProperty(this, "setCallbacks", function(callbacks) {
      _this.callbacks = callbacks;
    });
    _defineProperty(this, "setValidateMessages", function(validateMessages) {
      _this.validateMessages = validateMessages;
    });
    _defineProperty(this, "setPreserve", function(preserve2) {
      _this.preserve = preserve2;
    });
    _defineProperty(this, "watchList", []);
    _defineProperty(this, "registerWatch", function(callback) {
      _this.watchList.push(callback);
      return function() {
        _this.watchList = _this.watchList.filter(function(fn) {
          return fn !== callback;
        });
      };
    });
    _defineProperty(this, "notifyWatch", function() {
      var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (_this.watchList.length) {
        var values = _this.getFieldsValue();
        var allValues = _this.getFieldsValue(true);
        _this.watchList.forEach(function(callback) {
          callback(values, allValues, namePath);
        });
      }
    });
    _defineProperty(this, "timeoutId", null);
    _defineProperty(this, "warningUnhooked", function() {
      if (!_this.timeoutId && typeof window !== "undefined") {
        _this.timeoutId = setTimeout(function() {
          _this.timeoutId = null;
          if (!_this.formHooked) {
            warning_default(false, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
          }
        });
      }
    });
    _defineProperty(this, "updateStore", function(nextStore) {
      _this.store = nextStore;
    });
    _defineProperty(this, "getFieldEntities", function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!pure) {
        return _this.fieldEntities;
      }
      return _this.fieldEntities.filter(function(field) {
        return field.getNamePath().length;
      });
    });
    _defineProperty(this, "getFieldsMap", function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var cache = new NameMap_default();
      _this.getFieldEntities(pure).forEach(function(field) {
        var namePath = field.getNamePath();
        cache.set(namePath, field);
      });
      return cache;
    });
    _defineProperty(this, "getFieldEntitiesForNamePathList", function(nameList) {
      if (!nameList) {
        return _this.getFieldEntities(true);
      }
      var cache = _this.getFieldsMap(true);
      return nameList.map(function(name) {
        var namePath = getNamePath(name);
        return cache.get(namePath) || {
          INVALIDATE_NAME_PATH: getNamePath(name)
        };
      });
    });
    _defineProperty(this, "getFieldsValue", function(nameList, filterFunc) {
      _this.warningUnhooked();
      var mergedNameList;
      var mergedFilterFunc;
      var mergedStrict;
      if (nameList === true || Array.isArray(nameList)) {
        mergedNameList = nameList;
        mergedFilterFunc = filterFunc;
      } else if (nameList && _typeof(nameList) === "object") {
        mergedStrict = nameList.strict;
        mergedFilterFunc = nameList.filter;
      }
      if (mergedNameList === true && !mergedFilterFunc) {
        return _this.store;
      }
      var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
      var filteredNameList = [];
      fieldEntities.forEach(function(entity) {
        var _isListField, _ref3;
        var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
        if (mergedStrict) {
          var _isList, _ref2;
          if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) {
            return;
          }
        } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) {
          return;
        }
        if (!mergedFilterFunc) {
          filteredNameList.push(namePath);
        } else {
          var meta = "getMeta" in entity ? entity.getMeta() : null;
          if (mergedFilterFunc(meta)) {
            filteredNameList.push(namePath);
          }
        }
      });
      return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
    });
    _defineProperty(this, "getFieldValue", function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      return get(_this.store, namePath);
    });
    _defineProperty(this, "getFieldsError", function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
      return fieldEntities.map(function(entity, index3) {
        if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
          return {
            name: entity.getNamePath(),
            errors: entity.getErrors(),
            warnings: entity.getWarnings()
          };
        }
        return {
          name: getNamePath(nameList[index3]),
          errors: [],
          warnings: []
        };
      });
    });
    _defineProperty(this, "getFieldError", function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.errors;
    });
    _defineProperty(this, "getFieldWarning", function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.warnings;
    });
    _defineProperty(this, "isFieldsTouched", function() {
      _this.warningUnhooked();
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var arg0 = args[0], arg1 = args[1];
      var namePathList;
      var isAllFieldsTouched = false;
      if (args.length === 0) {
        namePathList = null;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = false;
        } else {
          namePathList = null;
          isAllFieldsTouched = arg0;
        }
      } else {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = arg1;
      }
      var fieldEntities = _this.getFieldEntities(true);
      var isFieldTouched = function isFieldTouched2(field) {
        return field.isFieldTouched();
      };
      if (!namePathList) {
        return isAllFieldsTouched ? fieldEntities.every(function(entity) {
          return isFieldTouched(entity) || entity.isList();
        }) : fieldEntities.some(isFieldTouched);
      }
      var map = new NameMap_default();
      namePathList.forEach(function(shortNamePath) {
        map.set(shortNamePath, []);
      });
      fieldEntities.forEach(function(field) {
        var fieldNamePath = field.getNamePath();
        namePathList.forEach(function(shortNamePath) {
          if (shortNamePath.every(function(nameUnit, i) {
            return fieldNamePath[i] === nameUnit;
          })) {
            map.update(shortNamePath, function(list) {
              return [].concat(_toConsumableArray(list), [field]);
            });
          }
        });
      });
      var isNamePathListTouched = function isNamePathListTouched2(entities) {
        return entities.some(isFieldTouched);
      };
      var namePathListEntities = map.map(function(_ref4) {
        var value = _ref4.value;
        return value;
      });
      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
    });
    _defineProperty(this, "isFieldTouched", function(name) {
      _this.warningUnhooked();
      return _this.isFieldsTouched([name]);
    });
    _defineProperty(this, "isFieldsValidating", function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntities();
      if (!nameList) {
        return fieldEntities.some(function(testField) {
          return testField.isFieldValidating();
        });
      }
      var namePathList = nameList.map(getNamePath);
      return fieldEntities.some(function(testField) {
        var fieldNamePath = testField.getNamePath();
        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
      });
    });
    _defineProperty(this, "isFieldValidating", function(name) {
      _this.warningUnhooked();
      return _this.isFieldsValidating([name]);
    });
    _defineProperty(this, "resetWithFieldInitialValue", function() {
      var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var cache = new NameMap_default();
      var fieldEntities = _this.getFieldEntities(true);
      fieldEntities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        var namePath = field.getNamePath();
        if (initialValue !== void 0) {
          var records = cache.get(namePath) || /* @__PURE__ */ new Set();
          records.add({
            entity: field,
            value: initialValue
          });
          cache.set(namePath, records);
        }
      });
      var resetWithFields = function resetWithFields2(entities) {
        entities.forEach(function(field) {
          var initialValue = field.props.initialValue;
          if (initialValue !== void 0) {
            var namePath = field.getNamePath();
            var formInitialValue = _this.getInitialValue(namePath);
            if (formInitialValue !== void 0) {
              warning_default(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
            } else {
              var records = cache.get(namePath);
              if (records && records.size > 1) {
                warning_default(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
              } else if (records) {
                var originValue = _this.getFieldValue(namePath);
                var isListField = field.isListField();
                if (!isListField && (!info.skipExist || originValue === void 0)) {
                  _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
                }
              }
            }
          }
        });
      };
      var requiredFieldEntities;
      if (info.entities) {
        requiredFieldEntities = info.entities;
      } else if (info.namePathList) {
        requiredFieldEntities = [];
        info.namePathList.forEach(function(namePath) {
          var records = cache.get(namePath);
          if (records) {
            var _requiredFieldEntitie;
            (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
              return r2.entity;
            })));
          }
        });
      } else {
        requiredFieldEntities = fieldEntities;
      }
      resetWithFields(requiredFieldEntities);
    });
    _defineProperty(this, "resetFields", function(nameList) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (!nameList) {
        _this.updateStore(merge(_this.initialValues));
        _this.resetWithFieldInitialValue();
        _this.notifyObservers(prevStore, null, {
          type: "reset"
        });
        _this.notifyWatch();
        return;
      }
      var namePathList = nameList.map(getNamePath);
      namePathList.forEach(function(namePath) {
        var initialValue = _this.getInitialValue(namePath);
        _this.updateStore(set(_this.store, namePath, initialValue));
      });
      _this.resetWithFieldInitialValue({
        namePathList
      });
      _this.notifyObservers(prevStore, namePathList, {
        type: "reset"
      });
      _this.notifyWatch(namePathList);
    });
    _defineProperty(this, "setFields", function(fields) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      var namePathList = [];
      fields.forEach(function(fieldData) {
        var name = fieldData.name, data = _objectWithoutProperties(fieldData, _excluded9);
        var namePath = getNamePath(name);
        namePathList.push(namePath);
        if ("value" in data) {
          _this.updateStore(set(_this.store, namePath, data.value));
        }
        _this.notifyObservers(prevStore, [namePath], {
          type: "setField",
          data: fieldData
        });
      });
      _this.notifyWatch(namePathList);
    });
    _defineProperty(this, "getFields", function() {
      var entities = _this.getFieldEntities(true);
      var fields = entities.map(function(field) {
        var namePath = field.getNamePath();
        var meta = field.getMeta();
        var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
          name: namePath,
          value: _this.getFieldValue(namePath)
        });
        Object.defineProperty(fieldData, "originRCField", {
          value: true
        });
        return fieldData;
      });
      return fields;
    });
    _defineProperty(this, "initEntityValue", function(entity) {
      var initialValue = entity.props.initialValue;
      if (initialValue !== void 0) {
        var namePath = entity.getNamePath();
        var prevValue = get(_this.store, namePath);
        if (prevValue === void 0) {
          _this.updateStore(set(_this.store, namePath, initialValue));
        }
      }
    });
    _defineProperty(this, "isMergedPreserve", function(fieldPreserve) {
      var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
      return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
    });
    _defineProperty(this, "registerField", function(entity) {
      _this.fieldEntities.push(entity);
      var namePath = entity.getNamePath();
      _this.notifyWatch([namePath]);
      if (entity.props.initialValue !== void 0) {
        var prevStore = _this.store;
        _this.resetWithFieldInitialValue({
          entities: [entity],
          skipExist: true
        });
        _this.notifyObservers(prevStore, [entity.getNamePath()], {
          type: "valueUpdate",
          source: "internal"
        });
      }
      return function(isListField, preserve2) {
        var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        _this.fieldEntities = _this.fieldEntities.filter(function(item) {
          return item !== entity;
        });
        if (!_this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
          var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
          if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
            return (
              // Only reset when no namePath exist
              !matchNamePath(field.getNamePath(), namePath)
            );
          })) {
            var _prevStore = _this.store;
            _this.updateStore(set(_prevStore, namePath, defaultValue, true));
            _this.notifyObservers(_prevStore, [namePath], {
              type: "remove"
            });
            _this.triggerDependenciesUpdate(_prevStore, namePath);
          }
        }
        _this.notifyWatch([namePath]);
      };
    });
    _defineProperty(this, "dispatch", function(action) {
      switch (action.type) {
        case "updateValue": {
          var namePath = action.namePath, value = action.value;
          _this.updateValue(namePath, value);
          break;
        }
        case "validateField": {
          var _namePath = action.namePath, triggerName = action.triggerName;
          _this.validateFields([_namePath], {
            triggerName
          });
          break;
        }
        default:
      }
    });
    _defineProperty(this, "notifyObservers", function(prevStore, namePathList, info) {
      if (_this.subscribable) {
        var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
          store: _this.getFieldsValue(true)
        });
        _this.getFieldEntities().forEach(function(_ref5) {
          var onStoreChange = _ref5.onStoreChange;
          onStoreChange(prevStore, namePathList, mergedInfo);
        });
      } else {
        _this.forceRootUpdate();
      }
    });
    _defineProperty(this, "triggerDependenciesUpdate", function(prevStore, namePath) {
      var childrenFields = _this.getDependencyChildrenFields(namePath);
      if (childrenFields.length) {
        _this.validateFields(childrenFields);
      }
      _this.notifyObservers(prevStore, childrenFields, {
        type: "dependenciesUpdate",
        relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
      });
      return childrenFields;
    });
    _defineProperty(this, "updateValue", function(name, value) {
      var namePath = getNamePath(name);
      var prevStore = _this.store;
      _this.updateStore(set(_this.store, namePath, value));
      _this.notifyObservers(prevStore, [namePath], {
        type: "valueUpdate",
        source: "internal"
      });
      _this.notifyWatch([namePath]);
      var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
      var onValuesChange = _this.callbacks.onValuesChange;
      if (onValuesChange) {
        var changedValues = cloneByNamePathList(_this.store, [namePath]);
        onValuesChange(changedValues, _this.getFieldsValue());
      }
      _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
    });
    _defineProperty(this, "setFieldsValue", function(store) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (store) {
        var nextStore = merge(_this.store, store);
        _this.updateStore(nextStore);
      }
      _this.notifyObservers(prevStore, null, {
        type: "valueUpdate",
        source: "external"
      });
      _this.notifyWatch();
    });
    _defineProperty(this, "setFieldValue", function(name, value) {
      _this.setFields([{
        name,
        value,
        errors: [],
        warnings: []
      }]);
    });
    _defineProperty(this, "getDependencyChildrenFields", function(rootNamePath) {
      var children = /* @__PURE__ */ new Set();
      var childrenFields = [];
      var dependencies2fields = new NameMap_default();
      _this.getFieldEntities().forEach(function(field) {
        var dependencies = field.props.dependencies;
        (dependencies || []).forEach(function(dependency) {
          var dependencyNamePath = getNamePath(dependency);
          dependencies2fields.update(dependencyNamePath, function() {
            var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
            fields.add(field);
            return fields;
          });
        });
      });
      var fillChildren = function fillChildren2(namePath) {
        var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
        fields.forEach(function(field) {
          if (!children.has(field)) {
            children.add(field);
            var fieldNamePath = field.getNamePath();
            if (field.isFieldDirty() && fieldNamePath.length) {
              childrenFields.push(fieldNamePath);
              fillChildren2(fieldNamePath);
            }
          }
        });
      };
      fillChildren(rootNamePath);
      return childrenFields;
    });
    _defineProperty(this, "triggerOnFieldsChange", function(namePathList, filedErrors) {
      var onFieldsChange = _this.callbacks.onFieldsChange;
      if (onFieldsChange) {
        var fields = _this.getFields();
        if (filedErrors) {
          var cache = new NameMap_default();
          filedErrors.forEach(function(_ref6) {
            var name = _ref6.name, errors = _ref6.errors;
            cache.set(name, errors);
          });
          fields.forEach(function(field) {
            field.errors = cache.get(field.name) || field.errors;
          });
        }
        var changedFields = fields.filter(function(_ref7) {
          var fieldName = _ref7.name;
          return containsNamePath(namePathList, fieldName);
        });
        if (changedFields.length) {
          onFieldsChange(changedFields, fields);
        }
      }
    });
    _defineProperty(this, "validateFields", function(arg1, arg2) {
      _this.warningUnhooked();
      var nameList;
      var options;
      if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
        nameList = arg1;
        options = arg2;
      } else {
        options = arg1;
      }
      var provideNameList = !!nameList;
      var namePathList = provideNameList ? nameList.map(getNamePath) : [];
      var promiseList = [];
      var TMP_SPLIT = String(Date.now());
      var validateNamePathList = /* @__PURE__ */ new Set();
      var _ref8 = options || {}, recursive = _ref8.recursive, dirty = _ref8.dirty;
      _this.getFieldEntities(true).forEach(function(field) {
        if (!provideNameList) {
          namePathList.push(field.getNamePath());
        }
        if (!field.props.rules || !field.props.rules.length) {
          return;
        }
        if (dirty && !field.isFieldDirty()) {
          return;
        }
        var fieldNamePath = field.getNamePath();
        validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
          var promise = field.validateRules(_objectSpread2({
            validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
          }, options));
          promiseList.push(promise.then(function() {
            return {
              name: fieldNamePath,
              errors: [],
              warnings: []
            };
          }).catch(function(ruleErrors) {
            var _ruleErrors$forEach;
            var mergedErrors = [];
            var mergedWarnings = [];
            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref9) {
              var warningOnly = _ref9.rule.warningOnly, errors = _ref9.errors;
              if (warningOnly) {
                mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
              } else {
                mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      var summaryPromise = allPromiseFinish(promiseList);
      _this.lastValidatePromise = summaryPromise;
      summaryPromise.catch(function(results) {
        return results;
      }).then(function(results) {
        var resultNamePathList = results.map(function(_ref10) {
          var name = _ref10.name;
          return name;
        });
        _this.notifyObservers(_this.store, resultNamePathList, {
          type: "validateFinish"
        });
        _this.triggerOnFieldsChange(resultNamePathList, results);
      });
      var returnPromise = summaryPromise.then(function() {
        if (_this.lastValidatePromise === summaryPromise) {
          return Promise.resolve(_this.getFieldsValue(namePathList));
        }
        return Promise.reject([]);
      }).catch(function(results) {
        var errorList = results.filter(function(result) {
          return result && result.errors.length;
        });
        return Promise.reject({
          values: _this.getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: _this.lastValidatePromise !== summaryPromise
        });
      });
      returnPromise.catch(function(e3) {
        return e3;
      });
      var triggerNamePathList = namePathList.filter(function(namePath) {
        return validateNamePathList.has(namePath.join(TMP_SPLIT));
      });
      _this.triggerOnFieldsChange(triggerNamePathList);
      return returnPromise;
    });
    _defineProperty(this, "submit", function() {
      _this.warningUnhooked();
      _this.validateFields().then(function(values) {
        var onFinish = _this.callbacks.onFinish;
        if (onFinish) {
          try {
            onFinish(values);
          } catch (err) {
            console.error(err);
          }
        }
      }).catch(function(e3) {
        var onFinishFailed = _this.callbacks.onFinishFailed;
        if (onFinishFailed) {
          onFinishFailed(e3);
        }
      });
    });
    this.forceRootUpdate = forceRootUpdate;
  });
  function useForm(form) {
    var formRef = React102.useRef();
    var _React$useState = React102.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        var forceReRender = function forceReRender2() {
          forceUpdate({});
        };
        var formStore = new FormStore(forceReRender);
        formRef.current = formStore.getForm();
      }
    }
    return [formRef.current];
  }
  var useForm_default = useForm;

  // node_modules/rc-field-form/es/Form.js
  var React104 = __toESM(require_react());

  // node_modules/rc-field-form/es/FormContext.js
  var React103 = __toESM(require_react());
  var FormContext = /* @__PURE__ */ React103.createContext({
    triggerFormChange: function triggerFormChange() {
    },
    triggerFormFinish: function triggerFormFinish() {
    },
    registerForm: function registerForm() {
    },
    unregisterForm: function unregisterForm() {
    }
  });
  var FormProvider = function FormProvider2(_ref) {
    var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
    var formContext = React103.useContext(FormContext);
    var formsRef = React103.useRef({});
    return /* @__PURE__ */ React103.createElement(FormContext.Provider, {
      value: _objectSpread2(_objectSpread2({}, formContext), {}, {
        validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
        // =========================================================
        // =                  Global Form Control                  =
        // =========================================================
        triggerFormChange: function triggerFormChange2(name, changedFields) {
          if (onFormChange) {
            onFormChange(name, {
              changedFields,
              forms: formsRef.current
            });
          }
          formContext.triggerFormChange(name, changedFields);
        },
        triggerFormFinish: function triggerFormFinish2(name, values) {
          if (onFormFinish) {
            onFormFinish(name, {
              values,
              forms: formsRef.current
            });
          }
          formContext.triggerFormFinish(name, values);
        },
        registerForm: function registerForm2(name, form) {
          if (name) {
            formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty({}, name, form));
          }
          formContext.registerForm(name, form);
        },
        unregisterForm: function unregisterForm2(name) {
          var newForms = _objectSpread2({}, formsRef.current);
          delete newForms[name];
          formsRef.current = newForms;
          formContext.unregisterForm(name);
        }
      })
    }, children);
  };
  var FormContext_default = FormContext;

  // node_modules/rc-field-form/es/Form.js
  var _excluded10 = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"];
  var Form = function Form2(_ref, ref) {
    var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve2 = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component9 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, clearOnDestroy = _ref.clearOnDestroy, restProps = _objectWithoutProperties(_ref, _excluded10);
    var nativeElementRef = React104.useRef(null);
    var formContext = React104.useContext(FormContext_default);
    var _useForm = useForm_default(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
    var _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _getInternalHooks.useSubscribe, setInitialValues = _getInternalHooks.setInitialValues, setCallbacks = _getInternalHooks.setCallbacks, setValidateMessages = _getInternalHooks.setValidateMessages, setPreserve = _getInternalHooks.setPreserve, destroyForm = _getInternalHooks.destroyForm;
    React104.useImperativeHandle(ref, function() {
      return _objectSpread2(_objectSpread2({}, formInstance), {}, {
        nativeElement: nativeElementRef.current
      });
    });
    React104.useEffect(function() {
      formContext.registerForm(name, formInstance);
      return function() {
        formContext.unregisterForm(name);
      };
    }, [formContext, formInstance, name]);
    setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
    setCallbacks({
      onValuesChange,
      onFieldsChange: function onFieldsChange(changedFields) {
        formContext.triggerFormChange(name, changedFields);
        if (_onFieldsChange) {
          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
          }
          _onFieldsChange.apply(void 0, [changedFields].concat(rest));
        }
      },
      onFinish: function onFinish(values) {
        formContext.triggerFormFinish(name, values);
        if (_onFinish) {
          _onFinish(values);
        }
      },
      onFinishFailed
    });
    setPreserve(preserve2);
    var mountRef = React104.useRef(null);
    setInitialValues(initialValues, !mountRef.current);
    if (!mountRef.current) {
      mountRef.current = true;
    }
    React104.useEffect(
      function() {
        return function() {
          return destroyForm(clearOnDestroy);
        };
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    var childrenNode;
    var childrenRenderProps = typeof children === "function";
    if (childrenRenderProps) {
      var _values = formInstance.getFieldsValue(true);
      childrenNode = children(_values, formInstance);
    } else {
      childrenNode = children;
    }
    useSubscribe(!childrenRenderProps);
    var prevFieldsRef = React104.useRef();
    React104.useEffect(function() {
      if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
        formInstance.setFields(fields || []);
      }
      prevFieldsRef.current = fields;
    }, [fields, formInstance]);
    var formContextValue = React104.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, formInstance), {}, {
        validateTrigger
      });
    }, [formInstance, validateTrigger]);
    var wrapperNode = /* @__PURE__ */ React104.createElement(ListContext_default.Provider, {
      value: null
    }, /* @__PURE__ */ React104.createElement(FieldContext_default.Provider, {
      value: formContextValue
    }, childrenNode));
    if (Component9 === false) {
      return wrapperNode;
    }
    return /* @__PURE__ */ React104.createElement(Component9, _extends({}, restProps, {
      ref: nativeElementRef,
      onSubmit: function onSubmit(event) {
        event.preventDefault();
        event.stopPropagation();
        formInstance.submit();
      },
      onReset: function onReset(event) {
        var _restProps$onReset;
        event.preventDefault();
        formInstance.resetFields();
        (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 || _restProps$onReset.call(restProps, event);
      }
    }), wrapperNode);
  };
  var Form_default = Form;

  // node_modules/rc-field-form/es/useWatch.js
  var import_react48 = __toESM(require_react());
  function stringify2(value) {
    try {
      return JSON.stringify(value);
    } catch (err) {
      return Math.random();
    }
  }
  var useWatchWarning = true ? function(namePath) {
    var fullyStr = namePath.join("__RC_FIELD_FORM_SPLIT__");
    var nameStrRef = (0, import_react48.useRef)(fullyStr);
    warning_default(nameStrRef.current === fullyStr, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
  } : function() {
  };
  function useWatch() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var dependencies = args[0], _args$ = args[1], _form = _args$ === void 0 ? {} : _args$;
    var options = isFormInstance(_form) ? {
      form: _form
    } : _form;
    var form = options.form;
    var _useState = (0, import_react48.useState)(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
    var valueStr = (0, import_react48.useMemo)(function() {
      return stringify2(value);
    }, [value]);
    var valueStrRef = (0, import_react48.useRef)(valueStr);
    valueStrRef.current = valueStr;
    var fieldContext = (0, import_react48.useContext)(FieldContext_default);
    var formInstance = form || fieldContext;
    var isValidForm = formInstance && formInstance._init;
    if (true) {
      warning_default(args.length === 2 ? form ? isValidForm : true : isValidForm, "useWatch requires a form instance since it can not auto detect from context.");
    }
    var namePath = getNamePath(dependencies);
    var namePathRef = (0, import_react48.useRef)(namePath);
    namePathRef.current = namePath;
    useWatchWarning(namePath);
    (0, import_react48.useEffect)(
      function() {
        if (!isValidForm) {
          return;
        }
        var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks;
        var _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
        var getWatchValue = function getWatchValue2(values, allValues) {
          var watchValue = options.preserve ? allValues : values;
          return typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, namePathRef.current);
        };
        var cancelRegister = registerWatch(function(values, allValues) {
          var newValue = getWatchValue(values, allValues);
          var nextValueStr = stringify2(newValue);
          if (valueStrRef.current !== nextValueStr) {
            valueStrRef.current = nextValueStr;
            setValue(newValue);
          }
        });
        var initialValue = getWatchValue(getFieldsValue(), getFieldsValue(true));
        if (value !== initialValue) {
          setValue(initialValue);
        }
        return cancelRegister;
      },
      // We do not need re-register since namePath content is the same
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [isValidForm]
    );
    return value;
  }
  var useWatch_default = useWatch;

  // node_modules/rc-field-form/es/index.js
  var InternalForm = /* @__PURE__ */ React105.forwardRef(Form_default);
  var RefForm = InternalForm;
  RefForm.FormProvider = FormProvider;
  RefForm.Field = Field_default;
  RefForm.List = List_default;
  RefForm.useForm = useForm_default;
  RefForm.useWatch = useWatch_default;
  var es_default6 = RefForm;

  // node_modules/antd/es/form/context.js
  var FormContext2 = /* @__PURE__ */ React106.createContext({
    labelAlign: "right",
    vertical: false,
    itemRef: () => {
    }
  });
  var NoStyleItemContext = /* @__PURE__ */ React106.createContext(null);
  var FormProvider3 = (props) => {
    const providerProps = omit(props, ["prefixCls"]);
    return /* @__PURE__ */ React106.createElement(FormProvider, Object.assign({}, providerProps));
  };
  var FormItemPrefixContext = /* @__PURE__ */ React106.createContext({
    prefixCls: ""
  });
  var FormItemInputContext = /* @__PURE__ */ React106.createContext({});
  if (true) {
    FormItemInputContext.displayName = "FormItemInputContext";
  }
  var NoFormStyle = ({
    children,
    status,
    override
  }) => {
    const formItemInputContext = React106.useContext(FormItemInputContext);
    const newFormItemInputContext = React106.useMemo(() => {
      const newContext = Object.assign({}, formItemInputContext);
      if (override) {
        delete newContext.isFormItemInput;
      }
      if (status) {
        delete newContext.status;
        delete newContext.hasFeedback;
        delete newContext.feedbackIcon;
      }
      return newContext;
    }, [status, override, formItemInputContext]);
    return /* @__PURE__ */ React106.createElement(FormItemInputContext.Provider, {
      value: newFormItemInputContext
    }, children);
  };
  var VariantContext = /* @__PURE__ */ React106.createContext(void 0);

  // node_modules/antd/es/_util/ContextIsolator.js
  var ContextIsolator = (props) => {
    const {
      space,
      form,
      children
    } = props;
    if (children === void 0 || children === null) {
      return null;
    }
    let result = children;
    if (form) {
      result = /* @__PURE__ */ import_react49.default.createElement(NoFormStyle, {
        override: true,
        status: true
      }, result);
    }
    if (space) {
      result = /* @__PURE__ */ import_react49.default.createElement(NoCompactStyle, null, result);
    }
    return result;
  };
  var ContextIsolator_default = ContextIsolator;

  // node_modules/antd/es/_util/hooks/useClosable.js
  var import_react50 = __toESM(require_react());

  // node_modules/antd/es/_util/extendsObject.js
  function mergeProps(...items) {
    const ret = {};
    items.forEach((item) => {
      if (item) {
        Object.keys(item).forEach((key) => {
          if (item[key] !== void 0) {
            ret[key] = item[key];
          }
        });
      }
    });
    return ret;
  }
  var extendsObject_default = mergeProps;

  // node_modules/antd/es/_util/hooks/useClosable.js
  function pickClosable(context) {
    if (!context) {
      return void 0;
    }
    const {
      closable,
      closeIcon
    } = context;
    return {
      closable,
      closeIcon
    };
  }
  function useClosableConfig(closableCollection) {
    const {
      closable,
      closeIcon
    } = closableCollection || {};
    return import_react50.default.useMemo(() => {
      if (
        // If `closable`, whatever rest be should be true
        !closable && (closable === false || closeIcon === false || closeIcon === null)
      ) {
        return false;
      }
      if (closable === void 0 && closeIcon === void 0) {
        return null;
      }
      let closableConfig = {
        closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0
      };
      if (closable && typeof closable === "object") {
        closableConfig = Object.assign(Object.assign({}, closableConfig), closable);
      }
      return closableConfig;
    }, [closable, closeIcon]);
  }
  var EmptyFallbackCloseCollection = {};
  function useClosable(propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection) {
    const propCloseConfig = useClosableConfig(propCloseCollection);
    const contextCloseConfig = useClosableConfig(contextCloseCollection);
    const [contextLocale] = useLocale_default("global", en_US_default6.global);
    const closeBtnIsDisabled = typeof propCloseConfig !== "boolean" ? !!(propCloseConfig === null || propCloseConfig === void 0 ? void 0 : propCloseConfig.disabled) : false;
    const mergedFallbackCloseCollection = import_react50.default.useMemo(() => Object.assign({
      closeIcon: /* @__PURE__ */ import_react50.default.createElement(CloseOutlined_default2, null)
    }, fallbackCloseCollection), [fallbackCloseCollection]);
    const mergedClosableConfig = import_react50.default.useMemo(() => {
      if (propCloseConfig === false) {
        return false;
      }
      if (propCloseConfig) {
        return extendsObject_default(mergedFallbackCloseCollection, contextCloseConfig, propCloseConfig);
      }
      if (contextCloseConfig === false) {
        return false;
      }
      if (contextCloseConfig) {
        return extendsObject_default(mergedFallbackCloseCollection, contextCloseConfig);
      }
      return !mergedFallbackCloseCollection.closable ? false : mergedFallbackCloseCollection;
    }, [propCloseConfig, contextCloseConfig, mergedFallbackCloseCollection]);
    return import_react50.default.useMemo(() => {
      var _a, _b;
      if (mergedClosableConfig === false) {
        return [false, null, closeBtnIsDisabled, {}];
      }
      const {
        closeIconRender
      } = mergedFallbackCloseCollection;
      const {
        closeIcon
      } = mergedClosableConfig;
      let mergedCloseIcon = closeIcon;
      const ariaOrDataProps = pickAttrs(mergedClosableConfig, true);
      if (mergedCloseIcon !== null && mergedCloseIcon !== void 0) {
        if (closeIconRender) {
          mergedCloseIcon = closeIconRender(closeIcon);
        }
        mergedCloseIcon = /* @__PURE__ */ import_react50.default.isValidElement(mergedCloseIcon) ? /* @__PURE__ */ import_react50.default.cloneElement(mergedCloseIcon, Object.assign(Object.assign(Object.assign({}, mergedCloseIcon.props), {
          "aria-label": (_b = (_a = mergedCloseIcon.props) === null || _a === void 0 ? void 0 : _a["aria-label"]) !== null && _b !== void 0 ? _b : contextLocale.close
        }), ariaOrDataProps)) : /* @__PURE__ */ import_react50.default.createElement("span", Object.assign({
          "aria-label": contextLocale.close
        }, ariaOrDataProps), mergedCloseIcon);
      }
      return [true, mergedCloseIcon, closeBtnIsDisabled, ariaOrDataProps];
    }, [mergedClosableConfig, mergedFallbackCloseCollection]);
  }

  // node_modules/rc-util/es/Dom/styleChecker.js
  var isStyleNameSupport = function isStyleNameSupport2(styleName) {
    if (canUseDom() && window.document.documentElement) {
      var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
      var documentElement = window.document.documentElement;
      return styleNameList.some(function(name) {
        return name in documentElement.style;
      });
    }
    return false;
  };
  var isStyleValueSupport = function isStyleValueSupport2(styleName, value) {
    if (!isStyleNameSupport(styleName)) {
      return false;
    }
    var ele = document.createElement("div");
    var origin2 = ele.style[styleName];
    ele.style[styleName] = value;
    return ele.style[styleName] !== origin2;
  };
  function isStyleSupport(styleName, styleValue) {
    if (!Array.isArray(styleName) && styleValue !== void 0) {
      return isStyleValueSupport(styleName, styleValue);
    }
    return isStyleNameSupport(styleName);
  }

  // node_modules/antd/es/_util/styleChecker.js
  var canUseDocElement = () => canUseDom() && window.document.documentElement;

  // node_modules/antd/es/skeleton/Skeleton.js
  var React117 = __toESM(require_react());
  var import_classnames31 = __toESM(require_classnames());

  // node_modules/antd/es/skeleton/Avatar.js
  var React110 = __toESM(require_react());
  var import_classnames24 = __toESM(require_classnames());

  // node_modules/antd/es/skeleton/Element.js
  var React109 = __toESM(require_react());
  var import_classnames23 = __toESM(require_classnames());
  var Element2 = (props) => {
    const {
      prefixCls,
      className,
      style: style2,
      size,
      shape
    } = props;
    const sizeCls = (0, import_classnames23.default)({
      [`${prefixCls}-lg`]: size === "large",
      [`${prefixCls}-sm`]: size === "small"
    });
    const shapeCls = (0, import_classnames23.default)({
      [`${prefixCls}-circle`]: shape === "circle",
      [`${prefixCls}-square`]: shape === "square",
      [`${prefixCls}-round`]: shape === "round"
    });
    const sizeStyle = React109.useMemo(() => typeof size === "number" ? {
      width: size,
      height: size,
      lineHeight: `${size}px`
    } : {}, [size]);
    return /* @__PURE__ */ React109.createElement("span", {
      className: (0, import_classnames23.default)(prefixCls, sizeCls, shapeCls, className),
      style: Object.assign(Object.assign({}, sizeStyle), style2)
    });
  };
  var Element_default = Element2;

  // node_modules/antd/es/skeleton/style/index.js
  var skeletonClsLoading = new Keyframes_default(`ant-skeleton-loading`, {
    "0%": {
      backgroundPosition: "100% 50%"
    },
    "100%": {
      backgroundPosition: "0 50%"
    }
  });
  var genSkeletonElementCommonSize = (size) => ({
    height: size,
    lineHeight: unit(size)
  });
  var genSkeletonElementAvatarSize = (size) => Object.assign({
    width: size
  }, genSkeletonElementCommonSize(size));
  var genSkeletonColor = (token2) => ({
    background: token2.skeletonLoadingBackground,
    backgroundSize: "400% 100%",
    animationName: skeletonClsLoading,
    animationDuration: token2.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite"
  });
  var genSkeletonElementInputSize = (size, calc) => Object.assign({
    width: calc(size).mul(5).equal(),
    minWidth: calc(size).mul(5).equal()
  }, genSkeletonElementCommonSize(size));
  var genSkeletonElementAvatar = (token2) => {
    const {
      skeletonAvatarCls,
      gradientFromColor,
      controlHeight,
      controlHeightLG,
      controlHeightSM
    } = token2;
    return {
      [skeletonAvatarCls]: Object.assign({
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor
      }, genSkeletonElementAvatarSize(controlHeight)),
      [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
        borderRadius: "50%"
      },
      [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
      [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
    };
  };
  var genSkeletonElementInput = (token2) => {
    const {
      controlHeight,
      borderRadiusSM,
      skeletonInputCls,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor,
      calc
    } = token2;
    return {
      [skeletonInputCls]: Object.assign({
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor,
        borderRadius: borderRadiusSM
      }, genSkeletonElementInputSize(controlHeight, calc)),
      [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG, calc)),
      [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM, calc))
    };
  };
  var genSkeletonElementImageSize = (size) => Object.assign({
    width: size
  }, genSkeletonElementCommonSize(size));
  var genSkeletonElementImage = (token2) => {
    const {
      skeletonImageCls,
      imageSizeBase,
      gradientFromColor,
      borderRadiusSM,
      calc
    } = token2;
    return {
      [skeletonImageCls]: Object.assign(Object.assign({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        verticalAlign: "middle",
        background: gradientFromColor,
        borderRadius: borderRadiusSM
      }, genSkeletonElementImageSize(calc(imageSizeBase).mul(2).equal())), {
        [`${skeletonImageCls}-path`]: {
          fill: "#bfbfbf"
        },
        [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
          maxWidth: calc(imageSizeBase).mul(4).equal(),
          maxHeight: calc(imageSizeBase).mul(4).equal()
        }),
        [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
          borderRadius: "50%"
        }
      }),
      [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
        borderRadius: "50%"
      }
    };
  };
  var genSkeletonElementButtonShape = (token2, size, buttonCls) => {
    const {
      skeletonButtonCls
    } = token2;
    return {
      [`${buttonCls}${skeletonButtonCls}-circle`]: {
        width: size,
        minWidth: size,
        borderRadius: "50%"
      },
      [`${buttonCls}${skeletonButtonCls}-round`]: {
        borderRadius: size
      }
    };
  };
  var genSkeletonElementButtonSize = (size, calc) => Object.assign({
    width: calc(size).mul(2).equal(),
    minWidth: calc(size).mul(2).equal()
  }, genSkeletonElementCommonSize(size));
  var genSkeletonElementButton = (token2) => {
    const {
      borderRadiusSM,
      skeletonButtonCls,
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor,
      calc
    } = token2;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      [skeletonButtonCls]: Object.assign({
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor,
        borderRadius: borderRadiusSM,
        width: calc(controlHeight).mul(2).equal(),
        minWidth: calc(controlHeight).mul(2).equal()
      }, genSkeletonElementButtonSize(controlHeight, calc))
    }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
      [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG, calc))
    }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
      [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM, calc))
    }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
  };
  var genBaseStyle = (token2) => {
    const {
      componentCls,
      skeletonAvatarCls,
      skeletonTitleCls,
      skeletonParagraphCls,
      skeletonButtonCls,
      skeletonInputCls,
      skeletonImageCls,
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor,
      padding,
      marginSM,
      borderRadius,
      titleHeight,
      blockRadius,
      paragraphLiHeight,
      controlHeightXS,
      paragraphMarginTop
    } = token2;
    return {
      [componentCls]: {
        display: "table",
        width: "100%",
        [`${componentCls}-header`]: {
          display: "table-cell",
          paddingInlineEnd: padding,
          verticalAlign: "top",
          // Avatar
          [skeletonAvatarCls]: Object.assign({
            display: "inline-block",
            verticalAlign: "top",
            background: gradientFromColor
          }, genSkeletonElementAvatarSize(controlHeight)),
          [`${skeletonAvatarCls}-circle`]: {
            borderRadius: "50%"
          },
          [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
          [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
        },
        [`${componentCls}-content`]: {
          display: "table-cell",
          width: "100%",
          verticalAlign: "top",
          // Title
          [skeletonTitleCls]: {
            width: "100%",
            height: titleHeight,
            background: gradientFromColor,
            borderRadius: blockRadius,
            [`+ ${skeletonParagraphCls}`]: {
              marginBlockStart: controlHeightSM
            }
          },
          // paragraph
          [skeletonParagraphCls]: {
            padding: 0,
            "> li": {
              width: "100%",
              height: paragraphLiHeight,
              listStyle: "none",
              background: gradientFromColor,
              borderRadius: blockRadius,
              "+ li": {
                marginBlockStart: controlHeightXS
              }
            }
          },
          [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
            width: "61%"
          }
        },
        [`&-round ${componentCls}-content`]: {
          [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
            borderRadius
          }
        }
      },
      [`${componentCls}-with-avatar ${componentCls}-content`]: {
        // Title
        [skeletonTitleCls]: {
          marginBlockStart: marginSM,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: paragraphMarginTop
          }
        }
      },
      // Skeleton element
      [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "auto"
      }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
      // Skeleton Block Button, Input
      [`${componentCls}${componentCls}-block`]: {
        width: "100%",
        [skeletonButtonCls]: {
          width: "100%"
        },
        [skeletonInputCls]: {
          width: "100%"
        }
      },
      // With active animation
      [`${componentCls}${componentCls}-active`]: {
        [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token2))
      }
    };
  };
  var prepareComponentToken3 = (token2) => {
    const {
      colorFillContent,
      colorFill
    } = token2;
    const gradientFromColor = colorFillContent;
    const gradientToColor = colorFill;
    return {
      color: gradientFromColor,
      colorGradientEnd: gradientToColor,
      gradientFromColor,
      gradientToColor,
      titleHeight: token2.controlHeight / 2,
      blockRadius: token2.borderRadiusSM,
      paragraphMarginTop: token2.marginLG + token2.marginXXS,
      paragraphLiHeight: token2.controlHeight / 2
    };
  };
  var style_default5 = genStyleHooks("Skeleton", (token2) => {
    const {
      componentCls,
      calc
    } = token2;
    const skeletonToken = merge2(token2, {
      skeletonAvatarCls: `${componentCls}-avatar`,
      skeletonTitleCls: `${componentCls}-title`,
      skeletonParagraphCls: `${componentCls}-paragraph`,
      skeletonButtonCls: `${componentCls}-button`,
      skeletonInputCls: `${componentCls}-input`,
      skeletonImageCls: `${componentCls}-image`,
      imageSizeBase: calc(token2.controlHeight).mul(1.5).equal(),
      borderRadius: 100,
      // Large number to make capsule shape
      skeletonLoadingBackground: `linear-gradient(90deg, ${token2.gradientFromColor} 25%, ${token2.gradientToColor} 37%, ${token2.gradientFromColor} 63%)`,
      skeletonLoadingMotionDuration: "1.4s"
    });
    return [genBaseStyle(skeletonToken)];
  }, prepareComponentToken3, {
    deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
  });

  // node_modules/antd/es/skeleton/Avatar.js
  var SkeletonAvatar = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      active,
      shape = "circle",
      size = "default"
    } = props;
    const {
      getPrefixCls
    } = React110.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default5(prefixCls);
    const otherProps = omit(props, ["prefixCls", "className"]);
    const cls3 = (0, import_classnames24.default)(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, className, rootClassName, hashId, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React110.createElement("div", {
      className: cls3
    }, /* @__PURE__ */ React110.createElement(Element_default, Object.assign({
      prefixCls: `${prefixCls}-avatar`,
      shape,
      size
    }, otherProps))));
  };
  var Avatar_default = SkeletonAvatar;

  // node_modules/antd/es/skeleton/Button.js
  var React111 = __toESM(require_react());
  var import_classnames25 = __toESM(require_classnames());
  var SkeletonButton = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      active,
      block = false,
      size = "default"
    } = props;
    const {
      getPrefixCls
    } = React111.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default5(prefixCls);
    const otherProps = omit(props, ["prefixCls"]);
    const cls3 = (0, import_classnames25.default)(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    }, className, rootClassName, hashId, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React111.createElement("div", {
      className: cls3
    }, /* @__PURE__ */ React111.createElement(Element_default, Object.assign({
      prefixCls: `${prefixCls}-button`,
      size
    }, otherProps))));
  };
  var Button_default = SkeletonButton;

  // node_modules/antd/es/skeleton/Image.js
  var React112 = __toESM(require_react());
  var import_classnames26 = __toESM(require_classnames());
  var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
  var SkeletonImage = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      active
    } = props;
    const {
      getPrefixCls
    } = React112.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default5(prefixCls);
    const cls3 = (0, import_classnames26.default)(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, className, rootClassName, hashId, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React112.createElement("div", {
      className: cls3
    }, /* @__PURE__ */ React112.createElement("div", {
      className: (0, import_classnames26.default)(`${prefixCls}-image`, className),
      style: style2
    }, /* @__PURE__ */ React112.createElement("svg", {
      viewBox: "0 0 1098 1024",
      xmlns: "http://www.w3.org/2000/svg",
      className: `${prefixCls}-image-svg`
    }, /* @__PURE__ */ React112.createElement("title", null, "Image placeholder"), /* @__PURE__ */ React112.createElement("path", {
      d: path,
      className: `${prefixCls}-image-path`
    })))));
  };
  var Image_default = SkeletonImage;

  // node_modules/antd/es/skeleton/Input.js
  var React113 = __toESM(require_react());
  var import_classnames27 = __toESM(require_classnames());
  var SkeletonInput = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      active,
      block,
      size = "default"
    } = props;
    const {
      getPrefixCls
    } = React113.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default5(prefixCls);
    const otherProps = omit(props, ["prefixCls"]);
    const cls3 = (0, import_classnames27.default)(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    }, className, rootClassName, hashId, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React113.createElement("div", {
      className: cls3
    }, /* @__PURE__ */ React113.createElement(Element_default, Object.assign({
      prefixCls: `${prefixCls}-input`,
      size
    }, otherProps))));
  };
  var Input_default = SkeletonInput;

  // node_modules/antd/es/skeleton/Node.js
  var React114 = __toESM(require_react());
  var import_classnames28 = __toESM(require_classnames());
  var SkeletonNode = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      active,
      children
    } = props;
    const {
      getPrefixCls
    } = React114.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default5(prefixCls);
    const cls3 = (0, import_classnames28.default)(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, hashId, className, rootClassName, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React114.createElement("div", {
      className: cls3
    }, /* @__PURE__ */ React114.createElement("div", {
      className: (0, import_classnames28.default)(`${prefixCls}-image`, className),
      style: style2
    }, children)));
  };
  var Node_default = SkeletonNode;

  // node_modules/antd/es/skeleton/Paragraph.js
  var React115 = __toESM(require_react());
  var import_classnames29 = __toESM(require_classnames());
  var getWidth = (index3, props) => {
    const {
      width,
      rows = 2
    } = props;
    if (Array.isArray(width)) {
      return width[index3];
    }
    if (rows - 1 === index3) {
      return width;
    }
    return void 0;
  };
  var Paragraph = (props) => {
    const {
      prefixCls,
      className,
      style: style2,
      rows = 0
    } = props;
    const rowList = Array.from({
      length: rows
    }).map((_, index3) => (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ React115.createElement("li", {
        key: index3,
        style: {
          width: getWidth(index3, props)
        }
      })
    ));
    return /* @__PURE__ */ React115.createElement("ul", {
      className: (0, import_classnames29.default)(prefixCls, className),
      style: style2
    }, rowList);
  };
  var Paragraph_default = Paragraph;

  // node_modules/antd/es/skeleton/Title.js
  var React116 = __toESM(require_react());
  var import_classnames30 = __toESM(require_classnames());
  var Title = ({
    prefixCls,
    className,
    width,
    style: style2
  }) => (
    // biome-ignore lint/a11y/useHeadingContent: HOC here
    /* @__PURE__ */ React116.createElement("h3", {
      className: (0, import_classnames30.default)(prefixCls, className),
      style: Object.assign({
        width
      }, style2)
    })
  );
  var Title_default = Title;

  // node_modules/antd/es/skeleton/Skeleton.js
  function getComponentProps(prop) {
    if (prop && typeof prop === "object") {
      return prop;
    }
    return {};
  }
  function getAvatarBasicProps(hasTitle, hasParagraph) {
    if (hasTitle && !hasParagraph) {
      return {
        size: "large",
        shape: "square"
      };
    }
    return {
      size: "large",
      shape: "circle"
    };
  }
  function getTitleBasicProps(hasAvatar, hasParagraph) {
    if (!hasAvatar && hasParagraph) {
      return {
        width: "38%"
      };
    }
    if (hasAvatar && hasParagraph) {
      return {
        width: "50%"
      };
    }
    return {};
  }
  function getParagraphBasicProps(hasAvatar, hasTitle) {
    const basicProps = {};
    if (!hasAvatar || !hasTitle) {
      basicProps.width = "61%";
    }
    if (!hasAvatar && hasTitle) {
      basicProps.rows = 3;
    } else {
      basicProps.rows = 2;
    }
    return basicProps;
  }
  var Skeleton = (props) => {
    const {
      prefixCls: customizePrefixCls,
      loading,
      className,
      rootClassName,
      style: style2,
      children,
      avatar = false,
      title = true,
      paragraph = true,
      active,
      round: round2
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("skeleton");
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default5(prefixCls);
    if (loading || !("loading" in props)) {
      const hasAvatar = !!avatar;
      const hasTitle = !!title;
      const hasParagraph = !!paragraph;
      let avatarNode;
      if (hasAvatar) {
        const avatarProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-avatar`
        }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
        avatarNode = /* @__PURE__ */ React117.createElement("div", {
          className: `${prefixCls}-header`
        }, /* @__PURE__ */ React117.createElement(Element_default, Object.assign({}, avatarProps)));
      }
      let contentNode;
      if (hasTitle || hasParagraph) {
        let $title;
        if (hasTitle) {
          const titleProps = Object.assign(Object.assign({
            prefixCls: `${prefixCls}-title`
          }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
          $title = /* @__PURE__ */ React117.createElement(Title_default, Object.assign({}, titleProps));
        }
        let paragraphNode;
        if (hasParagraph) {
          const paragraphProps = Object.assign(Object.assign({
            prefixCls: `${prefixCls}-paragraph`
          }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
          paragraphNode = /* @__PURE__ */ React117.createElement(Paragraph_default, Object.assign({}, paragraphProps));
        }
        contentNode = /* @__PURE__ */ React117.createElement("div", {
          className: `${prefixCls}-content`
        }, $title, paragraphNode);
      }
      const cls3 = (0, import_classnames31.default)(prefixCls, {
        [`${prefixCls}-with-avatar`]: hasAvatar,
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-round`]: round2
      }, contextClassName, className, rootClassName, hashId, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ React117.createElement("div", {
        className: cls3,
        style: Object.assign(Object.assign({}, contextStyle), style2)
      }, avatarNode, contentNode));
    }
    return children !== null && children !== void 0 ? children : null;
  };
  Skeleton.Button = Button_default;
  Skeleton.Avatar = Avatar_default;
  Skeleton.Input = Input_default;
  Skeleton.Image = Image_default;
  Skeleton.Node = Node_default;
  if (true) {
    Skeleton.displayName = "Skeleton";
  }
  var Skeleton_default = Skeleton;

  // node_modules/antd/es/skeleton/index.js
  var skeleton_default = Skeleton_default;

  // node_modules/antd/es/watermark/context.js
  var React118 = __toESM(require_react());
  function voidFunc() {
  }
  var WatermarkContext = /* @__PURE__ */ React118.createContext({
    add: voidFunc,
    remove: voidFunc
  });
  function usePanelRef(panelSelector) {
    const watermark = React118.useContext(WatermarkContext);
    const panelEleRef = React118.useRef(null);
    const panelRef = useEvent((ele) => {
      if (ele) {
        const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
        watermark.add(innerContentEle);
        panelEleRef.current = innerContentEle;
      } else {
        watermark.remove(panelEleRef.current);
      }
    });
    return panelRef;
  }

  // node_modules/antd/es/modal/shared.js
  var import_react53 = __toESM(require_react());

  // node_modules/antd/es/modal/components/NormalCancelBtn.js
  var import_react51 = __toESM(require_react());
  var NormalCancelBtn = () => {
    const {
      cancelButtonProps,
      cancelTextLocale,
      onCancel
    } = (0, import_react51.useContext)(ModalContext);
    return /* @__PURE__ */ import_react51.default.createElement(button_default2, Object.assign({
      onClick: onCancel
    }, cancelButtonProps), cancelTextLocale);
  };
  var NormalCancelBtn_default = NormalCancelBtn;

  // node_modules/antd/es/modal/components/NormalOkBtn.js
  var import_react52 = __toESM(require_react());
  var NormalOkBtn = () => {
    const {
      confirmLoading,
      okButtonProps,
      okType,
      okTextLocale,
      onOk
    } = (0, import_react52.useContext)(ModalContext);
    return /* @__PURE__ */ import_react52.default.createElement(button_default2, Object.assign({}, convertLegacyProps(okType), {
      loading: confirmLoading,
      onClick: onOk
    }, okButtonProps), okTextLocale);
  };
  var NormalOkBtn_default = NormalOkBtn;

  // node_modules/antd/es/modal/shared.js
  function renderCloseIcon(prefixCls, closeIcon) {
    return /* @__PURE__ */ import_react53.default.createElement("span", {
      className: `${prefixCls}-close-x`
    }, closeIcon || /* @__PURE__ */ import_react53.default.createElement(CloseOutlined_default2, {
      className: `${prefixCls}-close-icon`
    }));
  }
  var Footer = (props) => {
    const {
      okText,
      okType = "primary",
      cancelText,
      confirmLoading,
      onOk,
      onCancel,
      okButtonProps,
      cancelButtonProps,
      footer
    } = props;
    const [locale6] = useLocale_default("Modal", getConfirmLocale());
    const okTextLocale = okText || (locale6 === null || locale6 === void 0 ? void 0 : locale6.okText);
    const cancelTextLocale = cancelText || (locale6 === null || locale6 === void 0 ? void 0 : locale6.cancelText);
    const btnCtxValue = {
      confirmLoading,
      okButtonProps,
      cancelButtonProps,
      okTextLocale,
      cancelTextLocale,
      okType,
      onOk,
      onCancel
    };
    const btnCtxValueMemo = import_react53.default.useMemo(() => btnCtxValue, _toConsumableArray(Object.values(btnCtxValue)));
    let footerNode;
    if (typeof footer === "function" || typeof footer === "undefined") {
      footerNode = /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, /* @__PURE__ */ import_react53.default.createElement(NormalCancelBtn_default, null), /* @__PURE__ */ import_react53.default.createElement(NormalOkBtn_default, null));
      if (typeof footer === "function") {
        footerNode = footer(footerNode, {
          OkBtn: NormalOkBtn_default,
          CancelBtn: NormalCancelBtn_default
        });
      }
      footerNode = /* @__PURE__ */ import_react53.default.createElement(ModalContextProvider, {
        value: btnCtxValueMemo
      }, footerNode);
    } else {
      footerNode = footer;
    }
    return /* @__PURE__ */ import_react53.default.createElement(DisabledContextProvider, {
      disabled: false
    }, footerNode);
  };

  // node_modules/antd/es/grid/style/index.js
  var genGridRowStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // Grid system
      [componentCls]: {
        display: "flex",
        flexFlow: "row wrap",
        minWidth: 0,
        "&::before, &::after": {
          display: "flex"
        },
        "&-no-wrap": {
          flexWrap: "nowrap"
        },
        // The origin of the X-axis
        "&-start": {
          justifyContent: "flex-start"
        },
        // The center of the X-axis
        "&-center": {
          justifyContent: "center"
        },
        // The opposite of the X-axis
        "&-end": {
          justifyContent: "flex-end"
        },
        "&-space-between": {
          justifyContent: "space-between"
        },
        "&-space-around": {
          justifyContent: "space-around"
        },
        "&-space-evenly": {
          justifyContent: "space-evenly"
        },
        // Align at the top
        "&-top": {
          alignItems: "flex-start"
        },
        // Align at the center
        "&-middle": {
          alignItems: "center"
        },
        "&-bottom": {
          alignItems: "flex-end"
        }
      }
    };
  };
  var genGridColStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // Grid system
      [componentCls]: {
        position: "relative",
        maxWidth: "100%",
        // Prevent columns from collapsing when empty
        minHeight: 1
      }
    };
  };
  var genLoopGridColumnsStyle = (token2, sizeCls) => {
    const {
      prefixCls,
      componentCls,
      gridColumns
    } = token2;
    const gridColumnsStyle = {};
    for (let i = gridColumns; i >= 0; i--) {
      if (i === 0) {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
          display: "none"
        };
        gridColumnsStyle[`${componentCls}-push-${i}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}-pull-${i}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
          marginInlineStart: 0
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
          order: 0
        };
      } else {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [
          // https://github.com/ant-design/ant-design/issues/44456
          // Form set `display: flex` on Col which will override `display: block`.
          // Let's get it from css variable to support override.
          {
            ["--ant-display"]: "block",
            // Fallback to display if variable not support
            display: "block"
          },
          {
            display: "var(--ant-display)",
            flex: `0 0 ${i / gridColumns * 100}%`,
            maxWidth: `${i / gridColumns * 100}%`
          }
        ];
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
          insetInlineStart: `${i / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
          insetInlineEnd: `${i / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
          marginInlineStart: `${i / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
          order: i
        };
      }
    }
    gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = {
      flex: `var(--${prefixCls}${sizeCls}-flex)`
    };
    return gridColumnsStyle;
  };
  var genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
  var genGridMediaStyle = (token2, screenSize, sizeCls) => ({
    [`@media (min-width: ${unit(screenSize)})`]: Object.assign({}, genGridStyle(token2, sizeCls))
  });
  var prepareRowComponentToken = () => ({});
  var prepareColComponentToken = () => ({});
  var useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
  var getMediaSize = (token2) => {
    const mediaSizesMap = {
      xs: token2.screenXSMin,
      sm: token2.screenSMMin,
      md: token2.screenMDMin,
      lg: token2.screenLGMin,
      xl: token2.screenXLMin,
      xxl: token2.screenXXLMin
    };
    return mediaSizesMap;
  };
  var useColStyle = genStyleHooks("Grid", (token2) => {
    const gridToken = merge2(token2, {
      gridColumns: 24
      // Row is divided into 24 parts in Grid
    });
    const gridMediaSizesMap = getMediaSize(gridToken);
    delete gridMediaSizesMap.xs;
    return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], `-${key}`)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
  }, prepareColComponentToken);

  // node_modules/antd/es/modal/style/index.js
  function box(position3) {
    return {
      position: position3,
      inset: 0
    };
  }
  var genModalMaskStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return [{
      [`${componentCls}-root`]: {
        [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
          // reset scale avoid mousePosition bug
          transform: "none",
          opacity: 0,
          animationDuration: token2.motionDurationSlow,
          // https://github.com/ant-design/ant-design/issues/11777
          userSelect: "none"
        },
        // https://github.com/ant-design/ant-design/issues/37329
        // https://github.com/ant-design/ant-design/issues/40272
        [`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: {
          pointerEvents: "none"
        },
        [`${componentCls}-mask`]: Object.assign(Object.assign({}, box("fixed")), {
          zIndex: token2.zIndexPopupBase,
          height: "100%",
          backgroundColor: token2.colorBgMask,
          pointerEvents: "none",
          [`${componentCls}-hidden`]: {
            display: "none"
          }
        }),
        [`${componentCls}-wrap`]: Object.assign(Object.assign({}, box("fixed")), {
          zIndex: token2.zIndexPopupBase,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        })
      }
    }, {
      [`${componentCls}-root`]: initFadeMotion(token2)
    }];
  };
  var genModalStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [
      // ======================== Root =========================
      {
        [`${componentCls}-root`]: {
          [`${componentCls}-wrap-rtl`]: {
            direction: "rtl"
          },
          [`${componentCls}-centered`]: {
            textAlign: "center",
            "&::before": {
              display: "inline-block",
              width: 0,
              height: "100%",
              verticalAlign: "middle",
              content: '""'
            },
            [componentCls]: {
              top: 0,
              display: "inline-block",
              paddingBottom: 0,
              textAlign: "start",
              verticalAlign: "middle"
            }
          },
          [`@media (max-width: ${token2.screenSMMax}px)`]: {
            [componentCls]: {
              maxWidth: "calc(100vw - 16px)",
              margin: `${unit(token2.marginXS)} auto`
            },
            [`${componentCls}-centered`]: {
              [componentCls]: {
                flex: 1
              }
            }
          }
        }
      },
      // ======================== Modal ========================
      {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          pointerEvents: "none",
          position: "relative",
          top: 100,
          width: "auto",
          maxWidth: `calc(100vw - ${unit(token2.calc(token2.margin).mul(2).equal())})`,
          margin: "0 auto",
          paddingBottom: token2.paddingLG,
          [`${componentCls}-title`]: {
            margin: 0,
            color: token2.titleColor,
            fontWeight: token2.fontWeightStrong,
            fontSize: token2.titleFontSize,
            lineHeight: token2.titleLineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-content`]: {
            position: "relative",
            backgroundColor: token2.contentBg,
            backgroundClip: "padding-box",
            border: 0,
            borderRadius: token2.borderRadiusLG,
            boxShadow: token2.boxShadow,
            pointerEvents: "auto",
            padding: token2.contentPadding
          },
          [`${componentCls}-close`]: Object.assign({
            position: "absolute",
            top: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
            insetInlineEnd: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
            zIndex: token2.calc(token2.zIndexPopupBase).add(10).equal(),
            padding: 0,
            color: token2.modalCloseIconColor,
            fontWeight: token2.fontWeightStrong,
            lineHeight: 1,
            textDecoration: "none",
            background: "transparent",
            borderRadius: token2.borderRadiusSM,
            width: token2.modalCloseBtnSize,
            height: token2.modalCloseBtnSize,
            border: 0,
            outline: 0,
            cursor: "pointer",
            transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
            "&-x": {
              display: "flex",
              fontSize: token2.fontSizeLG,
              fontStyle: "normal",
              lineHeight: unit(token2.modalCloseBtnSize),
              justifyContent: "center",
              textTransform: "none",
              textRendering: "auto"
            },
            "&:disabled": {
              pointerEvents: "none"
            },
            "&:hover": {
              color: token2.modalCloseIconHoverColor,
              backgroundColor: token2.colorBgTextHover,
              textDecoration: "none"
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            }
          }, genFocusStyle(token2)),
          [`${componentCls}-header`]: {
            color: token2.colorText,
            background: token2.headerBg,
            borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
            marginBottom: token2.headerMarginBottom,
            padding: token2.headerPadding,
            borderBottom: token2.headerBorderBottom
          },
          [`${componentCls}-body`]: {
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            wordWrap: "break-word",
            padding: token2.bodyPadding,
            [`${componentCls}-body-skeleton`]: {
              width: "100%",
              height: "100%",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              margin: `${unit(token2.margin)} auto`
            }
          },
          [`${componentCls}-footer`]: {
            textAlign: "end",
            background: token2.footerBg,
            marginTop: token2.footerMarginTop,
            padding: token2.footerPadding,
            borderTop: token2.footerBorderTop,
            borderRadius: token2.footerBorderRadius,
            [`> ${token2.antCls}-btn + ${token2.antCls}-btn`]: {
              marginInlineStart: token2.marginXS
            }
          },
          [`${componentCls}-open`]: {
            overflow: "hidden"
          }
        })
      },
      // ======================== Pure =========================
      {
        [`${componentCls}-pure-panel`]: {
          top: "auto",
          padding: 0,
          display: "flex",
          flexDirection: "column",
          [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
            display: "flex",
            flexDirection: "column",
            flex: "auto"
          },
          [`${componentCls}-confirm-body`]: {
            marginBottom: "auto"
          }
        }
      }
    ];
  };
  var genRTLStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl",
          [`${componentCls}-confirm-body`]: {
            direction: "rtl"
          }
        }
      }
    };
  };
  var genResponsiveWidthStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const oriGridMediaSizesMap = getMediaSize(token2);
    const gridMediaSizesMap = Object.assign({}, oriGridMediaSizesMap);
    delete gridMediaSizesMap.xs;
    const cssVarPrefix = `--${componentCls.replace(".", "")}-`;
    const responsiveStyles = Object.keys(gridMediaSizesMap).map((key) => ({
      [`@media (min-width: ${unit(gridMediaSizesMap[key])})`]: {
        width: `var(${cssVarPrefix}${key}-width)`
      }
    }));
    return {
      [`${componentCls}-root`]: {
        [componentCls]: [].concat(_toConsumableArray(Object.keys(oriGridMediaSizesMap).map((currentKey, index3) => {
          const previousKey = Object.keys(oriGridMediaSizesMap)[index3 - 1];
          return previousKey ? {
            [`${cssVarPrefix}${currentKey}-width`]: `var(${cssVarPrefix}${previousKey}-width)`
          } : null;
        })), [{
          width: `var(${cssVarPrefix}xs-width)`
        }], _toConsumableArray(responsiveStyles))
      }
    };
  };
  var prepareToken2 = (token2) => {
    const headerPaddingVertical = token2.padding;
    const headerFontSize = token2.fontSizeHeading5;
    const headerLineHeight = token2.lineHeightHeading5;
    const modalToken = merge2(token2, {
      modalHeaderHeight: token2.calc(token2.calc(headerLineHeight).mul(headerFontSize).equal()).add(token2.calc(headerPaddingVertical).mul(2).equal()).equal(),
      modalFooterBorderColorSplit: token2.colorSplit,
      modalFooterBorderStyle: token2.lineType,
      modalFooterBorderWidth: token2.lineWidth,
      modalCloseIconColor: token2.colorIcon,
      modalCloseIconHoverColor: token2.colorIconHover,
      modalCloseBtnSize: token2.controlHeight,
      modalConfirmIconSize: token2.fontHeight,
      modalTitleHeight: token2.calc(token2.titleFontSize).mul(token2.titleLineHeight).equal()
    });
    return modalToken;
  };
  var prepareComponentToken4 = (token2) => ({
    footerBg: "transparent",
    headerBg: token2.colorBgElevated,
    titleLineHeight: token2.lineHeightHeading5,
    titleFontSize: token2.fontSizeHeading5,
    contentBg: token2.colorBgElevated,
    titleColor: token2.colorTextHeading,
    // internal
    contentPadding: token2.wireframe ? 0 : `${unit(token2.paddingMD)} ${unit(token2.paddingContentHorizontalLG)}`,
    headerPadding: token2.wireframe ? `${unit(token2.padding)} ${unit(token2.paddingLG)}` : 0,
    headerBorderBottom: token2.wireframe ? `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
    headerMarginBottom: token2.wireframe ? 0 : token2.marginXS,
    bodyPadding: token2.wireframe ? token2.paddingLG : 0,
    footerPadding: token2.wireframe ? `${unit(token2.paddingXS)} ${unit(token2.padding)}` : 0,
    footerBorderTop: token2.wireframe ? `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
    footerBorderRadius: token2.wireframe ? `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}` : 0,
    footerMarginTop: token2.wireframe ? 0 : token2.marginSM,
    confirmBodyPadding: token2.wireframe ? `${unit(token2.padding * 2)} ${unit(token2.padding * 2)} ${unit(token2.paddingLG)}` : 0,
    confirmIconMarginInlineEnd: token2.wireframe ? token2.margin : token2.marginSM,
    confirmBtnsMarginTop: token2.wireframe ? token2.marginLG : token2.marginSM
  });
  var style_default6 = genStyleHooks("Modal", (token2) => {
    const modalToken = prepareToken2(token2);
    return [genModalStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), initZoomMotion(modalToken, "zoom"), genResponsiveWidthStyle(modalToken)];
  }, prepareComponentToken4, {
    unitless: {
      titleLineHeight: true
    }
  });

  // node_modules/antd/es/modal/Modal.js
  var __rest9 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var mousePosition;
  var getClickPosition = (e3) => {
    mousePosition = {
      x: e3.pageX,
      y: e3.pageY
    };
    setTimeout(() => {
      mousePosition = null;
    }, 100);
  };
  if (canUseDocElement()) {
    document.documentElement.addEventListener("click", getClickPosition, true);
  }
  var Modal = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      open: open2,
      wrapClassName,
      centered,
      getContainer: getContainer2,
      focusTriggerAfterClose = true,
      style: style2,
      // Deprecated
      visible,
      width = 520,
      footer,
      classNames: modalClassNames,
      styles: modalStyles,
      children,
      loading,
      confirmLoading,
      zIndex: customizeZIndex,
      mousePosition: customizeMousePosition,
      onOk,
      onCancel,
      destroyOnHidden,
      destroyOnClose
    } = props, restProps = __rest9(props, ["prefixCls", "className", "rootClassName", "open", "wrapClassName", "centered", "getContainer", "focusTriggerAfterClose", "style", "visible", "width", "footer", "classNames", "styles", "children", "loading", "confirmLoading", "zIndex", "mousePosition", "onOk", "onCancel", "destroyOnHidden", "destroyOnClose"]);
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction,
      modal: modalContext
    } = React122.useContext(ConfigContext);
    const handleCancel = (e3) => {
      if (confirmLoading) {
        return;
      }
      onCancel === null || onCancel === void 0 ? void 0 : onCancel(e3);
    };
    const handleOk = (e3) => {
      onOk === null || onOk === void 0 ? void 0 : onOk(e3);
    };
    if (true) {
      const warning6 = devUseWarning("Modal");
      [["visible", "open"], ["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"], ["destroyOnClose", "destroyOnHidden"]].forEach(([deprecatedName, newName]) => {
        warning6.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
    }
    const prefixCls = getPrefixCls("modal", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default6(prefixCls, rootCls);
    const wrapClassNameExtended = (0, import_classnames32.default)(wrapClassName, {
      [`${prefixCls}-centered`]: centered !== null && centered !== void 0 ? centered : modalContext === null || modalContext === void 0 ? void 0 : modalContext.centered,
      [`${prefixCls}-wrap-rtl`]: direction === "rtl"
    });
    const dialogFooter = footer !== null && !loading ? /* @__PURE__ */ React122.createElement(Footer, Object.assign({}, props, {
      onOk: handleOk,
      onCancel: handleCancel
    })) : null;
    const [mergedClosable, mergedCloseIcon, closeBtnIsDisabled, ariaProps] = useClosable(pickClosable(props), pickClosable(modalContext), {
      closable: true,
      closeIcon: /* @__PURE__ */ React122.createElement(CloseOutlined_default2, {
        className: `${prefixCls}-close-icon`
      }),
      closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
    });
    const panelRef = usePanelRef(`.${prefixCls}-content`);
    const [zIndex, contextZIndex] = useZIndex("Modal", customizeZIndex);
    const [numWidth, responsiveWidth] = React122.useMemo(() => {
      if (width && typeof width === "object") {
        return [void 0, width];
      }
      return [width, void 0];
    }, [width]);
    const responsiveWidthVars = React122.useMemo(() => {
      const vars = {};
      if (responsiveWidth) {
        Object.keys(responsiveWidth).forEach((breakpoint) => {
          const breakpointWidth = responsiveWidth[breakpoint];
          if (breakpointWidth !== void 0) {
            vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === "number" ? `${breakpointWidth}px` : breakpointWidth;
          }
        });
      }
      return vars;
    }, [responsiveWidth]);
    return wrapCSSVar(/* @__PURE__ */ React122.createElement(ContextIsolator_default, {
      form: true,
      space: true
    }, /* @__PURE__ */ React122.createElement(zindexContext_default.Provider, {
      value: contextZIndex
    }, /* @__PURE__ */ React122.createElement(es_default4, Object.assign({
      width: numWidth
    }, restProps, {
      zIndex,
      getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
      prefixCls,
      rootClassName: (0, import_classnames32.default)(hashId, rootClassName, cssVarCls, rootCls),
      footer: dialogFooter,
      visible: open2 !== null && open2 !== void 0 ? open2 : visible,
      mousePosition: customizeMousePosition !== null && customizeMousePosition !== void 0 ? customizeMousePosition : mousePosition,
      onClose: handleCancel,
      closable: mergedClosable ? Object.assign({
        disabled: closeBtnIsDisabled,
        closeIcon: mergedCloseIcon
      }, ariaProps) : mergedClosable,
      closeIcon: mergedCloseIcon,
      focusTriggerAfterClose,
      transitionName: getTransitionName2(rootPrefixCls, "zoom", props.transitionName),
      maskTransitionName: getTransitionName2(rootPrefixCls, "fade", props.maskTransitionName),
      className: (0, import_classnames32.default)(hashId, className, modalContext === null || modalContext === void 0 ? void 0 : modalContext.className),
      style: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.style), style2), responsiveWidthVars),
      classNames: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.classNames), modalClassNames), {
        wrapper: (0, import_classnames32.default)(wrapClassNameExtended, modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.wrapper)
      }),
      styles: Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.styles), modalStyles),
      panelRef,
      // TODO: In the future, destroyOnClose in rc-dialog needs to be upgrade to destroyOnHidden
      destroyOnClose: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyOnClose
    }), loading ? /* @__PURE__ */ React122.createElement(skeleton_default, {
      active: true,
      title: false,
      paragraph: {
        rows: 4
      },
      className: `${prefixCls}-body-skeleton`
    }) : children))));
  };
  var Modal_default = Modal;

  // node_modules/antd/es/modal/style/confirm.js
  var genModalConfirmStyle = (token2) => {
    const {
      componentCls,
      titleFontSize,
      titleLineHeight,
      modalConfirmIconSize,
      fontSize,
      lineHeight,
      modalTitleHeight,
      fontHeight,
      confirmBodyPadding
    } = token2;
    const confirmComponentCls = `${componentCls}-confirm`;
    return {
      [confirmComponentCls]: {
        "&-rtl": {
          direction: "rtl"
        },
        [`${token2.antCls}-modal-header`]: {
          display: "none"
        },
        [`${confirmComponentCls}-body-wrapper`]: Object.assign({}, clearFix()),
        [`&${componentCls} ${componentCls}-body`]: {
          padding: confirmBodyPadding
        },
        // ====================== Body ======================
        [`${confirmComponentCls}-body`]: {
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "start",
          [`> ${token2.iconCls}`]: {
            flex: "none",
            fontSize: modalConfirmIconSize,
            marginInlineEnd: token2.confirmIconMarginInlineEnd,
            marginTop: token2.calc(token2.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
          },
          [`&-has-title > ${token2.iconCls}`]: {
            marginTop: token2.calc(token2.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
          }
        },
        [`${confirmComponentCls}-paragraph`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto",
          rowGap: token2.marginXS,
          // https://github.com/ant-design/ant-design/issues/51912
          maxWidth: `calc(100% - ${unit(token2.marginSM)})`
        },
        // https://github.com/ant-design/ant-design/issues/48159
        [`${token2.iconCls} + ${confirmComponentCls}-paragraph`]: {
          maxWidth: `calc(100% - ${unit(token2.calc(token2.modalConfirmIconSize).add(token2.marginSM).equal())})`
        },
        [`${confirmComponentCls}-title`]: {
          color: token2.colorTextHeading,
          fontWeight: token2.fontWeightStrong,
          fontSize: titleFontSize,
          lineHeight: titleLineHeight
        },
        [`${confirmComponentCls}-content`]: {
          color: token2.colorText,
          fontSize,
          lineHeight
        },
        // ===================== Footer =====================
        [`${confirmComponentCls}-btns`]: {
          textAlign: "end",
          marginTop: token2.confirmBtnsMarginTop,
          [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
            marginBottom: 0,
            marginInlineStart: token2.marginXS
          }
        }
      },
      [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorError
      },
      [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorWarning
      },
      [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorInfo
      },
      [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorSuccess
      }
    };
  };
  var confirm_default = genSubStyleComponent(["Modal", "confirm"], (token2) => {
    const modalToken = prepareToken2(token2);
    return [genModalConfirmStyle(modalToken)];
  }, prepareComponentToken4, {
    // confirm is weak than modal since no conflict here
    order: -1e3
  });

  // node_modules/antd/es/modal/ConfirmDialog.js
  var __rest10 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function ConfirmContent(props) {
    const {
      prefixCls,
      icon,
      okText,
      cancelText,
      confirmPrefixCls,
      type: type5,
      okCancel,
      footer,
      // Legacy for static function usage
      locale: staticLocale
    } = props, resetProps = __rest10(props, ["prefixCls", "icon", "okText", "cancelText", "confirmPrefixCls", "type", "okCancel", "footer", "locale"]);
    if (true) {
      const warning6 = devUseWarning("Modal");
      true ? warning6(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
    }
    let mergedIcon = icon;
    if (!icon && icon !== null) {
      switch (type5) {
        case "info":
          mergedIcon = /* @__PURE__ */ React123.createElement(InfoCircleFilled_default2, null);
          break;
        case "success":
          mergedIcon = /* @__PURE__ */ React123.createElement(CheckCircleFilled_default2, null);
          break;
        case "error":
          mergedIcon = /* @__PURE__ */ React123.createElement(CloseCircleFilled_default2, null);
          break;
        default:
          mergedIcon = /* @__PURE__ */ React123.createElement(ExclamationCircleFilled_default2, null);
      }
    }
    const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type5 === "confirm";
    const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
    const [locale6] = useLocale_default("Modal");
    const mergedLocale = staticLocale || locale6;
    const okTextLocale = okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText);
    const cancelTextLocale = cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText);
    const btnCtxValue = Object.assign({
      autoFocusButton,
      cancelTextLocale,
      okTextLocale,
      mergedOkCancel
    }, resetProps);
    const btnCtxValueMemo = React123.useMemo(() => btnCtxValue, _toConsumableArray(Object.values(btnCtxValue)));
    const footerOriginNode = /* @__PURE__ */ React123.createElement(React123.Fragment, null, /* @__PURE__ */ React123.createElement(ConfirmCancelBtn_default, null), /* @__PURE__ */ React123.createElement(ConfirmOkBtn_default, null));
    const hasTitle = props.title !== void 0 && props.title !== null;
    const bodyCls = `${confirmPrefixCls}-body`;
    return /* @__PURE__ */ React123.createElement("div", {
      className: `${confirmPrefixCls}-body-wrapper`
    }, /* @__PURE__ */ React123.createElement("div", {
      className: (0, import_classnames33.default)(bodyCls, {
        [`${bodyCls}-has-title`]: hasTitle
      })
    }, mergedIcon, /* @__PURE__ */ React123.createElement("div", {
      className: `${confirmPrefixCls}-paragraph`
    }, hasTitle && /* @__PURE__ */ React123.createElement("span", {
      className: `${confirmPrefixCls}-title`
    }, props.title), /* @__PURE__ */ React123.createElement("div", {
      className: `${confirmPrefixCls}-content`
    }, props.content))), footer === void 0 || typeof footer === "function" ? /* @__PURE__ */ React123.createElement(ModalContextProvider, {
      value: btnCtxValueMemo
    }, /* @__PURE__ */ React123.createElement("div", {
      className: `${confirmPrefixCls}-btns`
    }, typeof footer === "function" ? footer(footerOriginNode, {
      OkBtn: ConfirmOkBtn_default,
      CancelBtn: ConfirmCancelBtn_default
    }) : footerOriginNode)) : footer, /* @__PURE__ */ React123.createElement(confirm_default, {
      prefixCls
    }));
  }
  var ConfirmDialog = (props) => {
    const {
      close,
      zIndex,
      maskStyle,
      direction,
      prefixCls,
      wrapClassName,
      rootPrefixCls,
      bodyStyle,
      closable = false,
      onConfirm,
      styles
    } = props;
    if (true) {
      const warning6 = devUseWarning("Modal");
      [["visible", "open"], ["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"]].forEach(([deprecatedName, newName]) => {
        warning6.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
    }
    const confirmPrefixCls = `${prefixCls}-confirm`;
    const width = props.width || 416;
    const style2 = props.style || {};
    const mask = props.mask === void 0 ? true : props.mask;
    const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
    const classString = (0, import_classnames33.default)(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
      [`${confirmPrefixCls}-rtl`]: direction === "rtl"
    }, props.className);
    const [, token2] = useToken();
    const mergedZIndex = React123.useMemo(() => {
      if (zIndex !== void 0) {
        return zIndex;
      }
      return token2.zIndexPopupBase + CONTAINER_MAX_OFFSET;
    }, [zIndex, token2]);
    return /* @__PURE__ */ React123.createElement(Modal_default, Object.assign({}, props, {
      className: classString,
      wrapClassName: (0, import_classnames33.default)({
        [`${confirmPrefixCls}-centered`]: !!props.centered
      }, wrapClassName),
      onCancel: () => {
        close === null || close === void 0 ? void 0 : close({
          triggerCancel: true
        });
        onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(false);
      },
      title: "",
      footer: null,
      transitionName: getTransitionName2(rootPrefixCls || "", "zoom", props.transitionName),
      maskTransitionName: getTransitionName2(rootPrefixCls || "", "fade", props.maskTransitionName),
      mask,
      maskClosable,
      style: style2,
      styles: Object.assign({
        body: bodyStyle,
        mask: maskStyle
      }, styles),
      width,
      zIndex: mergedZIndex,
      closable
    }), /* @__PURE__ */ React123.createElement(ConfirmContent, Object.assign({}, props, {
      confirmPrefixCls
    })));
  };
  var ConfirmDialogWrapper = (props) => {
    const {
      rootPrefixCls,
      iconPrefixCls,
      direction,
      theme
    } = props;
    return /* @__PURE__ */ React123.createElement(config_provider_default, {
      prefixCls: rootPrefixCls,
      iconPrefixCls,
      direction,
      theme
    }, /* @__PURE__ */ React123.createElement(ConfirmDialog, Object.assign({}, props)));
  };
  if (true) {
    ConfirmDialog.displayName = "ConfirmDialog";
    ConfirmDialogWrapper.displayName = "ConfirmDialogWrapper";
  }
  var ConfirmDialog_default = ConfirmDialogWrapper;

  // node_modules/antd/es/modal/destroyFns.js
  var destroyFns = [];
  var destroyFns_default = destroyFns;

  // node_modules/antd/es/modal/confirm.js
  var defaultRootPrefixCls = "";
  function getRootPrefixCls() {
    return defaultRootPrefixCls;
  }
  var ConfirmDialogWrapper2 = (props) => {
    var _a, _b;
    const {
      prefixCls: customizePrefixCls,
      getContainer: getContainer2,
      direction
    } = props;
    const runtimeLocale2 = getConfirmLocale();
    const config = (0, import_react54.useContext)(ConfigContext);
    const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
    const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
    let mergedGetContainer = getContainer2;
    if (mergedGetContainer === false) {
      mergedGetContainer = void 0;
      if (true) {
        true ? warning_default2(false, "Modal", "Static method not support `getContainer` to be `false` since it do not have context env.") : void 0;
      }
    }
    return /* @__PURE__ */ import_react54.default.createElement(ConfirmDialog_default, Object.assign({}, props, {
      rootPrefixCls,
      prefixCls,
      iconPrefixCls: config.iconPrefixCls,
      theme: config.theme,
      direction: direction !== null && direction !== void 0 ? direction : config.direction,
      locale: (_b = (_a = config.locale) === null || _a === void 0 ? void 0 : _a.Modal) !== null && _b !== void 0 ? _b : runtimeLocale2,
      getContainer: mergedGetContainer
    }));
  };
  function confirm(config) {
    const global2 = globalConfig();
    if (!global2.holderRender) {
      warnContext("Modal");
    }
    const container = document.createDocumentFragment();
    let currentConfig = Object.assign(Object.assign({}, config), {
      close,
      open: true
    });
    let timeoutId;
    let reactUnmount;
    function destroy2(...args) {
      var _a;
      const triggerCancel = args.some((param) => param === null || param === void 0 ? void 0 : param.triggerCancel);
      if (triggerCancel) {
        var _a2;
        (_a = config.onCancel) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [config, () => {
        }].concat(_toConsumableArray(args.slice(1))));
      }
      for (let i = 0; i < destroyFns_default.length; i++) {
        const fn = destroyFns_default[i];
        if (fn === close) {
          destroyFns_default.splice(i, 1);
          break;
        }
      }
      reactUnmount();
    }
    function render4(props) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        const rootPrefixCls = global2.getPrefixCls(void 0, getRootPrefixCls());
        const iconPrefixCls = global2.getIconPrefixCls();
        const theme = global2.getTheme();
        const dom = /* @__PURE__ */ import_react54.default.createElement(ConfirmDialogWrapper2, Object.assign({}, props));
        const reactRender2 = unstableSetRender();
        reactUnmount = reactRender2(/* @__PURE__ */ import_react54.default.createElement(config_provider_default, {
          prefixCls: rootPrefixCls,
          iconPrefixCls,
          theme
        }, global2.holderRender ? global2.holderRender(dom) : dom), container);
      });
    }
    function close(...args) {
      currentConfig = Object.assign(Object.assign({}, currentConfig), {
        open: false,
        afterClose: () => {
          if (typeof config.afterClose === "function") {
            config.afterClose();
          }
          destroy2.apply(this, args);
        }
      });
      if (currentConfig.visible) {
        delete currentConfig.visible;
      }
      render4(currentConfig);
    }
    function update(configUpdate) {
      if (typeof configUpdate === "function") {
        currentConfig = configUpdate(currentConfig);
      } else {
        currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);
      }
      render4(currentConfig);
    }
    render4(currentConfig);
    destroyFns_default.push(close);
    return {
      destroy: close,
      update
    };
  }
  function withWarn(props) {
    return Object.assign(Object.assign({}, props), {
      type: "warning"
    });
  }
  function withInfo(props) {
    return Object.assign(Object.assign({}, props), {
      type: "info"
    });
  }
  function withSuccess(props) {
    return Object.assign(Object.assign({}, props), {
      type: "success"
    });
  }
  function withError(props) {
    return Object.assign(Object.assign({}, props), {
      type: "error"
    });
  }
  function withConfirm(props) {
    return Object.assign(Object.assign({}, props), {
      type: "confirm"
    });
  }
  function modalGlobalConfig({
    rootPrefixCls
  }) {
    true ? warning_default2(false, "Modal", "Modal.config is deprecated. Please use ConfigProvider.config instead.") : void 0;
    defaultRootPrefixCls = rootPrefixCls;
  }

  // node_modules/antd/es/modal/useModal/HookModal.js
  var React125 = __toESM(require_react());
  var __rest11 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var HookModal = (_a, ref) => {
    var _b;
    var {
      afterClose: hookAfterClose,
      config
    } = _a, restProps = __rest11(_a, ["afterClose", "config"]);
    const [open2, setOpen] = React125.useState(true);
    const [innerConfig, setInnerConfig] = React125.useState(config);
    const {
      direction,
      getPrefixCls
    } = React125.useContext(ConfigContext);
    const prefixCls = getPrefixCls("modal");
    const rootPrefixCls = getPrefixCls();
    const afterClose = () => {
      var _a2;
      hookAfterClose();
      (_a2 = innerConfig.afterClose) === null || _a2 === void 0 ? void 0 : _a2.call(innerConfig);
    };
    const close = (...args) => {
      var _a2;
      setOpen(false);
      const triggerCancel = args.some((param) => param === null || param === void 0 ? void 0 : param.triggerCancel);
      if (triggerCancel) {
        var _a22;
        (_a2 = innerConfig.onCancel) === null || _a2 === void 0 ? void 0 : (_a22 = _a2).call.apply(_a22, [innerConfig, () => {
        }].concat(_toConsumableArray(args.slice(1))));
      }
    };
    React125.useImperativeHandle(ref, () => ({
      destroy: close,
      update: (newConfig) => {
        setInnerConfig((originConfig) => {
          const nextConfig = typeof newConfig === "function" ? newConfig(originConfig) : newConfig;
          return Object.assign(Object.assign({}, originConfig), nextConfig);
        });
      }
    }));
    const mergedOkCancel = (_b = innerConfig.okCancel) !== null && _b !== void 0 ? _b : innerConfig.type === "confirm";
    const [contextLocale] = useLocale_default("Modal", en_US_default6.Modal);
    return /* @__PURE__ */ React125.createElement(ConfirmDialog_default, Object.assign({
      prefixCls,
      rootPrefixCls
    }, innerConfig, {
      close,
      open: open2,
      afterClose,
      okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),
      direction: innerConfig.direction || direction,
      cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)
    }, restProps));
  };
  var HookModal_default = /* @__PURE__ */ React125.forwardRef(HookModal);

  // node_modules/antd/es/modal/useModal/index.js
  var uuid4 = 0;
  var ElementsHolder = /* @__PURE__ */ React126.memo(/* @__PURE__ */ React126.forwardRef((_props, ref) => {
    const [elements, patchElement] = usePatchElement();
    React126.useImperativeHandle(ref, () => ({
      patchElement
    }), []);
    return /* @__PURE__ */ React126.createElement(React126.Fragment, null, elements);
  }));
  function useModal() {
    const holderRef = React126.useRef(null);
    const [actionQueue, setActionQueue] = React126.useState([]);
    React126.useEffect(() => {
      if (actionQueue.length) {
        const cloneQueue = _toConsumableArray(actionQueue);
        cloneQueue.forEach((action) => {
          action();
        });
        setActionQueue([]);
      }
    }, [actionQueue]);
    const getConfirmFunc = React126.useCallback((withFunc) => function hookConfirm(config) {
      var _a;
      uuid4 += 1;
      const modalRef = /* @__PURE__ */ React126.createRef();
      let resolvePromise;
      const promise = new Promise((resolve) => {
        resolvePromise = resolve;
      });
      let silent = false;
      let closeFunc;
      const modal = /* @__PURE__ */ React126.createElement(HookModal_default, {
        key: `modal-${uuid4}`,
        config: withFunc(config),
        ref: modalRef,
        afterClose: () => {
          closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
        },
        isSilent: () => silent,
        onConfirm: (confirmed) => {
          resolvePromise(confirmed);
        }
      });
      closeFunc = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.patchElement(modal);
      if (closeFunc) {
        destroyFns_default.push(closeFunc);
      }
      const instance = {
        destroy: () => {
          function destroyAction() {
            var _a2;
            (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
          }
          if (modalRef.current) {
            destroyAction();
          } else {
            setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
          }
        },
        update: (newConfig) => {
          function updateAction() {
            var _a2;
            (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.update(newConfig);
          }
          if (modalRef.current) {
            updateAction();
          } else {
            setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
          }
        },
        then: (resolve) => {
          silent = true;
          return promise.then(resolve);
        }
      };
      return instance;
    }, []);
    const fns = React126.useMemo(() => ({
      info: getConfirmFunc(withInfo),
      success: getConfirmFunc(withSuccess),
      error: getConfirmFunc(withError),
      warning: getConfirmFunc(withWarn),
      confirm: getConfirmFunc(withConfirm)
    }), []);
    return [fns, /* @__PURE__ */ React126.createElement(ElementsHolder, {
      key: "modal-holder",
      ref: holderRef
    })];
  }
  var useModal_default = useModal;

  // node_modules/antd/es/app/context.js
  var import_react55 = __toESM(require_react());
  var AppConfigContext = /* @__PURE__ */ import_react55.default.createContext({});

  // node_modules/antd/es/_util/PurePanel.js
  var React128 = __toESM(require_react());
  function withPureRenderTheme(Component9) {
    return (props) => /* @__PURE__ */ React128.createElement(config_provider_default, {
      theme: {
        token: {
          motion: false,
          zIndexPopupBase: 0
        }
      }
    }, /* @__PURE__ */ React128.createElement(Component9, Object.assign({}, props)));
  }
  var genPurePanel = (Component9, alignPropName, postProps, defaultPrefixCls2, getDropdownCls) => {
    const PurePanel6 = (props) => {
      const {
        prefixCls: customizePrefixCls,
        style: style2
      } = props;
      const holderRef = React128.useRef(null);
      const [popupHeight, setPopupHeight] = React128.useState(0);
      const [popupWidth, setPopupWidth] = React128.useState(0);
      const [open2, setOpen] = useMergedState(false, {
        value: props.open
      });
      const {
        getPrefixCls
      } = React128.useContext(ConfigContext);
      const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
      React128.useEffect(() => {
        setOpen(true);
        if (typeof ResizeObserver !== "undefined") {
          const resizeObserver2 = new ResizeObserver((entries) => {
            const element = entries[0].target;
            setPopupHeight(element.offsetHeight + 8);
            setPopupWidth(element.offsetWidth);
          });
          const interval = setInterval(() => {
            var _a;
            const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
            const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
            if (popup) {
              clearInterval(interval);
              resizeObserver2.observe(popup);
            }
          }, 10);
          return () => {
            clearInterval(interval);
            resizeObserver2.disconnect();
          };
        }
      }, []);
      let mergedProps = Object.assign(Object.assign({}, props), {
        style: Object.assign(Object.assign({}, style2), {
          margin: 0
        }),
        open: open2,
        visible: open2,
        getPopupContainer: () => holderRef.current
      });
      if (postProps) {
        mergedProps = postProps(mergedProps);
      }
      if (alignPropName) {
        Object.assign(mergedProps, {
          [alignPropName]: {
            overflow: {
              adjustX: false,
              adjustY: false
            }
          }
        });
      }
      const mergedStyle = {
        paddingBottom: popupHeight,
        position: "relative",
        minWidth: popupWidth
      };
      return /* @__PURE__ */ React128.createElement("div", {
        ref: holderRef,
        style: mergedStyle
      }, /* @__PURE__ */ React128.createElement(Component9, Object.assign({}, mergedProps)));
    };
    return withPureRenderTheme(PurePanel6);
  };
  var PurePanel_default2 = genPurePanel;

  // node_modules/antd/es/select/index.js
  var React187 = __toESM(require_react());
  var import_classnames52 = __toESM(require_classnames());

  // node_modules/rc-select/es/Select.js
  var React177 = __toESM(require_react());

  // node_modules/rc-select/es/BaseSelect/index.js
  var import_classnames45 = __toESM(require_classnames());

  // node_modules/rc-util/es/isMobile.js
  var isMobile_default = function() {
    if (typeof navigator === "undefined" || typeof window === "undefined") {
      return false;
    }
    var agent = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
  };

  // node_modules/rc-select/es/BaseSelect/index.js
  var React158 = __toESM(require_react());

  // node_modules/rc-select/es/TransBtn.js
  var React129 = __toESM(require_react());
  var import_classnames34 = __toESM(require_classnames());
  var TransBtn = function TransBtn2(props) {
    var className = props.className, customizeIcon = props.customizeIcon, customizeIconProps = props.customizeIconProps, children = props.children, _onMouseDown = props.onMouseDown, onClick = props.onClick;
    var icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
    return /* @__PURE__ */ React129.createElement("span", {
      className,
      onMouseDown: function onMouseDown(event) {
        event.preventDefault();
        _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(event);
      },
      style: {
        userSelect: "none",
        WebkitUserSelect: "none"
      },
      unselectable: "on",
      onClick,
      "aria-hidden": true
    }, icon !== void 0 ? icon : /* @__PURE__ */ React129.createElement("span", {
      className: (0, import_classnames34.default)(className.split(/\s+/).map(function(cls3) {
        return "".concat(cls3, "-icon");
      }))
    }, children));
  };
  var TransBtn_default = TransBtn;

  // node_modules/rc-select/es/hooks/useAllowClear.js
  var import_react56 = __toESM(require_react());
  var useAllowClear = function useAllowClear2(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon) {
    var disabled = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
    var mergedSearchValue = arguments.length > 6 ? arguments[6] : void 0;
    var mode = arguments.length > 7 ? arguments[7] : void 0;
    var mergedClearIcon = import_react56.default.useMemo(function() {
      if (_typeof(allowClear) === "object") {
        return allowClear.clearIcon;
      }
      if (clearIcon) {
        return clearIcon;
      }
    }, [allowClear, clearIcon]);
    var mergedAllowClear = import_react56.default.useMemo(function() {
      if (!disabled && !!allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
        return true;
      }
      return false;
    }, [allowClear, disabled, displayValues.length, mergedSearchValue, mode]);
    return {
      allowClear: mergedAllowClear,
      clearIcon: /* @__PURE__ */ import_react56.default.createElement(TransBtn_default, {
        className: "".concat(prefixCls, "-clear"),
        onMouseDown: onClearMouseDown,
        customizeIcon: mergedClearIcon
      }, "\xD7")
    };
  };

  // node_modules/rc-select/es/hooks/useBaseProps.js
  var React131 = __toESM(require_react());
  var BaseSelectContext = /* @__PURE__ */ React131.createContext(null);
  function useBaseProps() {
    return React131.useContext(BaseSelectContext);
  }

  // node_modules/rc-select/es/hooks/useDelayReset.js
  var React132 = __toESM(require_react());
  function useDelayReset() {
    var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    var _React$useState = React132.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
    var delayRef = React132.useRef(null);
    var cancelLatest = function cancelLatest2() {
      window.clearTimeout(delayRef.current);
    };
    React132.useEffect(function() {
      return cancelLatest;
    }, []);
    var delaySetBool = function delaySetBool2(value, callback) {
      cancelLatest();
      delayRef.current = window.setTimeout(function() {
        setBool(value);
        if (callback) {
          callback();
        }
      }, timeout);
    };
    return [bool, delaySetBool, cancelLatest];
  }

  // node_modules/rc-select/es/hooks/useLock.js
  var React133 = __toESM(require_react());
  function useLock() {
    var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
    var lockRef = React133.useRef(null);
    var timeoutRef = React133.useRef(null);
    React133.useEffect(function() {
      return function() {
        window.clearTimeout(timeoutRef.current);
      };
    }, []);
    function doLock(locked) {
      if (locked || lockRef.current === null) {
        lockRef.current = locked;
      }
      window.clearTimeout(timeoutRef.current);
      timeoutRef.current = window.setTimeout(function() {
        lockRef.current = null;
      }, duration);
    }
    return [function() {
      return lockRef.current;
    }, doLock];
  }

  // node_modules/rc-select/es/hooks/useSelectTriggerControl.js
  var React134 = __toESM(require_react());
  function useSelectTriggerControl(elements, open2, triggerOpen, customizedTrigger) {
    var propsRef = React134.useRef(null);
    propsRef.current = {
      open: open2,
      triggerOpen,
      customizedTrigger
    };
    React134.useEffect(function() {
      function onGlobalMouseDown(event) {
        var _propsRef$current;
        if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) {
          return;
        }
        var target = event.target;
        if (target.shadowRoot && event.composed) {
          target = event.composedPath()[0] || target;
        }
        if (propsRef.current.open && elements().filter(function(element) {
          return element;
        }).every(function(element) {
          return !element.contains(target) && element !== target;
        })) {
          propsRef.current.triggerOpen(false);
        }
      }
      window.addEventListener("mousedown", onGlobalMouseDown);
      return function() {
        return window.removeEventListener("mousedown", onGlobalMouseDown);
      };
    }, []);
  }

  // node_modules/rc-select/es/Selector/index.js
  var React144 = __toESM(require_react());
  var import_react60 = __toESM(require_react());

  // node_modules/rc-select/es/utils/keyUtil.js
  function isValidateOpenKey(currentKeyCode) {
    return (
      // Undefined for Edge bug:
      // https://github.com/ant-design/ant-design/issues/51292
      currentKeyCode && // Other keys
      ![
        // System function button
        KeyCode_default.ESC,
        KeyCode_default.SHIFT,
        KeyCode_default.BACKSPACE,
        KeyCode_default.TAB,
        KeyCode_default.WIN_KEY,
        KeyCode_default.ALT,
        KeyCode_default.META,
        KeyCode_default.WIN_KEY_RIGHT,
        KeyCode_default.CTRL,
        KeyCode_default.SEMICOLON,
        KeyCode_default.EQUALS,
        KeyCode_default.CAPS_LOCK,
        KeyCode_default.CONTEXT_MENU,
        // F1-F12
        KeyCode_default.F1,
        KeyCode_default.F2,
        KeyCode_default.F3,
        KeyCode_default.F4,
        KeyCode_default.F5,
        KeyCode_default.F6,
        KeyCode_default.F7,
        KeyCode_default.F8,
        KeyCode_default.F9,
        KeyCode_default.F10,
        KeyCode_default.F11,
        KeyCode_default.F12
      ].includes(currentKeyCode)
    );
  }

  // node_modules/rc-select/es/Selector/MultipleSelector.js
  var React142 = __toESM(require_react());
  var import_react59 = __toESM(require_react());
  var import_classnames39 = __toESM(require_classnames());

  // node_modules/rc-overflow/es/Overflow.js
  var React139 = __toESM(require_react());
  var import_react58 = __toESM(require_react());
  var import_classnames37 = __toESM(require_classnames());

  // node_modules/rc-overflow/es/Item.js
  var React135 = __toESM(require_react());
  var import_classnames35 = __toESM(require_classnames());
  var _excluded11 = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
  var UNDEFINED = void 0;
  function InternalItem(props, ref) {
    var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey3 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component9 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded11);
    var mergedHidden = responsive && !display;
    function internalRegisterSize(width) {
      registerSize(itemKey3, width);
    }
    React135.useEffect(function() {
      return function() {
        internalRegisterSize(null);
      };
    }, []);
    var childNode = renderItem && item !== UNDEFINED ? renderItem(item, {
      index: order
    }) : children;
    var overflowStyle;
    if (!invalidate) {
      overflowStyle = {
        opacity: mergedHidden ? 0 : 1,
        height: mergedHidden ? 0 : UNDEFINED,
        overflowY: mergedHidden ? "hidden" : UNDEFINED,
        order: responsive ? order : UNDEFINED,
        pointerEvents: mergedHidden ? "none" : UNDEFINED,
        position: mergedHidden ? "absolute" : UNDEFINED
      };
    }
    var overflowProps = {};
    if (mergedHidden) {
      overflowProps["aria-hidden"] = true;
    }
    var itemNode = /* @__PURE__ */ React135.createElement(Component9, _extends({
      className: (0, import_classnames35.default)(!invalidate && prefixCls, className),
      style: _objectSpread2(_objectSpread2({}, overflowStyle), style2)
    }, overflowProps, restProps, {
      ref
    }), childNode);
    if (responsive) {
      itemNode = /* @__PURE__ */ React135.createElement(es_default, {
        onResize: function onResize2(_ref) {
          var offsetWidth = _ref.offsetWidth;
          internalRegisterSize(offsetWidth);
        },
        disabled: responsiveDisabled
      }, itemNode);
    }
    return itemNode;
  }
  var Item = /* @__PURE__ */ React135.forwardRef(InternalItem);
  Item.displayName = "Item";
  var Item_default = Item;

  // node_modules/rc-overflow/es/hooks/useEffectState.js
  var React136 = __toESM(require_react());
  var import_react_dom4 = __toESM(require_react_dom());

  // node_modules/rc-overflow/es/hooks/channelUpdate.js
  function channelUpdate(callback) {
    if (typeof MessageChannel === "undefined") {
      raf_default(callback);
    } else {
      var channel = new MessageChannel();
      channel.port1.onmessage = function() {
        return callback();
      };
      channel.port2.postMessage(void 0);
    }
  }

  // node_modules/rc-overflow/es/hooks/useEffectState.js
  function useBatcher() {
    var updateFuncRef = React136.useRef(null);
    var notifyEffectUpdate = function notifyEffectUpdate2(callback) {
      if (!updateFuncRef.current) {
        updateFuncRef.current = [];
        channelUpdate(function() {
          (0, import_react_dom4.unstable_batchedUpdates)(function() {
            updateFuncRef.current.forEach(function(fn) {
              fn();
            });
            updateFuncRef.current = null;
          });
        });
      }
      updateFuncRef.current.push(callback);
    };
    return notifyEffectUpdate;
  }
  function useEffectState(notifyEffectUpdate, defaultValue) {
    var _React$useState = React136.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
    var setEffectVal = useEvent(function(nextValue) {
      notifyEffectUpdate(function() {
        setStateValue(nextValue);
      });
    });
    return [stateValue, setEffectVal];
  }

  // node_modules/rc-overflow/es/RawItem.js
  var React138 = __toESM(require_react());
  var import_classnames36 = __toESM(require_classnames());

  // node_modules/rc-overflow/es/context.js
  var import_react57 = __toESM(require_react());
  var OverflowContext = /* @__PURE__ */ import_react57.default.createContext(null);

  // node_modules/rc-overflow/es/RawItem.js
  var _excluded12 = ["component"];
  var _excluded24 = ["className"];
  var _excluded32 = ["className"];
  var InternalRawItem = function InternalRawItem2(props, ref) {
    var context = React138.useContext(OverflowContext);
    if (!context) {
      var _props$component = props.component, Component9 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties(props, _excluded12);
      return /* @__PURE__ */ React138.createElement(Component9, _extends({}, _restProps, {
        ref
      }));
    }
    var contextClassName = context.className, restContext = _objectWithoutProperties(context, _excluded24);
    var className = props.className, restProps = _objectWithoutProperties(props, _excluded32);
    return /* @__PURE__ */ React138.createElement(OverflowContext.Provider, {
      value: null
    }, /* @__PURE__ */ React138.createElement(Item_default, _extends({
      ref,
      className: (0, import_classnames36.default)(contextClassName, className)
    }, restContext, restProps)));
  };
  var RawItem = /* @__PURE__ */ React138.forwardRef(InternalRawItem);
  RawItem.displayName = "RawItem";
  var RawItem_default = RawItem;

  // node_modules/rc-overflow/es/Overflow.js
  var _excluded13 = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
  var RESPONSIVE = "responsive";
  var INVALIDATE = "invalidate";
  function defaultRenderRest(omittedItems) {
    return "+ ".concat(omittedItems.length, " ...");
  }
  function Overflow(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey3 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component9 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded13);
    var fullySSR = ssr === "full";
    var notifyEffectUpdate = useBatcher();
    var _useEffectState = useEffectState(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
    var mergedContainerWidth = containerWidth || 0;
    var _useEffectState3 = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
    var _useEffectState5 = useEffectState(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
    var _useEffectState7 = useEffectState(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
    var _useEffectState9 = useEffectState(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
    var _useState = (0, import_react58.useState)(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
    var _useState3 = (0, import_react58.useState)(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
    var mergedDisplayCount = React139.useMemo(function() {
      if (displayCount === null && fullySSR) {
        return Number.MAX_SAFE_INTEGER;
      }
      return displayCount || 0;
    }, [displayCount, containerWidth]);
    var _useState5 = (0, import_react58.useState)(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
    var itemPrefixCls = "".concat(prefixCls, "-item");
    var mergedRestWidth = Math.max(prevRestWidth, restWidth);
    var isResponsive = maxCount === RESPONSIVE;
    var shouldResponsive = data.length && isResponsive;
    var invalidate = maxCount === INVALIDATE;
    var showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
    var mergedData = (0, import_react58.useMemo)(function() {
      var items = data;
      if (shouldResponsive) {
        if (containerWidth === null && fullySSR) {
          items = data;
        } else {
          items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
        }
      } else if (typeof maxCount === "number") {
        items = data.slice(0, maxCount);
      }
      return items;
    }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
    var omittedItems = (0, import_react58.useMemo)(function() {
      if (shouldResponsive) {
        return data.slice(mergedDisplayCount + 1);
      }
      return data.slice(mergedData.length);
    }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
    var getKey3 = (0, import_react58.useCallback)(function(item, index3) {
      var _ref;
      if (typeof itemKey3 === "function") {
        return itemKey3(item);
      }
      return (_ref = itemKey3 && (item === null || item === void 0 ? void 0 : item[itemKey3])) !== null && _ref !== void 0 ? _ref : index3;
    }, [itemKey3]);
    var mergedRenderItem = (0, import_react58.useCallback)(renderItem || function(item) {
      return item;
    }, [renderItem]);
    function updateDisplayCount(count, suffixFixedStartVal, notReady) {
      if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
        return;
      }
      setDisplayCount(count);
      if (!notReady) {
        setRestReady(count < data.length - 1);
        onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(count);
      }
      if (suffixFixedStartVal !== void 0) {
        setSuffixFixedStart(suffixFixedStartVal);
      }
    }
    function onOverflowResize(_, element) {
      setContainerWidth(element.clientWidth);
    }
    function registerSize(key, width) {
      setItemWidths(function(origin2) {
        var clone = new Map(origin2);
        if (width === null) {
          clone.delete(key);
        } else {
          clone.set(key, width);
        }
        return clone;
      });
    }
    function registerOverflowSize(_, width) {
      setRestWidth(width);
      setPrevRestWidth(restWidth);
    }
    function registerSuffixSize(_, width) {
      setSuffixWidth(width);
    }
    function getItemWidth(index3) {
      return itemWidths.get(getKey3(mergedData[index3], index3));
    }
    useLayoutEffect_default(function() {
      if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
        var totalWidth = suffixWidth;
        var len = mergedData.length;
        var lastIndex = len - 1;
        if (!len) {
          updateDisplayCount(0, null);
          return;
        }
        for (var i = 0; i < len; i += 1) {
          var currentItemWidth = getItemWidth(i);
          if (fullySSR) {
            currentItemWidth = currentItemWidth || 0;
          }
          if (currentItemWidth === void 0) {
            updateDisplayCount(i - 1, void 0, true);
            break;
          }
          totalWidth += currentItemWidth;
          if (
            // Only one means `totalWidth` is the final width
            lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
            i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
          ) {
            updateDisplayCount(lastIndex, null);
            break;
          } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
            updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
            break;
          }
        }
        if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
          setSuffixFixedStart(null);
        }
      }
    }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey3, mergedData]);
    var displayRest = restReady && !!omittedItems.length;
    var suffixStyle = {};
    if (suffixFixedStart !== null && shouldResponsive) {
      suffixStyle = {
        position: "absolute",
        left: suffixFixedStart,
        top: 0
      };
    }
    var itemSharedProps = {
      prefixCls: itemPrefixCls,
      responsive: shouldResponsive,
      component: itemComponent,
      invalidate
    };
    var internalRenderItemNode = renderRawItem ? function(item, index3) {
      var key = getKey3(item, index3);
      return /* @__PURE__ */ React139.createElement(OverflowContext.Provider, {
        key,
        value: _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
          order: index3,
          item,
          itemKey: key,
          registerSize,
          display: index3 <= mergedDisplayCount
        })
      }, renderRawItem(item, index3));
    } : function(item, index3) {
      var key = getKey3(item, index3);
      return /* @__PURE__ */ React139.createElement(Item_default, _extends({}, itemSharedProps, {
        order: index3,
        key,
        item,
        renderItem: mergedRenderItem,
        itemKey: key,
        registerSize,
        display: index3 <= mergedDisplayCount
      }));
    };
    var restContextProps = {
      order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
      className: "".concat(itemPrefixCls, "-rest"),
      registerSize: registerOverflowSize,
      display: displayRest
    };
    var mergedRenderRest = renderRest || defaultRenderRest;
    var restNode = renderRawRest ? /* @__PURE__ */ React139.createElement(OverflowContext.Provider, {
      value: _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems)) : /* @__PURE__ */ React139.createElement(Item_default, _extends({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
    var overflowNode = /* @__PURE__ */ React139.createElement(Component9, _extends({
      className: (0, import_classnames37.default)(!invalidate && prefixCls, className),
      style: style2,
      ref
    }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ React139.createElement(Item_default, _extends({}, itemSharedProps, {
      responsive: isResponsive,
      responsiveDisabled: !shouldResponsive,
      order: mergedDisplayCount,
      className: "".concat(itemPrefixCls, "-suffix"),
      registerSize: registerSuffixSize,
      display: true,
      style: suffixStyle
    }), suffix));
    return isResponsive ? /* @__PURE__ */ React139.createElement(es_default, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode) : overflowNode;
  }
  var ForwardOverflow = /* @__PURE__ */ React139.forwardRef(Overflow);
  ForwardOverflow.displayName = "Overflow";
  ForwardOverflow.Item = RawItem_default;
  ForwardOverflow.RESPONSIVE = RESPONSIVE;
  ForwardOverflow.INVALIDATE = INVALIDATE;
  var Overflow_default = ForwardOverflow;

  // node_modules/rc-overflow/es/index.js
  var es_default7 = Overflow_default;

  // node_modules/rc-select/es/Selector/Input.js
  var React140 = __toESM(require_react());
  var import_classnames38 = __toESM(require_classnames());

  // node_modules/rc-util/es/composeProps.js
  function composeProps(originProps, patchProps, isAll) {
    var composedProps = _objectSpread2(_objectSpread2({}, originProps), isAll ? patchProps : {});
    Object.keys(patchProps).forEach(function(key) {
      var func = patchProps[key];
      if (typeof func === "function") {
        composedProps[key] = function() {
          var _originProps$key;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          func.apply(void 0, args);
          return (_originProps$key = originProps[key]) === null || _originProps$key === void 0 ? void 0 : _originProps$key.call.apply(_originProps$key, [originProps].concat(args));
        };
      }
    });
    return composedProps;
  }
  var composeProps_default = composeProps;

  // node_modules/rc-select/es/Selector/Input.js
  var _excluded14 = ["prefixCls", "id", "inputElement", "autoFocus", "autoComplete", "editable", "activeDescendantId", "value", "open", "attrs"];
  var Input = function Input2(props, ref) {
    var prefixCls = props.prefixCls, id = props.id, inputElement = props.inputElement, autoFocus = props.autoFocus, autoComplete = props.autoComplete, editable = props.editable, activeDescendantId = props.activeDescendantId, value = props.value, open2 = props.open, attrs = props.attrs, restProps = _objectWithoutProperties(props, _excluded14);
    var inputNode = inputElement || /* @__PURE__ */ React140.createElement("input", null);
    var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
    warning(!("maxLength" in inputNode.props), "Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled.");
    inputNode = /* @__PURE__ */ React140.cloneElement(inputNode, _objectSpread2(_objectSpread2(_objectSpread2({
      type: "search"
    }, composeProps_default(restProps, originProps, true)), {}, {
      // Override over origin props
      id,
      ref: composeRef(ref, originRef),
      autoComplete: autoComplete || "off",
      autoFocus,
      className: (0, import_classnames38.default)("".concat(prefixCls, "-selection-search-input"), originProps === null || originProps === void 0 ? void 0 : originProps.className),
      role: "combobox",
      "aria-expanded": open2 || false,
      "aria-haspopup": "listbox",
      "aria-owns": "".concat(id, "_list"),
      "aria-autocomplete": "list",
      "aria-controls": "".concat(id, "_list"),
      "aria-activedescendant": open2 ? activeDescendantId : void 0
    }, attrs), {}, {
      value: editable ? value : "",
      readOnly: !editable,
      unselectable: !editable ? "on" : null,
      style: _objectSpread2(_objectSpread2({}, originProps.style), {}, {
        opacity: editable ? null : 0
      })
    }));
    return inputNode;
  };
  var RefInput = /* @__PURE__ */ React140.forwardRef(Input);
  if (true) {
    RefInput.displayName = "Input";
  }
  var Input_default2 = RefInput;

  // node_modules/rc-select/es/hooks/useLayoutEffect.js
  var React141 = __toESM(require_react());

  // node_modules/rc-select/es/utils/commonUtil.js
  function toArray3(value) {
    if (Array.isArray(value)) {
      return value;
    }
    return value !== void 0 ? [value] : [];
  }
  var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
  var isBrowserClient = isClient;
  function hasValue2(value) {
    return value !== void 0 && value !== null;
  }
  function isComboNoValue(value) {
    return !value && value !== 0;
  }
  function isTitleType(title) {
    return ["string", "number"].includes(_typeof(title));
  }
  function getTitle(item) {
    var title = void 0;
    if (item) {
      if (isTitleType(item.title)) {
        title = item.title.toString();
      } else if (isTitleType(item.label)) {
        title = item.label.toString();
      }
    }
    return title;
  }

  // node_modules/rc-select/es/hooks/useLayoutEffect.js
  function useLayoutEffect7(effect, deps) {
    if (isBrowserClient) {
      React141.useLayoutEffect(effect, deps);
    } else {
      React141.useEffect(effect, deps);
    }
  }

  // node_modules/rc-select/es/Selector/MultipleSelector.js
  function itemKey(value) {
    var _value$key;
    return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
  }
  var onPreventMouseDown = function onPreventMouseDown2(event) {
    event.preventDefault();
    event.stopPropagation();
  };
  var SelectSelector = function SelectSelector2(props) {
    var id = props.id, prefixCls = props.prefixCls, values = props.values, open2 = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
      return "+ ".concat(omittedValues.length, " ...");
    } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur;
    var measureRef = React142.useRef(null);
    var _useState = (0, import_react59.useState)(0), _useState2 = _slicedToArray(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
    var _useState3 = (0, import_react59.useState)(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
    var selectionPrefixCls = "".concat(prefixCls, "-selection");
    var inputValue = open2 || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
    var inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open2 || focused);
    useLayoutEffect7(function() {
      setInputWidth(measureRef.current.scrollWidth);
    }, [inputValue]);
    var defaultRenderSelector = function defaultRenderSelector2(item, content, itemDisabled, closable, onClose) {
      return /* @__PURE__ */ React142.createElement("span", {
        title: getTitle(item),
        className: (0, import_classnames39.default)("".concat(selectionPrefixCls, "-item"), _defineProperty({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled))
      }, /* @__PURE__ */ React142.createElement("span", {
        className: "".concat(selectionPrefixCls, "-item-content")
      }, content), closable && /* @__PURE__ */ React142.createElement(TransBtn_default, {
        className: "".concat(selectionPrefixCls, "-item-remove"),
        onMouseDown: onPreventMouseDown,
        onClick: onClose,
        customizeIcon: removeIcon
      }, "\xD7"));
    };
    var customizeRenderSelector = function customizeRenderSelector2(value, content, itemDisabled, closable, onClose, isMaxTag) {
      var onMouseDown = function onMouseDown2(e3) {
        onPreventMouseDown(e3);
        onToggleOpen(!open2);
      };
      return /* @__PURE__ */ React142.createElement("span", {
        onMouseDown
      }, tagRender({
        label: content,
        value,
        disabled: itemDisabled,
        closable,
        onClose,
        isMaxTag: !!isMaxTag
      }));
    };
    var renderItem = function renderItem2(valueItem) {
      var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value;
      var closable = !disabled && !itemDisabled;
      var displayLabel = label;
      if (typeof maxTagTextLength === "number") {
        if (typeof label === "string" || typeof label === "number") {
          var strLabel = String(displayLabel);
          if (strLabel.length > maxTagTextLength) {
            displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
          }
        }
      }
      var onClose = function onClose2(event) {
        if (event) {
          event.stopPropagation();
        }
        onRemove(valueItem);
      };
      return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
    };
    var renderRest = function renderRest2(omittedValues) {
      if (!values.length) {
        return null;
      }
      var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
      return typeof tagRender === "function" ? customizeRenderSelector(void 0, content, false, false, void 0, true) : defaultRenderSelector({
        title: content
      }, content, false);
    };
    var inputNode = /* @__PURE__ */ React142.createElement("div", {
      className: "".concat(selectionPrefixCls, "-search"),
      style: {
        width: inputWidth
      },
      onFocus: function onFocus() {
        setFocused(true);
      },
      onBlur: function onBlur() {
        setFocused(false);
      }
    }, /* @__PURE__ */ React142.createElement(Input_default2, {
      ref: inputRef,
      open: open2,
      prefixCls,
      id,
      inputElement: null,
      disabled,
      autoFocus,
      autoComplete,
      editable: inputEditable,
      activeDescendantId,
      value: inputValue,
      onKeyDown: onInputKeyDown,
      onMouseDown: onInputMouseDown,
      onChange: onInputChange,
      onPaste: onInputPaste,
      onCompositionStart: onInputCompositionStart,
      onCompositionEnd: onInputCompositionEnd,
      onBlur: onInputBlur,
      tabIndex,
      attrs: pickAttrs(props, true)
    }), /* @__PURE__ */ React142.createElement("span", {
      ref: measureRef,
      className: "".concat(selectionPrefixCls, "-search-mirror"),
      "aria-hidden": true
    }, inputValue, "\xA0"));
    var selectionNode = /* @__PURE__ */ React142.createElement(es_default7, {
      prefixCls: "".concat(selectionPrefixCls, "-overflow"),
      data: values,
      renderItem,
      renderRest,
      suffix: inputNode,
      itemKey,
      maxCount: maxTagCount
    });
    return /* @__PURE__ */ React142.createElement("span", {
      className: "".concat(selectionPrefixCls, "-wrap")
    }, selectionNode, !values.length && !inputValue && /* @__PURE__ */ React142.createElement("span", {
      className: "".concat(selectionPrefixCls, "-placeholder")
    }, placeholder));
  };
  var MultipleSelector_default = SelectSelector;

  // node_modules/rc-select/es/Selector/SingleSelector.js
  var React143 = __toESM(require_react());
  var SingleSelector = function SingleSelector2(props) {
    var inputElement = props.inputElement, prefixCls = props.prefixCls, id = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open2 = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur, title = props.title;
    var _React$useState = React143.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
    var combobox = mode === "combobox";
    var inputEditable = combobox || showSearch;
    var item = values[0];
    var inputValue = searchValue || "";
    if (combobox && activeValue && !inputChanged) {
      inputValue = activeValue;
    }
    React143.useEffect(function() {
      if (combobox) {
        setInputChanged(false);
      }
    }, [combobox, activeValue]);
    var hasTextInput = mode !== "combobox" && !open2 && !showSearch ? false : !!inputValue;
    var selectionTitle = title === void 0 ? getTitle(item) : title;
    var placeholderNode = React143.useMemo(function() {
      if (item) {
        return null;
      }
      return /* @__PURE__ */ React143.createElement("span", {
        className: "".concat(prefixCls, "-selection-placeholder"),
        style: hasTextInput ? {
          visibility: "hidden"
        } : void 0
      }, placeholder);
    }, [item, hasTextInput, placeholder, prefixCls]);
    return /* @__PURE__ */ React143.createElement("span", {
      className: "".concat(prefixCls, "-selection-wrap")
    }, /* @__PURE__ */ React143.createElement("span", {
      className: "".concat(prefixCls, "-selection-search")
    }, /* @__PURE__ */ React143.createElement(Input_default2, {
      ref: inputRef,
      prefixCls,
      id,
      open: open2,
      inputElement,
      disabled,
      autoFocus,
      autoComplete,
      editable: inputEditable,
      activeDescendantId,
      value: inputValue,
      onKeyDown: onInputKeyDown,
      onMouseDown: onInputMouseDown,
      onChange: function onChange(e3) {
        setInputChanged(true);
        onInputChange(e3);
      },
      onPaste: onInputPaste,
      onCompositionStart: onInputCompositionStart,
      onCompositionEnd: onInputCompositionEnd,
      onBlur: onInputBlur,
      tabIndex,
      attrs: pickAttrs(props, true),
      maxLength: combobox ? maxLength : void 0
    })), !combobox && item ? /* @__PURE__ */ React143.createElement("span", {
      className: "".concat(prefixCls, "-selection-item"),
      title: selectionTitle,
      style: hasTextInput ? {
        visibility: "hidden"
      } : void 0
    }, item.label) : null, placeholderNode);
  };
  var SingleSelector_default = SingleSelector;

  // node_modules/rc-select/es/Selector/index.js
  var Selector = function Selector2(props, ref) {
    var inputRef = (0, import_react60.useRef)(null);
    var compositionStatusRef = (0, import_react60.useRef)(false);
    var prefixCls = props.prefixCls, open2 = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, disabled = props.disabled, prefix = props.prefix, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, onInputBlur = props.onInputBlur, domRef = props.domRef;
    React144.useImperativeHandle(ref, function() {
      return {
        focus: function focus(options) {
          inputRef.current.focus(options);
        },
        blur: function blur() {
          inputRef.current.blur();
        }
      };
    });
    var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
    var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
      var which = event.which;
      var isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
      if (!isTextAreaElement && open2 && (which === KeyCode_default.UP || which === KeyCode_default.DOWN)) {
        event.preventDefault();
      }
      if (onInputKeyDown) {
        onInputKeyDown(event);
      }
      if (which === KeyCode_default.ENTER && mode === "tags" && !compositionStatusRef.current && !open2) {
        onSearchSubmit === null || onSearchSubmit === void 0 || onSearchSubmit(event.target.value);
      }
      if (isTextAreaElement && !open2 && ~[KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.LEFT, KeyCode_default.RIGHT].indexOf(which)) {
        return;
      }
      if (isValidateOpenKey(which)) {
        onToggleOpen(true);
      }
    };
    var onInternalInputMouseDown = function onInternalInputMouseDown2() {
      setInputMouseDown(true);
    };
    var pastedTextRef = (0, import_react60.useRef)(null);
    var triggerOnSearch = function triggerOnSearch2(value) {
      if (onSearch(value, true, compositionStatusRef.current) !== false) {
        onToggleOpen(true);
      }
    };
    var onInputCompositionStart = function onInputCompositionStart2() {
      compositionStatusRef.current = true;
    };
    var onInputCompositionEnd = function onInputCompositionEnd2(e3) {
      compositionStatusRef.current = false;
      if (mode !== "combobox") {
        triggerOnSearch(e3.target.value);
      }
    };
    var onInputChange = function onInputChange2(event) {
      var value = event.target.value;
      if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
        var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        value = value.replace(replacedText, pastedTextRef.current);
      }
      pastedTextRef.current = null;
      triggerOnSearch(value);
    };
    var onInputPaste = function onInputPaste2(e3) {
      var clipboardData = e3.clipboardData;
      var value = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData("text");
      pastedTextRef.current = value || "";
    };
    var onClick = function onClick2(_ref) {
      var target = _ref.target;
      if (target !== inputRef.current) {
        var isIE = document.body.style.msTouchAction !== void 0;
        if (isIE) {
          setTimeout(function() {
            inputRef.current.focus();
          });
        } else {
          inputRef.current.focus();
        }
      }
    };
    var onMouseDown = function onMouseDown2(event) {
      var inputMouseDown = getInputMouseDown();
      if (event.target !== inputRef.current && !inputMouseDown && !(mode === "combobox" && disabled)) {
        event.preventDefault();
      }
      if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open2) {
        if (open2 && autoClearSearchValue !== false) {
          onSearch("", true, false);
        }
        onToggleOpen();
      }
    };
    var sharedProps = {
      inputRef,
      onInputKeyDown: onInternalInputKeyDown,
      onInputMouseDown: onInternalInputMouseDown,
      onInputChange,
      onInputPaste,
      onInputCompositionStart,
      onInputCompositionEnd,
      onInputBlur
    };
    var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ React144.createElement(MultipleSelector_default, _extends({}, props, sharedProps)) : /* @__PURE__ */ React144.createElement(SingleSelector_default, _extends({}, props, sharedProps));
    return /* @__PURE__ */ React144.createElement("div", {
      ref: domRef,
      className: "".concat(prefixCls, "-selector"),
      onClick,
      onMouseDown
    }, prefix && /* @__PURE__ */ React144.createElement("div", {
      className: "".concat(prefixCls, "-prefix")
    }, prefix), selectNode);
  };
  var ForwardSelector = /* @__PURE__ */ React144.forwardRef(Selector);
  if (true) {
    ForwardSelector.displayName = "Selector";
  }
  var Selector_default = ForwardSelector;

  // node_modules/@rc-component/trigger/es/index.js
  var import_classnames43 = __toESM(require_classnames());
  var React154 = __toESM(require_react());

  // node_modules/@rc-component/trigger/es/Popup/index.js
  var import_classnames42 = __toESM(require_classnames());
  var React148 = __toESM(require_react());

  // node_modules/@rc-component/trigger/es/Popup/Arrow.js
  var import_classnames40 = __toESM(require_classnames());
  var React145 = __toESM(require_react());
  function Arrow(props) {
    var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos;
    var _ref = arrow || {}, className = _ref.className, content = _ref.content;
    var _arrowPos$x = arrowPos.x, x = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
    var arrowRef = React145.useRef();
    if (!align || !align.points) {
      return null;
    }
    var alignStyle = {
      position: "absolute"
    };
    if (align.autoArrow !== false) {
      var popupPoints = align.points[0];
      var targetPoints = align.points[1];
      var popupTB = popupPoints[0];
      var popupLR = popupPoints[1];
      var targetTB = targetPoints[0];
      var targetLR = targetPoints[1];
      if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
        alignStyle.top = y;
      } else if (popupTB === "t") {
        alignStyle.top = 0;
      } else {
        alignStyle.bottom = 0;
      }
      if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
        alignStyle.left = x;
      } else if (popupLR === "l") {
        alignStyle.left = 0;
      } else {
        alignStyle.right = 0;
      }
    }
    return /* @__PURE__ */ React145.createElement("div", {
      ref: arrowRef,
      className: (0, import_classnames40.default)("".concat(prefixCls, "-arrow"), className),
      style: alignStyle
    }, content);
  }

  // node_modules/@rc-component/trigger/es/Popup/Mask.js
  var import_classnames41 = __toESM(require_classnames());
  var React146 = __toESM(require_react());
  function Mask3(props) {
    var prefixCls = props.prefixCls, open2 = props.open, zIndex = props.zIndex, mask = props.mask, motion2 = props.motion;
    if (!mask) {
      return null;
    }
    return /* @__PURE__ */ React146.createElement(es_default2, _extends({}, motion2, {
      motionAppear: true,
      visible: open2,
      removeOnLeave: true
    }), function(_ref) {
      var className = _ref.className;
      return /* @__PURE__ */ React146.createElement("div", {
        style: {
          zIndex
        },
        className: (0, import_classnames41.default)("".concat(prefixCls, "-mask"), className)
      });
    });
  }

  // node_modules/@rc-component/trigger/es/Popup/PopupContent.js
  var React147 = __toESM(require_react());
  var PopupContent = /* @__PURE__ */ React147.memo(function(_ref) {
    var children = _ref.children;
    return children;
  }, function(_, next2) {
    return next2.cache;
  });
  if (true) {
    PopupContent.displayName = "PopupContent";
  }
  var PopupContent_default = PopupContent;

  // node_modules/@rc-component/trigger/es/Popup/index.js
  var Popup = /* @__PURE__ */ React148.forwardRef(function(props, ref) {
    var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open2 = props.open, keepDom = props.keepDom, fresh = props.fresh, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion2 = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onPointerEnter = props.onPointerEnter, onPointerDownCapture = props.onPointerDownCapture, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
    var childNode = typeof popup === "function" ? popup() : popup;
    var isNodeVisible = open2 || keepDom;
    var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
    var _React$useState = React148.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
    useLayoutEffect_default(function() {
      if (!show && getPopupContainerNeedParams && target) {
        setShow(true);
      }
    }, [show, getPopupContainerNeedParams, target]);
    if (!show) {
      return null;
    }
    var AUTO = "auto";
    var offsetStyle = {
      left: "-1000vw",
      top: "-1000vh",
      right: AUTO,
      bottom: AUTO
    };
    if (ready || !open2) {
      var _experimental;
      var points = align.points;
      var dynamicInset = align.dynamicInset || ((_experimental = align._experimental) === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset);
      var alignRight = dynamicInset && points[0][1] === "r";
      var alignBottom = dynamicInset && points[0][0] === "b";
      if (alignRight) {
        offsetStyle.right = offsetR;
        offsetStyle.left = AUTO;
      } else {
        offsetStyle.left = offsetX;
        offsetStyle.right = AUTO;
      }
      if (alignBottom) {
        offsetStyle.bottom = offsetB;
        offsetStyle.top = AUTO;
      } else {
        offsetStyle.top = offsetY;
        offsetStyle.bottom = AUTO;
      }
    }
    var miscStyle = {};
    if (stretch) {
      if (stretch.includes("height") && targetHeight) {
        miscStyle.height = targetHeight;
      } else if (stretch.includes("minHeight") && targetHeight) {
        miscStyle.minHeight = targetHeight;
      }
      if (stretch.includes("width") && targetWidth) {
        miscStyle.width = targetWidth;
      } else if (stretch.includes("minWidth") && targetWidth) {
        miscStyle.minWidth = targetWidth;
      }
    }
    if (!open2) {
      miscStyle.pointerEvents = "none";
    }
    return /* @__PURE__ */ React148.createElement(Portal2, {
      open: forceRender || isNodeVisible,
      getContainer: getPopupContainer && function() {
        return getPopupContainer(target);
      },
      autoDestroy
    }, /* @__PURE__ */ React148.createElement(Mask3, {
      prefixCls,
      open: open2,
      zIndex,
      mask,
      motion: maskMotion
    }), /* @__PURE__ */ React148.createElement(es_default, {
      onResize: onAlign,
      disabled: !open2
    }, function(resizeObserverRef) {
      return /* @__PURE__ */ React148.createElement(es_default2, _extends({
        motionAppear: true,
        motionEnter: true,
        motionLeave: true,
        removeOnLeave: false,
        forceRender,
        leavedClassName: "".concat(prefixCls, "-hidden")
      }, motion2, {
        onAppearPrepare: onPrepare,
        onEnterPrepare: onPrepare,
        visible: open2,
        onVisibleChanged: function onVisibleChanged(nextVisible) {
          var _motion$onVisibleChan;
          motion2 === null || motion2 === void 0 || (_motion$onVisibleChan = motion2.onVisibleChanged) === null || _motion$onVisibleChan === void 0 || _motion$onVisibleChan.call(motion2, nextVisible);
          _onVisibleChanged(nextVisible);
        }
      }), function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        var cls3 = (0, import_classnames42.default)(prefixCls, motionClassName, className);
        return /* @__PURE__ */ React148.createElement("div", {
          ref: composeRef(resizeObserverRef, ref, motionRef),
          className: cls3,
          style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
            "--arrow-x": "".concat(arrowPos.x || 0, "px"),
            "--arrow-y": "".concat(arrowPos.y || 0, "px")
          }, offsetStyle), miscStyle), motionStyle), {}, {
            boxSizing: "border-box",
            zIndex
          }, style2),
          onMouseEnter,
          onMouseLeave,
          onPointerEnter,
          onClick,
          onPointerDownCapture
        }, arrow && /* @__PURE__ */ React148.createElement(Arrow, {
          prefixCls,
          arrow,
          arrowPos,
          align
        }), /* @__PURE__ */ React148.createElement(PopupContent_default, {
          cache: !open2 && !fresh
        }, childNode));
      });
    }));
  });
  if (true) {
    Popup.displayName = "Popup";
  }
  var Popup_default = Popup;

  // node_modules/@rc-component/trigger/es/TriggerWrapper.js
  var React149 = __toESM(require_react());
  var TriggerWrapper = /* @__PURE__ */ React149.forwardRef(function(props, ref) {
    var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
    var canUseRef = supportRef(children);
    var setRef = React149.useCallback(function(node2) {
      fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
    }, [getTriggerDOMNode]);
    var mergedRef = useComposeRef(setRef, getNodeRef(children));
    return canUseRef ? /* @__PURE__ */ React149.cloneElement(children, {
      ref: mergedRef
    }) : children;
  });
  if (true) {
    TriggerWrapper.displayName = "TriggerWrapper";
  }
  var TriggerWrapper_default = TriggerWrapper;

  // node_modules/@rc-component/trigger/es/context.js
  var React150 = __toESM(require_react());
  var TriggerContext = /* @__PURE__ */ React150.createContext(null);
  var context_default2 = TriggerContext;

  // node_modules/@rc-component/trigger/es/hooks/useAction.js
  var React151 = __toESM(require_react());
  function toArray4(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  }
  function useAction(mobile, action, showAction, hideAction) {
    return React151.useMemo(function() {
      var mergedShowAction = toArray4(showAction !== null && showAction !== void 0 ? showAction : action);
      var mergedHideAction = toArray4(hideAction !== null && hideAction !== void 0 ? hideAction : action);
      var showActionSet = new Set(mergedShowAction);
      var hideActionSet = new Set(mergedHideAction);
      if (mobile) {
        if (showActionSet.has("hover")) {
          showActionSet.delete("hover");
          showActionSet.add("click");
        }
        if (hideActionSet.has("hover")) {
          hideActionSet.delete("hover");
          hideActionSet.add("click");
        }
      }
      return [showActionSet, hideActionSet];
    }, [mobile, action, showAction, hideAction]);
  }

  // node_modules/@rc-component/trigger/es/hooks/useAlign.js
  var React152 = __toESM(require_react());

  // node_modules/@rc-component/trigger/es/util.js
  function isPointsEq() {
    var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
    if (isAlignPoint) {
      return a1[0] === a2[0];
    }
    return a1[0] === a2[0] && a1[1] === a2[1];
  }
  function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    var points = align.points;
    var placements4 = Object.keys(builtinPlacements);
    for (var i = 0; i < placements4.length; i += 1) {
      var _builtinPlacements$pl;
      var placement = placements4[i];
      if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
        return "".concat(prefixCls, "-placement-").concat(placement);
      }
    }
    return "";
  }
  function getMotion2(prefixCls, motion2, animation, transitionName) {
    if (motion2) {
      return motion2;
    }
    if (animation) {
      return {
        motionName: "".concat(prefixCls, "-").concat(animation)
      };
    }
    if (transitionName) {
      return {
        motionName: transitionName
      };
    }
    return null;
  }
  function getWin(ele) {
    return ele.ownerDocument.defaultView;
  }
  function collectScroller(ele) {
    var scrollerList = [];
    var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
    var scrollStyle = ["hidden", "scroll", "clip", "auto"];
    while (current) {
      var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
      if ([overflowX, overflowY, overflow].some(function(o3) {
        return scrollStyle.includes(o3);
      })) {
        scrollerList.push(current);
      }
      current = current.parentElement;
    }
    return scrollerList;
  }
  function toNum(num) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return Number.isNaN(num) ? defaultValue : num;
  }
  function getPxValue(val) {
    return toNum(parseFloat(val), 0);
  }
  function getVisibleArea(initArea, scrollerList) {
    var visibleArea = _objectSpread2({}, initArea);
    (scrollerList || []).forEach(function(ele) {
      if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
        return;
      }
      var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
      var eleRect = ele.getBoundingClientRect();
      var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
      var borderTopNum = getPxValue(borderTopWidth);
      var borderBottomNum = getPxValue(borderBottomWidth);
      var borderLeftNum = getPxValue(borderLeftWidth);
      var borderRightNum = getPxValue(borderRightWidth);
      var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
      var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
      var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
      var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
      var scaledBorderTopWidth = borderTopNum * scaleY;
      var scaledBorderBottomWidth = borderBottomNum * scaleY;
      var scaledBorderLeftWidth = borderLeftNum * scaleX;
      var scaledBorderRightWidth = borderRightNum * scaleX;
      var clipMarginWidth = 0;
      var clipMarginHeight = 0;
      if (overflow === "clip") {
        var clipNum = getPxValue(overflowClipMargin);
        clipMarginWidth = clipNum * scaleX;
        clipMarginHeight = clipNum * scaleY;
      }
      var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
      var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
      var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
      var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
      visibleArea.left = Math.max(visibleArea.left, eleLeft);
      visibleArea.top = Math.max(visibleArea.top, eleTop);
      visibleArea.right = Math.min(visibleArea.right, eleRight);
      visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
    });
    return visibleArea;
  }

  // node_modules/@rc-component/trigger/es/hooks/useAlign.js
  function getUnitOffset(size) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var offsetStr = "".concat(offset3);
    var cells = offsetStr.match(/^(.*)\%$/);
    if (cells) {
      return size * (parseFloat(cells[1]) / 100);
    }
    return parseFloat(offsetStr);
  }
  function getNumberOffset(rect, offset3) {
    var _ref = offset3 || [], _ref2 = _slicedToArray(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
    return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
  }
  function splitPoints() {
    var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return [points[0], points[1]];
  }
  function getAlignPoint(rect, points) {
    var topBottom = points[0];
    var leftRight = points[1];
    var x;
    var y;
    if (topBottom === "t") {
      y = rect.y;
    } else if (topBottom === "b") {
      y = rect.y + rect.height;
    } else {
      y = rect.y + rect.height / 2;
    }
    if (leftRight === "l") {
      x = rect.x;
    } else if (leftRight === "r") {
      x = rect.x + rect.width;
    } else {
      x = rect.x + rect.width / 2;
    }
    return {
      x,
      y
    };
  }
  function reversePoints(points, index3) {
    var reverseMap = {
      t: "b",
      b: "t",
      l: "r",
      r: "l"
    };
    return points.map(function(point, i) {
      if (i === index3) {
        return reverseMap[point] || "c";
      }
      return point;
    }).join("");
  }
  function useAlign(open2, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
    var _React$useState = React152.useState({
      ready: false,
      offsetX: 0,
      offsetY: 0,
      offsetR: 0,
      offsetB: 0,
      arrowX: 0,
      arrowY: 0,
      scaleX: 1,
      scaleY: 1,
      align: builtinPlacements[placement] || {}
    }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
    var alignCountRef = React152.useRef(0);
    var scrollerList = React152.useMemo(function() {
      if (!popupEle) {
        return [];
      }
      return collectScroller(popupEle);
    }, [popupEle]);
    var prevFlipRef = React152.useRef({});
    var resetFlipCache = function resetFlipCache2() {
      prevFlipRef.current = {};
    };
    if (!open2) {
      resetFlipCache();
    }
    var onAlign = useEvent(function() {
      if (popupEle && target && open2) {
        let getIntersectionVisibleArea = function(offsetX, offsetY) {
          var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea;
          var l2 = popupRect.x + offsetX;
          var t2 = popupRect.y + offsetY;
          var r2 = l2 + popupWidth;
          var b = t2 + popupHeight;
          var visibleL = Math.max(l2, area.left);
          var visibleT = Math.max(t2, area.top);
          var visibleR = Math.min(r2, area.right);
          var visibleB = Math.min(b, area.bottom);
          return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
        }, syncNextPopupPosition = function() {
          nextPopupY = popupRect.y + nextOffsetY;
          nextPopupBottom = nextPopupY + popupHeight;
          nextPopupX = popupRect.x + nextOffsetX;
          nextPopupRight = nextPopupX + popupWidth;
        };
        var _popupElement$parentE, _popupRect$x, _popupRect$y, _popupElement$parentE2;
        var popupElement = popupEle;
        var doc = popupElement.ownerDocument;
        var win = getWin(popupElement);
        var _win$getComputedStyle = win.getComputedStyle(popupElement), popupPosition = _win$getComputedStyle.position;
        var originLeft = popupElement.style.left;
        var originTop = popupElement.style.top;
        var originRight = popupElement.style.right;
        var originBottom = popupElement.style.bottom;
        var originOverflow = popupElement.style.overflow;
        var placementInfo = _objectSpread2(_objectSpread2({}, builtinPlacements[placement]), popupAlign);
        var placeholderElement = doc.createElement("div");
        (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);
        placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px");
        placeholderElement.style.top = "".concat(popupElement.offsetTop, "px");
        placeholderElement.style.position = popupPosition;
        placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px");
        placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px");
        popupElement.style.left = "0";
        popupElement.style.top = "0";
        popupElement.style.right = "auto";
        popupElement.style.bottom = "auto";
        popupElement.style.overflow = "hidden";
        var targetRect;
        if (Array.isArray(target)) {
          targetRect = {
            x: target[0],
            y: target[1],
            width: 0,
            height: 0
          };
        } else {
          var _rect$x, _rect$y;
          var rect = target.getBoundingClientRect();
          rect.x = (_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left;
          rect.y = (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top;
          targetRect = {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          };
        }
        var popupRect = popupElement.getBoundingClientRect();
        var _win$getComputedStyle2 = win.getComputedStyle(popupElement), height = _win$getComputedStyle2.height, width = _win$getComputedStyle2.width;
        popupRect.x = (_popupRect$x = popupRect.x) !== null && _popupRect$x !== void 0 ? _popupRect$x : popupRect.left;
        popupRect.y = (_popupRect$y = popupRect.y) !== null && _popupRect$y !== void 0 ? _popupRect$y : popupRect.top;
        var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
        var popupHeight = popupRect.height;
        var popupWidth = popupRect.width;
        var targetHeight = targetRect.height;
        var targetWidth = targetRect.width;
        var visibleRegion = {
          left: 0,
          top: 0,
          right: clientWidth,
          bottom: clientHeight
        };
        var scrollRegion = {
          left: -scrollLeft,
          top: -scrollTop,
          right: scrollWidth - scrollLeft,
          bottom: scrollHeight - scrollTop
        };
        var htmlRegion = placementInfo.htmlRegion;
        var VISIBLE = "visible";
        var VISIBLE_FIRST = "visibleFirst";
        if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
          htmlRegion = VISIBLE;
        }
        var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
        var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
        var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
        var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
        var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
        popupElement.style.left = "auto";
        popupElement.style.top = "auto";
        popupElement.style.right = "0";
        popupElement.style.bottom = "0";
        var popupMirrorRect = popupElement.getBoundingClientRect();
        popupElement.style.left = originLeft;
        popupElement.style.top = originTop;
        popupElement.style.right = originRight;
        popupElement.style.bottom = originBottom;
        popupElement.style.overflow = originOverflow;
        (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);
        var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
        var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
        if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible_default(target)) {
          return;
        }
        var offset3 = placementInfo.offset, targetOffset3 = placementInfo.targetOffset;
        var _getNumberOffset = getNumberOffset(popupRect, offset3), _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1];
        var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset3), _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
        targetRect.x -= targetOffsetX;
        targetRect.y -= targetOffsetY;
        var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1];
        var targetPoints = splitPoints(targetPoint);
        var popupPoints = splitPoints(popupPoint);
        var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
        var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
        var nextAlignInfo = _objectSpread2({}, placementInfo);
        var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
        var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
        var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
        var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
        var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
        var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
        var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
        var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
        var overflow = placementInfo.overflow || {};
        var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
        var supportAdjust = function supportAdjust2(val) {
          if (typeof val === "boolean") {
            return val;
          }
          return val >= 0;
        };
        var nextPopupY;
        var nextPopupBottom;
        var nextPopupX;
        var nextPopupRight;
        syncNextPopupPosition();
        var needAdjustY = supportAdjust(adjustY);
        var sameTB = popupPoints[0] === targetPoints[0];
        if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
          var tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            tmpNextOffsetY -= popupHeight - targetHeight;
          } else {
            tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
          }
          var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
          var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.bt = true;
            nextOffsetY = tmpNextOffsetY;
            popupOffsetY = -popupOffsetY;
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          } else {
            prevFlipRef.current.bt = false;
          }
        }
        if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
          var _tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            _tmpNextOffsetY += popupHeight - targetHeight;
          } else {
            _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
          }
          var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);
          var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.tb = true;
            nextOffsetY = _tmpNextOffsetY;
            popupOffsetY = -popupOffsetY;
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          } else {
            prevFlipRef.current.tb = false;
          }
        }
        var needAdjustX = supportAdjust(adjustX);
        var sameLR = popupPoints[1] === targetPoints[1];
        if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
          var tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            tmpNextOffsetX -= popupWidth - targetWidth;
          } else {
            tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
          }
          var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
          var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea2 >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.rl = true;
            nextOffsetX = tmpNextOffsetX;
            popupOffsetX = -popupOffsetX;
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          } else {
            prevFlipRef.current.rl = false;
          }
        }
        if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
          var _tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            _tmpNextOffsetX += popupWidth - targetWidth;
          } else {
            _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
          }
          var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);
          var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea3 >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.lr = true;
            nextOffsetX = _tmpNextOffsetX;
            popupOffsetX = -popupOffsetX;
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          } else {
            prevFlipRef.current.lr = false;
          }
        }
        syncNextPopupPosition();
        var numShiftX = shiftX === true ? 0 : shiftX;
        if (typeof numShiftX === "number") {
          if (nextPopupX < visibleRegionArea.left) {
            nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
            if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
            }
          }
          if (nextPopupRight > visibleRegionArea.right) {
            nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
            if (targetRect.x > visibleRegionArea.right - numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
            }
          }
        }
        var numShiftY = shiftY === true ? 0 : shiftY;
        if (typeof numShiftY === "number") {
          if (nextPopupY < visibleRegionArea.top) {
            nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
            if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
            }
          }
          if (nextPopupBottom > visibleRegionArea.bottom) {
            nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
            if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
            }
          }
        }
        var popupLeft = popupRect.x + nextOffsetX;
        var popupRight = popupLeft + popupWidth;
        var popupTop = popupRect.y + nextOffsetY;
        var popupBottom = popupTop + popupHeight;
        var targetLeft = targetRect.x;
        var targetRight = targetLeft + targetWidth;
        var targetTop = targetRect.y;
        var targetBottom = targetTop + targetHeight;
        var maxLeft = Math.max(popupLeft, targetLeft);
        var minRight = Math.min(popupRight, targetRight);
        var xCenter = (maxLeft + minRight) / 2;
        var nextArrowX = xCenter - popupLeft;
        var maxTop = Math.max(popupTop, targetTop);
        var minBottom = Math.min(popupBottom, targetBottom);
        var yCenter = (maxTop + minBottom) / 2;
        var nextArrowY = yCenter - popupTop;
        onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);
        var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
        var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
        if (_scaleX === 1) {
          nextOffsetX = Math.round(nextOffsetX);
          offsetX4Right = Math.round(offsetX4Right);
        }
        if (_scaleY === 1) {
          nextOffsetY = Math.round(nextOffsetY);
          offsetY4Bottom = Math.round(offsetY4Bottom);
        }
        var nextOffsetInfo = {
          ready: true,
          offsetX: nextOffsetX / _scaleX,
          offsetY: nextOffsetY / _scaleY,
          offsetR: offsetX4Right / _scaleX,
          offsetB: offsetY4Bottom / _scaleY,
          arrowX: nextArrowX / _scaleX,
          arrowY: nextArrowY / _scaleY,
          scaleX: _scaleX,
          scaleY: _scaleY,
          align: nextAlignInfo
        };
        setOffsetInfo(nextOffsetInfo);
      }
    });
    var triggerAlign = function triggerAlign2() {
      alignCountRef.current += 1;
      var id = alignCountRef.current;
      Promise.resolve().then(function() {
        if (alignCountRef.current === id) {
          onAlign();
        }
      });
    };
    var resetReady = function resetReady2() {
      setOffsetInfo(function(ori) {
        return _objectSpread2(_objectSpread2({}, ori), {}, {
          ready: false
        });
      });
    };
    useLayoutEffect_default(resetReady, [placement]);
    useLayoutEffect_default(function() {
      if (!open2) {
        resetReady();
      }
    }, [open2]);
    return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
  }

  // node_modules/@rc-component/trigger/es/hooks/useWatch.js
  function useWatch2(open2, target, popup, onAlign, onScroll) {
    useLayoutEffect_default(function() {
      if (open2 && target && popup) {
        let notifyScroll = function() {
          onAlign();
          onScroll();
        };
        var targetElement = target;
        var popupElement = popup;
        var targetScrollList = collectScroller(targetElement);
        var popupScrollList = collectScroller(popupElement);
        var win = getWin(popupElement);
        var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
        mergedList.forEach(function(scroller) {
          scroller.addEventListener("scroll", notifyScroll, {
            passive: true
          });
        });
        win.addEventListener("resize", notifyScroll, {
          passive: true
        });
        onAlign();
        return function() {
          mergedList.forEach(function(scroller) {
            scroller.removeEventListener("scroll", notifyScroll);
            win.removeEventListener("resize", notifyScroll);
          });
        };
      }
    }, [open2, target, popup]);
  }

  // node_modules/@rc-component/trigger/es/hooks/useWinClick.js
  var React153 = __toESM(require_react());
  function useWinClick(open2, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
    var openRef = React153.useRef(open2);
    openRef.current = open2;
    var popupPointerDownRef = React153.useRef(false);
    React153.useEffect(function() {
      if (clickToHide && popupEle && (!mask || maskClosable)) {
        var onPointerDown = function onPointerDown2() {
          popupPointerDownRef.current = false;
        };
        var onTriggerClose = function onTriggerClose2(e3) {
          var _e$composedPath;
          if (openRef.current && !inPopupOrChild(((_e$composedPath = e3.composedPath) === null || _e$composedPath === void 0 || (_e$composedPath = _e$composedPath.call(e3)) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath[0]) || e3.target) && !popupPointerDownRef.current) {
            triggerOpen(false);
          }
        };
        var win = getWin(popupEle);
        win.addEventListener("pointerdown", onPointerDown, true);
        win.addEventListener("mousedown", onTriggerClose, true);
        win.addEventListener("contextmenu", onTriggerClose, true);
        var targetShadowRoot = getShadowRoot(targetEle);
        if (targetShadowRoot) {
          targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
          targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
        }
        if (true) {
          var _targetEle$getRootNod, _popupEle$getRootNode;
          var targetRoot = targetEle === null || targetEle === void 0 || (_targetEle$getRootNod = targetEle.getRootNode) === null || _targetEle$getRootNod === void 0 ? void 0 : _targetEle$getRootNod.call(targetEle);
          var popupRoot = (_popupEle$getRootNode = popupEle.getRootNode) === null || _popupEle$getRootNode === void 0 ? void 0 : _popupEle$getRootNode.call(popupEle);
          warning(targetRoot === popupRoot, "trigger element and popup element should in same shadow root.");
        }
        return function() {
          win.removeEventListener("pointerdown", onPointerDown, true);
          win.removeEventListener("mousedown", onTriggerClose, true);
          win.removeEventListener("contextmenu", onTriggerClose, true);
          if (targetShadowRoot) {
            targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
            targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
          }
        };
      }
    }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
    function onPopupPointerDown() {
      popupPointerDownRef.current = true;
    }
    return onPopupPointerDown;
  }

  // node_modules/@rc-component/trigger/es/index.js
  var _excluded15 = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
  function generateTrigger() {
    var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : es_default3;
    var Trigger = /* @__PURE__ */ React154.forwardRef(function(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, fresh = props.fresh, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties(props, _excluded15);
      var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
      var _React$useState = React154.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
      useLayoutEffect_default(function() {
        setMobile(isMobile_default());
      }, []);
      var subPopupElements = React154.useRef({});
      var parentContext = React154.useContext(context_default2);
      var context = React154.useMemo(function() {
        return {
          registerSubPopup: function registerSubPopup(id2, subPopupEle) {
            subPopupElements.current[id2] = subPopupEle;
            parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id2, subPopupEle);
          }
        };
      }, [parentContext]);
      var id = useId_default();
      var _React$useState3 = React154.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
      var externalPopupRef = React154.useRef(null);
      var setPopupRef = useEvent(function(node2) {
        externalPopupRef.current = node2;
        if (isDOM(node2) && popupEle !== node2) {
          setPopupEle(node2);
        }
        parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, node2);
      });
      var _React$useState5 = React154.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
      var externalForwardRef = React154.useRef(null);
      var setTargetRef = useEvent(function(node2) {
        if (isDOM(node2) && targetEle !== node2) {
          setTargetEle(node2);
          externalForwardRef.current = node2;
        }
      });
      var child = React154.Children.only(children);
      var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
      var cloneProps = {};
      var inPopupOrChild = useEvent(function(ele) {
        var _getShadowRoot, _getShadowRoot2;
        var childDOM = targetEle;
        return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
          return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
        });
      });
      var mergePopupMotion = getMotion2(prefixCls, popupMotion, popupAnimation, popupTransitionName);
      var mergeMaskMotion = getMotion2(prefixCls, maskMotion, maskAnimation, maskTransitionName);
      var _React$useState7 = React154.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
      var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
      var setMergedOpen = useEvent(function(nextOpen) {
        if (popupVisible === void 0) {
          setInternalOpen(nextOpen);
        }
      });
      useLayoutEffect_default(function() {
        setInternalOpen(popupVisible || false);
      }, [popupVisible]);
      var openRef = React154.useRef(mergedOpen);
      openRef.current = mergedOpen;
      var lastTriggerRef = React154.useRef([]);
      lastTriggerRef.current = [];
      var internalTriggerOpen = useEvent(function(nextOpen) {
        var _lastTriggerRef$curre;
        setMergedOpen(nextOpen);
        if (((_lastTriggerRef$curre = lastTriggerRef.current[lastTriggerRef.current.length - 1]) !== null && _lastTriggerRef$curre !== void 0 ? _lastTriggerRef$curre : mergedOpen) !== nextOpen) {
          lastTriggerRef.current.push(nextOpen);
          onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
        }
      });
      var delayRef = React154.useRef();
      var clearDelay = function clearDelay2() {
        clearTimeout(delayRef.current);
      };
      var triggerOpen = function triggerOpen2(nextOpen) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        clearDelay();
        if (delay === 0) {
          internalTriggerOpen(nextOpen);
        } else {
          delayRef.current = setTimeout(function() {
            internalTriggerOpen(nextOpen);
          }, delay * 1e3);
        }
      };
      React154.useEffect(function() {
        return clearDelay;
      }, []);
      var _React$useState9 = React154.useState(false), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
      useLayoutEffect_default(function(firstMount) {
        if (!firstMount || mergedOpen) {
          setInMotion(true);
        }
      }, [mergedOpen]);
      var _React$useState11 = React154.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
      var _React$useState13 = React154.useState(null), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
      var setMousePosByEvent = function setMousePosByEvent2(event) {
        setMousePos([event.clientX, event.clientY]);
      };
      var _useAlign = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10];
      var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
      var clickToShow = showActions.has("click");
      var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
      var triggerAlign = useEvent(function() {
        if (!inMotion) {
          onAlign();
        }
      });
      var onScroll = function onScroll2() {
        if (openRef.current && alignPoint && clickToHide) {
          triggerOpen(false);
        }
      };
      useWatch2(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
      useLayoutEffect_default(function() {
        triggerAlign();
      }, [mousePos, popupPlacement]);
      useLayoutEffect_default(function() {
        if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
          triggerAlign();
        }
      }, [JSON.stringify(popupAlign)]);
      var alignedClassName = React154.useMemo(function() {
        var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
        return (0, import_classnames43.default)(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
      }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
      React154.useImperativeHandle(ref, function() {
        return {
          nativeElement: externalForwardRef.current,
          popupElement: externalPopupRef.current,
          forceAlign: triggerAlign
        };
      });
      var _React$useState15 = React154.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
      var _React$useState17 = React154.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
      var syncTargetSize = function syncTargetSize2() {
        if (stretch && targetEle) {
          var rect = targetEle.getBoundingClientRect();
          setTargetWidth(rect.width);
          setTargetHeight(rect.height);
        }
      };
      var onTargetResize = function onTargetResize2() {
        syncTargetSize();
        triggerAlign();
      };
      var onVisibleChanged = function onVisibleChanged2(visible) {
        setInMotion(false);
        onAlign();
        afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 || afterPopupVisibleChange(visible);
      };
      var onPrepare = function onPrepare2() {
        return new Promise(function(resolve) {
          syncTargetSize();
          setMotionPrepareResolve(function() {
            return resolve;
          });
        });
      };
      useLayoutEffect_default(function() {
        if (motionPrepareResolve) {
          onAlign();
          motionPrepareResolve();
          setMotionPrepareResolve(null);
        }
      }, [motionPrepareResolve]);
      function wrapperAction(eventName, nextOpen, delay, preEvent) {
        cloneProps[eventName] = function(event) {
          var _originChildProps$eve;
          preEvent === null || preEvent === void 0 || preEvent(event);
          triggerOpen(nextOpen, delay);
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 || _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
        };
      }
      if (clickToShow || clickToHide) {
        cloneProps.onClick = function(event) {
          var _originChildProps$onC;
          if (openRef.current && clickToHide) {
            triggerOpen(false);
          } else if (!openRef.current && clickToShow) {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 || _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
        };
      }
      var onPopupPointerDown = useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
      var hoverToShow = showActions.has("hover");
      var hoverToHide = hideActions.has("hover");
      var onPopupMouseEnter;
      var onPopupMouseLeave;
      if (hoverToShow) {
        wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
          setMousePosByEvent(event);
        });
        wrapperAction("onPointerEnter", true, mouseEnterDelay, function(event) {
          setMousePosByEvent(event);
        });
        onPopupMouseEnter = function onPopupMouseEnter2(event) {
          if ((mergedOpen || inMotion) && popupEle !== null && popupEle !== void 0 && popupEle.contains(event.target)) {
            triggerOpen(true, mouseEnterDelay);
          }
        };
        if (alignPoint) {
          cloneProps.onMouseMove = function(event) {
            var _originChildProps$onM;
            (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 || _originChildProps$onM.call(originChildProps, event);
          };
        }
      }
      if (hoverToHide) {
        wrapperAction("onMouseLeave", false, mouseLeaveDelay);
        wrapperAction("onPointerLeave", false, mouseLeaveDelay);
        onPopupMouseLeave = function onPopupMouseLeave2() {
          triggerOpen(false, mouseLeaveDelay);
        };
      }
      if (showActions.has("focus")) {
        wrapperAction("onFocus", true, focusDelay);
      }
      if (hideActions.has("focus")) {
        wrapperAction("onBlur", false, blurDelay);
      }
      if (showActions.has("contextMenu")) {
        cloneProps.onContextMenu = function(event) {
          var _originChildProps$onC2;
          if (openRef.current && hideActions.has("contextMenu")) {
            triggerOpen(false);
          } else {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          event.preventDefault();
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }
          (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
        };
      }
      if (className) {
        cloneProps.className = (0, import_classnames43.default)(originChildProps.className, className);
      }
      var renderedRef = React154.useRef(false);
      renderedRef.current || (renderedRef.current = forceRender || mergedOpen || inMotion);
      var mergedChildrenProps = _objectSpread2(_objectSpread2({}, originChildProps), cloneProps);
      var passedProps = {};
      var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
      passedEventList.forEach(function(eventName) {
        if (restProps[eventName]) {
          passedProps[eventName] = function() {
            var _mergedChildrenProps$;
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
            restProps[eventName].apply(restProps, args);
          };
        }
      });
      var triggerNode = /* @__PURE__ */ React154.cloneElement(child, _objectSpread2(_objectSpread2({}, mergedChildrenProps), passedProps));
      var arrowPos = {
        x: arrowX,
        y: arrowY
      };
      var innerArrow = arrow ? _objectSpread2({}, arrow !== true ? arrow : {}) : null;
      return /* @__PURE__ */ React154.createElement(React154.Fragment, null, /* @__PURE__ */ React154.createElement(es_default, {
        disabled: !mergedOpen,
        ref: setTargetRef,
        onResize: onTargetResize
      }, /* @__PURE__ */ React154.createElement(TriggerWrapper_default, {
        getTriggerDOMNode
      }, triggerNode)), renderedRef.current && /* @__PURE__ */ React154.createElement(context_default2.Provider, {
        value: context
      }, /* @__PURE__ */ React154.createElement(Popup_default, {
        portal: PortalComponent,
        ref: setPopupRef,
        prefixCls,
        popup,
        className: (0, import_classnames43.default)(popupClassName, alignedClassName),
        style: popupStyle,
        target: targetEle,
        onMouseEnter: onPopupMouseEnter,
        onMouseLeave: onPopupMouseLeave,
        onPointerEnter: onPopupMouseEnter,
        zIndex,
        open: mergedOpen,
        keepDom: inMotion,
        fresh,
        onClick: onPopupClick,
        onPointerDownCapture: onPopupPointerDown,
        mask,
        motion: mergePopupMotion,
        maskMotion: mergeMaskMotion,
        onVisibleChanged,
        onPrepare,
        forceRender,
        autoDestroy: mergedAutoDestroy,
        getPopupContainer,
        align: alignInfo,
        arrow: innerArrow,
        arrowPos,
        ready,
        offsetX,
        offsetY,
        offsetR,
        offsetB,
        onAlign: triggerAlign,
        stretch,
        targetWidth: targetWidth / scaleX,
        targetHeight: targetHeight / scaleY
      })));
    });
    if (true) {
      Trigger.displayName = "Trigger";
    }
    return Trigger;
  }
  var es_default8 = generateTrigger(es_default3);

  // node_modules/rc-select/es/SelectTrigger.js
  var import_classnames44 = __toESM(require_classnames());
  var React155 = __toESM(require_react());
  var _excluded16 = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
  var getBuiltInPlacements = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
    var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
    return {
      bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      }
    };
  };
  var SelectTrigger = function SelectTrigger2(props, ref) {
    var prefixCls = props.prefixCls, disabled = props.disabled, visible = props.visible, children = props.children, popupElement = props.popupElement, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, builtinPlacements = props.builtinPlacements, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty2 = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties(props, _excluded16);
    var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
    var popupNode = popupElement;
    if (dropdownRender) {
      popupNode = dropdownRender(popupElement);
    }
    var mergedBuiltinPlacements2 = React155.useMemo(function() {
      return builtinPlacements || getBuiltInPlacements(dropdownMatchSelectWidth);
    }, [builtinPlacements, dropdownMatchSelectWidth]);
    var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName;
    var isNumberPopupWidth = typeof dropdownMatchSelectWidth === "number";
    var stretch = React155.useMemo(function() {
      if (isNumberPopupWidth) {
        return null;
      }
      return dropdownMatchSelectWidth === false ? "minWidth" : "width";
    }, [dropdownMatchSelectWidth, isNumberPopupWidth]);
    var popupStyle = dropdownStyle;
    if (isNumberPopupWidth) {
      popupStyle = _objectSpread2(_objectSpread2({}, popupStyle), {}, {
        width: dropdownMatchSelectWidth
      });
    }
    var triggerPopupRef = React155.useRef(null);
    React155.useImperativeHandle(ref, function() {
      return {
        getPopupElement: function getPopupElement() {
          var _triggerPopupRef$curr;
          return (_triggerPopupRef$curr = triggerPopupRef.current) === null || _triggerPopupRef$curr === void 0 ? void 0 : _triggerPopupRef$curr.popupElement;
        }
      };
    });
    return /* @__PURE__ */ React155.createElement(es_default8, _extends({}, restProps, {
      showAction: onPopupVisibleChange ? ["click"] : [],
      hideAction: onPopupVisibleChange ? ["click"] : [],
      popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
      builtinPlacements: mergedBuiltinPlacements2,
      prefixCls: dropdownPrefixCls,
      popupTransitionName: mergedTransitionName,
      popup: /* @__PURE__ */ React155.createElement("div", {
        onMouseEnter: onPopupMouseEnter
      }, popupNode),
      ref: triggerPopupRef,
      stretch,
      popupAlign: dropdownAlign,
      popupVisible: visible,
      getPopupContainer,
      popupClassName: (0, import_classnames44.default)(dropdownClassName, _defineProperty({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
      popupStyle,
      getTriggerDOMNode,
      onPopupVisibleChange
    }), children);
  };
  var RefSelectTrigger = /* @__PURE__ */ React155.forwardRef(SelectTrigger);
  if (true) {
    RefSelectTrigger.displayName = "SelectTrigger";
  }
  var SelectTrigger_default = RefSelectTrigger;

  // node_modules/rc-select/es/utils/valueUtil.js
  function getKey(data, index3) {
    var key = data.key;
    var value;
    if ("value" in data) {
      value = data.value;
    }
    if (key !== null && key !== void 0) {
      return key;
    }
    if (value !== void 0) {
      return value;
    }
    return "rc-index-key-".concat(index3);
  }
  function isValidCount(value) {
    return typeof value !== "undefined" && !Number.isNaN(value);
  }
  function fillFieldNames(fieldNames, childrenAsData) {
    var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options = _ref.options, groupLabel = _ref.groupLabel;
    var mergedLabel = label || (childrenAsData ? "children" : "label");
    return {
      label: mergedLabel,
      value: value || "value",
      options: options || "options",
      groupLabel: groupLabel || mergedLabel
    };
  }
  function flattenOptions(options) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
    var flattenList = [];
    var _fillFieldNames = fillFieldNames(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options, groupLabel = _fillFieldNames.groupLabel;
    function dig(list, isGroupOption) {
      if (!Array.isArray(list)) {
        return;
      }
      list.forEach(function(data) {
        if (isGroupOption || !(fieldOptions in data)) {
          var value = data[fieldValue];
          flattenList.push({
            key: getKey(data, flattenList.length),
            groupOption: isGroupOption,
            data,
            label: data[fieldLabel],
            value
          });
        } else {
          var grpLabel = data[groupLabel];
          if (grpLabel === void 0 && childrenAsData) {
            grpLabel = data.label;
          }
          flattenList.push({
            key: getKey(data, flattenList.length),
            group: true,
            data,
            label: grpLabel
          });
          dig(data[fieldOptions], true);
        }
      });
    }
    dig(options, false);
    return flattenList;
  }
  function injectPropsWithOption(option) {
    var newOption = _objectSpread2({}, option);
    if (!("props" in newOption)) {
      Object.defineProperty(newOption, "props", {
        get: function get2() {
          warning_default(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
          return newOption;
        }
      });
    }
    return newOption;
  }
  var getSeparatedContent = function getSeparatedContent2(text, tokens, end) {
    if (!tokens || !tokens.length) {
      return null;
    }
    var match2 = false;
    var separate = function separate2(str, _ref3) {
      var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
      if (!token2) {
        return [str];
      }
      var list2 = str.split(token2);
      match2 = match2 || list2.length > 1;
      return list2.reduce(function(prevList, unitStr) {
        return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate2(unitStr, restTokens)));
      }, []).filter(Boolean);
    };
    var list = separate(text, tokens);
    if (match2) {
      return typeof end !== "undefined" ? list.slice(0, end) : list;
    } else {
      return null;
    }
  };

  // node_modules/rc-select/es/SelectContext.js
  var React156 = __toESM(require_react());
  var SelectContext = /* @__PURE__ */ React156.createContext(null);
  var SelectContext_default = SelectContext;

  // node_modules/rc-select/es/BaseSelect/Polite.js
  var React157 = __toESM(require_react());
  function Polite(props) {
    var visible = props.visible, values = props.values;
    if (!visible) {
      return null;
    }
    var MAX_COUNT = 50;
    return /* @__PURE__ */ React157.createElement("span", {
      "aria-live": "polite",
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      }
    }, "".concat(values.slice(0, MAX_COUNT).map(function(_ref) {
      var label = _ref.label, value = _ref.value;
      return ["number", "string"].includes(_typeof(label)) ? label : value;
    }).join(", ")), values.length > MAX_COUNT ? ", ..." : null);
  }

  // node_modules/rc-select/es/BaseSelect/index.js
  var _excluded17 = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "prefix", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
  var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
  var isMultiple = function isMultiple2(mode) {
    return mode === "tags" || mode === "multiple";
  };
  var BaseSelect = /* @__PURE__ */ React158.forwardRef(function(props, ref) {
    var _customizeRawInputEle;
    var id = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open2 = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, prefix = props.prefix, suffixIcon = props.suffixIcon, clearIcon = props.clearIcon, OptionList3 = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, builtinPlacements = props.builtinPlacements, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown2 = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties(props, _excluded17);
    var multiple = isMultiple(mode);
    var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
    var domProps = _objectSpread2({}, restProps);
    DEFAULT_OMIT_PROPS.forEach(function(propName) {
      delete domProps[propName];
    });
    omitDomProps === null || omitDomProps === void 0 || omitDomProps.forEach(function(propName) {
      delete domProps[propName];
    });
    var _React$useState = React158.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
    React158.useEffect(function() {
      setMobile(isMobile_default());
    }, []);
    var containerRef = React158.useRef(null);
    var selectorDomRef = React158.useRef(null);
    var triggerRef = React158.useRef(null);
    var selectorRef = React158.useRef(null);
    var listRef = React158.useRef(null);
    var blurRef = React158.useRef(false);
    var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
    React158.useImperativeHandle(ref, function() {
      var _selectorRef$current, _selectorRef$current2;
      return {
        focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
        blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
        scrollTo: function scrollTo2(arg) {
          var _listRef$current;
          return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
        },
        nativeElement: containerRef.current || selectorDomRef.current
      };
    });
    var mergedSearchValue = React158.useMemo(function() {
      var _displayValues$;
      if (mode !== "combobox") {
        return searchValue;
      }
      var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
      return typeof val === "string" || typeof val === "number" ? String(val) : "";
    }, [searchValue, mode, displayValues]);
    var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
    var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
    var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 || (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
    var _React$useState3 = React158.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), rendered = _React$useState4[0], setRendered = _React$useState4[1];
    useLayoutEffect_default(function() {
      setRendered(true);
    }, []);
    var _useMergedState = useMergedState(false, {
      defaultValue: defaultOpen,
      value: open2
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
    var mergedOpen = rendered ? innerOpen : false;
    var emptyListContent = !notFoundContent && emptyOptions;
    if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
      mergedOpen = false;
    }
    var triggerOpen = emptyListContent ? false : mergedOpen;
    var onToggleOpen = React158.useCallback(function(newOpen) {
      var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
      if (!disabled) {
        setInnerOpen(nextOpen);
        if (mergedOpen !== nextOpen) {
          onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 || onDropdownVisibleChange(nextOpen);
        }
      }
    }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
    var tokenWithEnter = React158.useMemo(function() {
      return (tokenSeparators || []).some(function(tokenSeparator) {
        return ["\n", "\r\n"].includes(tokenSeparator);
      });
    }, [tokenSeparators]);
    var _ref = React158.useContext(SelectContext_default) || {}, maxCount = _ref.maxCount, rawValues = _ref.rawValues;
    var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
      if (multiple && isValidCount(maxCount) && (rawValues === null || rawValues === void 0 ? void 0 : rawValues.size) >= maxCount) {
        return;
      }
      var ret = true;
      var newSearchText = searchText;
      onActiveValueChange === null || onActiveValueChange === void 0 || onActiveValueChange(null);
      var separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - rawValues.size : void 0);
      var patchLabels = isCompositing ? null : separatedList;
      if (mode !== "combobox" && patchLabels) {
        newSearchText = "";
        onSearchSplit === null || onSearchSplit === void 0 || onSearchSplit(patchLabels);
        onToggleOpen(false);
        ret = false;
      }
      if (onSearch && mergedSearchValue !== newSearchText) {
        onSearch(newSearchText, {
          source: fromTyping ? "typing" : "effect"
        });
      }
      return ret;
    };
    var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
      if (!searchText || !searchText.trim()) {
        return;
      }
      onSearch(searchText, {
        source: "submit"
      });
    };
    React158.useEffect(function() {
      if (!mergedOpen && !multiple && mode !== "combobox") {
        onInternalSearch("", false, false);
      }
    }, [mergedOpen]);
    React158.useEffect(function() {
      if (innerOpen && disabled) {
        setInnerOpen(false);
      }
      if (disabled && !blurRef.current) {
        setMockFocused(false);
      }
    }, [disabled]);
    var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
    var keyLockRef = React158.useRef(false);
    var onInternalKeyDown = function onInternalKeyDown2(event) {
      var clearLock = getClearLock();
      var key = event.key;
      var isEnterKey = key === "Enter";
      if (isEnterKey) {
        if (mode !== "combobox") {
          event.preventDefault();
        }
        if (!mergedOpen) {
          onToggleOpen(true);
        }
      }
      setClearLock(!!mergedSearchValue);
      if (key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
        var cloneDisplayValues = _toConsumableArray(displayValues);
        var removedDisplayValue = null;
        for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
          var current = cloneDisplayValues[i];
          if (!current.disabled) {
            cloneDisplayValues.splice(i, 1);
            removedDisplayValue = current;
            break;
          }
        }
        if (removedDisplayValue) {
          onDisplayValuesChange(cloneDisplayValues, {
            type: "remove",
            values: [removedDisplayValue]
          });
        }
      }
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
        var _listRef$current2;
        if (isEnterKey) {
          keyLockRef.current = true;
        }
        (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.onKeyDown.apply(_listRef$current2, [event].concat(rest));
      }
      onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2.apply(void 0, [event].concat(rest));
    };
    var onInternalKeyUp = function onInternalKeyUp2(event) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }
      if (mergedOpen) {
        var _listRef$current3;
        (_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 || _listRef$current3.onKeyUp.apply(_listRef$current3, [event].concat(rest));
      }
      if (event.key === "Enter") {
        keyLockRef.current = false;
      }
      onKeyUp === null || onKeyUp === void 0 || onKeyUp.apply(void 0, [event].concat(rest));
    };
    var onSelectorRemove = function onSelectorRemove2(val) {
      var newValues = displayValues.filter(function(i) {
        return i !== val;
      });
      onDisplayValuesChange(newValues, {
        type: "remove",
        values: [val]
      });
    };
    var onInputBlur = function onInputBlur2() {
      keyLockRef.current = false;
    };
    var focusRef = React158.useRef(false);
    var onContainerFocus = function onContainerFocus2() {
      setMockFocused(true);
      if (!disabled) {
        if (onFocus && !focusRef.current) {
          onFocus.apply(void 0, arguments);
        }
        if (showAction.includes("focus")) {
          onToggleOpen(true);
        }
      }
      focusRef.current = true;
    };
    var onContainerBlur = function onContainerBlur2() {
      blurRef.current = true;
      setMockFocused(false, function() {
        focusRef.current = false;
        blurRef.current = false;
        onToggleOpen(false);
      });
      if (disabled) {
        return;
      }
      if (mergedSearchValue) {
        if (mode === "tags") {
          onSearch(mergedSearchValue, {
            source: "submit"
          });
        } else if (mode === "multiple") {
          onSearch("", {
            source: "blur"
          });
        }
      }
      if (onBlur) {
        onBlur.apply(void 0, arguments);
      }
    };
    var activeTimeoutIds = [];
    React158.useEffect(function() {
      return function() {
        activeTimeoutIds.forEach(function(timeoutId) {
          return clearTimeout(timeoutId);
        });
        activeTimeoutIds.splice(0, activeTimeoutIds.length);
      };
    }, []);
    var onInternalMouseDown = function onInternalMouseDown2(event) {
      var _triggerRef$current;
      var target = event.target;
      var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
      if (popupElement && popupElement.contains(target)) {
        var timeoutId = setTimeout(function() {
          var index3 = activeTimeoutIds.indexOf(timeoutId);
          if (index3 !== -1) {
            activeTimeoutIds.splice(index3, 1);
          }
          cancelSetMockFocused();
          if (!mobile && !popupElement.contains(document.activeElement)) {
            var _selectorRef$current3;
            (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.focus();
          }
        });
        activeTimeoutIds.push(timeoutId);
      }
      for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        restArgs[_key3 - 1] = arguments[_key3];
      }
      onMouseDown === null || onMouseDown === void 0 || onMouseDown.apply(void 0, [event].concat(restArgs));
    };
    var _React$useState5 = React158.useState({}), _React$useState6 = _slicedToArray(_React$useState5, 2), forceUpdate = _React$useState6[1];
    function onPopupMouseEnter() {
      forceUpdate({});
    }
    var onTriggerVisibleChange;
    if (customizeRawInputElement) {
      onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
        onToggleOpen(newOpen);
      };
    }
    useSelectTriggerControl(function() {
      var _triggerRef$current2;
      return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
    }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
    var baseSelectContext = React158.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, props), {}, {
        notFoundContent,
        open: mergedOpen,
        triggerOpen,
        id,
        showSearch: mergedShowSearch,
        multiple,
        toggleOpen: onToggleOpen
      });
    }, [props, notFoundContent, triggerOpen, mergedOpen, id, mergedShowSearch, multiple, onToggleOpen]);
    var showSuffixIcon = !!suffixIcon || loading;
    var arrowNode;
    if (showSuffixIcon) {
      arrowNode = /* @__PURE__ */ React158.createElement(TransBtn_default, {
        className: (0, import_classnames45.default)("".concat(prefixCls, "-arrow"), _defineProperty({}, "".concat(prefixCls, "-arrow-loading"), loading)),
        customizeIcon: suffixIcon,
        customizeIconProps: {
          loading,
          searchValue: mergedSearchValue,
          open: mergedOpen,
          focused: mockFocused,
          showSearch: mergedShowSearch
        }
      });
    }
    var onClearMouseDown = function onClearMouseDown2() {
      var _selectorRef$current4;
      onClear === null || onClear === void 0 || onClear();
      (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 || _selectorRef$current4.focus();
      onDisplayValuesChange([], {
        type: "clear",
        values: displayValues
      });
      onInternalSearch("", false, false);
    };
    var _useAllowClear = useAllowClear(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode), mergedAllowClear = _useAllowClear.allowClear, clearNode = _useAllowClear.clearIcon;
    var optionList = /* @__PURE__ */ React158.createElement(OptionList3, {
      ref: listRef
    });
    var mergedClassName = (0, import_classnames45.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-focused"), mockFocused), "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-single"), !multiple), "".concat(prefixCls, "-allow-clear"), allowClear), "".concat(prefixCls, "-show-arrow"), showSuffixIcon), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-loading"), loading), "".concat(prefixCls, "-open"), mergedOpen), "".concat(prefixCls, "-customize-input"), customizeInputElement), "".concat(prefixCls, "-show-search"), mergedShowSearch));
    var selectorNode = /* @__PURE__ */ React158.createElement(SelectTrigger_default, {
      ref: triggerRef,
      disabled,
      prefixCls,
      visible: triggerOpen,
      popupElement: optionList,
      animation,
      transitionName,
      dropdownStyle,
      dropdownClassName,
      direction,
      dropdownMatchSelectWidth,
      dropdownRender,
      dropdownAlign,
      placement,
      builtinPlacements,
      getPopupContainer,
      empty: emptyOptions,
      getTriggerDOMNode: function getTriggerDOMNode(node2) {
        return (
          // TODO: This is workaround and should be removed in `rc-select`
          // And use new standard `nativeElement` for ref.
          // But we should update `rc-resize-observer` first.
          selectorDomRef.current || node2
        );
      },
      onPopupVisibleChange: onTriggerVisibleChange,
      onPopupMouseEnter
    }, customizeRawInputElement ? /* @__PURE__ */ React158.cloneElement(customizeRawInputElement, {
      ref: customizeRawInputRef
    }) : /* @__PURE__ */ React158.createElement(Selector_default, _extends({}, props, {
      domRef: selectorDomRef,
      prefixCls,
      inputElement: customizeInputElement,
      ref: selectorRef,
      id,
      prefix,
      showSearch: mergedShowSearch,
      autoClearSearchValue,
      mode,
      activeDescendantId,
      tagRender,
      values: displayValues,
      open: mergedOpen,
      onToggleOpen,
      activeValue,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      onSearchSubmit: onInternalSearchSubmit,
      onRemove: onSelectorRemove,
      tokenWithEnter,
      onInputBlur
    })));
    var renderNode;
    if (customizeRawInputElement) {
      renderNode = selectorNode;
    } else {
      renderNode = /* @__PURE__ */ React158.createElement("div", _extends({
        className: mergedClassName
      }, domProps, {
        ref: containerRef,
        onMouseDown: onInternalMouseDown,
        onKeyDown: onInternalKeyDown,
        onKeyUp: onInternalKeyUp,
        onFocus: onContainerFocus,
        onBlur: onContainerBlur
      }), /* @__PURE__ */ React158.createElement(Polite, {
        visible: mockFocused && !mergedOpen,
        values: displayValues
      }), selectorNode, arrowNode, mergedAllowClear && clearNode);
    }
    return /* @__PURE__ */ React158.createElement(BaseSelectContext.Provider, {
      value: baseSelectContext
    }, renderNode);
  });
  if (true) {
    BaseSelect.displayName = "BaseSelect";
  }
  var BaseSelect_default = BaseSelect;

  // node_modules/rc-select/es/OptGroup.js
  var OptGroup = function OptGroup2() {
    return null;
  };
  OptGroup.isSelectOptGroup = true;
  var OptGroup_default = OptGroup;

  // node_modules/rc-select/es/Option.js
  var Option = function Option2() {
    return null;
  };
  Option.isSelectOption = true;
  var Option_default = Option;

  // node_modules/rc-select/es/OptionList.js
  var import_classnames49 = __toESM(require_classnames());

  // node_modules/rc-virtual-list/es/List.js
  var import_classnames48 = __toESM(require_classnames());
  var React168 = __toESM(require_react());
  var import_react65 = __toESM(require_react());
  var import_react_dom5 = __toESM(require_react_dom());

  // node_modules/rc-virtual-list/es/Filler.js
  var React159 = __toESM(require_react());
  var import_classnames46 = __toESM(require_classnames());
  var Filler = /* @__PURE__ */ React159.forwardRef(function(_ref, ref) {
    var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
    var outerStyle = {};
    var innerStyle = {
      display: "flex",
      flexDirection: "column"
    };
    if (offsetY !== void 0) {
      outerStyle = {
        height,
        position: "relative",
        overflow: "hidden"
      };
      innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        transform: "translateY(".concat(offsetY, "px)")
      }, rtl ? "marginRight" : "marginLeft", -offsetX), "position", "absolute"), "left", 0), "right", 0), "top", 0));
    }
    return /* @__PURE__ */ React159.createElement("div", {
      style: outerStyle
    }, /* @__PURE__ */ React159.createElement(es_default, {
      onResize: function onResize2(_ref2) {
        var offsetHeight = _ref2.offsetHeight;
        if (offsetHeight && onInnerResize) {
          onInnerResize();
        }
      }
    }, /* @__PURE__ */ React159.createElement("div", _extends({
      style: innerStyle,
      className: (0, import_classnames46.default)(_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
      ref
    }, innerProps), children, extra)));
  });
  Filler.displayName = "Filler";
  var Filler_default = Filler;

  // node_modules/rc-virtual-list/es/hooks/useChildren.js
  var React161 = __toESM(require_react());

  // node_modules/rc-virtual-list/es/Item.js
  var React160 = __toESM(require_react());
  function Item2(_ref) {
    var children = _ref.children, setRef = _ref.setRef;
    var refFunc = React160.useCallback(function(node2) {
      setRef(node2);
    }, []);
    return /* @__PURE__ */ React160.cloneElement(children, {
      ref: refFunc
    });
  }

  // node_modules/rc-virtual-list/es/hooks/useChildren.js
  function useChildren(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, _ref) {
    var getKey3 = _ref.getKey;
    return list.slice(startIndex, endIndex + 1).map(function(item, index3) {
      var eleIndex = startIndex + index3;
      var node2 = renderFunc(item, eleIndex, {
        style: {
          width: scrollWidth
        },
        offsetX
      });
      var key = getKey3(item);
      return /* @__PURE__ */ React161.createElement(Item2, {
        key,
        setRef: function setRef(ele) {
          return setNodeRef(item, ele);
        }
      }, node2);
    });
  }

  // node_modules/rc-virtual-list/es/hooks/useDiffItem.js
  var React162 = __toESM(require_react());

  // node_modules/rc-virtual-list/es/utils/algorithmUtil.js
  function findListDiffIndex(originList, targetList, getKey3) {
    var originLen = originList.length;
    var targetLen = targetList.length;
    var shortList;
    var longList;
    if (originLen === 0 && targetLen === 0) {
      return null;
    }
    if (originLen < targetLen) {
      shortList = originList;
      longList = targetList;
    } else {
      shortList = targetList;
      longList = originList;
    }
    var notExistKey = {
      __EMPTY_ITEM__: true
    };
    function getItemKey(item) {
      if (item !== void 0) {
        return getKey3(item);
      }
      return notExistKey;
    }
    var diffIndex = null;
    var multiple = Math.abs(originLen - targetLen) !== 1;
    for (var i = 0; i < longList.length; i += 1) {
      var shortKey = getItemKey(shortList[i]);
      var longKey = getItemKey(longList[i]);
      if (shortKey !== longKey) {
        diffIndex = i;
        multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
        break;
      }
    }
    return diffIndex === null ? null : {
      index: diffIndex,
      multiple
    };
  }

  // node_modules/rc-virtual-list/es/hooks/useDiffItem.js
  function useDiffItem(data, getKey3, onDiff) {
    var _React$useState = React162.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
    var _React$useState3 = React162.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
    React162.useEffect(function() {
      var diff = findListDiffIndex(prevData || [], data || [], getKey3);
      if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
        onDiff === null || onDiff === void 0 || onDiff(diff.index);
        setDiffItem(data[diff.index]);
      }
      setPrevData(data);
    }, [data]);
    return [diffItem];
  }

  // node_modules/rc-virtual-list/es/hooks/useFrameWheel.js
  var import_react62 = __toESM(require_react());

  // node_modules/rc-virtual-list/es/utils/isFirefox.js
  var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
  var isFirefox_default = isFF;

  // node_modules/rc-virtual-list/es/hooks/useOriginScroll.js
  var import_react61 = __toESM(require_react());
  var useOriginScroll_default = function(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) {
    var lockRef = (0, import_react61.useRef)(false);
    var lockTimeoutRef = (0, import_react61.useRef)(null);
    function lockScroll() {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = true;
      lockTimeoutRef.current = setTimeout(function() {
        lockRef.current = false;
      }, 50);
    }
    var scrollPingRef = (0, import_react61.useRef)({
      top: isScrollAtTop,
      bottom: isScrollAtBottom,
      left: isScrollAtLeft,
      right: isScrollAtRight
    });
    scrollPingRef.current.top = isScrollAtTop;
    scrollPingRef.current.bottom = isScrollAtBottom;
    scrollPingRef.current.left = isScrollAtLeft;
    scrollPingRef.current.right = isScrollAtRight;
    return function(isHorizontal, delta) {
      var smoothOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var originScroll = isHorizontal ? (
        // Pass origin wheel when on the left
        delta < 0 && scrollPingRef.current.left || // Pass origin wheel when on the right
        delta > 0 && scrollPingRef.current.right
      ) : delta < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
      delta > 0 && scrollPingRef.current.bottom;
      if (smoothOffset && originScroll) {
        clearTimeout(lockTimeoutRef.current);
        lockRef.current = false;
      } else if (!originScroll || lockRef.current) {
        lockScroll();
      }
      return !lockRef.current && originScroll;
    };
  };

  // node_modules/rc-virtual-list/es/hooks/useFrameWheel.js
  function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
    var offsetRef = (0, import_react62.useRef)(0);
    var nextFrameRef = (0, import_react62.useRef)(null);
    var wheelValueRef = (0, import_react62.useRef)(null);
    var isMouseScrollRef = (0, import_react62.useRef)(false);
    var originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
    function onWheelY(e3, deltaY) {
      raf_default.cancel(nextFrameRef.current);
      if (originScroll(false, deltaY)) return;
      var event = e3;
      if (!event._virtualHandled) {
        event._virtualHandled = true;
      } else {
        return;
      }
      offsetRef.current += deltaY;
      wheelValueRef.current = deltaY;
      if (!isFirefox_default) {
        event.preventDefault();
      }
      nextFrameRef.current = raf_default(function() {
        var patchMultiple = isMouseScrollRef.current ? 10 : 1;
        onWheelDelta(offsetRef.current * patchMultiple, false);
        offsetRef.current = 0;
      });
    }
    function onWheelX(event, deltaX) {
      onWheelDelta(deltaX, true);
      if (!isFirefox_default) {
        event.preventDefault();
      }
    }
    var wheelDirectionRef = (0, import_react62.useRef)(null);
    var wheelDirectionCleanRef = (0, import_react62.useRef)(null);
    function onWheel(event) {
      if (!inVirtual) return;
      raf_default.cancel(wheelDirectionCleanRef.current);
      wheelDirectionCleanRef.current = raf_default(function() {
        wheelDirectionRef.current = null;
      }, 2);
      var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
      var mergedDeltaX = deltaX;
      var mergedDeltaY = deltaY;
      if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
        mergedDeltaX = deltaY;
        mergedDeltaY = 0;
        wheelDirectionRef.current = "sx";
      }
      var absX = Math.abs(mergedDeltaX);
      var absY = Math.abs(mergedDeltaY);
      if (wheelDirectionRef.current === null) {
        wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
      }
      if (wheelDirectionRef.current === "y") {
        onWheelY(event, mergedDeltaY);
      } else {
        onWheelX(event, mergedDeltaX);
      }
    }
    function onFireFoxScroll(event) {
      if (!inVirtual) return;
      isMouseScrollRef.current = event.detail === wheelValueRef.current;
    }
    return [onWheel, onFireFoxScroll];
  }

  // node_modules/rc-virtual-list/es/hooks/useGetSize.js
  var React163 = __toESM(require_react());
  function useGetSize(mergedData, getKey3, heights, itemHeight) {
    var _React$useMemo = React163.useMemo(function() {
      return [/* @__PURE__ */ new Map(), []];
    }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
    var getSize4 = function getSize5(startKey) {
      var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
      var startIndex = key2Index.get(startKey);
      var endIndex = key2Index.get(endKey);
      if (startIndex === void 0 || endIndex === void 0) {
        var dataLen = mergedData.length;
        for (var i = bottomList.length; i < dataLen; i += 1) {
          var _heights$get;
          var item = mergedData[i];
          var key = getKey3(item);
          key2Index.set(key, i);
          var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
          bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
          if (key === startKey) {
            startIndex = i;
          }
          if (key === endKey) {
            endIndex = i;
          }
          if (startIndex !== void 0 && endIndex !== void 0) {
            break;
          }
        }
      }
      return {
        top: bottomList[startIndex - 1] || 0,
        bottom: bottomList[endIndex]
      };
    };
    return getSize4;
  }

  // node_modules/rc-virtual-list/es/hooks/useHeights.js
  var React164 = __toESM(require_react());
  var import_react63 = __toESM(require_react());

  // node_modules/rc-virtual-list/es/utils/CacheMap.js
  var CacheMap = /* @__PURE__ */ function() {
    function CacheMap2() {
      _classCallCheck(this, CacheMap2);
      _defineProperty(this, "maps", void 0);
      _defineProperty(this, "id", 0);
      _defineProperty(this, "diffRecords", /* @__PURE__ */ new Map());
      this.maps = /* @__PURE__ */ Object.create(null);
    }
    _createClass(CacheMap2, [{
      key: "set",
      value: function set2(key, value) {
        this.diffRecords.set(key, this.maps[key]);
        this.maps[key] = value;
        this.id += 1;
      }
    }, {
      key: "get",
      value: function get2(key) {
        return this.maps[key];
      }
      /**
       * CacheMap will record the key changed.
       * To help to know what's update in the next render.
       */
    }, {
      key: "resetRecord",
      value: function resetRecord() {
        this.diffRecords.clear();
      }
    }, {
      key: "getRecord",
      value: function getRecord() {
        return this.diffRecords;
      }
    }]);
    return CacheMap2;
  }();
  var CacheMap_default = CacheMap;

  // node_modules/rc-virtual-list/es/hooks/useHeights.js
  function parseNumber(value) {
    var num = parseFloat(value);
    return isNaN(num) ? 0 : num;
  }
  function useHeights(getKey3, onItemAdd, onItemRemove) {
    var _React$useState = React164.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
    var instanceRef = (0, import_react63.useRef)(/* @__PURE__ */ new Map());
    var heightsRef = (0, import_react63.useRef)(new CacheMap_default());
    var promiseIdRef = (0, import_react63.useRef)(0);
    function cancelRaf() {
      promiseIdRef.current += 1;
    }
    function collectHeight() {
      var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      cancelRaf();
      var doCollect = function doCollect2() {
        var changed = false;
        instanceRef.current.forEach(function(element, key) {
          if (element && element.offsetParent) {
            var offsetHeight = element.offsetHeight;
            var _getComputedStyle = getComputedStyle(element), marginTop = _getComputedStyle.marginTop, marginBottom = _getComputedStyle.marginBottom;
            var marginTopNum = parseNumber(marginTop);
            var marginBottomNum = parseNumber(marginBottom);
            var totalHeight = offsetHeight + marginTopNum + marginBottomNum;
            if (heightsRef.current.get(key) !== totalHeight) {
              heightsRef.current.set(key, totalHeight);
              changed = true;
            }
          }
        });
        if (changed) {
          setUpdatedMark(function(c) {
            return c + 1;
          });
        }
      };
      if (sync) {
        doCollect();
      } else {
        promiseIdRef.current += 1;
        var id = promiseIdRef.current;
        Promise.resolve().then(function() {
          if (id === promiseIdRef.current) {
            doCollect();
          }
        });
      }
    }
    function setInstanceRef(item, instance) {
      var key = getKey3(item);
      var origin2 = instanceRef.current.get(key);
      if (instance) {
        instanceRef.current.set(key, instance);
        collectHeight();
      } else {
        instanceRef.current.delete(key);
      }
      if (!origin2 !== !instance) {
        if (instance) {
          onItemAdd === null || onItemAdd === void 0 || onItemAdd(item);
        } else {
          onItemRemove === null || onItemRemove === void 0 || onItemRemove(item);
        }
      }
    }
    (0, import_react63.useEffect)(function() {
      return cancelRaf;
    }, []);
    return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
  }

  // node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js
  var import_react64 = __toESM(require_react());
  var SMOOTH_PTG = 14 / 15;
  function useMobileTouchMove(inVirtual, listRef, callback) {
    var touchedRef = (0, import_react64.useRef)(false);
    var touchXRef = (0, import_react64.useRef)(0);
    var touchYRef = (0, import_react64.useRef)(0);
    var elementRef = (0, import_react64.useRef)(null);
    var intervalRef = (0, import_react64.useRef)(null);
    var cleanUpEvents;
    var onTouchMove = function onTouchMove2(e3) {
      if (touchedRef.current) {
        var currentX = Math.ceil(e3.touches[0].pageX);
        var currentY = Math.ceil(e3.touches[0].pageY);
        var offsetX = touchXRef.current - currentX;
        var offsetY = touchYRef.current - currentY;
        var _isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
        if (_isHorizontal) {
          touchXRef.current = currentX;
        } else {
          touchYRef.current = currentY;
        }
        var scrollHandled = callback(_isHorizontal, _isHorizontal ? offsetX : offsetY, false, e3);
        if (scrollHandled) {
          e3.preventDefault();
        }
        clearInterval(intervalRef.current);
        if (scrollHandled) {
          intervalRef.current = setInterval(function() {
            if (_isHorizontal) {
              offsetX *= SMOOTH_PTG;
            } else {
              offsetY *= SMOOTH_PTG;
            }
            var offset3 = Math.floor(_isHorizontal ? offsetX : offsetY);
            if (!callback(_isHorizontal, offset3, true) || Math.abs(offset3) <= 0.1) {
              clearInterval(intervalRef.current);
            }
          }, 16);
        }
      }
    };
    var onTouchEnd = function onTouchEnd2() {
      touchedRef.current = false;
      cleanUpEvents();
    };
    var onTouchStart = function onTouchStart2(e3) {
      cleanUpEvents();
      if (e3.touches.length === 1 && !touchedRef.current) {
        touchedRef.current = true;
        touchXRef.current = Math.ceil(e3.touches[0].pageX);
        touchYRef.current = Math.ceil(e3.touches[0].pageY);
        elementRef.current = e3.target;
        elementRef.current.addEventListener("touchmove", onTouchMove, {
          passive: false
        });
        elementRef.current.addEventListener("touchend", onTouchEnd, {
          passive: true
        });
      }
    };
    cleanUpEvents = function cleanUpEvents2() {
      if (elementRef.current) {
        elementRef.current.removeEventListener("touchmove", onTouchMove);
        elementRef.current.removeEventListener("touchend", onTouchEnd);
      }
    };
    useLayoutEffect_default(function() {
      if (inVirtual) {
        listRef.current.addEventListener("touchstart", onTouchStart, {
          passive: true
        });
      }
      return function() {
        var _listRef$current;
        (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener("touchstart", onTouchStart);
        cleanUpEvents();
        clearInterval(intervalRef.current);
      };
    }, [inVirtual]);
  }

  // node_modules/rc-virtual-list/es/hooks/useScrollDrag.js
  var React165 = __toESM(require_react());
  function smoothScrollOffset(offset3) {
    return Math.floor(Math.pow(offset3, 0.5));
  }
  function getPageXY(e3, horizontal) {
    var obj = "touches" in e3 ? e3.touches[0] : e3;
    return obj[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
  }
  function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
    React165.useEffect(function() {
      var ele = componentRef.current;
      if (inVirtual && ele) {
        var mouseDownLock = false;
        var rafId;
        var _offset;
        var stopScroll = function stopScroll2() {
          raf_default.cancel(rafId);
        };
        var continueScroll = function continueScroll2() {
          stopScroll();
          rafId = raf_default(function() {
            onScrollOffset(_offset);
            continueScroll2();
          });
        };
        var onMouseDown = function onMouseDown2(e3) {
          if (e3.target.draggable || e3.button !== 0) {
            return;
          }
          var event = e3;
          if (!event._virtualHandled) {
            event._virtualHandled = true;
            mouseDownLock = true;
          }
        };
        var onMouseUp = function onMouseUp2() {
          mouseDownLock = false;
          stopScroll();
        };
        var onMouseMove = function onMouseMove2(e3) {
          if (mouseDownLock) {
            var mouseY = getPageXY(e3, false);
            var _ele$getBoundingClien = ele.getBoundingClientRect(), top = _ele$getBoundingClien.top, bottom = _ele$getBoundingClien.bottom;
            if (mouseY <= top) {
              var diff = top - mouseY;
              _offset = -smoothScrollOffset(diff);
              continueScroll();
            } else if (mouseY >= bottom) {
              var _diff = mouseY - bottom;
              _offset = smoothScrollOffset(_diff);
              continueScroll();
            } else {
              stopScroll();
            }
          }
        };
        ele.addEventListener("mousedown", onMouseDown);
        ele.ownerDocument.addEventListener("mouseup", onMouseUp);
        ele.ownerDocument.addEventListener("mousemove", onMouseMove);
        return function() {
          ele.removeEventListener("mousedown", onMouseDown);
          ele.ownerDocument.removeEventListener("mouseup", onMouseUp);
          ele.ownerDocument.removeEventListener("mousemove", onMouseMove);
          stopScroll();
        };
      }
    }, [inVirtual]);
  }

  // node_modules/rc-virtual-list/es/hooks/useScrollTo.js
  var React166 = __toESM(require_react());
  var MAX_TIMES = 10;
  function useScrollTo(containerRef, data, heights, itemHeight, getKey3, collectHeight, syncScrollTop, triggerFlash) {
    var scrollRef = React166.useRef();
    var _React$useState = React166.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
    useLayoutEffect_default(function() {
      if (syncState && syncState.times < MAX_TIMES) {
        if (!containerRef.current) {
          setSyncState(function(ori) {
            return _objectSpread2({}, ori);
          });
          return;
        }
        collectHeight();
        var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index3 = syncState.index, offset3 = syncState.offset;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        var targetTop = null;
        if (height) {
          var mergedAlign = targetAlign || originAlign;
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data.length - 1, index3);
          for (var i = 0; i <= maxLen; i += 1) {
            var key = getKey3(data[i]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
          }
          var leftHeight = mergedAlign === "top" ? offset3 : height - offset3;
          for (var _i = maxLen; _i >= 0; _i -= 1) {
            var _key = getKey3(data[_i]);
            var _cacheHeight = heights.get(_key);
            if (_cacheHeight === void 0) {
              needCollectHeight = true;
              break;
            }
            leftHeight -= _cacheHeight;
            if (leftHeight <= 0) {
              break;
            }
          }
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset3;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset3;
              break;
            default: {
              var scrollTop = containerRef.current.scrollTop;
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null) {
            syncScrollTop(targetTop);
          }
          if (targetTop !== syncState.lastTop) {
            needCollectHeight = true;
          }
        }
        if (needCollectHeight) {
          setSyncState(_objectSpread2(_objectSpread2({}, syncState), {}, {
            times: syncState.times + 1,
            targetAlign: newTargetAlign,
            lastTop: targetTop
          }));
        }
      } else if ((syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) {
        warning_default(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
      }
    }, [syncState, containerRef.current]);
    return function(arg) {
      if (arg === null || arg === void 0) {
        triggerFlash();
        return;
      }
      raf_default.cancel(scrollRef.current);
      if (typeof arg === "number") {
        syncScrollTop(arg);
      } else if (arg && _typeof(arg) === "object") {
        var index3;
        var align = arg.align;
        if ("index" in arg) {
          index3 = arg.index;
        } else {
          index3 = data.findIndex(function(item) {
            return getKey3(item) === arg.key;
          });
        }
        var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
        setSyncState({
          times: 0,
          index: index3,
          offset: offset3,
          originAlign: align
        });
      }
    };
  }

  // node_modules/rc-virtual-list/es/ScrollBar.js
  var import_classnames47 = __toESM(require_classnames());
  var React167 = __toESM(require_react());
  var ScrollBar = /* @__PURE__ */ React167.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle, showScrollBar = props.showScrollBar;
    var _React$useState = React167.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
    var _React$useState3 = React167.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
    var _React$useState5 = React167.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
    var isLTR = !rtl;
    var scrollbarRef = React167.useRef();
    var thumbRef = React167.useRef();
    var _React$useState7 = React167.useState(showScrollBar), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
    var visibleTimeoutRef = React167.useRef();
    var delayHidden = function delayHidden2() {
      if (showScrollBar === true || showScrollBar === false) return;
      clearTimeout(visibleTimeoutRef.current);
      setVisible(true);
      visibleTimeoutRef.current = setTimeout(function() {
        setVisible(false);
      }, 3e3);
    };
    var enableScrollRange = scrollRange - containerSize || 0;
    var enableOffsetRange = containerSize - spinSize || 0;
    var top = React167.useMemo(function() {
      if (scrollOffset === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollOffset / enableScrollRange;
      return ptg * enableOffsetRange;
    }, [scrollOffset, enableScrollRange, enableOffsetRange]);
    var onContainerMouseDown = function onContainerMouseDown2(e3) {
      e3.stopPropagation();
      e3.preventDefault();
    };
    var stateRef = React167.useRef({
      top,
      dragging,
      pageY: pageXY,
      startTop
    });
    stateRef.current = {
      top,
      dragging,
      pageY: pageXY,
      startTop
    };
    var onThumbMouseDown = function onThumbMouseDown2(e3) {
      setDragging(true);
      setPageXY(getPageXY(e3, horizontal));
      setStartTop(stateRef.current.top);
      onStartMove();
      e3.stopPropagation();
      e3.preventDefault();
    };
    React167.useEffect(function() {
      var onScrollbarTouchStart = function onScrollbarTouchStart2(e3) {
        e3.preventDefault();
      };
      var scrollbarEle = scrollbarRef.current;
      var thumbEle = thumbRef.current;
      scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, {
        passive: false
      });
      thumbEle.addEventListener("touchstart", onThumbMouseDown, {
        passive: false
      });
      return function() {
        scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
        thumbEle.removeEventListener("touchstart", onThumbMouseDown);
      };
    }, []);
    var enableScrollRangeRef = React167.useRef();
    enableScrollRangeRef.current = enableScrollRange;
    var enableOffsetRangeRef = React167.useRef();
    enableOffsetRangeRef.current = enableOffsetRange;
    React167.useEffect(function() {
      if (dragging) {
        var moveRafId;
        var onMouseMove = function onMouseMove2(e3) {
          var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
          raf_default.cancel(moveRafId);
          var rect = scrollbarRef.current.getBoundingClientRect();
          var scale = containerSize / (horizontal ? rect.width : rect.height);
          if (stateDragging) {
            var offset3 = (getPageXY(e3, horizontal) - statePageY) * scale;
            var newTop = stateStartTop;
            if (!isLTR && horizontal) {
              newTop -= offset3;
            } else {
              newTop += offset3;
            }
            var tmpEnableScrollRange = enableScrollRangeRef.current;
            var tmpEnableOffsetRange = enableOffsetRangeRef.current;
            var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
            var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
            newScrollTop = Math.max(newScrollTop, 0);
            newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
            moveRafId = raf_default(function() {
              onScroll(newScrollTop, horizontal);
            });
          }
        };
        var onMouseUp = function onMouseUp2() {
          setDragging(false);
          onStopMove();
        };
        window.addEventListener("mousemove", onMouseMove, {
          passive: true
        });
        window.addEventListener("touchmove", onMouseMove, {
          passive: true
        });
        window.addEventListener("mouseup", onMouseUp, {
          passive: true
        });
        window.addEventListener("touchend", onMouseUp, {
          passive: true
        });
        return function() {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("touchmove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
          window.removeEventListener("touchend", onMouseUp);
          raf_default.cancel(moveRafId);
        };
      }
    }, [dragging]);
    React167.useEffect(function() {
      delayHidden();
      return function() {
        clearTimeout(visibleTimeoutRef.current);
      };
    }, [scrollOffset]);
    React167.useImperativeHandle(ref, function() {
      return {
        delayHidden
      };
    });
    var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
    var containerStyle = {
      position: "absolute",
      visibility: visible ? null : "hidden"
    };
    var thumbStyle = {
      position: "absolute",
      borderRadius: 99,
      background: "var(--rc-virtual-list-scrollbar-bg, rgba(0, 0, 0, 0.5))",
      cursor: "pointer",
      userSelect: "none"
    };
    if (horizontal) {
      Object.assign(containerStyle, {
        height: 8,
        left: 0,
        right: 0,
        bottom: 0
      });
      Object.assign(thumbStyle, _defineProperty({
        height: "100%",
        width: spinSize
      }, isLTR ? "left" : "right", top));
    } else {
      Object.assign(containerStyle, _defineProperty({
        width: 8,
        top: 0,
        bottom: 0
      }, isLTR ? "right" : "left", 0));
      Object.assign(thumbStyle, {
        width: "100%",
        height: spinSize,
        top
      });
    }
    return /* @__PURE__ */ React167.createElement("div", {
      ref: scrollbarRef,
      className: (0, import_classnames47.default)(scrollbarPrefixCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
      style: _objectSpread2(_objectSpread2({}, containerStyle), style2),
      onMouseDown: onContainerMouseDown,
      onMouseMove: delayHidden
    }, /* @__PURE__ */ React167.createElement("div", {
      ref: thumbRef,
      className: (0, import_classnames47.default)("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
      style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
      onMouseDown: onThumbMouseDown
    }));
  });
  if (true) {
    ScrollBar.displayName = "ScrollBar";
  }
  var ScrollBar_default = ScrollBar;

  // node_modules/rc-virtual-list/es/utils/scrollbarUtil.js
  var MIN_SIZE = 20;
  function getSpinSize() {
    var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var baseSize = containerSize / scrollRange * containerSize;
    if (isNaN(baseSize)) {
      baseSize = 0;
    }
    baseSize = Math.max(baseSize, MIN_SIZE);
    return Math.floor(baseSize);
  }

  // node_modules/rc-virtual-list/es/List.js
  var _excluded18 = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles", "showScrollBar"];
  var EMPTY_DATA = [];
  var ScrollStyle = {
    overflowY: "auto",
    overflowAnchor: "none"
  };
  function RawList(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data = props.data, children = props.children, itemKey3 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component9 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, _props$showScrollBar = props.showScrollBar, showScrollBar = _props$showScrollBar === void 0 ? "optional" : _props$showScrollBar, restProps = _objectWithoutProperties(props, _excluded18);
    var getKey3 = React168.useCallback(function(item) {
      if (typeof itemKey3 === "function") {
        return itemKey3(item);
      }
      return item === null || item === void 0 ? void 0 : item[itemKey3];
    }, [itemKey3]);
    var _useHeights = useHeights(getKey3, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
    var useVirtual = !!(virtual !== false && height && itemHeight);
    var containerHeight = React168.useMemo(function() {
      return Object.values(heights.maps).reduce(function(total, curr) {
        return total + curr;
      }, 0);
    }, [heights.id, heights.maps]);
    var inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
    var isRTL = direction === "rtl";
    var mergedClassName = (0, import_classnames48.default)(prefixCls, _defineProperty({}, "".concat(prefixCls, "-rtl"), isRTL), className);
    var mergedData = data || EMPTY_DATA;
    var componentRef = (0, import_react65.useRef)();
    var fillerInnerRef = (0, import_react65.useRef)();
    var containerRef = (0, import_react65.useRef)();
    var _useState = (0, import_react65.useState)(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
    var _useState3 = (0, import_react65.useState)(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
    var _useState5 = (0, import_react65.useState)(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
    var onScrollbarStartMove = function onScrollbarStartMove2() {
      setScrollMoving(true);
    };
    var onScrollbarStopMove = function onScrollbarStopMove2() {
      setScrollMoving(false);
    };
    var sharedConfig = {
      getKey: getKey3
    };
    function syncScrollTop(newTop) {
      setOffsetTop(function(origin2) {
        var value;
        if (typeof newTop === "function") {
          value = newTop(origin2);
        } else {
          value = newTop;
        }
        var alignedTop = keepInRange(value);
        componentRef.current.scrollTop = alignedTop;
        return alignedTop;
      });
    }
    var rangeRef = (0, import_react65.useRef)({
      start: 0,
      end: mergedData.length
    });
    var diffItemRef = (0, import_react65.useRef)();
    var _useDiffItem = useDiffItem(mergedData, getKey3), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
    diffItemRef.current = diffItem;
    var _React$useMemo = React168.useMemo(function() {
      if (!useVirtual) {
        return {
          scrollHeight: void 0,
          start: 0,
          end: mergedData.length - 1,
          offset: void 0
        };
      }
      if (!inVirtual) {
        var _fillerInnerRef$curre;
        return {
          scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
          start: 0,
          end: mergedData.length - 1,
          offset: void 0
        };
      }
      var itemTop = 0;
      var startIndex;
      var startOffset;
      var endIndex;
      var dataLen = mergedData.length;
      for (var i = 0; i < dataLen; i += 1) {
        var _item = mergedData[i];
        var key = getKey3(_item);
        var cacheHeight = heights.get(key);
        var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
        if (currentItemBottom >= offsetTop && startIndex === void 0) {
          startIndex = i;
          startOffset = itemTop;
        }
        if (currentItemBottom > offsetTop + height && endIndex === void 0) {
          endIndex = i;
        }
        itemTop = currentItemBottom;
      }
      if (startIndex === void 0) {
        startIndex = 0;
        startOffset = 0;
        endIndex = Math.ceil(height / itemHeight);
      }
      if (endIndex === void 0) {
        endIndex = mergedData.length - 1;
      }
      endIndex = Math.min(endIndex + 1, mergedData.length - 1);
      return {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      };
    }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
    rangeRef.current.start = start;
    rangeRef.current.end = end;
    React168.useLayoutEffect(function() {
      var changedRecord = heights.getRecord();
      if (changedRecord.size === 1) {
        var recordKey = Array.from(changedRecord.keys())[0];
        var prevCacheHeight = changedRecord.get(recordKey);
        var startItem = mergedData[start];
        if (startItem && prevCacheHeight === void 0) {
          var startIndexKey = getKey3(startItem);
          if (startIndexKey === recordKey) {
            var realStartHeight = heights.get(recordKey);
            var diffHeight = realStartHeight - itemHeight;
            syncScrollTop(function(ori) {
              return ori + diffHeight;
            });
          }
        }
      }
      heights.resetRecord();
    }, [scrollHeight]);
    var _React$useState = React168.useState({
      width: 0,
      height
    }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
    var onHolderResize = function onHolderResize2(sizeInfo) {
      setSize({
        width: sizeInfo.offsetWidth,
        height: sizeInfo.offsetHeight
      });
    };
    var verticalScrollBarRef = (0, import_react65.useRef)();
    var horizontalScrollBarRef = (0, import_react65.useRef)();
    var horizontalScrollBarSpinSize = React168.useMemo(function() {
      return getSpinSize(size.width, scrollWidth);
    }, [size.width, scrollWidth]);
    var verticalScrollBarSpinSize = React168.useMemo(function() {
      return getSpinSize(size.height, scrollHeight);
    }, [size.height, scrollHeight]);
    var maxScrollHeight = scrollHeight - height;
    var maxScrollHeightRef = (0, import_react65.useRef)(maxScrollHeight);
    maxScrollHeightRef.current = maxScrollHeight;
    function keepInRange(newScrollTop) {
      var newTop = newScrollTop;
      if (!Number.isNaN(maxScrollHeightRef.current)) {
        newTop = Math.min(newTop, maxScrollHeightRef.current);
      }
      newTop = Math.max(newTop, 0);
      return newTop;
    }
    var isScrollAtTop = offsetTop <= 0;
    var isScrollAtBottom = offsetTop >= maxScrollHeight;
    var isScrollAtLeft = offsetLeft <= 0;
    var isScrollAtRight = offsetLeft >= scrollWidth;
    var originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
    var getVirtualScrollInfo = function getVirtualScrollInfo2() {
      return {
        x: isRTL ? -offsetLeft : offsetLeft,
        y: offsetTop
      };
    };
    var lastVirtualScrollInfoRef = (0, import_react65.useRef)(getVirtualScrollInfo());
    var triggerScroll = useEvent(function(params) {
      if (onVirtualScroll) {
        var nextInfo = _objectSpread2(_objectSpread2({}, getVirtualScrollInfo()), params);
        if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
          onVirtualScroll(nextInfo);
          lastVirtualScrollInfoRef.current = nextInfo;
        }
      }
    });
    function onScrollBar(newScrollOffset, horizontal) {
      var newOffset = newScrollOffset;
      if (horizontal) {
        (0, import_react_dom5.flushSync)(function() {
          setOffsetLeft(newOffset);
        });
        triggerScroll();
      } else {
        syncScrollTop(newOffset);
      }
    }
    function onFallbackScroll(e3) {
      var newScrollTop = e3.currentTarget.scrollTop;
      if (newScrollTop !== offsetTop) {
        syncScrollTop(newScrollTop);
      }
      onScroll === null || onScroll === void 0 || onScroll(e3);
      triggerScroll();
    }
    var keepInHorizontalRange = function keepInHorizontalRange2(nextOffsetLeft) {
      var tmpOffsetLeft = nextOffsetLeft;
      var max = !!scrollWidth ? scrollWidth - size.width : 0;
      tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
      tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
      return tmpOffsetLeft;
    };
    var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
      if (fromHorizontal) {
        (0, import_react_dom5.flushSync)(function() {
          setOffsetLeft(function(left) {
            var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
            return keepInHorizontalRange(nextOffsetLeft);
          });
        });
        triggerScroll();
      } else {
        syncScrollTop(function(top) {
          var newTop = top + offsetXY;
          return newTop;
        });
      }
    });
    var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
    useMobileTouchMove(useVirtual, componentRef, function(isHorizontal, delta, smoothOffset, e3) {
      var event = e3;
      if (originScroll(isHorizontal, delta, smoothOffset)) {
        return false;
      }
      if (!event || !event._virtualHandled) {
        if (event) {
          event._virtualHandled = true;
        }
        onRawWheel({
          preventDefault: function preventDefault() {
          },
          deltaX: isHorizontal ? delta : 0,
          deltaY: isHorizontal ? 0 : delta
        });
        return true;
      }
      return false;
    });
    useScrollDrag(inVirtual, componentRef, function(offset3) {
      syncScrollTop(function(top) {
        return top + offset3;
      });
    });
    useLayoutEffect_default(function() {
      function onMozMousePixelScroll(e3) {
        var scrollingUpAtTop = isScrollAtTop && e3.detail < 0;
        var scrollingDownAtBottom = isScrollAtBottom && e3.detail > 0;
        if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) {
          e3.preventDefault();
        }
      }
      var componentEle = componentRef.current;
      componentEle.addEventListener("wheel", onRawWheel, {
        passive: false
      });
      componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, {
        passive: true
      });
      componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, {
        passive: false
      });
      return function() {
        componentEle.removeEventListener("wheel", onRawWheel);
        componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      };
    }, [useVirtual, isScrollAtTop, isScrollAtBottom]);
    useLayoutEffect_default(function() {
      if (scrollWidth) {
        var newOffsetLeft = keepInHorizontalRange(offsetLeft);
        setOffsetLeft(newOffsetLeft);
        triggerScroll({
          x: newOffsetLeft
        });
      }
    }, [size.width, scrollWidth]);
    var delayHideScrollBar = function delayHideScrollBar2() {
      var _verticalScrollBarRef, _horizontalScrollBarR;
      (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden();
      (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
    };
    var _scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey3, function() {
      return collectHeight(true);
    }, syncScrollTop, delayHideScrollBar);
    React168.useImperativeHandle(ref, function() {
      return {
        nativeElement: containerRef.current,
        getScrollInfo: getVirtualScrollInfo,
        scrollTo: function scrollTo2(config) {
          function isPosScroll(arg) {
            return arg && _typeof(arg) === "object" && ("left" in arg || "top" in arg);
          }
          if (isPosScroll(config)) {
            if (config.left !== void 0) {
              setOffsetLeft(keepInHorizontalRange(config.left));
            }
            _scrollTo(config.top);
          } else {
            _scrollTo(config);
          }
        }
      };
    });
    useLayoutEffect_default(function() {
      if (onVisibleChange) {
        var renderList = mergedData.slice(start, end + 1);
        onVisibleChange(renderList, mergedData);
      }
    }, [start, end, mergedData]);
    var getSize4 = useGetSize(mergedData, getKey3, heights, itemHeight);
    var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
      start,
      end,
      virtual: inVirtual,
      offsetX: offsetLeft,
      offsetY: fillerOffset,
      rtl: isRTL,
      getSize: getSize4
    });
    var listChildren = useChildren(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
    var componentStyle = null;
    if (height) {
      componentStyle = _objectSpread2(_defineProperty({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
      if (useVirtual) {
        componentStyle.overflowY = "hidden";
        if (scrollWidth) {
          componentStyle.overflowX = "hidden";
        }
        if (scrollMoving) {
          componentStyle.pointerEvents = "none";
        }
      }
    }
    var containerProps = {};
    if (isRTL) {
      containerProps.dir = "rtl";
    }
    return /* @__PURE__ */ React168.createElement("div", _extends({
      ref: containerRef,
      style: _objectSpread2(_objectSpread2({}, style2), {}, {
        position: "relative"
      }),
      className: mergedClassName
    }, containerProps, restProps), /* @__PURE__ */ React168.createElement(es_default, {
      onResize: onHolderResize
    }, /* @__PURE__ */ React168.createElement(Component9, {
      className: "".concat(prefixCls, "-holder"),
      style: componentStyle,
      ref: componentRef,
      onScroll: onFallbackScroll,
      onMouseEnter: delayHideScrollBar
    }, /* @__PURE__ */ React168.createElement(Filler_default, {
      prefixCls,
      height: scrollHeight,
      offsetX: offsetLeft,
      offsetY: fillerOffset,
      scrollWidth,
      onInnerResize: collectHeight,
      ref: fillerInnerRef,
      innerProps,
      rtl: isRTL,
      extra: extraContent
    }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ React168.createElement(ScrollBar_default, {
      ref: verticalScrollBarRef,
      prefixCls,
      scrollOffset: offsetTop,
      scrollRange: scrollHeight,
      rtl: isRTL,
      onScroll: onScrollBar,
      onStartMove: onScrollbarStartMove,
      onStopMove: onScrollbarStopMove,
      spinSize: verticalScrollBarSpinSize,
      containerSize: size.height,
      style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
      thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb,
      showScrollBar
    }), inVirtual && scrollWidth > size.width && /* @__PURE__ */ React168.createElement(ScrollBar_default, {
      ref: horizontalScrollBarRef,
      prefixCls,
      scrollOffset: offsetLeft,
      scrollRange: scrollWidth,
      rtl: isRTL,
      onScroll: onScrollBar,
      onStartMove: onScrollbarStartMove,
      onStopMove: onScrollbarStopMove,
      spinSize: horizontalScrollBarSpinSize,
      containerSize: size.width,
      horizontal: true,
      style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
      thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb,
      showScrollBar
    }));
  }
  var List2 = /* @__PURE__ */ React168.forwardRef(RawList);
  List2.displayName = "List";
  var List_default2 = List2;

  // node_modules/rc-virtual-list/es/index.js
  var es_default9 = List_default2;

  // node_modules/rc-select/es/OptionList.js
  var React169 = __toESM(require_react());
  var import_react66 = __toESM(require_react());

  // node_modules/rc-select/es/utils/platformUtil.js
  function isPlatformMac() {
    return /(mac\sos|macintosh)/i.test(navigator.appVersion);
  }

  // node_modules/rc-select/es/OptionList.js
  var _excluded19 = ["disabled", "title", "children", "style", "className"];
  function isTitleType2(content) {
    return typeof content === "string" || typeof content === "number";
  }
  var OptionList = function OptionList2(_, ref) {
    var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id = _useBaseProps.id, open2 = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
    var _React$useContext = React169.useContext(SelectContext_default), maxCount = _React$useContext.maxCount, flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, direction = _React$useContext.direction, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight, optionRender = _React$useContext.optionRender;
    var itemPrefixCls = "".concat(prefixCls, "-item");
    var memoFlattenOptions = useMemo(function() {
      return flattenOptions2;
    }, [open2, flattenOptions2], function(prev2, next2) {
      return next2[0] && prev2[1] !== next2[1];
    });
    var listRef = React169.useRef(null);
    var overMaxCount = React169.useMemo(function() {
      return multiple && isValidCount(maxCount) && (rawValues === null || rawValues === void 0 ? void 0 : rawValues.size) >= maxCount;
    }, [multiple, maxCount, rawValues === null || rawValues === void 0 ? void 0 : rawValues.size]);
    var onListMouseDown = function onListMouseDown2(event) {
      event.preventDefault();
    };
    var scrollIntoView = function scrollIntoView2(args) {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(typeof args === "number" ? {
        index: args
      } : args);
    };
    var isSelected = React169.useCallback(function(value) {
      if (mode === "combobox") {
        return false;
      }
      return rawValues.has(value);
    }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]);
    var getEnabledActiveIndex = function getEnabledActiveIndex2(index3) {
      var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var len = memoFlattenOptions.length;
      for (var i = 0; i < len; i += 1) {
        var current = (index3 + i * offset3 + len) % len;
        var _ref = memoFlattenOptions[current] || {}, group = _ref.group, data = _ref.data;
        if (!group && !(data !== null && data !== void 0 && data.disabled) && (isSelected(data.value) || !overMaxCount)) {
          return current;
        }
      }
      return -1;
    };
    var _React$useState = React169.useState(function() {
      return getEnabledActiveIndex(0);
    }), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
    var setActive = function setActive2(index3) {
      var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      setActiveIndex(index3);
      var info = {
        source: fromKeyboard ? "keyboard" : "mouse"
      };
      var flattenItem = memoFlattenOptions[index3];
      if (!flattenItem) {
        onActiveValue(null, -1, info);
        return;
      }
      onActiveValue(flattenItem.value, index3, info);
    };
    (0, import_react66.useEffect)(function() {
      setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
    }, [memoFlattenOptions.length, searchValue]);
    var isAriaSelected = React169.useCallback(function(value) {
      if (mode === "combobox") {
        return String(value).toLowerCase() === searchValue.toLowerCase();
      }
      return rawValues.has(value);
    }, [mode, searchValue, _toConsumableArray(rawValues).toString(), rawValues.size]);
    (0, import_react66.useEffect)(function() {
      var timeoutId = setTimeout(function() {
        if (!multiple && open2 && rawValues.size === 1) {
          var value = Array.from(rawValues)[0];
          var index3 = memoFlattenOptions.findIndex(function(_ref2) {
            var data = _ref2.data;
            return searchValue ? String(data.value).startsWith(searchValue) : data.value === value;
          });
          if (index3 !== -1) {
            setActive(index3);
            scrollIntoView(index3);
          }
        }
      });
      if (open2) {
        var _listRef$current2;
        (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.scrollTo(void 0);
      }
      return function() {
        return clearTimeout(timeoutId);
      };
    }, [open2, searchValue]);
    var onSelectValue = function onSelectValue2(value) {
      if (value !== void 0) {
        onSelect(value, {
          selected: !rawValues.has(value)
        });
      }
      if (!multiple) {
        toggleOpen(false);
      }
    };
    React169.useImperativeHandle(ref, function() {
      return {
        onKeyDown: function onKeyDown2(event) {
          var which = event.which, ctrlKey = event.ctrlKey;
          switch (which) {
            // >>> Arrow keys & ctrl + n/p on Mac
            case KeyCode_default.N:
            case KeyCode_default.P:
            case KeyCode_default.UP:
            case KeyCode_default.DOWN: {
              var offset3 = 0;
              if (which === KeyCode_default.UP) {
                offset3 = -1;
              } else if (which === KeyCode_default.DOWN) {
                offset3 = 1;
              } else if (isPlatformMac() && ctrlKey) {
                if (which === KeyCode_default.N) {
                  offset3 = 1;
                } else if (which === KeyCode_default.P) {
                  offset3 = -1;
                }
              }
              if (offset3 !== 0) {
                var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset3, offset3);
                scrollIntoView(nextActiveIndex);
                setActive(nextActiveIndex, true);
              }
              break;
            }
            // >>> Select (Tab / Enter)
            case KeyCode_default.TAB:
            case KeyCode_default.ENTER: {
              var _item$data;
              var item = memoFlattenOptions[activeIndex];
              if (item && !(item !== null && item !== void 0 && (_item$data = item.data) !== null && _item$data !== void 0 && _item$data.disabled) && !overMaxCount) {
                onSelectValue(item.value);
              } else {
                onSelectValue(void 0);
              }
              if (open2) {
                event.preventDefault();
              }
              break;
            }
            // >>> Close
            case KeyCode_default.ESC: {
              toggleOpen(false);
              if (open2) {
                event.stopPropagation();
              }
            }
          }
        },
        onKeyUp: function onKeyUp() {
        },
        scrollTo: function scrollTo2(index3) {
          scrollIntoView(index3);
        }
      };
    });
    if (memoFlattenOptions.length === 0) {
      return /* @__PURE__ */ React169.createElement("div", {
        role: "listbox",
        id: "".concat(id, "_list"),
        className: "".concat(itemPrefixCls, "-empty"),
        onMouseDown: onListMouseDown
      }, notFoundContent);
    }
    var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
      return fieldNames[key];
    });
    var getLabel = function getLabel2(item) {
      return item.label;
    };
    function getItemAriaProps(item, index3) {
      var group = item.group;
      return {
        role: group ? "presentation" : "option",
        id: "".concat(id, "_list_").concat(index3)
      };
    }
    var renderItem = function renderItem2(index3) {
      var item = memoFlattenOptions[index3];
      if (!item) {
        return null;
      }
      var itemData = item.data || {};
      var value = itemData.value;
      var group = item.group;
      var attrs = pickAttrs(itemData, true);
      var mergedLabel = getLabel(item);
      return item ? /* @__PURE__ */ React169.createElement("div", _extends({
        "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
      }, attrs, {
        key: index3
      }, getItemAriaProps(item, index3), {
        "aria-selected": isAriaSelected(value)
      }), value) : null;
    };
    var a11yProps = {
      role: "listbox",
      id: "".concat(id, "_list")
    };
    return /* @__PURE__ */ React169.createElement(React169.Fragment, null, virtual && /* @__PURE__ */ React169.createElement("div", _extends({}, a11yProps, {
      style: {
        height: 0,
        width: 0,
        overflow: "hidden"
      }
    }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ React169.createElement(es_default9, {
      itemKey: "key",
      ref: listRef,
      data: memoFlattenOptions,
      height: listHeight,
      itemHeight: listItemHeight,
      fullHeight: false,
      onMouseDown: onListMouseDown,
      onScroll: onPopupScroll,
      virtual,
      direction,
      innerProps: virtual ? null : a11yProps
    }, function(item, itemIndex) {
      var group = item.group, groupOption = item.groupOption, data = item.data, label = item.label, value = item.value;
      var key = data.key;
      if (group) {
        var _data$title;
        var groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType2(label) ? label.toString() : void 0;
        return /* @__PURE__ */ React169.createElement("div", {
          className: (0, import_classnames49.default)(itemPrefixCls, "".concat(itemPrefixCls, "-group"), data.className),
          title: groupTitle
        }, label !== void 0 ? label : key);
      }
      var disabled = data.disabled, title = data.title, children = data.children, style2 = data.style, className = data.className, otherProps = _objectWithoutProperties(data, _excluded19);
      var passedProps = omit(otherProps, omitFieldNameList);
      var selected = isSelected(value);
      var mergedDisabled = disabled || !selected && overMaxCount;
      var optionPrefixCls = "".concat(itemPrefixCls, "-option");
      var optionClassName = (0, import_classnames49.default)(itemPrefixCls, optionPrefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(optionPrefixCls, "-grouped"), groupOption), "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !mergedDisabled), "".concat(optionPrefixCls, "-disabled"), mergedDisabled), "".concat(optionPrefixCls, "-selected"), selected));
      var mergedLabel = getLabel(item);
      var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
      var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
      var optionTitle = isTitleType2(content) ? content.toString() : void 0;
      if (title !== void 0) {
        optionTitle = title;
      }
      return /* @__PURE__ */ React169.createElement("div", _extends({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
        "aria-selected": isAriaSelected(value),
        className: optionClassName,
        title: optionTitle,
        onMouseMove: function onMouseMove() {
          if (activeIndex === itemIndex || mergedDisabled) {
            return;
          }
          setActive(itemIndex);
        },
        onClick: function onClick() {
          if (!mergedDisabled) {
            onSelectValue(value);
          }
        },
        style: style2
      }), /* @__PURE__ */ React169.createElement("div", {
        className: "".concat(optionPrefixCls, "-content")
      }, typeof optionRender === "function" ? optionRender(item, {
        index: itemIndex
      }) : content), /* @__PURE__ */ React169.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ React169.createElement(TransBtn_default, {
        className: "".concat(itemPrefixCls, "-option-state"),
        customizeIcon: menuItemSelectedIcon,
        customizeIconProps: {
          value,
          disabled: mergedDisabled,
          isSelected: selected
        }
      }, selected ? "\u2713" : null));
    }));
  };
  var RefOptionList = /* @__PURE__ */ React169.forwardRef(OptionList);
  if (true) {
    RefOptionList.displayName = "OptionList";
  }
  var OptionList_default = RefOptionList;

  // node_modules/rc-select/es/hooks/useCache.js
  var React170 = __toESM(require_react());
  var useCache_default = function(labeledValues, valueOptions) {
    var cacheRef = React170.useRef({
      values: /* @__PURE__ */ new Map(),
      options: /* @__PURE__ */ new Map()
    });
    var filledLabeledValues = React170.useMemo(function() {
      var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
      var patchedValues = labeledValues.map(function(item) {
        if (item.label === void 0) {
          var _prevValueCache$get;
          return _objectSpread2(_objectSpread2({}, item), {}, {
            label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
          });
        }
        return item;
      });
      var valueCache = /* @__PURE__ */ new Map();
      var optionCache = /* @__PURE__ */ new Map();
      patchedValues.forEach(function(item) {
        valueCache.set(item.value, item);
        optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
      });
      cacheRef.current.values = valueCache;
      cacheRef.current.options = optionCache;
      return patchedValues;
    }, [labeledValues, valueOptions]);
    var getOption = React170.useCallback(function(val) {
      return valueOptions.get(val) || cacheRef.current.options.get(val);
    }, [valueOptions]);
    return [filledLabeledValues, getOption];
  };

  // node_modules/rc-select/es/hooks/useFilterOptions.js
  var React171 = __toESM(require_react());
  function includes(test2, search) {
    return toArray3(test2).join("").toUpperCase().includes(search);
  }
  var useFilterOptions_default = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
    return React171.useMemo(function() {
      if (!searchValue || filterOption === false) {
        return options;
      }
      var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
      var filteredOptions = [];
      var customizeFilter = typeof filterOption === "function";
      var upperSearch = searchValue.toUpperCase();
      var filterFunc = customizeFilter ? filterOption : function(_, option) {
        if (optionFilterProp) {
          return includes(option[optionFilterProp], upperSearch);
        }
        if (option[fieldOptions]) {
          return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
        }
        return includes(option[fieldValue], upperSearch);
      };
      var wrapOption = customizeFilter ? function(opt) {
        return injectPropsWithOption(opt);
      } : function(opt) {
        return opt;
      };
      options.forEach(function(item) {
        if (item[fieldOptions]) {
          var matchGroup = filterFunc(searchValue, wrapOption(item));
          if (matchGroup) {
            filteredOptions.push(item);
          } else {
            var subOptions = item[fieldOptions].filter(function(subItem) {
              return filterFunc(searchValue, wrapOption(subItem));
            });
            if (subOptions.length) {
              filteredOptions.push(_objectSpread2(_objectSpread2({}, item), {}, _defineProperty({}, fieldOptions, subOptions)));
            }
          }
          return;
        }
        if (filterFunc(searchValue, wrapOption(item))) {
          filteredOptions.push(item);
        }
      });
      return filteredOptions;
    }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
  };

  // node_modules/rc-select/es/hooks/useId.js
  var React172 = __toESM(require_react());
  var uuid5 = 0;
  var isBrowserClient2 = canUseDom();
  function getUUID() {
    var retId;
    if (isBrowserClient2) {
      retId = uuid5;
      uuid5 += 1;
    } else {
      retId = "TEST_OR_SSR";
    }
    return retId;
  }
  function useId3(id) {
    var _React$useState = React172.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
    React172.useEffect(function() {
      setInnerId("rc_select_".concat(getUUID()));
    }, []);
    return id || innerId;
  }

  // node_modules/rc-select/es/hooks/useOptions.js
  var React174 = __toESM(require_react());

  // node_modules/rc-select/es/utils/legacyUtil.js
  var React173 = __toESM(require_react());
  var _excluded20 = ["children", "value"];
  var _excluded25 = ["children"];
  function convertNodeToOption(node2) {
    var _ref = node2, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties(_ref$props, _excluded20);
    return _objectSpread2({
      key,
      value: value !== void 0 ? value : key,
      children
    }, restProps);
  }
  function convertChildrenToData(nodes) {
    var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return toArray(nodes).map(function(node2, index3) {
      if (!/* @__PURE__ */ React173.isValidElement(node2) || !node2.type) {
        return null;
      }
      var _ref2 = node2, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties(_ref2$props, _excluded25);
      if (optionOnly || !isSelectOptGroup) {
        return convertNodeToOption(node2);
      }
      return _objectSpread2(_objectSpread2({
        key: "__RC_SELECT_GRP__".concat(key === null ? index3 : key, "__"),
        label: key
      }, restProps), {}, {
        options: convertChildrenToData(children)
      });
    }).filter(function(data) {
      return data;
    });
  }

  // node_modules/rc-select/es/hooks/useOptions.js
  var useOptions = function useOptions2(options, children, fieldNames, optionFilterProp, optionLabelProp) {
    return React174.useMemo(function() {
      var mergedOptions = options;
      var childrenAsData = !options;
      if (childrenAsData) {
        mergedOptions = convertChildrenToData(children);
      }
      var valueOptions = /* @__PURE__ */ new Map();
      var labelOptions = /* @__PURE__ */ new Map();
      var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key) {
        if (key && typeof key === "string") {
          labelOptionsMap.set(option[key], option);
        }
      };
      var dig = function dig2(optionList) {
        var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        for (var i = 0; i < optionList.length; i += 1) {
          var option = optionList[i];
          if (!option[fieldNames.options] || isChildren) {
            valueOptions.set(option[fieldNames.value], option);
            setLabelOptions(labelOptions, option, fieldNames.label);
            setLabelOptions(labelOptions, option, optionFilterProp);
            setLabelOptions(labelOptions, option, optionLabelProp);
          } else {
            dig2(option[fieldNames.options], true);
          }
        }
      };
      dig(mergedOptions);
      return {
        options: mergedOptions,
        valueOptions,
        labelOptions
      };
    }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
  };
  var useOptions_default = useOptions;

  // node_modules/rc-select/es/hooks/useRefFunc.js
  var React175 = __toESM(require_react());
  function useRefFunc(callback) {
    var funcRef = React175.useRef();
    funcRef.current = callback;
    var cacheFn = React175.useCallback(function() {
      return funcRef.current.apply(funcRef, arguments);
    }, []);
    return cacheFn;
  }

  // node_modules/rc-select/es/utils/warningPropsUtil.js
  var React176 = __toESM(require_react());
  function warningProps(props) {
    var mode = props.mode, options = props.options, children = props.children, backfill = props.backfill, allowClear = props.allowClear, placeholder = props.placeholder, getInputElement = props.getInputElement, showSearch = props.showSearch, onSearch = props.onSearch, defaultOpen = props.defaultOpen, autoFocus = props.autoFocus, labelInValue = props.labelInValue, value = props.value, inputValue = props.inputValue, optionLabelProp = props.optionLabelProp;
    var multiple = isMultiple(mode);
    var mergedShowSearch = showSearch !== void 0 ? showSearch : multiple || mode === "combobox";
    var mergedOptions = options || convertChildrenToData(children);
    warning_default(mode !== "tags" || mergedOptions.every(function(opt) {
      return !opt.disabled;
    }), "Please avoid setting option to disabled in tags mode since user can always type text as tag.");
    if (mode === "tags" || mode === "combobox") {
      var hasNumberValue = mergedOptions.some(function(item) {
        if (item.options) {
          return item.options.some(function(opt) {
            return typeof ("value" in opt ? opt.value : opt.key) === "number";
          });
        }
        return typeof ("value" in item ? item.value : item.key) === "number";
      });
      warning_default(!hasNumberValue, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
    }
    warning_default(mode !== "combobox" || !optionLabelProp, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.");
    warning_default(mode === "combobox" || !backfill, "`backfill` only works with `combobox` mode.");
    warning_default(mode === "combobox" || !getInputElement, "`getInputElement` only work with `combobox` mode.");
    noteOnce(mode !== "combobox" || !getInputElement || !allowClear || !placeholder, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.");
    if (onSearch && !mergedShowSearch && mode !== "combobox" && mode !== "tags") {
      warning_default(false, "`onSearch` should work with `showSearch` instead of use alone.");
    }
    noteOnce(!defaultOpen || autoFocus, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.");
    if (value !== void 0 && value !== null) {
      var values = toArray3(value);
      warning_default(!labelInValue || values.every(function(val) {
        return _typeof(val) === "object" && ("key" in val || "value" in val);
      }), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`");
      warning_default(!multiple || Array.isArray(value), "`value` should be array when `mode` is `multiple` or `tags`");
    }
    if (children) {
      var invalidateChildType = null;
      toArray(children).some(function(node2) {
        if (!/* @__PURE__ */ React176.isValidElement(node2) || !node2.type) {
          return false;
        }
        var _ref = node2, type5 = _ref.type;
        if (type5.isSelectOption) {
          return false;
        }
        if (type5.isSelectOptGroup) {
          var allChildrenValid = toArray(node2.props.children).every(function(subNode) {
            if (!/* @__PURE__ */ React176.isValidElement(subNode) || !node2.type || subNode.type.isSelectOption) {
              return true;
            }
            invalidateChildType = subNode.type;
            return false;
          });
          if (allChildrenValid) {
            return false;
          }
          return true;
        }
        invalidateChildType = type5;
        return true;
      });
      if (invalidateChildType) {
        warning_default(false, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(invalidateChildType.displayName || invalidateChildType.name || invalidateChildType, "`."));
      }
      warning_default(inputValue === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
    }
  }
  function warningNullOptions(options, fieldNames) {
    if (options) {
      var recursiveOptions = function recursiveOptions2(optionsList) {
        var inGroup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        for (var i = 0; i < optionsList.length; i++) {
          var option = optionsList[i];
          if (option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.value] === null) {
            warning_default(false, "`value` in Select options should not be `null`.");
            return true;
          }
          if (!inGroup && Array.isArray(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options]) && recursiveOptions2(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options], true)) {
            break;
          }
        }
      };
      recursiveOptions(options);
    }
  }
  var warningPropsUtil_default = warningProps;

  // node_modules/rc-select/es/Select.js
  var _excluded21 = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "optionRender", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "labelRender", "value", "defaultValue", "labelInValue", "onChange", "maxCount"];
  var OMIT_DOM_PROPS = ["inputValue"];
  function isRawValue(value) {
    return !value || _typeof(value) !== "object";
  }
  var Select = /* @__PURE__ */ React177.forwardRef(function(props, ref) {
    var id = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, optionRender = props.optionRender, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, direction = props.direction, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, labelRender = props.labelRender, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, maxCount = props.maxCount, restProps = _objectWithoutProperties(props, _excluded21);
    var mergedId = useId3(id);
    var multiple = isMultiple(mode);
    var childrenAsData = !!(!options && children);
    var mergedFilterOption = React177.useMemo(function() {
      if (filterOption === void 0 && mode === "combobox") {
        return false;
      }
      return filterOption;
    }, [filterOption, mode]);
    var mergedFieldNames = React177.useMemo(
      function() {
        return fillFieldNames(fieldNames, childrenAsData);
      },
      /* eslint-disable react-hooks/exhaustive-deps */
      [
        // We stringify fieldNames to avoid unnecessary re-renders.
        JSON.stringify(fieldNames),
        childrenAsData
      ]
      /* eslint-enable react-hooks/exhaustive-deps */
    );
    var _useMergedState = useMergedState("", {
      value: searchValue !== void 0 ? searchValue : inputValue,
      postState: function postState(search) {
        return search || "";
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
    var parsedOptions = useOptions_default(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
    var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
    var convert2LabelValues = React177.useCallback(function(draftValues) {
      var valueList = toArray3(draftValues);
      return valueList.map(function(val) {
        var rawValue;
        var rawLabel;
        var rawKey;
        var rawDisabled;
        var rawTitle;
        if (isRawValue(val)) {
          rawValue = val;
        } else {
          var _val$value;
          rawKey = val.key;
          rawLabel = val.label;
          rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
        }
        var option = valueOptions.get(rawValue);
        if (option) {
          var _option$key;
          if (rawLabel === void 0) rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
          if (rawKey === void 0) rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
          rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
          rawTitle = option === null || option === void 0 ? void 0 : option.title;
          if (!optionLabelProp) {
            var optionLabel = option === null || option === void 0 ? void 0 : option[mergedFieldNames.label];
            if (optionLabel !== void 0 && !/* @__PURE__ */ React177.isValidElement(optionLabel) && !/* @__PURE__ */ React177.isValidElement(rawLabel) && optionLabel !== rawLabel) {
              warning_default(false, "`label` of `value` is not same as `label` in Select options.");
            }
          }
        }
        return {
          label: rawLabel,
          value: rawValue,
          key: rawKey,
          disabled: rawDisabled,
          title: rawTitle
        };
      });
    }, [mergedFieldNames, optionLabelProp, valueOptions]);
    var _useMergedState3 = useMergedState(defaultValue, {
      value
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
    var rawLabeledValues = React177.useMemo(function() {
      var _values$;
      var newInternalValue = multiple && internalValue === null ? [] : internalValue;
      var values = convert2LabelValues(newInternalValue);
      if (mode === "combobox" && isComboNoValue((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) {
        return [];
      }
      return values;
    }, [internalValue, convert2LabelValues, mode, multiple]);
    var _useCache = useCache_default(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
    var displayValues = React177.useMemo(function() {
      if (!mode && mergedValues.length === 1) {
        var firstValue = mergedValues[0];
        if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
          return [];
        }
      }
      return mergedValues.map(function(item) {
        var _ref;
        return _objectSpread2(_objectSpread2({}, item), {}, {
          label: (_ref = typeof labelRender === "function" ? labelRender(item) : item.label) !== null && _ref !== void 0 ? _ref : item.value
        });
      });
    }, [mode, mergedValues, labelRender]);
    var rawValues = React177.useMemo(function() {
      return new Set(mergedValues.map(function(val) {
        return val.value;
      }));
    }, [mergedValues]);
    React177.useEffect(function() {
      if (mode === "combobox") {
        var _mergedValues$;
        var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
        setSearchValue(hasValue2(strValue) ? String(strValue) : "");
      }
    }, [mergedValues]);
    var createTagOption = useRefFunc(function(val, label) {
      var mergedLabel = label !== null && label !== void 0 ? label : val;
      return _defineProperty(_defineProperty({}, mergedFieldNames.value, val), mergedFieldNames.label, mergedLabel);
    });
    var filledTagOptions = React177.useMemo(function() {
      if (mode !== "tags") {
        return mergedOptions;
      }
      var cloneOptions = _toConsumableArray(mergedOptions);
      var existOptions = function existOptions2(val) {
        return valueOptions.has(val);
      };
      _toConsumableArray(mergedValues).sort(function(a, b) {
        return a.value < b.value ? -1 : 1;
      }).forEach(function(item) {
        var val = item.value;
        if (!existOptions(val)) {
          cloneOptions.push(createTagOption(val, item.label));
        }
      });
      return cloneOptions;
    }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
    var filteredOptions = useFilterOptions_default(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
    var filledSearchOptions = React177.useMemo(function() {
      if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
        return item[optionFilterProp || "value"] === mergedSearchValue;
      })) {
        return filteredOptions;
      }
      if (filteredOptions.some(function(item) {
        return item[mergedFieldNames.value] === mergedSearchValue;
      })) {
        return filteredOptions;
      }
      return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
    }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]);
    var sorter = function sorter2(inputOptions) {
      var sortedOptions = _toConsumableArray(inputOptions).sort(function(a, b) {
        return filterSort(a, b, {
          searchValue: mergedSearchValue
        });
      });
      return sortedOptions.map(function(item) {
        if (Array.isArray(item.options)) {
          return _objectSpread2(_objectSpread2({}, item), {}, {
            options: item.options.length > 0 ? sorter2(item.options) : item.options
          });
        }
        return item;
      });
    };
    var orderedFilteredOptions = React177.useMemo(function() {
      if (!filterSort) {
        return filledSearchOptions;
      }
      return sorter(filledSearchOptions);
    }, [filledSearchOptions, filterSort, mergedSearchValue]);
    var displayOptions = React177.useMemo(function() {
      return flattenOptions(orderedFilteredOptions, {
        fieldNames: mergedFieldNames,
        childrenAsData
      });
    }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
    var triggerChange = function triggerChange2(values) {
      var labeledValues = convert2LabelValues(values);
      setInternalValue(labeledValues);
      if (onChange && // Trigger event only when value changed
      (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index3) {
        var _mergedValues$index;
        return ((_mergedValues$index = mergedValues[index3]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
      }))) {
        var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v) {
          return v.value;
        });
        var returnOptions = labeledValues.map(function(v) {
          return injectPropsWithOption(getMixedOption(v.value));
        });
        onChange(
          // Value
          multiple ? returnValues : returnValues[0],
          // Option
          multiple ? returnOptions : returnOptions[0]
        );
      }
    };
    var _React$useState = React177.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
    var _React$useState3 = React177.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
    var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
    var onActiveValue = React177.useCallback(function(active, index3) {
      var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$source = _ref3.source, source = _ref3$source === void 0 ? "keyboard" : _ref3$source;
      setAccessibilityIndex(index3);
      if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
        setActiveValue(String(active));
      }
    }, [backfill, mode]);
    var triggerSelect = function triggerSelect2(val, selected, type5) {
      var getSelectEnt = function getSelectEnt2() {
        var _option$key2;
        var option = getMixedOption(val);
        return [labelInValue ? {
          label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
          value: val,
          key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
        } : val, injectPropsWithOption(option)];
      };
      if (selected && onSelect) {
        var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
        onSelect(wrappedValue, _option);
      } else if (!selected && onDeselect && type5 !== "clear") {
        var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
        onDeselect(_wrappedValue, _option2);
      }
    };
    var onInternalSelect = useRefFunc(function(val, info) {
      var cloneValues;
      var mergedSelect = multiple ? info.selected : true;
      if (mergedSelect) {
        cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
      } else {
        cloneValues = mergedValues.filter(function(v) {
          return v.value !== val;
        });
      }
      triggerChange(cloneValues);
      triggerSelect(val, mergedSelect);
      if (mode === "combobox") {
        setActiveValue("");
      } else if (!isMultiple || autoClearSearchValue) {
        setSearchValue("");
        setActiveValue("");
      }
    });
    var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info) {
      triggerChange(nextValues);
      var type5 = info.type, values = info.values;
      if (type5 === "remove" || type5 === "clear") {
        values.forEach(function(item) {
          triggerSelect(item.value, false, type5);
        });
      }
    };
    var onInternalSearch = function onInternalSearch2(searchText, info) {
      setSearchValue(searchText);
      setActiveValue(null);
      if (info.source === "submit") {
        var formatted = (searchText || "").trim();
        if (formatted) {
          var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
          triggerChange(newRawValues);
          triggerSelect(formatted, true);
          setSearchValue("");
        }
        return;
      }
      if (info.source !== "blur") {
        if (mode === "combobox") {
          triggerChange(searchText);
        }
        onSearch === null || onSearch === void 0 || onSearch(searchText);
      }
    };
    var onInternalSearchSplit = function onInternalSearchSplit2(words) {
      var patchValues = words;
      if (mode !== "tags") {
        patchValues = words.map(function(word) {
          var opt = labelOptions.get(word);
          return opt === null || opt === void 0 ? void 0 : opt.value;
        }).filter(function(val) {
          return val !== void 0;
        });
      }
      var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
      triggerChange(newRawValues);
      newRawValues.forEach(function(newRawValue) {
        triggerSelect(newRawValue, true);
      });
    };
    var selectContext = React177.useMemo(function() {
      var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
      return _objectSpread2(_objectSpread2({}, parsedOptions), {}, {
        flattenOptions: displayOptions,
        onActiveValue,
        defaultActiveFirstOption: mergedDefaultActiveFirstOption,
        onSelect: onInternalSelect,
        menuItemSelectedIcon,
        rawValues,
        fieldNames: mergedFieldNames,
        virtual: realVirtual,
        direction,
        listHeight,
        listItemHeight,
        childrenAsData,
        maxCount,
        optionRender
      });
    }, [maxCount, parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, direction, listHeight, listItemHeight, childrenAsData, optionRender]);
    if (true) {
      warningPropsUtil_default(props);
      warningNullOptions(mergedOptions, mergedFieldNames);
    }
    return /* @__PURE__ */ React177.createElement(SelectContext_default.Provider, {
      value: selectContext
    }, /* @__PURE__ */ React177.createElement(BaseSelect_default, _extends({}, restProps, {
      // >>> MISC
      id: mergedId,
      prefixCls,
      ref,
      omitDomProps: OMIT_DOM_PROPS,
      mode,
      displayValues,
      onDisplayValuesChange,
      direction,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      autoClearSearchValue,
      onSearchSplit: onInternalSearchSplit,
      dropdownMatchSelectWidth,
      OptionList: OptionList_default,
      emptyOptions: !displayOptions.length,
      activeValue,
      activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
    })));
  });
  if (true) {
    Select.displayName = "Select";
  }
  var TypedSelect = Select;
  TypedSelect.Option = Option_default;
  TypedSelect.OptGroup = OptGroup_default;
  var Select_default = TypedSelect;

  // node_modules/rc-select/es/index.js
  var es_default10 = Select_default;

  // node_modules/antd/es/_util/statusUtils.js
  var import_classnames50 = __toESM(require_classnames());
  function getStatusClassNames(prefixCls, status, hasFeedback) {
    return (0, import_classnames50.default)({
      [`${prefixCls}-status-success`]: status === "success",
      [`${prefixCls}-status-warning`]: status === "warning",
      [`${prefixCls}-status-error`]: status === "error",
      [`${prefixCls}-status-validating`]: status === "validating",
      [`${prefixCls}-has-feedback`]: hasFeedback
    });
  }
  var getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;

  // node_modules/antd/es/config-provider/defaultRenderEmpty.js
  var import_react68 = __toESM(require_react());

  // node_modules/antd/es/empty/index.js
  var React180 = __toESM(require_react());
  var import_classnames51 = __toESM(require_classnames());

  // node_modules/antd/es/empty/empty.js
  var React178 = __toESM(require_react());
  var Empty2 = () => {
    const [, token2] = useToken();
    const [locale6] = useLocale_default("Empty");
    const bgColor = new FastColor(token2.colorBgBase);
    const themeStyle = bgColor.toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {};
    return /* @__PURE__ */ React178.createElement("svg", {
      style: themeStyle,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ React178.createElement("title", null, (locale6 === null || locale6 === void 0 ? void 0 : locale6.description) || "Empty"), /* @__PURE__ */ React178.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ React178.createElement("g", {
      transform: "translate(24 31.67)"
    }, /* @__PURE__ */ React178.createElement("ellipse", {
      fillOpacity: ".8",
      fill: "#F5F5F7",
      cx: "67.797",
      cy: "106.89",
      rx: "67.797",
      ry: "12.668"
    }), /* @__PURE__ */ React178.createElement("path", {
      d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      fill: "#AEB8C2"
    }), /* @__PURE__ */ React178.createElement("path", {
      d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      fill: "url(#linearGradient-1)",
      transform: "translate(13.56)"
    }), /* @__PURE__ */ React178.createElement("path", {
      d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      fill: "#F5F5F7"
    }), /* @__PURE__ */ React178.createElement("path", {
      d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      fill: "#DCE0E6"
    })), /* @__PURE__ */ React178.createElement("path", {
      d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      fill: "#DCE0E6"
    }), /* @__PURE__ */ React178.createElement("g", {
      transform: "translate(149.65 15.383)",
      fill: "#FFF"
    }, /* @__PURE__ */ React178.createElement("ellipse", {
      cx: "20.654",
      cy: "3.167",
      rx: "2.849",
      ry: "2.815"
    }), /* @__PURE__ */ React178.createElement("path", {
      d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }))));
  };
  if (true) {
    Empty2.displayName = "EmptyImage";
  }
  var empty_default = Empty2;

  // node_modules/antd/es/empty/simple.js
  var React179 = __toESM(require_react());
  var import_react67 = __toESM(require_react());
  var Simple = () => {
    const [, token2] = useToken();
    const [locale6] = useLocale_default("Empty");
    const {
      colorFill,
      colorFillTertiary,
      colorFillQuaternary,
      colorBgContainer
    } = token2;
    const {
      borderColor,
      shadowColor,
      contentColor
    } = (0, import_react67.useMemo)(() => ({
      borderColor: new FastColor(colorFill).onBackground(colorBgContainer).toHexString(),
      shadowColor: new FastColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
      contentColor: new FastColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
    }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
    return /* @__PURE__ */ React179.createElement("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ React179.createElement("title", null, (locale6 === null || locale6 === void 0 ? void 0 : locale6.description) || "Empty"), /* @__PURE__ */ React179.createElement("g", {
      transform: "translate(0 1)",
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ React179.createElement("ellipse", {
      fill: shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }), /* @__PURE__ */ React179.createElement("g", {
      fillRule: "nonzero",
      stroke: borderColor
    }, /* @__PURE__ */ React179.createElement("path", {
      d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }), /* @__PURE__ */ React179.createElement("path", {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: contentColor
    }))));
  };
  if (true) {
    Simple.displayName = "SimpleImage";
  }
  var simple_default = Simple;

  // node_modules/antd/es/empty/style/index.js
  var genSharedEmptyStyle = (token2) => {
    const {
      componentCls,
      margin,
      marginXS,
      marginXL,
      fontSize,
      lineHeight
    } = token2;
    return {
      [componentCls]: {
        marginInline: marginXS,
        fontSize,
        lineHeight,
        textAlign: "center",
        // 原来 &-image 没有父子结构，现在为了外层承担我们的 hashId，改成父子结构
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeight,
          marginBottom: marginXS,
          opacity: token2.opacityImage,
          img: {
            height: "100%"
          },
          svg: {
            maxWidth: "100%",
            height: "100%",
            margin: "auto"
          }
        },
        [`${componentCls}-description`]: {
          color: token2.colorTextDescription
        },
        // 原来 &-footer 没有父子结构，现在为了外层承担我们的 hashId，改成父子结构
        [`${componentCls}-footer`]: {
          marginTop: margin
        },
        "&-normal": {
          marginBlock: marginXL,
          color: token2.colorTextDescription,
          [`${componentCls}-description`]: {
            color: token2.colorTextDescription
          },
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightMD
          }
        },
        "&-small": {
          marginBlock: marginXS,
          color: token2.colorTextDescription,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightSM
          }
        }
      }
    };
  };
  var style_default7 = genStyleHooks("Empty", (token2) => {
    const {
      componentCls,
      controlHeightLG,
      calc
    } = token2;
    const emptyToken = merge2(token2, {
      emptyImgCls: `${componentCls}-img`,
      emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
      emptyImgHeightMD: controlHeightLG,
      emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
    });
    return [genSharedEmptyStyle(emptyToken)];
  });

  // node_modules/antd/es/empty/index.js
  var __rest12 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var defaultEmptyImg = /* @__PURE__ */ React180.createElement(empty_default, null);
  var simpleEmptyImg = /* @__PURE__ */ React180.createElement(simple_default, null);
  var Empty3 = (props) => {
    const {
      className,
      rootClassName,
      prefixCls: customizePrefixCls,
      image = defaultEmptyImg,
      description,
      children,
      imageStyle,
      style: style2,
      classNames: emptyClassNames,
      styles
    } = props, restProps = __rest12(props, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style", "classNames", "styles"]);
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("empty");
    const prefixCls = getPrefixCls("empty", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default7(prefixCls);
    const [locale6] = useLocale_default("Empty");
    const des = typeof description !== "undefined" ? description : locale6 === null || locale6 === void 0 ? void 0 : locale6.description;
    const alt = typeof des === "string" ? des : "empty";
    let imageNode = null;
    if (typeof image === "string") {
      imageNode = /* @__PURE__ */ React180.createElement("img", {
        alt,
        src: image
      });
    } else {
      imageNode = image;
    }
    if (true) {
      const warning6 = devUseWarning("Empty");
      [["imageStyle", "styles: { image: {} }"]].forEach(([deprecatedName, newName]) => {
        warning6.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
    }
    return wrapCSSVar(/* @__PURE__ */ React180.createElement("div", Object.assign({
      className: (0, import_classnames51.default)(hashId, cssVarCls, prefixCls, contextClassName, {
        [`${prefixCls}-normal`]: image === simpleEmptyImg,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, contextClassNames.root, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.root),
      style: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), contextStyle), styles === null || styles === void 0 ? void 0 : styles.root), style2)
    }, restProps), /* @__PURE__ */ React180.createElement("div", {
      className: (0, import_classnames51.default)(`${prefixCls}-image`, contextClassNames.image, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.image),
      style: Object.assign(Object.assign(Object.assign({}, imageStyle), contextStyles.image), styles === null || styles === void 0 ? void 0 : styles.image)
    }, imageNode), des && /* @__PURE__ */ React180.createElement("div", {
      className: (0, import_classnames51.default)(`${prefixCls}-description`, contextClassNames.description, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.description),
      style: Object.assign(Object.assign({}, contextStyles.description), styles === null || styles === void 0 ? void 0 : styles.description)
    }, des), children && /* @__PURE__ */ React180.createElement("div", {
      className: (0, import_classnames51.default)(`${prefixCls}-footer`, contextClassNames.footer, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.footer),
      style: Object.assign(Object.assign({}, contextStyles.footer), styles === null || styles === void 0 ? void 0 : styles.footer)
    }, children)));
  };
  Empty3.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
  Empty3.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
  if (true) {
    Empty3.displayName = "Empty";
  }
  var empty_default2 = Empty3;

  // node_modules/antd/es/config-provider/defaultRenderEmpty.js
  var DefaultRenderEmpty = (props) => {
    const {
      componentName
    } = props;
    const {
      getPrefixCls
    } = (0, import_react68.useContext)(ConfigContext);
    const prefix = getPrefixCls("empty");
    switch (componentName) {
      case "Table":
      case "List":
        return /* @__PURE__ */ import_react68.default.createElement(empty_default2, {
          image: empty_default2.PRESENTED_IMAGE_SIMPLE
        });
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return /* @__PURE__ */ import_react68.default.createElement(empty_default2, {
          image: empty_default2.PRESENTED_IMAGE_SIMPLE,
          className: `${prefix}-small`
        });
      /**
       * This type of component should satisfy the nullish coalescing operator(??) on the left-hand side.
       * to let the component itself implement the logic.
       * For example `Table.filter`.
       */
      case "Table.filter":
        return null;
      default:
        return /* @__PURE__ */ import_react68.default.createElement(empty_default2, null);
    }
  };
  var defaultRenderEmpty_default = DefaultRenderEmpty;

  // node_modules/antd/es/form/hooks/useVariants.js
  var React182 = __toESM(require_react());
  var useVariant = (component, variant, legacyBordered = void 0) => {
    var _a, _b;
    const {
      variant: configVariant,
      [component]: componentConfig
    } = React182.useContext(ConfigContext);
    const ctxVariant = React182.useContext(VariantContext);
    const configComponentVariant = componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.variant;
    let mergedVariant;
    if (typeof variant !== "undefined") {
      mergedVariant = variant;
    } else if (legacyBordered === false) {
      mergedVariant = "borderless";
    } else {
      mergedVariant = (_b = (_a = ctxVariant !== null && ctxVariant !== void 0 ? ctxVariant : configComponentVariant) !== null && _a !== void 0 ? _a : configVariant) !== null && _b !== void 0 ? _b : "outlined";
    }
    const enableVariantCls = Variants.includes(mergedVariant);
    return [mergedVariant, enableVariantCls];
  };
  var useVariants_default = useVariant;

  // node_modules/antd/es/select/mergedBuiltinPlacements.js
  var getBuiltInPlacements3 = (popupOverflow) => {
    const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
    const sharedConfig = {
      overflow: {
        adjustX: true,
        adjustY: true,
        shiftY: true
      },
      htmlRegion,
      dynamicInset: true
    };
    return {
      bottomLeft: Object.assign(Object.assign({}, sharedConfig), {
        points: ["tl", "bl"],
        offset: [0, 4]
      }),
      bottomRight: Object.assign(Object.assign({}, sharedConfig), {
        points: ["tr", "br"],
        offset: [0, 4]
      }),
      topLeft: Object.assign(Object.assign({}, sharedConfig), {
        points: ["bl", "tl"],
        offset: [0, -4]
      }),
      topRight: Object.assign(Object.assign({}, sharedConfig), {
        points: ["br", "tr"],
        offset: [0, -4]
      })
    };
  };
  function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
    return buildInPlacements || getBuiltInPlacements3(popupOverflow);
  }
  var mergedBuiltinPlacements_default = mergedBuiltinPlacements;

  // node_modules/antd/es/select/style/dropdown.js
  var genItemStyle = (token2) => {
    const {
      optionHeight,
      optionFontSize,
      optionLineHeight,
      optionPadding
    } = token2;
    return {
      position: "relative",
      display: "block",
      minHeight: optionHeight,
      padding: optionPadding,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: optionFontSize,
      lineHeight: optionLineHeight,
      boxSizing: "border-box"
    };
  };
  var genSingleStyle = (token2) => {
    const {
      antCls,
      componentCls
    } = token2;
    const selectItemCls = `${componentCls}-item`;
    const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
    const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
    const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
    const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
    const selectedItemCls = `${selectItemCls}-option-selected`;
    return [
      {
        [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          top: -9999,
          zIndex: token2.zIndexPopup,
          boxSizing: "border-box",
          padding: token2.paddingXXS,
          overflow: "hidden",
          fontSize: token2.fontSize,
          // Fix select render lag of long text in chrome
          // https://github.com/ant-design/ant-design/issues/11456
          // https://github.com/ant-design/ant-design/issues/11843
          fontVariant: "initial",
          backgroundColor: token2.colorBgElevated,
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
            animationName: slideUpIn
          },
          [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
            animationName: slideDownIn
          },
          [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
            animationName: slideUpOut
          },
          [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
            animationName: slideDownOut
          },
          "&-hidden": {
            display: "none"
          },
          [selectItemCls]: Object.assign(Object.assign({}, genItemStyle(token2)), {
            cursor: "pointer",
            transition: `background ${token2.motionDurationSlow} ease`,
            borderRadius: token2.borderRadiusSM,
            // =========== Group ============
            "&-group": {
              color: token2.colorTextDescription,
              fontSize: token2.fontSizeSM,
              cursor: "default"
            },
            // =========== Option ===========
            "&-option": {
              display: "flex",
              "&-content": Object.assign({
                flex: "auto"
              }, textEllipsis),
              "&-state": {
                flex: "none",
                display: "flex",
                alignItems: "center"
              },
              [`&-active:not(${selectItemCls}-option-disabled)`]: {
                backgroundColor: token2.optionActiveBg
              },
              [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                color: token2.optionSelectedColor,
                fontWeight: token2.optionSelectedFontWeight,
                backgroundColor: token2.optionSelectedBg,
                [`${selectItemCls}-option-state`]: {
                  color: token2.colorPrimary
                }
              },
              "&-disabled": {
                [`&${selectItemCls}-option-selected`]: {
                  backgroundColor: token2.colorBgContainerDisabled
                },
                color: token2.colorTextDisabled,
                cursor: "not-allowed"
              },
              "&-grouped": {
                paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
              }
            },
            "&-empty": Object.assign(Object.assign({}, genItemStyle(token2)), {
              color: token2.colorTextDisabled
            })
          }),
          // https://github.com/ant-design/ant-design/pull/46646
          [`${selectedItemCls}:has(+ ${selectedItemCls})`]: {
            borderEndStartRadius: 0,
            borderEndEndRadius: 0,
            [`& + ${selectedItemCls}`]: {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0
            }
          },
          // =========================== RTL ===========================
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Follow code may reuse in other components
      initSlideMotion(token2, "slide-up"),
      initSlideMotion(token2, "slide-down"),
      initMoveMotion(token2, "move-up"),
      initMoveMotion(token2, "move-down")
    ];
  };
  var dropdown_default = genSingleStyle;

  // node_modules/antd/es/select/style/multiple.js
  var getMultipleSelectorUnit = (token2) => {
    const {
      multipleSelectItemHeight,
      paddingXXS,
      lineWidth,
      INTERNAL_FIXED_ITEM_MARGIN
    } = token2;
    const basePadding = token2.max(token2.calc(paddingXXS).sub(lineWidth).equal(), 0);
    const containerPadding = token2.max(token2.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0);
    return {
      basePadding,
      containerPadding,
      itemHeight: unit(multipleSelectItemHeight),
      itemLineHeight: unit(token2.calc(multipleSelectItemHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal())
    };
  };
  var getSelectItemStyle = (token2) => {
    const {
      multipleSelectItemHeight,
      selectHeight,
      lineWidth
    } = token2;
    const selectItemDist = token2.calc(selectHeight).sub(multipleSelectItemHeight).div(2).sub(lineWidth).equal();
    return selectItemDist;
  };
  var genOverflowStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      borderRadiusSM,
      motionDurationSlow,
      paddingXS,
      multipleItemColorDisabled,
      multipleItemBorderColorDisabled,
      colorIcon,
      colorIconHover,
      INTERNAL_FIXED_ITEM_MARGIN
    } = token2;
    const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
    return {
      /**
       * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
       * may update to redesign with its align logic.
       */
      // =========================== Overflow ===========================
      [selectOverflowPrefixCls]: {
        position: "relative",
        display: "flex",
        flex: "auto",
        flexWrap: "wrap",
        maxWidth: "100%",
        "&-item": {
          flex: "none",
          alignSelf: "center",
          // https://github.com/ant-design/ant-design/issues/54179
          maxWidth: "calc(100% - 4px)",
          display: "inline-flex"
        },
        // ======================== Selections ==========================
        [`${componentCls}-selection-item`]: {
          display: "flex",
          alignSelf: "center",
          flex: "none",
          boxSizing: "border-box",
          maxWidth: "100%",
          marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
          borderRadius: borderRadiusSM,
          cursor: "default",
          transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
          marginInlineEnd: token2.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
          paddingInlineStart: paddingXS,
          paddingInlineEnd: token2.calc(paddingXS).div(2).equal(),
          [`${componentCls}-disabled&`]: {
            color: multipleItemColorDisabled,
            borderColor: multipleItemBorderColorDisabled,
            cursor: "not-allowed"
          },
          // It's ok not to do this, but 24px makes bottom narrow in view should adjust
          "&-content": {
            display: "inline-block",
            marginInlineEnd: token2.calc(paddingXS).div(2).equal(),
            overflow: "hidden",
            whiteSpace: "pre",
            // fix whitespace wrapping. custom tags display all whitespace within.
            textOverflow: "ellipsis"
          },
          "&-remove": Object.assign(Object.assign({}, resetIcon()), {
            display: "inline-flex",
            alignItems: "center",
            color: colorIcon,
            fontWeight: "bold",
            fontSize: 10,
            lineHeight: "inherit",
            cursor: "pointer",
            [`> ${iconCls}`]: {
              verticalAlign: "-0.2em"
            },
            "&:hover": {
              color: colorIconHover
            }
          })
        }
      }
    };
  };
  var genSelectionStyle = (token2, suffix) => {
    const {
      componentCls,
      INTERNAL_FIXED_ITEM_MARGIN
    } = token2;
    const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
    const selectItemHeight = token2.multipleSelectItemHeight;
    const selectItemDist = getSelectItemStyle(token2);
    const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
    const multipleSelectorUnit = getMultipleSelectorUnit(token2);
    return {
      [`${componentCls}-multiple${suffixCls}`]: Object.assign(Object.assign({}, genOverflowStyle(token2)), {
        // ========================= Selector =========================
        [`${componentCls}-selector`]: {
          display: "flex",
          alignItems: "center",
          width: "100%",
          height: "100%",
          // Multiple is little different that horizontal is follow the vertical
          paddingInline: multipleSelectorUnit.basePadding,
          paddingBlock: multipleSelectorUnit.containerPadding,
          borderRadius: token2.borderRadius,
          [`${componentCls}-disabled&`]: {
            background: token2.multipleSelectorBgDisabled,
            cursor: "not-allowed"
          },
          "&:after": {
            display: "inline-block",
            width: 0,
            margin: `${unit(INTERNAL_FIXED_ITEM_MARGIN)} 0`,
            lineHeight: unit(selectItemHeight),
            visibility: "hidden",
            content: '"\\a0"'
          }
        },
        // ======================== Selections ========================
        [`${componentCls}-selection-item`]: {
          height: multipleSelectorUnit.itemHeight,
          lineHeight: unit(multipleSelectorUnit.itemLineHeight)
        },
        // ========================== Wrap ===========================
        [`${componentCls}-selection-wrap`]: {
          alignSelf: "flex-start",
          "&:after": {
            lineHeight: unit(selectItemHeight),
            marginBlock: INTERNAL_FIXED_ITEM_MARGIN
          }
        },
        // ========================== Input ==========================
        [`${componentCls}-prefix`]: {
          marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal()
        },
        [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item,
        ${componentCls}-prefix + ${componentCls}-selection-wrap
      `]: {
          [`${componentCls}-selection-search`]: {
            marginInlineStart: 0
          },
          [`${componentCls}-selection-placeholder`]: {
            insetInlineStart: 0
          }
        },
        // https://github.com/ant-design/ant-design/issues/44754
        // Same as `wrap:after`
        [`${selectOverflowPrefixCls}-item-suffix`]: {
          minHeight: multipleSelectorUnit.itemHeight,
          marginBlock: INTERNAL_FIXED_ITEM_MARGIN
        },
        [`${componentCls}-selection-search`]: {
          display: "inline-flex",
          position: "relative",
          maxWidth: "100%",
          marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(selectItemDist).equal(),
          [`
          &-input,
          &-mirror
        `]: {
            height: selectItemHeight,
            fontFamily: token2.fontFamily,
            lineHeight: unit(selectItemHeight),
            transition: `all ${token2.motionDurationSlow}`
          },
          "&-input": {
            width: "100%",
            minWidth: 4.1
            // fix search cursor missing
          },
          "&-mirror": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            insetInlineEnd: "auto",
            zIndex: 999,
            whiteSpace: "pre",
            // fix whitespace wrapping caused width calculation bug
            visibility: "hidden"
          }
        },
        // ======================= Placeholder =======================
        [`${componentCls}-selection-placeholder`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal(),
          insetInlineEnd: token2.inputPaddingHorizontalBase,
          transform: "translateY(-50%)",
          transition: `all ${token2.motionDurationSlow}`
        }
      })
    };
  };
  function genSizeStyle(token2, suffix) {
    const {
      componentCls
    } = token2;
    const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
    const rawStyle = {
      [`${componentCls}-multiple${suffixCls}`]: {
        fontSize: token2.fontSize,
        // ========================= Selector =========================
        [`${componentCls}-selector`]: {
          [`${componentCls}-show-search&`]: {
            cursor: "text"
          }
        },
        [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
          paddingInlineEnd: token2.calc(token2.fontSizeIcon).add(token2.controlPaddingHorizontal).equal()
        }
      }
    };
    return [genSelectionStyle(token2, suffix), rawStyle];
  }
  var genMultipleStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const smallToken = merge2(token2, {
      selectHeight: token2.controlHeightSM,
      multipleSelectItemHeight: token2.multipleItemHeightSM,
      borderRadius: token2.borderRadiusSM,
      borderRadiusSM: token2.borderRadiusXS
    });
    const largeToken = merge2(token2, {
      fontSize: token2.fontSizeLG,
      selectHeight: token2.controlHeightLG,
      multipleSelectItemHeight: token2.multipleItemHeightLG,
      borderRadius: token2.borderRadiusLG,
      borderRadiusSM: token2.borderRadius
    });
    return [
      genSizeStyle(token2),
      // ======================== Small ========================
      genSizeStyle(smallToken, "sm"),
      // Padding
      {
        [`${componentCls}-multiple${componentCls}-sm`]: {
          [`${componentCls}-selection-placeholder`]: {
            insetInline: token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal()
          },
          // https://github.com/ant-design/ant-design/issues/29559
          [`${componentCls}-selection-search`]: {
            marginInlineStart: 2
            // Magic Number
          }
        }
      },
      // ======================== Large ========================
      genSizeStyle(largeToken, "lg")
    ];
  };
  var multiple_default = genMultipleStyle;

  // node_modules/antd/es/select/style/single.js
  function genSizeStyle2(token2, suffix) {
    const {
      componentCls,
      inputPaddingHorizontalBase,
      borderRadius
    } = token2;
    const selectHeightWithoutBorder = token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal();
    const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
    return {
      [`${componentCls}-single${suffixCls}`]: {
        fontSize: token2.fontSize,
        height: token2.controlHeight,
        // ========================= Selector =========================
        [`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent(token2, true)), {
          display: "flex",
          borderRadius,
          flex: "1 1 auto",
          [`${componentCls}-selection-wrap:after`]: {
            lineHeight: unit(selectHeightWithoutBorder)
          },
          [`${componentCls}-selection-search`]: {
            position: "absolute",
            inset: 0,
            width: "100%",
            "&-input": {
              width: "100%",
              WebkitAppearance: "textfield"
            }
          },
          [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
            display: "block",
            padding: 0,
            lineHeight: unit(selectHeightWithoutBorder),
            transition: `all ${token2.motionDurationSlow}, visibility 0s`,
            alignSelf: "center"
          },
          [`${componentCls}-selection-placeholder`]: {
            transition: "none",
            pointerEvents: "none"
          },
          // For common baseline align
          [[
            "&:after",
            /* For '' value baseline align */
            `${componentCls}-selection-item:empty:after`,
            /* For undefined value baseline align */
            `${componentCls}-selection-placeholder:empty:after`
          ].join(",")]: {
            display: "inline-block",
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          }
        }),
        [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-search,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
          paddingInlineEnd: token2.showArrowPaddingInlineEnd
        },
        // Opacity selection if open
        [`&${componentCls}-open ${componentCls}-selection-item`]: {
          color: token2.colorTextPlaceholder
        },
        // ========================== Input ==========================
        // We only change the style of non-customize input which is only support by `combobox` mode.
        // Not customize
        [`&:not(${componentCls}-customize-input)`]: {
          [`${componentCls}-selector`]: {
            width: "100%",
            height: "100%",
            alignItems: "center",
            padding: `0 ${unit(inputPaddingHorizontalBase)}`,
            [`${componentCls}-selection-search-input`]: {
              height: selectHeightWithoutBorder,
              fontSize: token2.fontSize
            },
            "&:after": {
              lineHeight: unit(selectHeightWithoutBorder)
            }
          }
        },
        [`&${componentCls}-customize-input`]: {
          [`${componentCls}-selector`]: {
            "&:after": {
              display: "none"
            },
            [`${componentCls}-selection-search`]: {
              position: "static",
              width: "100%"
            },
            [`${componentCls}-selection-placeholder`]: {
              position: "absolute",
              insetInlineStart: 0,
              insetInlineEnd: 0,
              padding: `0 ${unit(inputPaddingHorizontalBase)}`,
              "&:after": {
                display: "none"
              }
            }
          }
        }
      }
    };
  }
  function genSingleStyle2(token2) {
    const {
      componentCls
    } = token2;
    const inputPaddingHorizontalSM = token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal();
    return [
      genSizeStyle2(token2),
      // ======================== Small ========================
      // Shared
      genSizeStyle2(merge2(token2, {
        controlHeight: token2.controlHeightSM,
        borderRadius: token2.borderRadiusSM
      }), "sm"),
      // padding
      {
        [`${componentCls}-single${componentCls}-sm`]: {
          [`&:not(${componentCls}-customize-input)`]: {
            [`${componentCls}-selector`]: {
              padding: `0 ${unit(inputPaddingHorizontalSM)}`
            },
            // With arrow should provides `padding-right` to show the arrow
            [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
              insetInlineEnd: token2.calc(inputPaddingHorizontalSM).add(token2.calc(token2.fontSize).mul(1.5)).equal()
            },
            [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
              paddingInlineEnd: token2.calc(token2.fontSize).mul(1.5).equal()
            }
          }
        }
      },
      // ======================== Large ========================
      // Shared
      genSizeStyle2(merge2(token2, {
        controlHeight: token2.singleItemHeightLG,
        fontSize: token2.fontSizeLG,
        borderRadius: token2.borderRadiusLG
      }), "lg")
    ];
  }

  // node_modules/antd/es/select/style/token.js
  var prepareComponentToken5 = (token2) => {
    const {
      fontSize,
      lineHeight,
      lineWidth,
      controlHeight,
      controlHeightSM,
      controlHeightLG,
      paddingXXS,
      controlPaddingHorizontal,
      zIndexPopupBase,
      colorText,
      fontWeightStrong,
      controlItemBgActive,
      controlItemBgHover,
      colorBgContainer,
      colorFillSecondary,
      colorBgContainerDisabled,
      colorTextDisabled,
      colorPrimaryHover,
      colorPrimary,
      controlOutline
    } = token2;
    const dblPaddingXXS = paddingXXS * 2;
    const dblLineWidth = lineWidth * 2;
    const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
    const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
    const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
    const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
    return {
      INTERNAL_FIXED_ITEM_MARGIN,
      zIndexPopup: zIndexPopupBase + 50,
      optionSelectedColor: colorText,
      optionSelectedFontWeight: fontWeightStrong,
      optionSelectedBg: controlItemBgActive,
      optionActiveBg: controlItemBgHover,
      optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
      optionFontSize: fontSize,
      optionLineHeight: lineHeight,
      optionHeight: controlHeight,
      selectorBg: colorBgContainer,
      clearBg: colorBgContainer,
      singleItemHeightLG: controlHeightLG,
      multipleItemBg: colorFillSecondary,
      multipleItemBorderColor: "transparent",
      multipleItemHeight,
      multipleItemHeightSM,
      multipleItemHeightLG,
      multipleSelectorBgDisabled: colorBgContainerDisabled,
      multipleItemColorDisabled: colorTextDisabled,
      multipleItemBorderColorDisabled: "transparent",
      showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25),
      hoverBorderColor: colorPrimaryHover,
      activeBorderColor: colorPrimary,
      activeOutlineColor: controlOutline,
      selectAffixPadding: paddingXXS
    };
  };

  // node_modules/antd/es/select/style/variants.js
  var genBaseOutlinedStyle = (token2, options) => {
    const {
      componentCls,
      antCls,
      controlOutlineWidth
    } = token2;
    return {
      [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${options.borderColor}`,
        background: token2.selectorBg
      },
      [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
        [`&:hover ${componentCls}-selector`]: {
          borderColor: options.hoverBorderHover
        },
        [`${componentCls}-focused& ${componentCls}-selector`]: {
          borderColor: options.activeBorderColor,
          boxShadow: `0 0 0 ${unit(controlOutlineWidth)} ${options.activeOutlineColor}`,
          outline: 0
        },
        [`${componentCls}-prefix`]: {
          color: options.color
        }
      }
    };
  };
  var genOutlinedStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}`]: Object.assign({}, genBaseOutlinedStyle(token2, options))
  });
  var genOutlinedStyle = (token2) => ({
    "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle(token2, {
      borderColor: token2.colorBorder,
      hoverBorderHover: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeOutlineColor: token2.activeOutlineColor,
      color: token2.colorText
    })), genOutlinedStatusStyle(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderHover: token2.colorErrorHover,
      activeBorderColor: token2.colorError,
      activeOutlineColor: token2.colorErrorOutline,
      color: token2.colorError
    })), genOutlinedStatusStyle(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderHover: token2.colorWarningHover,
      activeBorderColor: token2.colorWarning,
      activeOutlineColor: token2.colorWarningOutline,
      color: token2.colorWarning
    })), {
      [`&${token2.componentCls}-disabled`]: {
        [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
          background: token2.colorBgContainerDisabled,
          color: token2.colorTextDisabled
        }
      },
      [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
        background: token2.multipleItemBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
      }
    })
  });
  var genBaseFilledStyle = (token2, options) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
        background: options.bg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
        color: options.color
      },
      [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
        [`&:hover ${componentCls}-selector`]: {
          background: options.hoverBg
        },
        [`${componentCls}-focused& ${componentCls}-selector`]: {
          background: token2.selectorBg,
          borderColor: options.activeBorderColor,
          outline: 0
        }
      }
    };
  };
  var genFilledStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}`]: Object.assign({}, genBaseFilledStyle(token2, options))
  });
  var genFilledStyle = (token2) => ({
    "&-filled": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle(token2, {
      bg: token2.colorFillTertiary,
      hoverBg: token2.colorFillSecondary,
      activeBorderColor: token2.activeBorderColor,
      color: token2.colorText
    })), genFilledStatusStyle(token2, {
      status: "error",
      bg: token2.colorErrorBg,
      hoverBg: token2.colorErrorBgHover,
      activeBorderColor: token2.colorError,
      color: token2.colorError
    })), genFilledStatusStyle(token2, {
      status: "warning",
      bg: token2.colorWarningBg,
      hoverBg: token2.colorWarningBgHover,
      activeBorderColor: token2.colorWarning,
      color: token2.colorWarning
    })), {
      [`&${token2.componentCls}-disabled`]: {
        [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
          borderColor: token2.colorBorder,
          background: token2.colorBgContainerDisabled,
          color: token2.colorTextDisabled
        }
      },
      [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
        background: token2.colorBgContainer,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
      }
    })
  });
  var genBorderlessStyle = (token2) => ({
    "&-borderless": {
      [`${token2.componentCls}-selector`]: {
        background: "transparent",
        border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`
      },
      [`&${token2.componentCls}-disabled`]: {
        [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
          color: token2.colorTextDisabled
        }
      },
      [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
        background: token2.multipleItemBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
      },
      // Status
      [`&${token2.componentCls}-status-error`]: {
        [`${token2.componentCls}-prefix, ${token2.componentCls}-selection-item`]: {
          color: token2.colorError
        }
      },
      [`&${token2.componentCls}-status-warning`]: {
        [`${token2.componentCls}-prefix, ${token2.componentCls}-selection-item`]: {
          color: token2.colorWarning
        }
      }
    }
  });
  var genBaseUnderlinedStyle = (token2, options) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
        borderWidth: `0 0 ${unit(token2.lineWidth)} 0`,
        borderStyle: `none none ${token2.lineType} none`,
        borderColor: options.borderColor,
        background: token2.selectorBg,
        borderRadius: 0
      },
      [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
        [`&:hover ${componentCls}-selector`]: {
          borderColor: options.hoverBorderHover
        },
        [`${componentCls}-focused& ${componentCls}-selector`]: {
          borderColor: options.activeBorderColor,
          outline: 0
        },
        [`${componentCls}-prefix`]: {
          color: options.color
        }
      }
    };
  };
  var genUnderlinedStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}`]: Object.assign({}, genBaseUnderlinedStyle(token2, options))
  });
  var genUnderlinedStyle = (token2) => ({
    "&-underlined": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseUnderlinedStyle(token2, {
      borderColor: token2.colorBorder,
      hoverBorderHover: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeOutlineColor: token2.activeOutlineColor,
      color: token2.colorText
    })), genUnderlinedStatusStyle(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderHover: token2.colorErrorHover,
      activeBorderColor: token2.colorError,
      activeOutlineColor: token2.colorErrorOutline,
      color: token2.colorError
    })), genUnderlinedStatusStyle(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderHover: token2.colorWarningHover,
      activeBorderColor: token2.colorWarning,
      activeOutlineColor: token2.colorWarningOutline,
      color: token2.colorWarning
    })), {
      [`&${token2.componentCls}-disabled`]: {
        [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
          color: token2.colorTextDisabled
        }
      },
      [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
        background: token2.multipleItemBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
      }
    })
  });
  var genVariantsStyle = (token2) => ({
    [token2.componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedStyle(token2)), genFilledStyle(token2)), genBorderlessStyle(token2)), genUnderlinedStyle(token2))
  });
  var variants_default = genVariantsStyle;

  // node_modules/antd/es/select/style/index.js
  var genSelectorStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      position: "relative",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      input: {
        cursor: "pointer"
      },
      [`${componentCls}-show-search&`]: {
        cursor: "text",
        input: {
          cursor: "auto",
          color: "inherit",
          height: "100%"
        }
      },
      [`${componentCls}-disabled&`]: {
        cursor: "not-allowed",
        input: {
          cursor: "not-allowed"
        }
      }
    };
  };
  var getSearchInputWithoutBorderStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-selection-search-input`]: {
        margin: 0,
        padding: 0,
        background: "transparent",
        border: "none",
        outline: "none",
        appearance: "none",
        fontFamily: "inherit",
        "&::-webkit-search-cancel-button": {
          display: "none",
          appearance: "none"
        }
      }
    };
  };
  var genBaseStyle2 = (token2) => {
    const {
      antCls,
      componentCls,
      inputPaddingHorizontalBase,
      iconCls
    } = token2;
    const hoverShowClearStyle = {
      [`${componentCls}-clear`]: {
        opacity: 1,
        background: token2.colorBgBase,
        borderRadius: "50%"
      }
    };
    return {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-flex",
        cursor: "pointer",
        [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
        // ======================== Selection ========================
        [`${componentCls}-selection-item`]: Object.assign(Object.assign({
          flex: 1,
          fontWeight: "normal",
          position: "relative",
          userSelect: "none"
        }, textEllipsis), {
          // https://github.com/ant-design/ant-design/issues/40421
          [`> ${antCls}-typography`]: {
            display: "inline"
          }
        }),
        // ======================= Placeholder =======================
        [`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
          flex: 1,
          color: token2.colorTextPlaceholder,
          pointerEvents: "none"
        }),
        // ========================== Arrow ==========================
        [`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
          position: "absolute",
          top: "50%",
          insetInlineStart: "auto",
          insetInlineEnd: inputPaddingHorizontalBase,
          height: token2.fontSizeIcon,
          marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          lineHeight: 1,
          textAlign: "center",
          pointerEvents: "none",
          display: "flex",
          alignItems: "center",
          transition: `opacity ${token2.motionDurationSlow} ease`,
          [iconCls]: {
            verticalAlign: "top",
            transition: `transform ${token2.motionDurationSlow}`,
            "> svg": {
              verticalAlign: "top"
            },
            [`&:not(${componentCls}-suffix)`]: {
              pointerEvents: "auto"
            }
          },
          [`${componentCls}-disabled &`]: {
            cursor: "not-allowed"
          },
          "> *:not(:last-child)": {
            marginInlineEnd: 8
            // FIXME: magic
          }
        }),
        // ========================== Wrap ===========================
        [`${componentCls}-selection-wrap`]: {
          display: "flex",
          width: "100%",
          position: "relative",
          minWidth: 0,
          // https://github.com/ant-design/ant-design/issues/51669
          "&:after": {
            content: '"\\a0"',
            width: 0,
            overflow: "hidden"
          }
        },
        // ========================= Prefix ==========================
        [`${componentCls}-prefix`]: {
          flex: "none",
          marginInlineEnd: token2.selectAffixPadding
        },
        // ========================== Clear ==========================
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "auto",
          insetInlineEnd: inputPaddingHorizontalBase,
          zIndex: 1,
          display: "inline-block",
          width: token2.fontSizeIcon,
          height: token2.fontSizeIcon,
          marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          fontStyle: "normal",
          lineHeight: 1,
          textAlign: "center",
          textTransform: "none",
          cursor: "pointer",
          opacity: 0,
          transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
          textRendering: "auto",
          // https://github.com/ant-design/ant-design/issues/54205
          // Force GPU compositing on Safari to prevent flickering on opacity/transform transitions
          transform: "translateZ(0)",
          "&:before": {
            display: "block"
          },
          "&:hover": {
            color: token2.colorIcon
          }
        },
        "@media(hover:none)": hoverShowClearStyle,
        "&:hover": hoverShowClearStyle
      }),
      // ========================= Feedback ==========================
      [`${componentCls}-status`]: {
        "&-error, &-warning, &-success, &-validating": {
          [`&${componentCls}-has-feedback`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
            }
          }
        }
      }
    };
  };
  var genSelectStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [
      {
        [componentCls]: {
          // ==================== In Form ====================
          [`&${componentCls}-in-form-item`]: {
            width: "100%"
          }
        }
      },
      // =====================================================
      // ==                       LTR                       ==
      // =====================================================
      // Base
      genBaseStyle2(token2),
      // Single
      genSingleStyle2(token2),
      // Multiple
      multiple_default(token2),
      // Dropdown
      dropdown_default(token2),
      // =====================================================
      // ==                       RTL                       ==
      // =====================================================
      {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        }
      },
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(token2, {
        borderElCls: `${componentCls}-selector`,
        focusElCls: `${componentCls}-focused`
      })
    ];
  };
  var style_default8 = genStyleHooks("Select", (token2, {
    rootPrefixCls
  }) => {
    const selectToken = merge2(token2, {
      rootPrefixCls,
      inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
      multipleSelectItemHeight: token2.multipleItemHeight,
      selectHeight: token2.controlHeight
    });
    return [genSelectStyle(selectToken), variants_default(selectToken)];
  }, prepareComponentToken5, {
    unitless: {
      optionLineHeight: true,
      optionSelectedFontWeight: true
    }
  });

  // node_modules/antd/es/select/useIcons.js
  var React186 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/CheckOutlined.js
  var React183 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/CheckOutlined.js
  var CheckOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
  var CheckOutlined_default = CheckOutlined;

  // node_modules/@ant-design/icons/es/icons/CheckOutlined.js
  var CheckOutlined2 = function CheckOutlined3(props, ref) {
    return /* @__PURE__ */ React183.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: CheckOutlined_default
    }));
  };
  var RefIcon8 = /* @__PURE__ */ React183.forwardRef(CheckOutlined2);
  if (true) {
    RefIcon8.displayName = "CheckOutlined";
  }
  var CheckOutlined_default2 = RefIcon8;

  // node_modules/@ant-design/icons/es/icons/DownOutlined.js
  var React184 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/DownOutlined.js
  var DownOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
  var DownOutlined_default = DownOutlined;

  // node_modules/@ant-design/icons/es/icons/DownOutlined.js
  var DownOutlined2 = function DownOutlined3(props, ref) {
    return /* @__PURE__ */ React184.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: DownOutlined_default
    }));
  };
  var RefIcon9 = /* @__PURE__ */ React184.forwardRef(DownOutlined2);
  if (true) {
    RefIcon9.displayName = "DownOutlined";
  }
  var DownOutlined_default2 = RefIcon9;

  // node_modules/@ant-design/icons/es/icons/SearchOutlined.js
  var React185 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/SearchOutlined.js
  var SearchOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
  var SearchOutlined_default = SearchOutlined;

  // node_modules/@ant-design/icons/es/icons/SearchOutlined.js
  var SearchOutlined2 = function SearchOutlined3(props, ref) {
    return /* @__PURE__ */ React185.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: SearchOutlined_default
    }));
  };
  var RefIcon10 = /* @__PURE__ */ React185.forwardRef(SearchOutlined2);
  if (true) {
    RefIcon10.displayName = "SearchOutlined";
  }
  var SearchOutlined_default2 = RefIcon10;

  // node_modules/antd/es/select/useIcons.js
  function useIcons({
    suffixIcon,
    clearIcon,
    menuItemSelectedIcon,
    removeIcon,
    loading,
    multiple,
    hasFeedback,
    prefixCls,
    showSuffixIcon,
    feedbackIcon,
    showArrow,
    componentName
  }) {
    if (true) {
      const warning6 = devUseWarning(componentName);
      warning6.deprecated(!clearIcon, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
    }
    const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : /* @__PURE__ */ React186.createElement(CloseCircleFilled_default2, null);
    const getSuffixIconNode = (arrowIcon) => {
      if (suffixIcon === null && !hasFeedback && !showArrow) {
        return null;
      }
      return /* @__PURE__ */ React186.createElement(React186.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
    };
    let mergedSuffixIcon = null;
    if (suffixIcon !== void 0) {
      mergedSuffixIcon = getSuffixIconNode(suffixIcon);
    } else if (loading) {
      mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ React186.createElement(LoadingOutlined_default2, {
        spin: true
      }));
    } else {
      const iconCls = `${prefixCls}-suffix`;
      mergedSuffixIcon = ({
        open: open2,
        showSearch
      }) => {
        if (open2 && showSearch) {
          return getSuffixIconNode(/* @__PURE__ */ React186.createElement(SearchOutlined_default2, {
            className: iconCls
          }));
        }
        return getSuffixIconNode(/* @__PURE__ */ React186.createElement(DownOutlined_default2, {
          className: iconCls
        }));
      };
    }
    let mergedItemIcon = null;
    if (menuItemSelectedIcon !== void 0) {
      mergedItemIcon = menuItemSelectedIcon;
    } else if (multiple) {
      mergedItemIcon = /* @__PURE__ */ React186.createElement(CheckOutlined_default2, null);
    } else {
      mergedItemIcon = null;
    }
    let mergedRemoveIcon = null;
    if (removeIcon !== void 0) {
      mergedRemoveIcon = removeIcon;
    } else {
      mergedRemoveIcon = /* @__PURE__ */ React186.createElement(CloseOutlined_default2, null);
    }
    return {
      clearIcon: mergedClearIcon,
      suffixIcon: mergedSuffixIcon,
      itemIcon: mergedItemIcon,
      removeIcon: mergedRemoveIcon
    };
  }

  // node_modules/antd/es/select/useShowArrow.js
  function useShowArrow(suffixIcon, showArrow) {
    return showArrow !== void 0 ? showArrow : suffixIcon !== null;
  }

  // node_modules/antd/es/select/index.js
  var __rest13 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
  var InternalSelect = (props, ref) => {
    var _a, _b, _c, _d, _e;
    const {
      prefixCls: customizePrefixCls,
      bordered,
      className,
      rootClassName,
      getPopupContainer,
      popupClassName,
      dropdownClassName,
      listHeight = 256,
      placement,
      listItemHeight: customListItemHeight,
      size: customizeSize,
      disabled: customDisabled,
      notFoundContent,
      status: customStatus,
      builtinPlacements,
      dropdownMatchSelectWidth,
      popupMatchSelectWidth,
      direction: propDirection,
      style: style2,
      allowClear,
      variant: customizeVariant,
      dropdownStyle,
      transitionName,
      tagRender,
      maxCount,
      prefix,
      dropdownRender,
      popupRender,
      onDropdownVisibleChange,
      onOpenChange,
      styles,
      classNames: classNames146
    } = props, rest = __rest13(props, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear", "variant", "dropdownStyle", "transitionName", "tagRender", "maxCount", "prefix", "dropdownRender", "popupRender", "onDropdownVisibleChange", "onOpenChange", "styles", "classNames"]);
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      renderEmpty,
      direction: contextDirection,
      virtual,
      popupMatchSelectWidth: contextPopupMatchSelectWidth,
      popupOverflow
    } = React187.useContext(ConfigContext);
    const {
      showSearch,
      style: contextStyle,
      styles: contextStyles,
      className: contextClassName,
      classNames: contextClassNames
    } = useComponentConfig("select");
    const [, token2] = useToken();
    const listItemHeight = customListItemHeight !== null && customListItemHeight !== void 0 ? customListItemHeight : token2 === null || token2 === void 0 ? void 0 : token2.controlHeight;
    const prefixCls = getPrefixCls("select", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const direction = propDirection !== null && propDirection !== void 0 ? propDirection : contextDirection;
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const [variant, enableVariantCls] = useVariants_default("select", customizeVariant, bordered);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default8(prefixCls, rootCls);
    const mode = React187.useMemo(() => {
      const {
        mode: m
      } = props;
      if (m === "combobox") {
        return void 0;
      }
      if (m === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
        return "combobox";
      }
      return m;
    }, [props.mode]);
    const isMultiple3 = mode === "multiple" || mode === "tags";
    const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
    const mergedPopupMatchSelectWidth = (_a = popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth) !== null && _a !== void 0 ? _a : contextPopupMatchSelectWidth;
    const mergedPopupStyle = ((_b = styles === null || styles === void 0 ? void 0 : styles.popup) === null || _b === void 0 ? void 0 : _b.root) || ((_c = contextStyles.popup) === null || _c === void 0 ? void 0 : _c.root) || dropdownStyle;
    const mergedPopupRender = popupRender || dropdownRender;
    const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
    const {
      status: contextStatus,
      hasFeedback,
      isFormItemInput,
      feedbackIcon
    } = React187.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    let mergedNotFound;
    if (notFoundContent !== void 0) {
      mergedNotFound = notFoundContent;
    } else if (mode === "combobox") {
      mergedNotFound = null;
    } else {
      mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ React187.createElement(defaultRenderEmpty_default, {
        componentName: "Select"
      });
    }
    const {
      suffixIcon,
      itemIcon,
      removeIcon,
      clearIcon
    } = useIcons(Object.assign(Object.assign({}, rest), {
      multiple: isMultiple3,
      hasFeedback,
      feedbackIcon,
      showSuffixIcon,
      prefixCls,
      componentName: "Select"
    }));
    const mergedAllowClear = allowClear === true ? {
      clearIcon
    } : allowClear;
    const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
    const mergedPopupClassName = (0, import_classnames52.default)(((_d = classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.popup) === null || _d === void 0 ? void 0 : _d.root) || ((_e = contextClassNames === null || contextClassNames === void 0 ? void 0 : contextClassNames.popup) === null || _e === void 0 ? void 0 : _e.root) || popupClassName || dropdownClassName, {
      [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
    }, rootClassName, contextClassNames.root, classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.root, cssVarCls, rootCls, hashId);
    const mergedSize = useSize_default((ctx) => {
      var _a2;
      return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
    });
    const disabled = React187.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const mergedClassName = (0, import_classnames52.default)({
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, contextClassNames.root, classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.root, rootClassName, cssVarCls, rootCls, hashId);
    const memoPlacement = React187.useMemo(() => {
      if (placement !== void 0) {
        return placement;
      }
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }, [placement, direction]);
    if (true) {
      const warning6 = devUseWarning("Select");
      const deprecatedProps = {
        dropdownMatchSelectWidth: "popupMatchSelectWidth",
        dropdownStyle: "styles.popup.root",
        dropdownClassName: "classNames.popup.root",
        popupClassName: "classNames.popup.root",
        dropdownRender: "popupRender",
        onDropdownVisibleChange: "onOpenChange",
        bordered: "variant"
      };
      Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
        warning6.deprecated(!(oldProp in props), oldProp, newProp);
      });
      true ? warning6(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.") : void 0;
      true ? warning6(!(typeof maxCount !== "undefined" && !isMultiple3), "usage", "`maxCount` only works with mode `multiple` or `tags`") : void 0;
    }
    const [zIndex] = useZIndex("SelectLike", mergedPopupStyle === null || mergedPopupStyle === void 0 ? void 0 : mergedPopupStyle.zIndex);
    return wrapCSSVar(/* @__PURE__ */ React187.createElement(es_default10, Object.assign({
      ref,
      virtual,
      showSearch
    }, selectProps, {
      style: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), styles === null || styles === void 0 ? void 0 : styles.root), contextStyle), style2),
      dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
      transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
      builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
      listHeight,
      listItemHeight,
      mode,
      prefixCls,
      placement: memoPlacement,
      direction,
      prefix,
      suffixIcon,
      menuItemSelectedIcon: itemIcon,
      removeIcon,
      allowClear: mergedAllowClear,
      notFoundContent: mergedNotFound,
      className: mergedClassName,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      dropdownClassName: mergedPopupClassName,
      disabled: mergedDisabled,
      dropdownStyle: Object.assign(Object.assign({}, mergedPopupStyle), {
        zIndex
      }),
      maxCount: isMultiple3 ? maxCount : void 0,
      tagRender: isMultiple3 ? tagRender : void 0,
      dropdownRender: mergedPopupRender,
      onDropdownVisibleChange: mergedOnOpenChange
    })));
  };
  if (true) {
    InternalSelect.displayName = "Select";
  }
  var Select2 = /* @__PURE__ */ React187.forwardRef(InternalSelect);
  var PurePanel2 = PurePanel_default2(Select2, "dropdownAlign");
  Select2.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
  Select2.Option = Option_default;
  Select2.OptGroup = OptGroup_default;
  Select2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel2;
  if (true) {
    Select2.displayName = "Select";
  }
  var select_default = Select2;

  // node_modules/antd/es/_util/responsiveObserver.js
  var import_react69 = __toESM(require_react());

  // node_modules/antd/es/_util/mediaQueryUtil.js
  var addMediaQueryListener = (mql, handler) => {
    if (typeof (mql === null || mql === void 0 ? void 0 : mql.addEventListener) !== "undefined") {
      mql.addEventListener("change", handler);
    } else if (typeof (mql === null || mql === void 0 ? void 0 : mql.addListener) !== "undefined") {
      mql.addListener(handler);
    }
  };
  var removeMediaQueryListener = (mql, handler) => {
    if (typeof (mql === null || mql === void 0 ? void 0 : mql.removeEventListener) !== "undefined") {
      mql.removeEventListener("change", handler);
    } else if (typeof (mql === null || mql === void 0 ? void 0 : mql.removeListener) !== "undefined") {
      mql.removeListener(handler);
    }
  };

  // node_modules/antd/es/_util/responsiveObserver.js
  var responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
  var getResponsiveMap = (token2) => ({
    xs: `(max-width: ${token2.screenXSMax}px)`,
    sm: `(min-width: ${token2.screenSM}px)`,
    md: `(min-width: ${token2.screenMD}px)`,
    lg: `(min-width: ${token2.screenLG}px)`,
    xl: `(min-width: ${token2.screenXL}px)`,
    xxl: `(min-width: ${token2.screenXXL}px)`
  });
  var validateBreakpoints = (token2) => {
    const indexableToken = token2;
    const revBreakpoints = [].concat(responsiveArray).reverse();
    revBreakpoints.forEach((breakpoint, i) => {
      const breakpointUpper = breakpoint.toUpperCase();
      const screenMin = `screen${breakpointUpper}Min`;
      const screen = `screen${breakpointUpper}`;
      if (!(indexableToken[screenMin] <= indexableToken[screen])) {
        throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
      }
      if (i < revBreakpoints.length - 1) {
        const screenMax = `screen${breakpointUpper}Max`;
        if (!(indexableToken[screen] <= indexableToken[screenMax])) {
          throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
        }
        const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();
        const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
        if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
          throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
        }
      }
    });
    return token2;
  };
  var useResponsiveObserver = () => {
    const [, token2] = useToken();
    const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
    return import_react69.default.useMemo(() => {
      const subscribers = /* @__PURE__ */ new Map();
      let subUid = -1;
      let screens = {};
      return {
        responsiveMap,
        matchHandlers: {},
        dispatch(pointMap) {
          screens = pointMap;
          subscribers.forEach((func) => func(screens));
          return subscribers.size >= 1;
        },
        subscribe(func) {
          if (!subscribers.size) {
            this.register();
          }
          subUid += 1;
          subscribers.set(subUid, func);
          func(screens);
          return subUid;
        },
        unsubscribe(paramToken) {
          subscribers.delete(paramToken);
          if (!subscribers.size) {
            this.unregister();
          }
        },
        register() {
          Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {
            const listener = ({
              matches
            }) => {
              this.dispatch(Object.assign(Object.assign({}, screens), {
                [screen]: matches
              }));
            };
            const mql = window.matchMedia(mediaQuery);
            addMediaQueryListener(mql, listener);
            this.matchHandlers[mediaQuery] = {
              mql,
              listener
            };
            listener(mql);
          });
        },
        unregister() {
          Object.values(responsiveMap).forEach((mediaQuery) => {
            const handler = this.matchHandlers[mediaQuery];
            removeMediaQueryListener(handler === null || handler === void 0 ? void 0 : handler.mql, handler === null || handler === void 0 ? void 0 : handler.listener);
          });
          subscribers.clear();
        }
      };
    }, [token2]);
  };
  var responsiveObserver_default = useResponsiveObserver;

  // node_modules/antd/es/grid/hooks/useBreakpoint.js
  var import_react70 = __toESM(require_react());

  // node_modules/antd/es/_util/hooks/useForceUpdate.js
  var React189 = __toESM(require_react());
  function useForceUpdate() {
    const [, forceUpdate] = React189.useReducer((x) => x + 1, 0);
    return forceUpdate;
  }

  // node_modules/antd/es/grid/hooks/useBreakpoint.js
  function useBreakpoint(refreshOnChange = true, defaultScreens = {}) {
    const screensRef = (0, import_react70.useRef)(defaultScreens);
    const forceUpdate = useForceUpdate();
    const responsiveObserver = responsiveObserver_default();
    useLayoutEffect_default(() => {
      const token2 = responsiveObserver.subscribe((supportScreens) => {
        screensRef.current = supportScreens;
        if (refreshOnChange) {
          forceUpdate();
        }
      });
      return () => responsiveObserver.unsubscribe(token2);
    }, []);
    return screensRef.current;
  }
  var useBreakpoint_default = useBreakpoint;

  // node_modules/antd/es/tooltip/index.js
  var React193 = __toESM(require_react());
  var import_classnames57 = __toESM(require_classnames());

  // node_modules/rc-tooltip/es/Popup.js
  var import_classnames53 = __toESM(require_classnames());
  var React190 = __toESM(require_react());
  function Popup2(props) {
    var children = props.children, prefixCls = props.prefixCls, id = props.id, innerStyle = props.overlayInnerStyle, bodyClassName = props.bodyClassName, className = props.className, style2 = props.style;
    return /* @__PURE__ */ React190.createElement("div", {
      className: (0, import_classnames53.default)("".concat(prefixCls, "-content"), className),
      style: style2
    }, /* @__PURE__ */ React190.createElement("div", {
      className: (0, import_classnames53.default)("".concat(prefixCls, "-inner"), bodyClassName),
      id,
      role: "tooltip",
      style: innerStyle
    }, typeof children === "function" ? children() : children));
  }

  // node_modules/rc-tooltip/es/Tooltip.js
  var import_classnames54 = __toESM(require_classnames());
  var React191 = __toESM(require_react());
  var import_react71 = __toESM(require_react());

  // node_modules/rc-tooltip/es/placements.js
  var autoAdjustOverflowTopBottom = {
    shiftX: 64,
    adjustY: 1
  };
  var autoAdjustOverflowLeftRight = {
    adjustX: 1,
    shiftY: true
  };
  var targetOffset = [0, 0];
  var placements = {
    left: {
      points: ["cr", "cl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset
    },
    right: {
      points: ["cl", "cr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset
    },
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset
    }
  };

  // node_modules/rc-tooltip/es/Tooltip.js
  var _excluded26 = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow", "classNames", "styles"];
  var Tooltip = function Tooltip2(props, ref) {
    var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion2 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle, arrowContent = props.arrowContent, overlay = props.overlay, id = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, tooltipClassNames = props.classNames, tooltipStyles = props.styles, restProps = _objectWithoutProperties(props, _excluded26);
    var mergedId = useId_default(id);
    var triggerRef = (0, import_react71.useRef)(null);
    (0, import_react71.useImperativeHandle)(ref, function() {
      return triggerRef.current;
    });
    var extraProps = _objectSpread2({}, restProps);
    if ("visible" in props) {
      extraProps.popupVisible = props.visible;
    }
    var getPopupElement = function getPopupElement2() {
      return /* @__PURE__ */ React191.createElement(Popup2, {
        key: "content",
        prefixCls,
        id: mergedId,
        bodyClassName: tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.body,
        overlayInnerStyle: _objectSpread2(_objectSpread2({}, overlayInnerStyle), tooltipStyles === null || tooltipStyles === void 0 ? void 0 : tooltipStyles.body)
      }, overlay);
    };
    var getChildren = function getChildren2() {
      var child = React191.Children.only(children);
      var originalProps = (child === null || child === void 0 ? void 0 : child.props) || {};
      var childProps = _objectSpread2(_objectSpread2({}, originalProps), {}, {
        "aria-describedby": overlay ? mergedId : null
      });
      return /* @__PURE__ */ React191.cloneElement(children, childProps);
    };
    return /* @__PURE__ */ React191.createElement(es_default8, _extends({
      popupClassName: (0, import_classnames54.default)(overlayClassName, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.root),
      prefixCls,
      popup: getPopupElement,
      action: trigger,
      builtinPlacements: placements,
      popupPlacement: placement,
      ref: triggerRef,
      popupAlign: align,
      getPopupContainer: getTooltipContainer,
      onPopupVisibleChange: onVisibleChange,
      afterPopupVisibleChange: afterVisibleChange,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupMotion: motion2,
      defaultPopupVisible: defaultVisible,
      autoDestroy: destroyTooltipOnHide,
      mouseLeaveDelay,
      popupStyle: _objectSpread2(_objectSpread2({}, overlayStyle), tooltipStyles === null || tooltipStyles === void 0 ? void 0 : tooltipStyles.root),
      mouseEnterDelay,
      arrow: showArrow
    }, extraProps), getChildren());
  };
  var Tooltip_default = /* @__PURE__ */ (0, import_react71.forwardRef)(Tooltip);

  // node_modules/rc-tooltip/es/index.js
  var es_default11 = Tooltip_default;

  // node_modules/antd/es/style/roundedArrow.js
  function getArrowToken(token2) {
    const {
      sizePopupArrow,
      borderRadiusXS,
      borderRadiusOuter
    } = token2;
    const unitWidth = sizePopupArrow / 2;
    const ax = 0;
    const ay = unitWidth;
    const bx = borderRadiusOuter * 1 / Math.sqrt(2);
    const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
    const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
    const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
    const dx = 2 * unitWidth - cx;
    const dy = cy;
    const ex = 2 * unitWidth - bx;
    const ey = by;
    const fx = 2 * unitWidth - ax;
    const fy = ay;
    const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
    const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
    const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
    const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
    return {
      arrowShadowWidth: shadowWidth,
      arrowPath,
      arrowPolygon
    };
  }
  var genRoundedArrow = (token2, bgColor, boxShadow) => {
    const {
      sizePopupArrow,
      arrowPolygon,
      arrowPath,
      arrowShadowWidth,
      borderRadiusXS,
      calc
    } = token2;
    return {
      pointerEvents: "none",
      width: sizePopupArrow,
      height: sizePopupArrow,
      overflow: "hidden",
      "&::before": {
        position: "absolute",
        bottom: 0,
        insetInlineStart: 0,
        width: sizePopupArrow,
        height: calc(sizePopupArrow).div(2).equal(),
        background: bgColor,
        clipPath: {
          _multi_value_: true,
          value: [arrowPolygon, arrowPath]
        },
        content: '""'
      },
      "&::after": {
        content: '""',
        position: "absolute",
        width: arrowShadowWidth,
        height: arrowShadowWidth,
        bottom: 0,
        insetInline: 0,
        margin: "auto",
        borderRadius: {
          _skip_check_: true,
          value: `0 0 ${unit(borderRadiusXS)} 0`
        },
        transform: "translateY(50%) rotate(-135deg)",
        boxShadow,
        zIndex: 0,
        background: "transparent"
      }
    };
  };

  // node_modules/antd/es/style/placementArrow.js
  var MAX_VERTICAL_CONTENT_RADIUS = 8;
  function getArrowOffsetToken(options) {
    const {
      contentRadius,
      limitVerticalRadius
    } = options;
    const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
    const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
    return {
      arrowOffsetHorizontal: arrowOffset,
      arrowOffsetVertical
    };
  }
  function isInject(valid, code) {
    if (!valid) {
      return {};
    }
    return code;
  }
  function getArrowStyle(token2, colorBg, options) {
    const {
      componentCls,
      boxShadowPopoverArrow,
      arrowOffsetVertical,
      arrowOffsetHorizontal
    } = token2;
    const {
      arrowDistance = 0,
      arrowPlacement = {
        left: true,
        right: true,
        top: true,
        bottom: true
      }
    } = options || {};
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
        // ============================ Basic ============================
        [`${componentCls}-arrow`]: [Object.assign(Object.assign({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, genRoundedArrow(token2, colorBg, boxShadowPopoverArrow)), {
          "&:before": {
            background: colorBg
          }
        })]
      }, isInject(!!arrowPlacement.top, {
        [[`&-placement-top > ${componentCls}-arrow`, `&-placement-topLeft > ${componentCls}-arrow`, `&-placement-topRight > ${componentCls}-arrow`].join(",")]: {
          bottom: arrowDistance,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        "&-placement-topLeft": {
          "--arrow-offset-horizontal": arrowOffsetHorizontal,
          [`> ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        },
        "&-placement-topRight": {
          "--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
          [`> ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        }
      })), isInject(!!arrowPlacement.bottom, {
        [[`&-placement-bottom > ${componentCls}-arrow`, `&-placement-bottomLeft > ${componentCls}-arrow`, `&-placement-bottomRight > ${componentCls}-arrow`].join(",")]: {
          top: arrowDistance,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        "&-placement-bottomLeft": {
          "--arrow-offset-horizontal": arrowOffsetHorizontal,
          [`> ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        },
        "&-placement-bottomRight": {
          "--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
          [`> ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        }
      })), isInject(!!arrowPlacement.left, {
        [[`&-placement-left > ${componentCls}-arrow`, `&-placement-leftTop > ${componentCls}-arrow`, `&-placement-leftBottom > ${componentCls}-arrow`].join(",")]: {
          right: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-leftBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      })), isInject(!!arrowPlacement.right, {
        [[`&-placement-right > ${componentCls}-arrow`, `&-placement-rightTop > ${componentCls}-arrow`, `&-placement-rightBottom > ${componentCls}-arrow`].join(",")]: {
          left: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-rightBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      }))
    };
  }

  // node_modules/antd/es/_util/placements.js
  function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow3) {
    if (autoAdjustOverflow3 === false) {
      return {
        adjustX: false,
        adjustY: false
      };
    }
    const overflow = autoAdjustOverflow3 && typeof autoAdjustOverflow3 === "object" ? autoAdjustOverflow3 : {};
    const baseOverflow = {};
    switch (placement) {
      case "top":
      case "bottom":
        baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
        baseOverflow.shiftY = true;
        baseOverflow.adjustY = true;
        break;
      case "left":
      case "right":
        baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
        baseOverflow.shiftX = true;
        baseOverflow.adjustX = true;
        break;
    }
    const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
    if (!mergedOverflow.shiftX) {
      mergedOverflow.adjustX = true;
    }
    if (!mergedOverflow.shiftY) {
      mergedOverflow.adjustY = true;
    }
    return mergedOverflow;
  }
  var PlacementAlignMap = {
    left: {
      points: ["cr", "cl"]
    },
    right: {
      points: ["cl", "cr"]
    },
    top: {
      points: ["bc", "tc"]
    },
    bottom: {
      points: ["tc", "bc"]
    },
    topLeft: {
      points: ["bl", "tl"]
    },
    leftTop: {
      points: ["tr", "tl"]
    },
    topRight: {
      points: ["br", "tr"]
    },
    rightTop: {
      points: ["tl", "tr"]
    },
    bottomRight: {
      points: ["tr", "br"]
    },
    rightBottom: {
      points: ["bl", "br"]
    },
    bottomLeft: {
      points: ["tl", "bl"]
    },
    leftBottom: {
      points: ["br", "bl"]
    }
  };
  var ArrowCenterPlacementAlignMap = {
    topLeft: {
      points: ["bl", "tc"]
    },
    leftTop: {
      points: ["tr", "cl"]
    },
    topRight: {
      points: ["br", "tc"]
    },
    rightTop: {
      points: ["tl", "cr"]
    },
    bottomRight: {
      points: ["tr", "bc"]
    },
    rightBottom: {
      points: ["bl", "cr"]
    },
    bottomLeft: {
      points: ["tl", "bc"]
    },
    leftBottom: {
      points: ["br", "cl"]
    }
  };
  var DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
  function getPlacements(config) {
    const {
      arrowWidth,
      autoAdjustOverflow: autoAdjustOverflow3,
      arrowPointAtCenter,
      offset: offset3,
      borderRadius,
      visibleFirst
    } = config;
    const halfArrowWidth = arrowWidth / 2;
    const placementMap = {};
    const arrowOffset = getArrowOffsetToken({
      contentRadius: borderRadius,
      limitVerticalRadius: true
    });
    Object.keys(PlacementAlignMap).forEach((key) => {
      const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
      const placementInfo = Object.assign(Object.assign({}, template), {
        offset: [0, 0],
        dynamicInset: true
      });
      placementMap[key] = placementInfo;
      if (DisableAutoArrowList.has(key)) {
        placementInfo.autoArrow = false;
      }
      switch (key) {
        case "top":
        case "topLeft":
        case "topRight":
          placementInfo.offset[1] = -halfArrowWidth - offset3;
          break;
        case "bottom":
        case "bottomLeft":
        case "bottomRight":
          placementInfo.offset[1] = halfArrowWidth + offset3;
          break;
        case "left":
        case "leftTop":
        case "leftBottom":
          placementInfo.offset[0] = -halfArrowWidth - offset3;
          break;
        case "right":
        case "rightTop":
        case "rightBottom":
          placementInfo.offset[0] = halfArrowWidth + offset3;
          break;
      }
      if (arrowPointAtCenter) {
        switch (key) {
          case "topLeft":
          case "bottomLeft":
            placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
            break;
          case "topRight":
          case "bottomRight":
            placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
            break;
          case "leftTop":
          case "rightTop":
            placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
            break;
          case "leftBottom":
          case "rightBottom":
            placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
            break;
        }
      }
      placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow3);
      if (visibleFirst) {
        placementInfo.htmlRegion = "visibleFirst";
      }
    });
    return placementMap;
  }

  // node_modules/antd/es/tooltip/PurePanel.js
  var React192 = __toESM(require_react());
  var import_classnames56 = __toESM(require_classnames());

  // node_modules/antd/es/tooltip/style/index.js
  var genTooltipStyle = (token2) => {
    const {
      calc,
      componentCls,
      // ant-tooltip
      tooltipMaxWidth,
      tooltipColor,
      tooltipBg,
      tooltipBorderRadius,
      zIndexPopup,
      controlHeight,
      boxShadowSecondary,
      paddingSM,
      paddingXS,
      arrowOffsetHorizontal,
      sizePopupArrow
    } = token2;
    const edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal();
    const centerAlignMinWidth = calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal();
    return [
      {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          zIndex: zIndexPopup,
          display: "block",
          width: "max-content",
          maxWidth: tooltipMaxWidth,
          visibility: "visible",
          // When use `autoArrow`, origin will follow the arrow position
          "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
          transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" "),
          "&-hidden": {
            display: "none"
          },
          "--antd-arrow-background-color": tooltipBg,
          // Wrapper for the tooltip content
          [`${componentCls}-inner`]: {
            minWidth: centerAlignMinWidth,
            minHeight: controlHeight,
            padding: `${unit(token2.calc(paddingSM).div(2).equal())} ${unit(paddingXS)}`,
            color: tooltipColor,
            textAlign: "start",
            textDecoration: "none",
            wordWrap: "break-word",
            backgroundColor: tooltipBg,
            borderRadius: tooltipBorderRadius,
            boxShadow: boxShadowSecondary,
            boxSizing: "border-box"
          },
          // Align placement should have another min width
          [[`&-placement-topLeft`, `&-placement-topRight`, `&-placement-bottomLeft`, `&-placement-bottomRight`].join(",")]: {
            minWidth: edgeAlignMinWidth
          },
          // Limit left and right placement radius
          [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
            [`${componentCls}-inner`]: {
              borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
            }
          },
          [`${componentCls}-content`]: {
            position: "relative"
          }
        }), genPresetColor(token2, (colorKey, {
          darkColor
        }) => ({
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-inner`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        }))), {
          // RTL
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Arrow Style
      getArrowStyle(token2, "var(--antd-arrow-background-color)"),
      // Pure Render
      {
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none",
          margin: token2.sizePopupArrow
        }
      }
    ];
  };
  var prepareComponentToken6 = (token2) => Object.assign(Object.assign({
    zIndexPopup: token2.zIndexPopupBase + 70
  }, getArrowOffsetToken({
    contentRadius: token2.borderRadius,
    limitVerticalRadius: true
  })), getArrowToken(merge2(token2, {
    borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
  })));
  var style_default9 = (prefixCls, injectStyle = true) => {
    const useStyle = genStyleHooks("Tooltip", (token2) => {
      const {
        borderRadius,
        colorTextLightSolid,
        colorBgSpotlight
      } = token2;
      const TooltipToken = merge2(token2, {
        // default variables
        tooltipMaxWidth: 250,
        tooltipColor: colorTextLightSolid,
        tooltipBorderRadius: borderRadius,
        tooltipBg: colorBgSpotlight
      });
      return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
    }, prepareComponentToken6, {
      resetStyle: false,
      // Popover use Tooltip as internal component. We do not need to handle this.
      injectStyle
    });
    return useStyle(prefixCls);
  };

  // node_modules/antd/es/tooltip/util.js
  var import_classnames55 = __toESM(require_classnames());

  // node_modules/antd/es/_util/colors.js
  var inverseColors = PresetColors.map((color) => `${color}-inverse`);
  var PresetStatusColorTypes = ["success", "processing", "error", "default", "warning"];
  function isPresetColor(color, includeInverse = true) {
    if (includeInverse) {
      return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
    }
    return PresetColors.includes(color);
  }
  function isPresetStatusColor(color) {
    return PresetStatusColorTypes.includes(color);
  }

  // node_modules/antd/es/tooltip/util.js
  function parseColor(prefixCls, color) {
    const isInternalColor = isPresetColor(color);
    const className = (0, import_classnames55.default)({
      [`${prefixCls}-${color}`]: color && isInternalColor
    });
    const overlayStyle = {};
    const arrowStyle = {};
    if (color && !isInternalColor) {
      overlayStyle.background = color;
      arrowStyle["--antd-arrow-background-color"] = color;
    }
    return {
      className,
      overlayStyle,
      arrowStyle
    };
  }

  // node_modules/antd/es/tooltip/PurePanel.js
  var PurePanel3 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      placement = "top",
      title,
      color,
      overlayInnerStyle
    } = props;
    const {
      getPrefixCls
    } = React192.useContext(ConfigContext);
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default9(prefixCls);
    const colorInfo = parseColor(prefixCls, color);
    const arrowContentStyle = colorInfo.arrowStyle;
    const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
    const cls3 = (0, import_classnames56.default)(hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
    return wrapCSSVar(/* @__PURE__ */ React192.createElement("div", {
      className: cls3,
      style: arrowContentStyle
    }, /* @__PURE__ */ React192.createElement("div", {
      className: `${prefixCls}-arrow`
    }), /* @__PURE__ */ React192.createElement(Popup2, Object.assign({}, props, {
      className: hashId,
      prefixCls,
      overlayInnerStyle: formattedOverlayInnerStyle
    }), title)));
  };
  var PurePanel_default3 = PurePanel3;

  // node_modules/antd/es/tooltip/index.js
  var __rest14 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var InternalTooltip = /* @__PURE__ */ React193.forwardRef((props, ref) => {
    var _a, _b;
    const {
      prefixCls: customizePrefixCls,
      openClassName,
      getTooltipContainer,
      color,
      overlayInnerStyle,
      children,
      afterOpenChange,
      afterVisibleChange,
      destroyTooltipOnHide,
      destroyOnHidden,
      arrow = true,
      title,
      overlay,
      builtinPlacements,
      arrowPointAtCenter = false,
      autoAdjustOverflow: autoAdjustOverflow3 = true,
      motion: motion2,
      getPopupContainer,
      placement = "top",
      mouseEnterDelay = 0.1,
      mouseLeaveDelay = 0.1,
      overlayStyle,
      rootClassName,
      overlayClassName,
      styles,
      classNames: tooltipClassNames
    } = props, restProps = __rest14(props, ["prefixCls", "openClassName", "getTooltipContainer", "color", "overlayInnerStyle", "children", "afterOpenChange", "afterVisibleChange", "destroyTooltipOnHide", "destroyOnHidden", "arrow", "title", "overlay", "builtinPlacements", "arrowPointAtCenter", "autoAdjustOverflow", "motion", "getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName", "overlayClassName", "styles", "classNames"]);
    const mergedShowArrow = !!arrow;
    const [, token2] = useToken();
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("tooltip");
    const warning6 = devUseWarning("Tooltip");
    const tooltipRef = React193.useRef(null);
    const forceAlign = () => {
      var _a2;
      (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
    };
    React193.useImperativeHandle(ref, () => {
      var _a2, _b2;
      return {
        forceAlign,
        forcePopupAlign: () => {
          warning6.deprecated(false, "forcePopupAlign", "forceAlign");
          forceAlign();
        },
        nativeElement: (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.nativeElement,
        popupElement: (_b2 = tooltipRef.current) === null || _b2 === void 0 ? void 0 : _b2.popupElement
      };
    });
    if (true) {
      [["visible", "open"], ["defaultVisible", "defaultOpen"], ["onVisibleChange", "onOpenChange"], ["afterVisibleChange", "afterOpenChange"], ["destroyTooltipOnHide", "destroyOnHidden"], ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"], ["overlayStyle", "styles={{ root: {} }}"], ["overlayInnerStyle", "styles={{ body: {} }}"], ["overlayClassName", 'classNames={{ root: "" }}']].forEach(([deprecatedName, newName]) => {
        warning6.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
      true ? warning6(!destroyTooltipOnHide || typeof destroyTooltipOnHide === "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly.") : void 0;
      true ? warning6(!arrow || typeof arrow === "boolean" || !("arrowPointAtCenter" in arrow), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead.") : void 0;
    }
    const [open2, setOpen] = useMergedState(false, {
      value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
      defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
    });
    const noTitle = !title && !overlay && title !== 0;
    const onOpenChange = (vis) => {
      var _a2, _b2;
      setOpen(noTitle ? false : vis);
      if (!noTitle) {
        (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
        (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
      }
    };
    const tooltipPlacements = React193.useMemo(() => {
      var _a2, _b2;
      let mergedArrowPointAtCenter = arrowPointAtCenter;
      if (typeof arrow === "object") {
        mergedArrowPointAtCenter = (_b2 = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
      }
      return builtinPlacements || getPlacements({
        arrowPointAtCenter: mergedArrowPointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow3,
        arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
        borderRadius: token2.borderRadius,
        offset: token2.marginXXS,
        visibleFirst: true
      });
    }, [arrowPointAtCenter, arrow, builtinPlacements, token2]);
    const memoOverlay = React193.useMemo(() => {
      if (title === 0) {
        return title;
      }
      return overlay || title || "";
    }, [overlay, title]);
    const memoOverlayWrapper = /* @__PURE__ */ React193.createElement(ContextIsolator_default, {
      space: true
    }, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const injectFromPopover = props["data-popover-inject"];
    let tempOpen = open2;
    if (!("open" in props) && !("visible" in props) && noTitle) {
      tempOpen = false;
    }
    const child = /* @__PURE__ */ React193.isValidElement(children) && !isFragment2(children) ? children : /* @__PURE__ */ React193.createElement("span", null, children);
    const childProps = child.props;
    const childCls = !childProps.className || typeof childProps.className === "string" ? (0, import_classnames57.default)(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
    const [wrapCSSVar, hashId, cssVarCls] = style_default9(prefixCls, !injectFromPopover);
    const colorInfo = parseColor(prefixCls, color);
    const arrowContentStyle = colorInfo.arrowStyle;
    const rootClassNames = (0, import_classnames57.default)(overlayClassName, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, colorInfo.className, rootClassName, hashId, cssVarCls, contextClassName, contextClassNames.root, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.root);
    const bodyClassNames = (0, import_classnames57.default)(contextClassNames.body, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.body);
    const [zIndex, contextZIndex] = useZIndex("Tooltip", restProps.zIndex);
    const content = /* @__PURE__ */ React193.createElement(es_default11, Object.assign({}, restProps, {
      zIndex,
      showArrow: mergedShowArrow,
      placement,
      mouseEnterDelay,
      mouseLeaveDelay,
      prefixCls,
      classNames: {
        root: rootClassNames,
        body: bodyClassNames
      },
      styles: {
        root: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, arrowContentStyle), contextStyles.root), contextStyle), overlayStyle), styles === null || styles === void 0 ? void 0 : styles.root),
        body: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.body), overlayInnerStyle), styles === null || styles === void 0 ? void 0 : styles.body), colorInfo.overlayStyle)
      },
      getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
      ref: tooltipRef,
      builtinPlacements: tooltipPlacements,
      overlay: memoOverlayWrapper,
      visible: tempOpen,
      onVisibleChange: onOpenChange,
      afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
      arrowContent: /* @__PURE__ */ React193.createElement("span", {
        className: `${prefixCls}-arrow-content`
      }),
      motion: {
        motionName: getTransitionName2(rootPrefixCls, "zoom-big-fast", props.transitionName),
        motionDeadline: 1e3
      },
      // TODO: In the future, destroyTooltipOnHide in rc-tooltip needs to be upgrade to destroyOnHidden
      destroyTooltipOnHide: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : !!destroyTooltipOnHide
    }), tempOpen ? cloneElement3(child, {
      className: childCls
    }) : child);
    return wrapCSSVar(/* @__PURE__ */ React193.createElement(zindexContext_default.Provider, {
      value: contextZIndex
    }, content));
  });
  var Tooltip3 = InternalTooltip;
  if (true) {
    Tooltip3.displayName = "Tooltip";
  }
  Tooltip3._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default3;
  var tooltip_default = Tooltip3;

  // node_modules/antd/es/dropdown/dropdown.js
  var React229 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/LeftOutlined.js
  var React194 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/LeftOutlined.js
  var LeftOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
  var LeftOutlined_default = LeftOutlined;

  // node_modules/@ant-design/icons/es/icons/LeftOutlined.js
  var LeftOutlined2 = function LeftOutlined3(props, ref) {
    return /* @__PURE__ */ React194.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: LeftOutlined_default
    }));
  };
  var RefIcon11 = /* @__PURE__ */ React194.forwardRef(LeftOutlined2);
  if (true) {
    RefIcon11.displayName = "LeftOutlined";
  }
  var LeftOutlined_default2 = RefIcon11;

  // node_modules/antd/es/dropdown/dropdown.js
  var import_classnames71 = __toESM(require_classnames());

  // node_modules/rc-dropdown/es/Dropdown.js
  var import_classnames58 = __toESM(require_classnames());
  var import_react73 = __toESM(require_react());

  // node_modules/rc-dropdown/es/hooks/useAccessibility.js
  var React195 = __toESM(require_react());
  var ESC = KeyCode_default.ESC;
  var TAB = KeyCode_default.TAB;
  function useAccessibility(_ref) {
    var visible = _ref.visible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus, overlayRef = _ref.overlayRef;
    var focusMenuRef = React195.useRef(false);
    var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
      if (visible) {
        var _triggerRef$current, _triggerRef$current$f;
        (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 || (_triggerRef$current$f = _triggerRef$current.focus) === null || _triggerRef$current$f === void 0 || _triggerRef$current$f.call(_triggerRef$current);
        onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(false);
      }
    };
    var focusMenu = function focusMenu2() {
      var _overlayRef$current;
      if ((_overlayRef$current = overlayRef.current) !== null && _overlayRef$current !== void 0 && _overlayRef$current.focus) {
        overlayRef.current.focus();
        focusMenuRef.current = true;
        return true;
      }
      return false;
    };
    var handleKeyDown = function handleKeyDown2(event) {
      switch (event.keyCode) {
        case ESC:
          handleCloseMenuAndReturnFocus();
          break;
        case TAB: {
          var focusResult = false;
          if (!focusMenuRef.current) {
            focusResult = focusMenu();
          }
          if (focusResult) {
            event.preventDefault();
          } else {
            handleCloseMenuAndReturnFocus();
          }
          break;
        }
      }
    };
    React195.useEffect(function() {
      if (visible) {
        window.addEventListener("keydown", handleKeyDown);
        if (autoFocus) {
          raf_default(focusMenu, 3);
        }
        return function() {
          window.removeEventListener("keydown", handleKeyDown);
          focusMenuRef.current = false;
        };
      }
      return function() {
        focusMenuRef.current = false;
      };
    }, [visible]);
  }

  // node_modules/rc-dropdown/es/Overlay.js
  var import_react72 = __toESM(require_react());
  var Overlay = /* @__PURE__ */ (0, import_react72.forwardRef)(function(props, ref) {
    var overlay = props.overlay, arrow = props.arrow, prefixCls = props.prefixCls;
    var overlayNode = (0, import_react72.useMemo)(function() {
      var overlayElement;
      if (typeof overlay === "function") {
        overlayElement = overlay();
      } else {
        overlayElement = overlay;
      }
      return overlayElement;
    }, [overlay]);
    var composedRef = composeRef(ref, getNodeRef(overlayNode));
    return /* @__PURE__ */ import_react72.default.createElement(import_react72.default.Fragment, null, arrow && /* @__PURE__ */ import_react72.default.createElement("div", {
      className: "".concat(prefixCls, "-arrow")
    }), /* @__PURE__ */ import_react72.default.cloneElement(overlayNode, {
      ref: supportRef(overlayNode) ? composedRef : void 0
    }));
  });
  var Overlay_default = Overlay;

  // node_modules/rc-dropdown/es/placements.js
  var autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };
  var targetOffset2 = [0, 0];
  var placements2 = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset2
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset2
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset2
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset2
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset2
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset2
    }
  };
  var placements_default = placements2;

  // node_modules/rc-dropdown/es/Dropdown.js
  var _excluded27 = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
  function Dropdown(props, ref) {
    var _children$props;
    var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements4 = _props$placements === void 0 ? placements_default : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, overlay = props.overlay, children = props.children, onVisibleChange = props.onVisibleChange, otherProps = _objectWithoutProperties(props, _excluded27);
    var _React$useState = import_react73.default.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
    var mergedVisible = "visible" in props ? visible : triggerVisible;
    var triggerRef = import_react73.default.useRef(null);
    var overlayRef = import_react73.default.useRef(null);
    var childRef = import_react73.default.useRef(null);
    import_react73.default.useImperativeHandle(ref, function() {
      return triggerRef.current;
    });
    var handleVisibleChange = function handleVisibleChange2(newVisible) {
      setTriggerVisible(newVisible);
      onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(newVisible);
    };
    useAccessibility({
      visible: mergedVisible,
      triggerRef: childRef,
      onVisibleChange: handleVisibleChange,
      autoFocus,
      overlayRef
    });
    var onClick = function onClick2(e3) {
      var onOverlayClick = props.onOverlayClick;
      setTriggerVisible(false);
      if (onOverlayClick) {
        onOverlayClick(e3);
      }
    };
    var getMenuElement = function getMenuElement2() {
      return /* @__PURE__ */ import_react73.default.createElement(Overlay_default, {
        ref: overlayRef,
        overlay,
        prefixCls,
        arrow
      });
    };
    var getMenuElementOrLambda = function getMenuElementOrLambda2() {
      if (typeof overlay === "function") {
        return getMenuElement;
      }
      return getMenuElement();
    };
    var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
      var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint = props.alignPoint;
      if ("minOverlayWidthMatchTrigger" in props) {
        return minOverlayWidthMatchTrigger;
      }
      return !alignPoint;
    };
    var getOpenClassName = function getOpenClassName2() {
      var openClassName = props.openClassName;
      if (openClassName !== void 0) {
        return openClassName;
      }
      return "".concat(prefixCls, "-open");
    };
    var childrenNode = /* @__PURE__ */ import_react73.default.cloneElement(children, {
      className: (0, import_classnames58.default)((_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.className, mergedVisible && getOpenClassName()),
      ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
    });
    var triggerHideAction = hideAction;
    if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
      triggerHideAction = ["click"];
    }
    return /* @__PURE__ */ import_react73.default.createElement(es_default8, _extends({
      builtinPlacements: placements4
    }, otherProps, {
      prefixCls,
      ref: triggerRef,
      popupClassName: (0, import_classnames58.default)(overlayClassName, _defineProperty({}, "".concat(prefixCls, "-show-arrow"), arrow)),
      popupStyle: overlayStyle,
      action: trigger,
      showAction,
      hideAction: triggerHideAction,
      popupPlacement: placement,
      popupAlign: align,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupVisible: mergedVisible,
      stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
      popup: getMenuElementOrLambda(),
      onPopupVisibleChange: handleVisibleChange,
      onPopupClick: onClick,
      getPopupContainer
    }), childrenNode);
  }
  var Dropdown_default = /* @__PURE__ */ import_react73.default.forwardRef(Dropdown);

  // node_modules/rc-dropdown/es/index.js
  var es_default12 = Dropdown_default;

  // node_modules/antd/es/_util/isPrimitive.js
  var isPrimitive = (value) => typeof value !== "object" && typeof value !== "function" || value === null;
  var isPrimitive_default = isPrimitive;

  // node_modules/antd/es/menu/index.js
  var React228 = __toESM(require_react());
  var import_react79 = __toESM(require_react());

  // node_modules/rc-menu/es/Menu.js
  var import_classnames65 = __toESM(require_classnames());
  var React218 = __toESM(require_react());
  var import_react75 = __toESM(require_react());
  var import_react_dom6 = __toESM(require_react_dom());

  // node_modules/rc-menu/es/context/IdContext.js
  var React198 = __toESM(require_react());
  var IdContext = /* @__PURE__ */ React198.createContext(null);
  function getMenuId(uuid8, eventKey) {
    if (uuid8 === void 0) {
      return null;
    }
    return "".concat(uuid8, "-").concat(eventKey);
  }
  function useMenuId(eventKey) {
    var id = React198.useContext(IdContext);
    return getMenuId(id, eventKey);
  }

  // node_modules/rc-menu/es/context/MenuContext.js
  var React199 = __toESM(require_react());
  var _excluded28 = ["children", "locked"];
  var MenuContext = /* @__PURE__ */ React199.createContext(null);
  function mergeProps2(origin2, target) {
    var clone = _objectSpread2({}, origin2);
    Object.keys(target).forEach(function(key) {
      var value = target[key];
      if (value !== void 0) {
        clone[key] = value;
      }
    });
    return clone;
  }
  function InheritableContextProvider(_ref) {
    var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties(_ref, _excluded28);
    var context = React199.useContext(MenuContext);
    var inheritableContext = useMemo(function() {
      return mergeProps2(context, restProps);
    }, [context, restProps], function(prev2, next2) {
      return !locked && (prev2[0] !== next2[0] || !isEqual_default(prev2[1], next2[1], true));
    });
    return /* @__PURE__ */ React199.createElement(MenuContext.Provider, {
      value: inheritableContext
    }, children);
  }

  // node_modules/rc-menu/es/context/PathContext.js
  var React200 = __toESM(require_react());
  var EmptyList = [];
  var PathRegisterContext = /* @__PURE__ */ React200.createContext(null);
  function useMeasure() {
    return React200.useContext(PathRegisterContext);
  }
  var PathTrackerContext = /* @__PURE__ */ React200.createContext(EmptyList);
  function useFullPath(eventKey) {
    var parentKeyPath = React200.useContext(PathTrackerContext);
    return React200.useMemo(function() {
      return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
    }, [parentKeyPath, eventKey]);
  }
  var PathUserContext = /* @__PURE__ */ React200.createContext(null);

  // node_modules/rc-menu/es/context/PrivateContext.js
  var React201 = __toESM(require_react());
  var PrivateContext = /* @__PURE__ */ React201.createContext({});
  var PrivateContext_default = PrivateContext;

  // node_modules/rc-util/es/Dom/focus.js
  function focusable(node2) {
    var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (isVisible_default(node2)) {
      var nodeName = node2.nodeName.toLowerCase();
      var isFocusableElement = (
        // Focusable element
        ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
        node2.isContentEditable || // Anchor with href element
        nodeName === "a" && !!node2.getAttribute("href")
      );
      var tabIndexAttr = node2.getAttribute("tabindex");
      var tabIndexNum = Number(tabIndexAttr);
      var tabIndex = null;
      if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
        tabIndex = tabIndexNum;
      } else if (isFocusableElement && tabIndex === null) {
        tabIndex = 0;
      }
      if (isFocusableElement && node2.disabled) {
        tabIndex = null;
      }
      return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
    }
    return false;
  }
  function getFocusNodeList(node2) {
    var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
      return focusable(child, includePositive);
    });
    if (focusable(node2, includePositive)) {
      res.unshift(node2);
    }
    return res;
  }

  // node_modules/rc-menu/es/hooks/useAccessibility.js
  var React202 = __toESM(require_react());
  var LEFT = KeyCode_default.LEFT;
  var RIGHT = KeyCode_default.RIGHT;
  var UP = KeyCode_default.UP;
  var DOWN = KeyCode_default.DOWN;
  var ENTER = KeyCode_default.ENTER;
  var ESC2 = KeyCode_default.ESC;
  var HOME = KeyCode_default.HOME;
  var END = KeyCode_default.END;
  var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
  function getOffset(mode, isRootLevel, isRtl, which) {
    var _offsets;
    var prev2 = "prev";
    var next2 = "next";
    var children = "children";
    var parent = "parent";
    if (mode === "inline" && which === ENTER) {
      return {
        inlineTrigger: true
      };
    }
    var inline2 = _defineProperty(_defineProperty({}, UP, prev2), DOWN, next2);
    var horizontal = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEFT, isRtl ? next2 : prev2), RIGHT, isRtl ? prev2 : next2), DOWN, children), ENTER, children);
    var vertical = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, UP, prev2), DOWN, next2), ENTER, children), ESC2, parent), LEFT, isRtl ? children : parent), RIGHT, isRtl ? parent : children);
    var offsets = {
      inline: inline2,
      horizontal,
      vertical,
      inlineSub: inline2,
      horizontalSub: vertical,
      verticalSub: vertical
    };
    var type5 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
    switch (type5) {
      case prev2:
        return {
          offset: -1,
          sibling: true
        };
      case next2:
        return {
          offset: 1,
          sibling: true
        };
      case parent:
        return {
          offset: -1,
          sibling: false
        };
      case children:
        return {
          offset: 1,
          sibling: false
        };
      default:
        return null;
    }
  }
  function findContainerUL(element) {
    var current = element;
    while (current) {
      if (current.getAttribute("data-menu-list")) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function getFocusElement(activeElement, elements) {
    var current = activeElement || document.activeElement;
    while (current) {
      if (elements.has(current)) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function getFocusableElements(container, elements) {
    var list = getFocusNodeList(container, true);
    return list.filter(function(ele) {
      return elements.has(ele);
    });
  }
  function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
    var offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    if (!parentQueryContainer) {
      return null;
    }
    var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
    var count = sameLevelFocusableMenuElementList.length;
    var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
      return focusMenuElement === ele;
    });
    if (offset3 < 0) {
      if (focusIndex === -1) {
        focusIndex = count - 1;
      } else {
        focusIndex -= 1;
      }
    } else if (offset3 > 0) {
      focusIndex += 1;
    }
    focusIndex = (focusIndex + count) % count;
    return sameLevelFocusableMenuElementList[focusIndex];
  }
  var refreshElements = function refreshElements2(keys2, id) {
    var elements = /* @__PURE__ */ new Set();
    var key2element = /* @__PURE__ */ new Map();
    var element2key = /* @__PURE__ */ new Map();
    keys2.forEach(function(key) {
      var element = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));
      if (element) {
        elements.add(element);
        element2key.set(element, key);
        key2element.set(key, element);
      }
    });
    return {
      elements,
      key2element,
      element2key
    };
  };
  function useAccessibility2(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
    var rafRef = React202.useRef();
    var activeRef = React202.useRef();
    activeRef.current = activeKey;
    var cleanRaf = function cleanRaf2() {
      raf_default.cancel(rafRef.current);
    };
    React202.useEffect(function() {
      return function() {
        cleanRaf();
      };
    }, []);
    return function(e3) {
      var which = e3.which;
      if ([].concat(ArrowKeys, [ENTER, ESC2, HOME, END]).includes(which)) {
        var keys2 = getKeys();
        var refreshedElements = refreshElements(keys2, id);
        var _refreshedElements = refreshedElements, elements = _refreshedElements.elements, key2element = _refreshedElements.key2element, element2key = _refreshedElements.element2key;
        var activeElement = key2element.get(activeKey);
        var focusMenuElement = getFocusElement(activeElement, elements);
        var focusMenuKey = element2key.get(focusMenuElement);
        var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
        if (!offsetObj && which !== HOME && which !== END) {
          return;
        }
        if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
          e3.preventDefault();
        }
        var tryFocus = function tryFocus2(menuElement) {
          if (menuElement) {
            var focusTargetElement = menuElement;
            var link = menuElement.querySelector("a");
            if (link !== null && link !== void 0 && link.getAttribute("href")) {
              focusTargetElement = link;
            }
            var targetKey = element2key.get(menuElement);
            triggerActiveKey(targetKey);
            cleanRaf();
            rafRef.current = raf_default(function() {
              if (activeRef.current === targetKey) {
                focusTargetElement.focus();
              }
            });
          }
        };
        if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
          var parentQueryContainer;
          if (!focusMenuElement || mode === "inline") {
            parentQueryContainer = containerRef.current;
          } else {
            parentQueryContainer = findContainerUL(focusMenuElement);
          }
          var targetElement;
          var focusableElements = getFocusableElements(parentQueryContainer, elements);
          if (which === HOME) {
            targetElement = focusableElements[0];
          } else if (which === END) {
            targetElement = focusableElements[focusableElements.length - 1];
          } else {
            targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
          }
          tryFocus(targetElement);
        } else if (offsetObj.inlineTrigger) {
          triggerAccessibilityOpen(focusMenuKey);
        } else if (offsetObj.offset > 0) {
          triggerAccessibilityOpen(focusMenuKey, true);
          cleanRaf();
          rafRef.current = raf_default(function() {
            refreshedElements = refreshElements(keys2, id);
            var controlId = focusMenuElement.getAttribute("aria-controls");
            var subQueryContainer = document.getElementById(controlId);
            var targetElement2 = getNextFocusElement(subQueryContainer, refreshedElements.elements);
            tryFocus(targetElement2);
          }, 5);
        } else if (offsetObj.offset < 0) {
          var keyPath = getKeyPath(focusMenuKey, true);
          var parentKey = keyPath[keyPath.length - 2];
          var parentMenuElement = key2element.get(parentKey);
          triggerAccessibilityOpen(parentKey, false);
          tryFocus(parentMenuElement);
        }
      }
      originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e3);
    };
  }

  // node_modules/rc-menu/es/hooks/useKeyRecords.js
  var React203 = __toESM(require_react());
  var import_react74 = __toESM(require_react());

  // node_modules/rc-menu/es/utils/timeUtil.js
  function nextSlice(callback) {
    Promise.resolve().then(callback);
  }

  // node_modules/rc-menu/es/hooks/useKeyRecords.js
  var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
  var getPathStr = function getPathStr2(keyPath) {
    return keyPath.join(PATH_SPLIT);
  };
  var getPathKeys = function getPathKeys2(keyPathStr) {
    return keyPathStr.split(PATH_SPLIT);
  };
  var OVERFLOW_KEY = "rc-menu-more";
  function useKeyRecords() {
    var _React$useState = React203.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1];
    var key2pathRef = (0, import_react74.useRef)(/* @__PURE__ */ new Map());
    var path2keyRef = (0, import_react74.useRef)(/* @__PURE__ */ new Map());
    var _React$useState3 = React203.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
    var updateRef = (0, import_react74.useRef)(0);
    var destroyRef = (0, import_react74.useRef)(false);
    var forceUpdate = function forceUpdate2() {
      if (!destroyRef.current) {
        internalForceUpdate({});
      }
    };
    var registerPath = (0, import_react74.useCallback)(function(key, keyPath) {
      if (true) {
        warning_default(!key2pathRef.current.has(key), "Duplicated key '".concat(key, "' used in Menu by path [").concat(keyPath.join(" > "), "]"));
      }
      var connectedPath = getPathStr(keyPath);
      path2keyRef.current.set(connectedPath, key);
      key2pathRef.current.set(key, connectedPath);
      updateRef.current += 1;
      var id = updateRef.current;
      nextSlice(function() {
        if (id === updateRef.current) {
          forceUpdate();
        }
      });
    }, []);
    var unregisterPath = (0, import_react74.useCallback)(function(key, keyPath) {
      var connectedPath = getPathStr(keyPath);
      path2keyRef.current.delete(connectedPath);
      key2pathRef.current.delete(key);
    }, []);
    var refreshOverflowKeys = (0, import_react74.useCallback)(function(keys2) {
      setOverflowKeys(keys2);
    }, []);
    var getKeyPath = (0, import_react74.useCallback)(function(eventKey, includeOverflow) {
      var fullPath = key2pathRef.current.get(eventKey) || "";
      var keys2 = getPathKeys(fullPath);
      if (includeOverflow && overflowKeys.includes(keys2[0])) {
        keys2.unshift(OVERFLOW_KEY);
      }
      return keys2;
    }, [overflowKeys]);
    var isSubPathKey = (0, import_react74.useCallback)(function(pathKeys, eventKey) {
      return pathKeys.filter(function(item) {
        return item !== void 0;
      }).some(function(pathKey2) {
        var pathKeyList = getKeyPath(pathKey2, true);
        return pathKeyList.includes(eventKey);
      });
    }, [getKeyPath]);
    var getKeys = function getKeys2() {
      var keys2 = _toConsumableArray(key2pathRef.current.keys());
      if (overflowKeys.length) {
        keys2.push(OVERFLOW_KEY);
      }
      return keys2;
    };
    var getSubPathKeys = (0, import_react74.useCallback)(function(key) {
      var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
      var pathKeys = /* @__PURE__ */ new Set();
      _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey2) {
        if (pathKey2.startsWith(connectedPath)) {
          pathKeys.add(path2keyRef.current.get(pathKey2));
        }
      });
      return pathKeys;
    }, []);
    React203.useEffect(function() {
      return function() {
        destroyRef.current = true;
      };
    }, []);
    return {
      // Register
      registerPath,
      unregisterPath,
      refreshOverflowKeys,
      // Util
      isSubPathKey,
      getKeyPath,
      getKeys,
      getSubPathKeys
    };
  }

  // node_modules/rc-menu/es/hooks/useMemoCallback.js
  var React204 = __toESM(require_react());
  function useMemoCallback(func) {
    var funRef = React204.useRef(func);
    funRef.current = func;
    var callback = React204.useCallback(function() {
      var _funRef$current;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
    }, []);
    return func ? callback : void 0;
  }

  // node_modules/rc-menu/es/hooks/useUUID.js
  var React205 = __toESM(require_react());
  var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
  var internalId = 0;
  function useUUID(id) {
    var _useMergedState = useMergedState(id, {
      value: id
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid8 = _useMergedState2[0], setUUID = _useMergedState2[1];
    React205.useEffect(function() {
      internalId += 1;
      var newId = false ? "test" : "".concat(uniquePrefix, "-").concat(internalId);
      setUUID("rc-menu-uuid-".concat(newId));
    }, []);
    return uuid8;
  }

  // node_modules/rc-menu/es/MenuItem.js
  var import_classnames59 = __toESM(require_classnames());
  var React209 = __toESM(require_react());

  // node_modules/rc-menu/es/hooks/useActive.js
  var React206 = __toESM(require_react());
  function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
    var _React$useContext = React206.useContext(MenuContext), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
    var ret = {
      active: activeKey === eventKey
    };
    if (!disabled) {
      ret.onMouseEnter = function(domEvent) {
        onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
          key: eventKey,
          domEvent
        });
        onActive(eventKey);
      };
      ret.onMouseLeave = function(domEvent) {
        onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
          key: eventKey,
          domEvent
        });
        onInactive(eventKey);
      };
    }
    return ret;
  }

  // node_modules/rc-menu/es/hooks/useDirectionStyle.js
  var React207 = __toESM(require_react());
  function useDirectionStyle(level) {
    var _React$useContext = React207.useContext(MenuContext), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
    if (mode !== "inline") {
      return null;
    }
    var len = level;
    return rtl ? {
      paddingRight: len * inlineIndent
    } : {
      paddingLeft: len * inlineIndent
    };
  }

  // node_modules/rc-menu/es/Icon.js
  var React208 = __toESM(require_react());
  function Icon2(_ref) {
    var icon = _ref.icon, props = _ref.props, children = _ref.children;
    var iconNode;
    if (icon === null || icon === false) {
      return null;
    }
    if (typeof icon === "function") {
      iconNode = /* @__PURE__ */ React208.createElement(icon, _objectSpread2({}, props));
    } else if (typeof icon !== "boolean") {
      iconNode = icon;
    }
    return iconNode || children || null;
  }

  // node_modules/rc-menu/es/utils/warnUtil.js
  var _excluded29 = ["item"];
  function warnItemProp(_ref) {
    var item = _ref.item, restInfo = _objectWithoutProperties(_ref, _excluded29);
    Object.defineProperty(restInfo, "item", {
      get: function get2() {
        warning_default(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
        return item;
      }
    });
    return restInfo;
  }

  // node_modules/rc-menu/es/MenuItem.js
  var _excluded30 = ["title", "attribute", "elementRef"];
  var _excluded210 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"];
  var _excluded33 = ["active"];
  var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
    _inherits(LegacyMenuItem2, _React$Component);
    var _super = _createSuper(LegacyMenuItem2);
    function LegacyMenuItem2() {
      _classCallCheck(this, LegacyMenuItem2);
      return _super.apply(this, arguments);
    }
    _createClass(LegacyMenuItem2, [{
      key: "render",
      value: function render4() {
        var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties(_this$props, _excluded30);
        var passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
        warning_default(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
        return /* @__PURE__ */ React209.createElement(es_default7.Item, _extends({}, attribute, {
          title: typeof title === "string" ? title : void 0
        }, passedProps, {
          ref: elementRef
        }));
      }
    }]);
    return LegacyMenuItem2;
  }(React209.Component);
  var InternalMenuItem = /* @__PURE__ */ React209.forwardRef(function(props, ref) {
    var style2 = props.style, className = props.className, eventKey = props.eventKey, warnKey = props.warnKey, disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties(props, _excluded210);
    var domDataId = useMenuId(eventKey);
    var _React$useContext = React209.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
    var _React$useContext2 = React209.useContext(PrivateContext_default), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
    var itemCls = "".concat(prefixCls, "-item");
    var legacyMenuItemRef = React209.useRef();
    var elementRef = React209.useRef();
    var mergedDisabled = contextDisabled || disabled;
    var mergedEleRef = useComposeRef(ref, elementRef);
    var connectedKeys = useFullPath(eventKey);
    if (warnKey) {
      warning_default(false, "MenuItem should not leave undefined `key`.");
    }
    var getEventInfo = function getEventInfo2(e3) {
      return {
        key: eventKey,
        // Note: For legacy code is reversed which not like other antd component
        keyPath: _toConsumableArray(connectedKeys).reverse(),
        item: legacyMenuItemRef.current,
        domEvent: e3
      };
    };
    var mergedItemIcon = itemIcon || contextItemIcon;
    var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded33);
    var selected = selectedKeys.includes(eventKey);
    var directionStyle = useDirectionStyle(connectedKeys.length);
    var onInternalClick = function onInternalClick2(e3) {
      if (mergedDisabled) {
        return;
      }
      var info = getEventInfo(e3);
      onClick === null || onClick === void 0 || onClick(warnItemProp(info));
      onItemClick(info);
    };
    var onInternalKeyDown = function onInternalKeyDown2(e3) {
      onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(e3);
      if (e3.which === KeyCode_default.ENTER) {
        var info = getEventInfo(e3);
        onClick === null || onClick === void 0 || onClick(warnItemProp(info));
        onItemClick(info);
      }
    };
    var onInternalFocus = function onInternalFocus2(e3) {
      onActive(eventKey);
      onFocus === null || onFocus === void 0 || onFocus(e3);
    };
    var optionRoleProps = {};
    if (props.role === "option") {
      optionRoleProps["aria-selected"] = selected;
    }
    var renderNode = /* @__PURE__ */ React209.createElement(LegacyMenuItem, _extends({
      ref: legacyMenuItemRef,
      elementRef: mergedEleRef,
      role: role === null ? "none" : role || "menuitem",
      tabIndex: disabled ? null : -1,
      "data-menu-id": overflowDisabled && domDataId ? null : domDataId
    }, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
      component: "li",
      "aria-disabled": disabled,
      style: _objectSpread2(_objectSpread2({}, directionStyle), style2),
      className: (0, import_classnames59.default)(itemCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(itemCls, "-active"), active), "".concat(itemCls, "-selected"), selected), "".concat(itemCls, "-disabled"), mergedDisabled), className),
      onClick: onInternalClick,
      onKeyDown: onInternalKeyDown,
      onFocus: onInternalFocus
    }), children, /* @__PURE__ */ React209.createElement(Icon2, {
      props: _objectSpread2(_objectSpread2({}, props), {}, {
        isSelected: selected
      }),
      icon: mergedItemIcon
    }));
    if (_internalRenderMenuItem) {
      renderNode = _internalRenderMenuItem(renderNode, props, {
        selected
      });
    }
    return renderNode;
  });
  function MenuItem(props, ref) {
    var eventKey = props.eventKey;
    var measure = useMeasure();
    var connectedKeyPath = useFullPath(eventKey);
    React209.useEffect(function() {
      if (measure) {
        measure.registerPath(eventKey, connectedKeyPath);
        return function() {
          measure.unregisterPath(eventKey, connectedKeyPath);
        };
      }
    }, [connectedKeyPath]);
    if (measure) {
      return null;
    }
    return /* @__PURE__ */ React209.createElement(InternalMenuItem, _extends({}, props, {
      ref
    }));
  }
  var MenuItem_default = /* @__PURE__ */ React209.forwardRef(MenuItem);

  // node_modules/rc-menu/es/SubMenu/index.js
  var React214 = __toESM(require_react());
  var import_classnames62 = __toESM(require_classnames());

  // node_modules/rc-menu/es/SubMenu/SubMenuList.js
  var React210 = __toESM(require_react());
  var import_classnames60 = __toESM(require_classnames());
  var _excluded31 = ["className", "children"];
  var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
    var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded31);
    var _React$useContext = React210.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
    return /* @__PURE__ */ React210.createElement("ul", _extends({
      className: (0, import_classnames60.default)(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
      role: "menu"
    }, restProps, {
      "data-menu-list": true,
      ref
    }), children);
  };
  var SubMenuList = /* @__PURE__ */ React210.forwardRef(InternalSubMenuList);
  SubMenuList.displayName = "SubMenuList";
  var SubMenuList_default = SubMenuList;

  // node_modules/rc-menu/es/utils/commonUtil.js
  var React211 = __toESM(require_react());
  function parseChildren(children, keyPath) {
    return toArray(children).map(function(child, index3) {
      if (/* @__PURE__ */ React211.isValidElement(child)) {
        var _eventKey, _child$props;
        var key = child.key;
        var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
        var emptyKey = eventKey === null || eventKey === void 0;
        if (emptyKey) {
          eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index3]).join("-"));
        }
        var cloneProps = {
          key: eventKey,
          eventKey
        };
        if (emptyKey) {
          cloneProps.warnKey = true;
        }
        return /* @__PURE__ */ React211.cloneElement(child, cloneProps);
      }
      return child;
    });
  }

  // node_modules/rc-menu/es/SubMenu/PopupTrigger.js
  var React212 = __toESM(require_react());
  var import_classnames61 = __toESM(require_classnames());

  // node_modules/rc-menu/es/placements.js
  var autoAdjustOverflow2 = {
    adjustX: 1,
    adjustY: 1
  };
  var placements3 = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow2
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow2
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow2
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow2
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow2
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow2
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow2
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow2
    }
  };
  var placementsRtl = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow2
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow2
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow2
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow2
    },
    rightTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow2
    },
    rightBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow2
    },
    leftTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow2
    },
    leftBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow2
    }
  };

  // node_modules/rc-menu/es/utils/motionUtil.js
  function getMotion3(mode, motion2, defaultMotions) {
    if (motion2) {
      return motion2;
    }
    if (defaultMotions) {
      return defaultMotions[mode] || defaultMotions.other;
    }
    return void 0;
  }

  // node_modules/rc-menu/es/SubMenu/PopupTrigger.js
  var popupPlacementMap = {
    horizontal: "bottomLeft",
    vertical: "rightTop",
    "vertical-left": "rightTop",
    "vertical-right": "leftTop"
  };
  function PopupTrigger(_ref) {
    var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
    var _React$useContext = React212.useContext(MenuContext), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
    var _React$useState = React212.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
    var placement = rtl ? _objectSpread2(_objectSpread2({}, placementsRtl), builtinPlacements) : _objectSpread2(_objectSpread2({}, placements3), builtinPlacements);
    var popupPlacement = popupPlacementMap[mode];
    var targetMotion = getMotion3(mode, motion2, defaultMotions);
    var targetMotionRef = React212.useRef(targetMotion);
    if (mode !== "inline") {
      targetMotionRef.current = targetMotion;
    }
    var mergedMotion = _objectSpread2(_objectSpread2({}, targetMotionRef.current), {}, {
      leavedClassName: "".concat(prefixCls, "-hidden"),
      removeOnLeave: false,
      motionAppear: true
    });
    var visibleRef = React212.useRef();
    React212.useEffect(function() {
      visibleRef.current = raf_default(function() {
        setInnerVisible(visible);
      });
      return function() {
        raf_default.cancel(visibleRef.current);
      };
    }, [visible]);
    return /* @__PURE__ */ React212.createElement(es_default8, {
      prefixCls,
      popupClassName: (0, import_classnames61.default)("".concat(prefixCls, "-popup"), _defineProperty({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
      stretch: mode === "horizontal" ? "minWidth" : null,
      getPopupContainer,
      builtinPlacements: placement,
      popupPlacement,
      popupVisible: innerVisible,
      popup,
      popupStyle,
      popupAlign: popupOffset && {
        offset: popupOffset
      },
      action: disabled ? [] : [triggerSubMenuAction],
      mouseEnterDelay: subMenuOpenDelay,
      mouseLeaveDelay: subMenuCloseDelay,
      onPopupVisibleChange: onVisibleChange,
      forceRender: forceSubMenuRender,
      popupMotion: mergedMotion,
      fresh: true
    }, children);
  }

  // node_modules/rc-menu/es/SubMenu/InlineSubMenuList.js
  var React213 = __toESM(require_react());
  function InlineSubMenuList(_ref) {
    var id = _ref.id, open2 = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
    var fixedMode = "inline";
    var _React$useContext = React213.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
    var sameModeRef = React213.useRef(false);
    sameModeRef.current = mode === fixedMode;
    var _React$useState = React213.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy2 = _React$useState2[0], setDestroy = _React$useState2[1];
    var mergedOpen = sameModeRef.current ? open2 : false;
    React213.useEffect(function() {
      if (sameModeRef.current) {
        setDestroy(false);
      }
    }, [mode]);
    var mergedMotion = _objectSpread2({}, getMotion3(fixedMode, motion2, defaultMotions));
    if (keyPath.length > 1) {
      mergedMotion.motionAppear = false;
    }
    var originOnVisibleChanged = mergedMotion.onVisibleChanged;
    mergedMotion.onVisibleChanged = function(newVisible) {
      if (!sameModeRef.current && !newVisible) {
        setDestroy(true);
      }
      return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
    };
    if (destroy2) {
      return null;
    }
    return /* @__PURE__ */ React213.createElement(InheritableContextProvider, {
      mode: fixedMode,
      locked: !sameModeRef.current
    }, /* @__PURE__ */ React213.createElement(es_default2, _extends({
      visible: mergedOpen
    }, mergedMotion, {
      forceRender: forceSubMenuRender,
      removeOnLeave: false,
      leavedClassName: "".concat(prefixCls, "-hidden")
    }), function(_ref2) {
      var motionClassName = _ref2.className, motionStyle = _ref2.style;
      return /* @__PURE__ */ React213.createElement(SubMenuList_default, {
        id,
        className: motionClassName,
        style: motionStyle
      }, children);
    }));
  }

  // node_modules/rc-menu/es/SubMenu/index.js
  var _excluded34 = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"];
  var _excluded211 = ["active"];
  var InternalSubMenu = /* @__PURE__ */ React214.forwardRef(function(props, ref) {
    var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey, warnKey = props.warnKey, disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, popupStyle = props.popupStyle, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties(props, _excluded34);
    var domDataId = useMenuId(eventKey);
    var _React$useContext = React214.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
    var _React$useContext2 = React214.useContext(PrivateContext_default), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
    var _React$useContext3 = React214.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
    var connectedPath = useFullPath();
    var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
    var mergedDisabled = contextDisabled || disabled;
    var elementRef = React214.useRef();
    var popupRef = React214.useRef();
    if (warnKey) {
      warning_default(false, "SubMenu should not leave undefined `key`.");
    }
    var mergedItemIcon = itemIcon !== null && itemIcon !== void 0 ? itemIcon : contextItemIcon;
    var mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;
    var originOpen = openKeys.includes(eventKey);
    var open2 = !overflowDisabled && originOpen;
    var childrenSelected = isSubPathKey(selectedKeys, eventKey);
    var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded211);
    var _React$useState = React214.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
    var triggerChildrenActive = function triggerChildrenActive2(newActive) {
      if (!mergedDisabled) {
        setChildrenActive(newActive);
      }
    };
    var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
      triggerChildrenActive(true);
      onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
        key: eventKey,
        domEvent
      });
    };
    var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
      triggerChildrenActive(false);
      onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
        key: eventKey,
        domEvent
      });
    };
    var mergedActive = React214.useMemo(function() {
      if (active) {
        return active;
      }
      if (mode !== "inline") {
        return childrenActive || isSubPathKey([activeKey], eventKey);
      }
      return false;
    }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
    var directionStyle = useDirectionStyle(connectedPath.length);
    var onInternalTitleClick = function onInternalTitleClick2(e3) {
      if (mergedDisabled) {
        return;
      }
      onTitleClick === null || onTitleClick === void 0 || onTitleClick({
        key: eventKey,
        domEvent: e3
      });
      if (mode === "inline") {
        onOpenChange(eventKey, !originOpen);
      }
    };
    var onMergedItemClick = useMemoCallback(function(info) {
      onClick === null || onClick === void 0 || onClick(warnItemProp(info));
      onItemClick(info);
    });
    var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
      if (mode !== "inline") {
        onOpenChange(eventKey, newVisible);
      }
    };
    var onInternalFocus = function onInternalFocus2() {
      onActive(eventKey);
    };
    var popupId = domDataId && "".concat(domDataId, "-popup");
    var expandIconNode = React214.useMemo(function() {
      return /* @__PURE__ */ React214.createElement(Icon2, {
        icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
        props: _objectSpread2(_objectSpread2({}, props), {}, {
          isOpen: open2,
          // [Legacy] Not sure why need this mark
          isSubMenu: true
        })
      }, /* @__PURE__ */ React214.createElement("i", {
        className: "".concat(subMenuPrefixCls, "-arrow")
      }));
    }, [mode, mergedExpandIcon, props, open2, subMenuPrefixCls]);
    var titleNode = /* @__PURE__ */ React214.createElement("div", _extends({
      role: "menuitem",
      style: directionStyle,
      className: "".concat(subMenuPrefixCls, "-title"),
      tabIndex: mergedDisabled ? null : -1,
      ref: elementRef,
      title: typeof title === "string" ? title : null,
      "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
      "aria-expanded": open2,
      "aria-haspopup": true,
      "aria-controls": popupId,
      "aria-disabled": mergedDisabled,
      onClick: onInternalTitleClick,
      onFocus: onInternalFocus
    }, activeProps), title, expandIconNode);
    var triggerModeRef = React214.useRef(mode);
    if (mode !== "inline" && connectedPath.length > 1) {
      triggerModeRef.current = "vertical";
    } else {
      triggerModeRef.current = mode;
    }
    if (!overflowDisabled) {
      var triggerMode = triggerModeRef.current;
      titleNode = /* @__PURE__ */ React214.createElement(PopupTrigger, {
        mode: triggerMode,
        prefixCls: subMenuPrefixCls,
        visible: !internalPopupClose && open2 && mode !== "inline",
        popupClassName,
        popupOffset,
        popupStyle,
        popup: /* @__PURE__ */ React214.createElement(
          InheritableContextProvider,
          {
            mode: triggerMode === "horizontal" ? "vertical" : triggerMode
          },
          /* @__PURE__ */ React214.createElement(SubMenuList_default, {
            id: popupId,
            ref: popupRef
          }, children)
        ),
        disabled: mergedDisabled,
        onVisibleChange: onPopupVisibleChange
      }, titleNode);
    }
    var listNode = /* @__PURE__ */ React214.createElement(es_default7.Item, _extends({
      ref,
      role: "none"
    }, restProps, {
      component: "li",
      style: style2,
      className: (0, import_classnames62.default)(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(subMenuPrefixCls, "-open"), open2), "".concat(subMenuPrefixCls, "-active"), mergedActive), "".concat(subMenuPrefixCls, "-selected"), childrenSelected), "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled)),
      onMouseEnter: onInternalMouseEnter,
      onMouseLeave: onInternalMouseLeave
    }), titleNode, !overflowDisabled && /* @__PURE__ */ React214.createElement(InlineSubMenuList, {
      id: popupId,
      open: open2,
      keyPath: connectedPath
    }, children));
    if (_internalRenderSubMenuItem) {
      listNode = _internalRenderSubMenuItem(listNode, props, {
        selected: childrenSelected,
        active: mergedActive,
        open: open2,
        disabled: mergedDisabled
      });
    }
    return /* @__PURE__ */ React214.createElement(InheritableContextProvider, {
      onItemClick: onMergedItemClick,
      mode: mode === "horizontal" ? "vertical" : mode,
      itemIcon: mergedItemIcon,
      expandIcon: mergedExpandIcon
    }, listNode);
  });
  var SubMenu = /* @__PURE__ */ React214.forwardRef(function(props, ref) {
    var eventKey = props.eventKey, children = props.children;
    var connectedKeyPath = useFullPath(eventKey);
    var childList = parseChildren(children, connectedKeyPath);
    var measure = useMeasure();
    React214.useEffect(function() {
      if (measure) {
        measure.registerPath(eventKey, connectedKeyPath);
        return function() {
          measure.unregisterPath(eventKey, connectedKeyPath);
        };
      }
    }, [connectedKeyPath]);
    var renderNode;
    if (measure) {
      renderNode = childList;
    } else {
      renderNode = /* @__PURE__ */ React214.createElement(InternalSubMenu, _extends({
        ref
      }, props), childList);
    }
    return /* @__PURE__ */ React214.createElement(PathTrackerContext.Provider, {
      value: connectedKeyPath
    }, renderNode);
  });
  if (true) {
    SubMenu.displayName = "SubMenu";
  }
  var SubMenu_default = SubMenu;

  // node_modules/rc-menu/es/utils/nodeUtil.js
  var React217 = __toESM(require_react());

  // node_modules/rc-menu/es/Divider.js
  var React215 = __toESM(require_react());
  var import_classnames63 = __toESM(require_classnames());
  function Divider(_ref) {
    var className = _ref.className, style2 = _ref.style;
    var _React$useContext = React215.useContext(MenuContext), prefixCls = _React$useContext.prefixCls;
    var measure = useMeasure();
    if (measure) {
      return null;
    }
    return /* @__PURE__ */ React215.createElement("li", {
      role: "separator",
      className: (0, import_classnames63.default)("".concat(prefixCls, "-item-divider"), className),
      style: style2
    });
  }

  // node_modules/rc-menu/es/MenuItemGroup.js
  var import_classnames64 = __toESM(require_classnames());
  var React216 = __toESM(require_react());
  var _excluded35 = ["className", "title", "eventKey", "children"];
  var InternalMenuItemGroup = /* @__PURE__ */ React216.forwardRef(function(props, ref) {
    var className = props.className, title = props.title, eventKey = props.eventKey, children = props.children, restProps = _objectWithoutProperties(props, _excluded35);
    var _React$useContext = React216.useContext(MenuContext), prefixCls = _React$useContext.prefixCls;
    var groupPrefixCls = "".concat(prefixCls, "-item-group");
    return /* @__PURE__ */ React216.createElement("li", _extends({
      ref,
      role: "presentation"
    }, restProps, {
      onClick: function onClick(e3) {
        return e3.stopPropagation();
      },
      className: (0, import_classnames64.default)(groupPrefixCls, className)
    }), /* @__PURE__ */ React216.createElement("div", {
      role: "presentation",
      className: "".concat(groupPrefixCls, "-title"),
      title: typeof title === "string" ? title : void 0
    }, title), /* @__PURE__ */ React216.createElement("ul", {
      role: "group",
      className: "".concat(groupPrefixCls, "-list")
    }, children));
  });
  var MenuItemGroup = /* @__PURE__ */ React216.forwardRef(function(props, ref) {
    var eventKey = props.eventKey, children = props.children;
    var connectedKeyPath = useFullPath(eventKey);
    var childList = parseChildren(children, connectedKeyPath);
    var measure = useMeasure();
    if (measure) {
      return childList;
    }
    return /* @__PURE__ */ React216.createElement(InternalMenuItemGroup, _extends({
      ref
    }, omit(props, ["warnKey"])), childList);
  });
  if (true) {
    MenuItemGroup.displayName = "MenuItemGroup";
  }
  var MenuItemGroup_default = MenuItemGroup;

  // node_modules/rc-menu/es/utils/nodeUtil.js
  var _excluded36 = ["label", "children", "key", "type", "extra"];
  function convertItemsToNodes(list, components, prefixCls) {
    var MergedMenuItem = components.item, MergedMenuItemGroup = components.group, MergedSubMenu = components.submenu, MergedDivider = components.divider;
    return (list || []).map(function(opt, index3) {
      if (opt && _typeof(opt) === "object") {
        var _ref = opt, label = _ref.label, children = _ref.children, key = _ref.key, type5 = _ref.type, extra = _ref.extra, restProps = _objectWithoutProperties(_ref, _excluded36);
        var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index3);
        if (children || type5 === "group") {
          if (type5 === "group") {
            return /* @__PURE__ */ React217.createElement(MergedMenuItemGroup, _extends({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes(children, components, prefixCls));
          }
          return /* @__PURE__ */ React217.createElement(MergedSubMenu, _extends({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children, components, prefixCls));
        }
        if (type5 === "divider") {
          return /* @__PURE__ */ React217.createElement(MergedDivider, _extends({
            key: mergedKey
          }, restProps));
        }
        return /* @__PURE__ */ React217.createElement(MergedMenuItem, _extends({
          key: mergedKey
        }, restProps, {
          extra
        }), label, (!!extra || extra === 0) && /* @__PURE__ */ React217.createElement("span", {
          className: "".concat(prefixCls, "-item-extra")
        }, extra));
      }
      return null;
    }).filter(function(opt) {
      return opt;
    });
  }
  function parseItems(children, items, keyPath, components, prefixCls) {
    var childNodes = children;
    var mergedComponents = _objectSpread2({
      divider: Divider,
      item: MenuItem_default,
      group: MenuItemGroup_default,
      submenu: SubMenu_default
    }, components);
    if (items) {
      childNodes = convertItemsToNodes(items, mergedComponents, prefixCls);
    }
    return parseChildren(childNodes, keyPath);
  }

  // node_modules/rc-menu/es/Menu.js
  var _excluded37 = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem", "_internalComponents"];
  var EMPTY_LIST2 = [];
  var Menu = /* @__PURE__ */ React218.forwardRef(function(props, ref) {
    var _childList$;
    var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style2 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown2 = _ref.onKeyDown, openAnimation = _ref.openAnimation, openTransitionName = _ref.openTransitionName, _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, _internalComponents = _ref._internalComponents, restProps = _objectWithoutProperties(_ref, _excluded37);
    var _React$useMemo = React218.useMemo(function() {
      return [parseItems(children, items, EMPTY_LIST2, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST2, {}, prefixCls)];
    }, [children, items, _internalComponents]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), childList = _React$useMemo2[0], measureChildList = _React$useMemo2[1];
    var _React$useState = React218.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
    var containerRef = React218.useRef();
    var uuid8 = useUUID(id);
    var isRtl = direction === "rtl";
    if (true) {
      warning_default(!openAnimation && !openTransitionName, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
    }
    var _useMergedState = useMergedState(defaultOpenKeys, {
      value: openKeys,
      postState: function postState(keys2) {
        return keys2 || EMPTY_LIST2;
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
    var triggerOpenKeys = function triggerOpenKeys2(keys2) {
      var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      function doUpdate() {
        setMergedOpenKeys(keys2);
        onOpenChange === null || onOpenChange === void 0 || onOpenChange(keys2);
      }
      if (forceFlush) {
        (0, import_react_dom6.flushSync)(doUpdate);
      } else {
        doUpdate();
      }
    };
    var _React$useState3 = React218.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
    var mountRef = React218.useRef(false);
    var _React$useMemo3 = React218.useMemo(function() {
      if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
        return ["vertical", inlineCollapsed];
      }
      return [mode, false];
    }, [mode, inlineCollapsed]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 2), mergedMode = _React$useMemo4[0], mergedInlineCollapsed = _React$useMemo4[1];
    var isInlineMode = mergedMode === "inline";
    var _React$useState5 = React218.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
    var _React$useState7 = React218.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
    React218.useEffect(function() {
      setInternalMode(mergedMode);
      setInternalInlineCollapsed(mergedInlineCollapsed);
      if (!mountRef.current) {
        return;
      }
      if (isInlineMode) {
        setMergedOpenKeys(inlineCacheOpenKeys);
      } else {
        triggerOpenKeys(EMPTY_LIST2);
      }
    }, [mergedMode, mergedInlineCollapsed]);
    var _React$useState9 = React218.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
    var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
    React218.useEffect(function() {
      if (isInlineMode) {
        setInlineCacheOpenKeys(mergedOpenKeys);
      }
    }, [mergedOpenKeys]);
    React218.useEffect(function() {
      mountRef.current = true;
      return function() {
        mountRef.current = false;
      };
    }, []);
    var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
    var registerPathContext = React218.useMemo(function() {
      return {
        registerPath,
        unregisterPath
      };
    }, [registerPath, unregisterPath]);
    var pathUserContext = React218.useMemo(function() {
      return {
        isSubPathKey
      };
    }, [isSubPathKey]);
    React218.useEffect(function() {
      refreshOverflowKeys(allVisible ? EMPTY_LIST2 : childList.slice(lastVisibleIndex + 1).map(function(child) {
        return child.key;
      }));
    }, [lastVisibleIndex, allVisible]);
    var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
      value: activeKey
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
    var onActive = useMemoCallback(function(key) {
      setMergedActiveKey(key);
    });
    var onInactive = useMemoCallback(function() {
      setMergedActiveKey(void 0);
    });
    (0, import_react75.useImperativeHandle)(ref, function() {
      return {
        list: containerRef.current,
        focus: function focus(options) {
          var _childList$find;
          var keys2 = getKeys();
          var _refreshElements = refreshElements(keys2, uuid8), elements = _refreshElements.elements, key2element = _refreshElements.key2element, element2key = _refreshElements.element2key;
          var focusableElements = getFocusableElements(containerRef.current, elements);
          var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : focusableElements[0] ? element2key.get(focusableElements[0]) : (_childList$find = childList.find(function(node2) {
            return !node2.props.disabled;
          })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
          var elementToFocus = key2element.get(shouldFocusKey);
          if (shouldFocusKey && elementToFocus) {
            var _elementToFocus$focus;
            elementToFocus === null || elementToFocus === void 0 || (_elementToFocus$focus = elementToFocus.focus) === null || _elementToFocus$focus === void 0 || _elementToFocus$focus.call(elementToFocus, options);
          }
        }
      };
    });
    var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
      value: selectedKeys,
      // Legacy convert key to array
      postState: function postState(keys2) {
        if (Array.isArray(keys2)) {
          return keys2;
        }
        if (keys2 === null || keys2 === void 0) {
          return EMPTY_LIST2;
        }
        return [keys2];
      }
    }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
    var triggerSelection = function triggerSelection2(info) {
      if (selectable) {
        var targetKey = info.key;
        var exist = mergedSelectKeys.includes(targetKey);
        var newSelectKeys;
        if (multiple) {
          if (exist) {
            newSelectKeys = mergedSelectKeys.filter(function(key) {
              return key !== targetKey;
            });
          } else {
            newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
          }
        } else {
          newSelectKeys = [targetKey];
        }
        setMergedSelectKeys(newSelectKeys);
        var selectInfo = _objectSpread2(_objectSpread2({}, info), {}, {
          selectedKeys: newSelectKeys
        });
        if (exist) {
          onDeselect === null || onDeselect === void 0 || onDeselect(selectInfo);
        } else {
          onSelect === null || onSelect === void 0 || onSelect(selectInfo);
        }
      }
      if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
        triggerOpenKeys(EMPTY_LIST2);
      }
    };
    var onInternalClick = useMemoCallback(function(info) {
      onClick === null || onClick === void 0 || onClick(warnItemProp(info));
      triggerSelection(info);
    });
    var onInternalOpenChange = useMemoCallback(function(key, open2) {
      var newOpenKeys = mergedOpenKeys.filter(function(k) {
        return k !== key;
      });
      if (open2) {
        newOpenKeys.push(key);
      } else if (internalMode !== "inline") {
        var subPathKeys = getSubPathKeys(key);
        newOpenKeys = newOpenKeys.filter(function(k) {
          return !subPathKeys.has(k);
        });
      }
      if (!isEqual_default(mergedOpenKeys, newOpenKeys, true)) {
        triggerOpenKeys(newOpenKeys, true);
      }
    });
    var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open2) {
      var nextOpen = open2 !== null && open2 !== void 0 ? open2 : !mergedOpenKeys.includes(key);
      onInternalOpenChange(key, nextOpen);
    };
    var onInternalKeyDown = useAccessibility2(internalMode, mergedActiveKey, isRtl, uuid8, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
    React218.useEffect(function() {
      setMounted(true);
    }, []);
    var privateContext = React218.useMemo(function() {
      return {
        _internalRenderMenuItem,
        _internalRenderSubMenuItem
      };
    }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
    var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
      // Need wrap for overflow dropdown that do not response for open
      childList.map(function(child, index3) {
        return (
          // Always wrap provider to avoid sub node re-mount
          /* @__PURE__ */ React218.createElement(InheritableContextProvider, {
            key: child.key,
            overflowDisabled: index3 > lastVisibleIndex
          }, child)
        );
      })
    );
    var container = /* @__PURE__ */ React218.createElement(es_default7, _extends({
      id,
      ref: containerRef,
      prefixCls: "".concat(prefixCls, "-overflow"),
      component: "ul",
      itemComponent: MenuItem_default,
      className: (0, import_classnames65.default)(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), "".concat(prefixCls, "-rtl"), isRtl), rootClassName),
      dir: direction,
      style: style2,
      role: "menu",
      tabIndex,
      data: wrappedChildList,
      renderRawItem: function renderRawItem(node2) {
        return node2;
      },
      renderRawRest: function renderRawRest(omitItems) {
        var len = omitItems.length;
        var originOmitItems = len ? childList.slice(-len) : null;
        return /* @__PURE__ */ React218.createElement(SubMenu_default, {
          eventKey: OVERFLOW_KEY,
          title: overflowedIndicator,
          disabled: allVisible,
          internalPopupClose: len === 0,
          popupClassName: overflowedIndicatorPopupClassName
        }, originOmitItems);
      },
      maxCount: internalMode !== "horizontal" || disabledOverflow ? es_default7.INVALIDATE : es_default7.RESPONSIVE,
      ssr: "full",
      "data-menu-list": true,
      onVisibleChange: function onVisibleChange(newLastIndex) {
        setLastVisibleIndex(newLastIndex);
      },
      onKeyDown: onInternalKeyDown
    }, restProps));
    return /* @__PURE__ */ React218.createElement(PrivateContext_default.Provider, {
      value: privateContext
    }, /* @__PURE__ */ React218.createElement(IdContext.Provider, {
      value: uuid8
    }, /* @__PURE__ */ React218.createElement(InheritableContextProvider, {
      prefixCls,
      rootClassName,
      mode: internalMode,
      openKeys: mergedOpenKeys,
      rtl: isRtl,
      disabled,
      motion: mounted ? motion2 : null,
      defaultMotions: mounted ? defaultMotions : null,
      activeKey: mergedActiveKey,
      onActive,
      onInactive,
      selectedKeys: mergedSelectKeys,
      inlineIndent,
      subMenuOpenDelay,
      subMenuCloseDelay,
      forceSubMenuRender,
      builtinPlacements,
      triggerSubMenuAction,
      getPopupContainer,
      itemIcon,
      expandIcon,
      onItemClick: onInternalClick,
      onOpenChange: onInternalOpenChange
    }, /* @__PURE__ */ React218.createElement(PathUserContext.Provider, {
      value: pathUserContext
    }, container), /* @__PURE__ */ React218.createElement("div", {
      style: {
        display: "none"
      },
      "aria-hidden": true
    }, /* @__PURE__ */ React218.createElement(PathRegisterContext.Provider, {
      value: registerPathContext
    }, measureChildList)))));
  });
  var Menu_default = Menu;

  // node_modules/rc-menu/es/index.js
  var ExportMenu = Menu_default;
  ExportMenu.Item = MenuItem_default;
  ExportMenu.SubMenu = SubMenu_default;
  ExportMenu.ItemGroup = MenuItemGroup_default;
  ExportMenu.Divider = Divider;
  var es_default13 = ExportMenu;

  // node_modules/antd/es/layout/Sider.js
  var React221 = __toESM(require_react());
  var import_react76 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/BarsOutlined.js
  var React219 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/BarsOutlined.js
  var BarsOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "bars", "theme": "outlined" };
  var BarsOutlined_default = BarsOutlined;

  // node_modules/@ant-design/icons/es/icons/BarsOutlined.js
  var BarsOutlined2 = function BarsOutlined3(props, ref) {
    return /* @__PURE__ */ React219.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: BarsOutlined_default
    }));
  };
  var RefIcon12 = /* @__PURE__ */ React219.forwardRef(BarsOutlined2);
  if (true) {
    RefIcon12.displayName = "BarsOutlined";
  }
  var BarsOutlined_default2 = RefIcon12;

  // node_modules/antd/es/layout/Sider.js
  var import_classnames66 = __toESM(require_classnames());

  // node_modules/antd/es/layout/context.js
  var React220 = __toESM(require_react());
  var LayoutContext = /* @__PURE__ */ React220.createContext({
    siderHook: {
      addSider: () => null,
      removeSider: () => null
    }
  });

  // node_modules/antd/es/layout/style/index.js
  var genLayoutStyle = (token2) => {
    const {
      antCls,
      // .ant
      componentCls,
      // .ant-layout
      colorText,
      footerBg,
      headerHeight,
      headerPadding,
      headerColor,
      footerPadding,
      fontSize,
      bodyBg,
      headerBg
    } = token2;
    return {
      [componentCls]: {
        display: "flex",
        flex: "auto",
        flexDirection: "column",
        /* fix firefox can't set height smaller than content on flex item */
        minHeight: 0,
        background: bodyBg,
        "&, *": {
          boxSizing: "border-box"
        },
        [`&${componentCls}-has-sider`]: {
          flexDirection: "row",
          [`> ${componentCls}, > ${componentCls}-content`]: {
            // https://segmentfault.com/a/1190000019498300
            width: 0
          }
        },
        [`${componentCls}-header, &${componentCls}-footer`]: {
          flex: "0 0 auto"
        },
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      },
      // ==================== Header ====================
      [`${componentCls}-header`]: {
        height: headerHeight,
        padding: headerPadding,
        color: headerColor,
        lineHeight: unit(headerHeight),
        background: headerBg,
        // Other components/menu/style/index.less line:686
        // Integration with header element so menu items have the same height
        [`${antCls}-menu`]: {
          lineHeight: "inherit"
        }
      },
      // ==================== Footer ====================
      [`${componentCls}-footer`]: {
        padding: footerPadding,
        color: colorText,
        fontSize,
        background: footerBg
      },
      // =================== Content ====================
      [`${componentCls}-content`]: {
        flex: "auto",
        color: colorText,
        // fix firefox can't set height smaller than content on flex item
        minHeight: 0
      }
    };
  };
  var prepareComponentToken7 = (token2) => {
    const {
      colorBgLayout,
      controlHeight,
      controlHeightLG,
      colorText,
      controlHeightSM,
      marginXXS,
      colorTextLightSolid,
      colorBgContainer
    } = token2;
    const paddingInline = controlHeightLG * 1.25;
    return {
      // Deprecated
      colorBgHeader: "#001529",
      colorBgBody: colorBgLayout,
      colorBgTrigger: "#002140",
      bodyBg: colorBgLayout,
      headerBg: "#001529",
      headerHeight: controlHeight * 2,
      headerPadding: `0 ${paddingInline}px`,
      headerColor: colorText,
      footerPadding: `${controlHeightSM}px ${paddingInline}px`,
      footerBg: colorBgLayout,
      siderBg: "#001529",
      triggerHeight: controlHeightLG + marginXXS * 2,
      triggerBg: "#002140",
      triggerColor: colorTextLightSolid,
      zeroTriggerWidth: controlHeightLG,
      zeroTriggerHeight: controlHeightLG,
      lightSiderBg: colorBgContainer,
      lightTriggerBg: colorBgContainer,
      lightTriggerColor: colorText
    };
  };
  var DEPRECATED_TOKENS = [["colorBgBody", "bodyBg"], ["colorBgHeader", "headerBg"], ["colorBgTrigger", "triggerBg"]];
  var style_default10 = genStyleHooks("Layout", (token2) => [genLayoutStyle(token2)], prepareComponentToken7, {
    deprecatedTokens: DEPRECATED_TOKENS
  });

  // node_modules/antd/es/layout/style/sider.js
  var genSiderStyle = (token2) => {
    const {
      componentCls,
      siderBg,
      motionDurationMid,
      motionDurationSlow,
      antCls,
      triggerHeight,
      triggerColor,
      triggerBg,
      headerHeight,
      zeroTriggerWidth,
      zeroTriggerHeight,
      borderRadiusLG,
      lightSiderBg,
      lightTriggerColor,
      lightTriggerBg,
      bodyBg
    } = token2;
    return {
      [componentCls]: {
        position: "relative",
        // fix firefox can't set width smaller than content on flex item
        minWidth: 0,
        background: siderBg,
        transition: `all ${motionDurationMid}, background 0s`,
        "&-has-trigger": {
          paddingBottom: triggerHeight
        },
        "&-right": {
          order: 1
        },
        [`${componentCls}-children`]: {
          height: "100%",
          // Hack for fixing margin collapse bug
          // https://github.com/ant-design/ant-design/issues/7967
          // solution from https://stackoverflow.com/a/33132624/3040605
          marginTop: -0.1,
          paddingTop: 0.1,
          [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
            width: "auto"
          }
        },
        [`&-zero-width ${componentCls}-children`]: {
          overflow: "hidden"
        },
        [`${componentCls}-trigger`]: {
          position: "fixed",
          bottom: 0,
          zIndex: 1,
          height: triggerHeight,
          color: triggerColor,
          lineHeight: unit(triggerHeight),
          textAlign: "center",
          background: triggerBg,
          cursor: "pointer",
          transition: `all ${motionDurationMid}`
        },
        [`${componentCls}-zero-width-trigger`]: {
          position: "absolute",
          top: headerHeight,
          insetInlineEnd: token2.calc(zeroTriggerWidth).mul(-1).equal(),
          zIndex: 1,
          width: zeroTriggerWidth,
          height: zeroTriggerHeight,
          color: triggerColor,
          fontSize: token2.fontSizeXL,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          background: siderBg,
          borderRadius: `0 ${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0`,
          cursor: "pointer",
          transition: `background ${motionDurationSlow} ease`,
          "&::after": {
            position: "absolute",
            inset: 0,
            background: "transparent",
            transition: `all ${motionDurationSlow}`,
            content: '""'
          },
          "&:hover::after": {
            background: `rgba(255, 255, 255, 0.2)`
          },
          "&-right": {
            insetInlineStart: token2.calc(zeroTriggerWidth).mul(-1).equal(),
            borderRadius: `${unit(borderRadiusLG)} 0 0 ${unit(borderRadiusLG)}`
          }
        },
        // Light
        "&-light": {
          background: lightSiderBg,
          [`${componentCls}-trigger`]: {
            color: lightTriggerColor,
            background: lightTriggerBg
          },
          [`${componentCls}-zero-width-trigger`]: {
            color: lightTriggerColor,
            background: lightTriggerBg,
            border: `1px solid ${bodyBg}`,
            // Safe to modify to any other color
            borderInlineStart: 0
          }
        }
      }
    };
  };
  var sider_default = genStyleHooks(["Layout", "Sider"], (token2) => [genSiderStyle(token2)], prepareComponentToken7, {
    deprecatedTokens: DEPRECATED_TOKENS
  });

  // node_modules/antd/es/layout/Sider.js
  var __rest15 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var dimensionMaxMap = {
    xs: "479.98px",
    sm: "575.98px",
    md: "767.98px",
    lg: "991.98px",
    xl: "1199.98px",
    xxl: "1599.98px"
  };
  var isNumeric = (value) => !Number.isNaN(Number.parseFloat(value)) && isFinite(value);
  var SiderContext = /* @__PURE__ */ React221.createContext({});
  var generateId = /* @__PURE__ */ (() => {
    let i = 0;
    return (prefix = "") => {
      i += 1;
      return `${prefix}${i}`;
    };
  })();
  var Sider = /* @__PURE__ */ React221.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      trigger,
      children,
      defaultCollapsed = false,
      theme = "dark",
      style: style2 = {},
      collapsible = false,
      reverseArrow = false,
      width = 200,
      collapsedWidth = 80,
      zeroWidthTriggerStyle,
      breakpoint,
      onCollapse,
      onBreakpoint
    } = props, otherProps = __rest15(props, ["prefixCls", "className", "trigger", "children", "defaultCollapsed", "theme", "style", "collapsible", "reverseArrow", "width", "collapsedWidth", "zeroWidthTriggerStyle", "breakpoint", "onCollapse", "onBreakpoint"]);
    const {
      siderHook
    } = (0, import_react76.useContext)(LayoutContext);
    const [collapsed, setCollapsed] = (0, import_react76.useState)("collapsed" in props ? props.collapsed : defaultCollapsed);
    const [below, setBelow] = (0, import_react76.useState)(false);
    (0, import_react76.useEffect)(() => {
      if ("collapsed" in props) {
        setCollapsed(props.collapsed);
      }
    }, [props.collapsed]);
    const handleSetCollapsed = (value, type5) => {
      if (!("collapsed" in props)) {
        setCollapsed(value);
      }
      onCollapse === null || onCollapse === void 0 ? void 0 : onCollapse(value, type5);
    };
    const {
      getPrefixCls,
      direction
    } = (0, import_react76.useContext)(ConfigContext);
    const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = sider_default(prefixCls);
    const responsiveHandlerRef = (0, import_react76.useRef)(null);
    responsiveHandlerRef.current = (mql) => {
      setBelow(mql.matches);
      onBreakpoint === null || onBreakpoint === void 0 ? void 0 : onBreakpoint(mql.matches);
      if (collapsed !== mql.matches) {
        handleSetCollapsed(mql.matches, "responsive");
      }
    };
    (0, import_react76.useEffect)(() => {
      function responsiveHandler(mql2) {
        var _a;
        return (_a = responsiveHandlerRef.current) === null || _a === void 0 ? void 0 : _a.call(responsiveHandlerRef, mql2);
      }
      let mql;
      if (typeof (window === null || window === void 0 ? void 0 : window.matchMedia) !== "undefined" && breakpoint && breakpoint in dimensionMaxMap) {
        mql = window.matchMedia(`screen and (max-width: ${dimensionMaxMap[breakpoint]})`);
        addMediaQueryListener(mql, responsiveHandler);
        responsiveHandler(mql);
      }
      return () => {
        removeMediaQueryListener(mql, responsiveHandler);
      };
    }, [breakpoint]);
    (0, import_react76.useEffect)(() => {
      const uniqueId = generateId("ant-sider-");
      siderHook.addSider(uniqueId);
      return () => siderHook.removeSider(uniqueId);
    }, []);
    const toggle = () => {
      handleSetCollapsed(!collapsed, "clickTrigger");
    };
    const divProps = omit(otherProps, ["collapsed"]);
    const rawWidth = collapsed ? collapsedWidth : width;
    const siderWidth = isNumeric(rawWidth) ? `${rawWidth}px` : String(rawWidth);
    const zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? /* @__PURE__ */ React221.createElement("span", {
      onClick: toggle,
      className: (0, import_classnames66.default)(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
      style: zeroWidthTriggerStyle
    }, trigger || /* @__PURE__ */ React221.createElement(BarsOutlined_default2, null)) : null;
    const reverseIcon = direction === "rtl" === !reverseArrow;
    const iconObj = {
      expanded: reverseIcon ? /* @__PURE__ */ React221.createElement(RightOutlined_default2, null) : /* @__PURE__ */ React221.createElement(LeftOutlined_default2, null),
      collapsed: reverseIcon ? /* @__PURE__ */ React221.createElement(LeftOutlined_default2, null) : /* @__PURE__ */ React221.createElement(RightOutlined_default2, null)
    };
    const status = collapsed ? "collapsed" : "expanded";
    const defaultTrigger = iconObj[status];
    const triggerDom = trigger !== null ? zeroWidthTrigger || /* @__PURE__ */ React221.createElement("div", {
      className: `${prefixCls}-trigger`,
      onClick: toggle,
      style: {
        width: siderWidth
      }
    }, trigger || defaultTrigger) : null;
    const divStyle = Object.assign(Object.assign({}, style2), {
      flex: `0 0 ${siderWidth}`,
      maxWidth: siderWidth,
      minWidth: siderWidth,
      width: siderWidth
    });
    const siderCls = (0, import_classnames66.default)(prefixCls, `${prefixCls}-${theme}`, {
      [`${prefixCls}-collapsed`]: !!collapsed,
      [`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
      [`${prefixCls}-below`]: !!below,
      [`${prefixCls}-zero-width`]: parseFloat(siderWidth) === 0
    }, className, hashId, cssVarCls);
    const contextValue = React221.useMemo(() => ({
      siderCollapsed: collapsed
    }), [collapsed]);
    return wrapCSSVar(/* @__PURE__ */ React221.createElement(SiderContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React221.createElement("aside", Object.assign({
      className: siderCls
    }, divProps, {
      style: divStyle,
      ref
    }), /* @__PURE__ */ React221.createElement("div", {
      className: `${prefixCls}-children`
    }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null)));
  });
  if (true) {
    Sider.displayName = "Sider";
  }
  var Sider_default = Sider;

  // node_modules/antd/es/menu/menu.js
  var React227 = __toESM(require_react());
  var import_react78 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/EllipsisOutlined.js
  var React222 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/EllipsisOutlined.js
  var EllipsisOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
  var EllipsisOutlined_default = EllipsisOutlined;

  // node_modules/@ant-design/icons/es/icons/EllipsisOutlined.js
  var EllipsisOutlined2 = function EllipsisOutlined3(props, ref) {
    return /* @__PURE__ */ React222.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: EllipsisOutlined_default
    }));
  };
  var RefIcon13 = /* @__PURE__ */ React222.forwardRef(EllipsisOutlined2);
  if (true) {
    RefIcon13.displayName = "EllipsisOutlined";
  }
  var EllipsisOutlined_default2 = RefIcon13;

  // node_modules/antd/es/menu/menu.js
  var import_classnames70 = __toESM(require_classnames());

  // node_modules/antd/es/menu/MenuContext.js
  var import_react77 = __toESM(require_react());
  var MenuContext2 = /* @__PURE__ */ (0, import_react77.createContext)({
    prefixCls: "",
    firstLevel: true,
    inlineCollapsed: false
  });
  var MenuContext_default = MenuContext2;

  // node_modules/antd/es/menu/MenuDivider.js
  var React223 = __toESM(require_react());
  var import_classnames67 = __toESM(require_classnames());
  var __rest16 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var MenuDivider = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      dashed
    } = props, restProps = __rest16(props, ["prefixCls", "className", "dashed"]);
    const {
      getPrefixCls
    } = React223.useContext(ConfigContext);
    const prefixCls = getPrefixCls("menu", customizePrefixCls);
    const classString = (0, import_classnames67.default)({
      [`${prefixCls}-item-divider-dashed`]: !!dashed
    }, className);
    return /* @__PURE__ */ React223.createElement(Divider, Object.assign({
      className: classString
    }, restProps));
  };
  var MenuDivider_default = MenuDivider;

  // node_modules/antd/es/menu/MenuItem.js
  var React224 = __toESM(require_react());
  var import_classnames68 = __toESM(require_classnames());
  var MenuItem2 = (props) => {
    var _a;
    const {
      className,
      children,
      icon,
      title,
      danger,
      extra
    } = props;
    const {
      prefixCls,
      firstLevel,
      direction,
      disableMenuItemTitleTooltip,
      inlineCollapsed: isInlineCollapsed
    } = React224.useContext(MenuContext_default);
    const renderItemChildren = (inlineCollapsed) => {
      const label = children === null || children === void 0 ? void 0 : children[0];
      const wrapNode = /* @__PURE__ */ React224.createElement("span", {
        className: (0, import_classnames68.default)(`${prefixCls}-title-content`, {
          [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0
        })
      }, children);
      if (!icon || /* @__PURE__ */ React224.isValidElement(children) && children.type === "span") {
        if (children && inlineCollapsed && firstLevel && typeof label === "string") {
          return /* @__PURE__ */ React224.createElement("div", {
            className: `${prefixCls}-inline-collapsed-noicon`
          }, label.charAt(0));
        }
      }
      return wrapNode;
    };
    const {
      siderCollapsed
    } = React224.useContext(SiderContext);
    let tooltipTitle = title;
    if (typeof title === "undefined") {
      tooltipTitle = firstLevel ? children : "";
    } else if (title === false) {
      tooltipTitle = "";
    }
    const tooltipProps = {
      title: tooltipTitle
    };
    if (!siderCollapsed && !isInlineCollapsed) {
      tooltipProps.title = null;
      tooltipProps.open = false;
    }
    const childrenLength = toArray(children).length;
    let returnNode = /* @__PURE__ */ React224.createElement(MenuItem_default, Object.assign({}, omit(props, ["title", "icon", "danger"]), {
      className: (0, import_classnames68.default)({
        [`${prefixCls}-item-danger`]: danger,
        [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
      }, className),
      title: typeof title === "string" ? title : void 0
    }), cloneElement3(icon, {
      className: (0, import_classnames68.default)(/* @__PURE__ */ React224.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : void 0, `${prefixCls}-item-icon`)
    }), renderItemChildren(isInlineCollapsed));
    if (!disableMenuItemTitleTooltip) {
      returnNode = /* @__PURE__ */ React224.createElement(tooltip_default, Object.assign({}, tooltipProps, {
        placement: direction === "rtl" ? "left" : "right",
        classNames: {
          root: `${prefixCls}-inline-collapsed-tooltip`
        }
      }), returnNode);
    }
    return returnNode;
  };
  var MenuItem_default2 = MenuItem2;

  // node_modules/antd/es/menu/OverrideContext.js
  var React225 = __toESM(require_react());
  var __rest17 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var OverrideContext = /* @__PURE__ */ React225.createContext(null);
  var OverrideProvider = /* @__PURE__ */ React225.forwardRef((props, ref) => {
    const {
      children
    } = props, restProps = __rest17(props, ["children"]);
    const override = React225.useContext(OverrideContext);
    const context = React225.useMemo(() => Object.assign(Object.assign({}, override), restProps), [
      override,
      restProps.prefixCls,
      // restProps.expandIcon, Not mark as deps since this is a ReactNode
      restProps.mode,
      restProps.selectable,
      restProps.rootClassName
      // restProps.validator, Not mark as deps since this is a function
    ]);
    const canRef = supportNodeRef(children);
    const mergedRef = useComposeRef(ref, canRef ? getNodeRef(children) : null);
    return /* @__PURE__ */ React225.createElement(OverrideContext.Provider, {
      value: context
    }, /* @__PURE__ */ React225.createElement(ContextIsolator_default, {
      space: true
    }, canRef ? /* @__PURE__ */ React225.cloneElement(children, {
      ref: mergedRef
    }) : children));
  });
  var OverrideContext_default = OverrideContext;

  // node_modules/antd/es/menu/style/horizontal.js
  var getHorizontalStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      horizontalLineHeight,
      colorSplit,
      lineWidth,
      lineType,
      itemPaddingInline
    } = token2;
    return {
      [`${componentCls}-horizontal`]: {
        lineHeight: horizontalLineHeight,
        border: 0,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        boxShadow: "none",
        "&::after": {
          display: "block",
          clear: "both",
          height: 0,
          content: '"\\20"'
        },
        // ======================= Item =======================
        [`${componentCls}-item, ${componentCls}-submenu`]: {
          position: "relative",
          display: "inline-block",
          verticalAlign: "bottom",
          paddingInline: itemPaddingInline
        },
        [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
          backgroundColor: "transparent"
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
        },
        // ===================== Sub Menu =====================
        [`${componentCls}-submenu-arrow`]: {
          display: "none"
        }
      }
    };
  };
  var horizontal_default = getHorizontalStyle;

  // node_modules/antd/es/menu/style/rtl.js
  var getRTLStyle = ({
    componentCls,
    menuArrowOffset,
    calc
  }) => ({
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    // Vertical Arrow
    [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
      [`${componentCls}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(${unit(calc(menuArrowOffset).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${unit(menuArrowOffset)})`
        }
      }
    }
  });
  var rtl_default = getRTLStyle;

  // node_modules/antd/es/menu/style/theme.js
  var accessibilityFocus = (token2) => Object.assign({}, genFocusOutline(token2));
  var getThemeStyle = (token2, themeSuffix) => {
    const {
      componentCls,
      itemColor,
      itemSelectedColor,
      subMenuItemSelectedColor,
      groupTitleColor,
      itemBg,
      subMenuItemBg,
      itemSelectedBg,
      activeBarHeight,
      activeBarWidth,
      activeBarBorderWidth,
      motionDurationSlow,
      motionEaseInOut,
      motionEaseOut,
      itemPaddingInline,
      motionDurationMid,
      itemHoverColor,
      lineType,
      colorSplit,
      // Disabled
      itemDisabledColor,
      // Danger
      dangerItemColor,
      dangerItemHoverColor,
      dangerItemSelectedColor,
      dangerItemActiveBg,
      dangerItemSelectedBg,
      // Bg
      popupBg,
      itemHoverBg,
      itemActiveBg,
      menuSubMenuBg,
      // Horizontal
      horizontalItemSelectedColor,
      horizontalItemSelectedBg,
      horizontalItemBorderRadius,
      horizontalItemHoverBg
    } = token2;
    return {
      [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
        color: itemColor,
        background: itemBg,
        [`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token2)),
        // ======================== Item ========================
        [`${componentCls}-item`]: {
          "&-group-title, &-extra": {
            color: groupTitleColor
          }
        },
        [`${componentCls}-submenu-selected > ${componentCls}-submenu-title`]: {
          color: subMenuItemSelectedColor
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          color: itemColor,
          [`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token2))
        },
        // Disabled
        [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
          color: `${itemDisabledColor} !important`
        },
        // Hover
        [`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
          [`&:hover, > ${componentCls}-submenu-title:hover`]: {
            color: itemHoverColor
          }
        },
        [`&:not(${componentCls}-horizontal)`]: {
          [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
            "&:hover": {
              backgroundColor: itemHoverBg
            },
            "&:active": {
              backgroundColor: itemActiveBg
            }
          },
          [`${componentCls}-submenu-title`]: {
            "&:hover": {
              backgroundColor: itemHoverBg
            },
            "&:active": {
              backgroundColor: itemActiveBg
            }
          }
        },
        // Danger - only Item has
        [`${componentCls}-item-danger`]: {
          color: dangerItemColor,
          [`&${componentCls}-item:hover`]: {
            [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
              color: dangerItemHoverColor
            }
          },
          [`&${componentCls}-item:active`]: {
            background: dangerItemActiveBg
          }
        },
        [`${componentCls}-item a`]: {
          "&, &:hover": {
            color: "inherit"
          }
        },
        [`${componentCls}-item-selected`]: {
          color: itemSelectedColor,
          // Danger
          [`&${componentCls}-item-danger`]: {
            color: dangerItemSelectedColor
          },
          "a, a:hover": {
            color: "inherit"
          }
        },
        [`& ${componentCls}-item-selected`]: {
          backgroundColor: itemSelectedBg,
          // Danger
          [`&${componentCls}-item-danger`]: {
            backgroundColor: dangerItemSelectedBg
          }
        },
        [`&${componentCls}-submenu > ${componentCls}`]: {
          backgroundColor: menuSubMenuBg
        },
        // ===== 设置浮层的颜色 =======
        // ！dark 模式会被popupBg 会被rest 为 darkPopupBg
        [`&${componentCls}-popup > ${componentCls}`]: {
          backgroundColor: popupBg
        },
        [`&${componentCls}-submenu-popup > ${componentCls}`]: {
          backgroundColor: popupBg
        },
        // ===== 设置浮层的颜色 end =======
        // ====================== Horizontal ======================
        [`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? {
          borderBottom: 0
        } : {}), {
          [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
            top: activeBarBorderWidth,
            marginTop: token2.calc(activeBarBorderWidth).mul(-1).equal(),
            marginBottom: 0,
            borderRadius: horizontalItemBorderRadius,
            "&::after": {
              position: "absolute",
              insetInline: itemPaddingInline,
              bottom: 0,
              borderBottom: `${unit(activeBarHeight)} solid transparent`,
              transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
              content: '""'
            },
            "&:hover, &-active, &-open": {
              background: horizontalItemHoverBg,
              "&::after": {
                borderBottomWidth: activeBarHeight,
                borderBottomColor: horizontalItemSelectedColor
              }
            },
            "&-selected": {
              color: horizontalItemSelectedColor,
              backgroundColor: horizontalItemSelectedBg,
              "&:hover": {
                backgroundColor: horizontalItemSelectedBg
              },
              "&::after": {
                borderBottomWidth: activeBarHeight,
                borderBottomColor: horizontalItemSelectedColor
              }
            }
          }
        }),
        // ================== Inline & Vertical ===================
        //
        [`&${componentCls}-root`]: {
          [`&${componentCls}-inline, &${componentCls}-vertical`]: {
            borderInlineEnd: `${unit(activeBarBorderWidth)} ${lineType} ${colorSplit}`
          }
        },
        // ======================== Inline ========================
        [`&${componentCls}-inline`]: {
          // Sub
          [`${componentCls}-sub${componentCls}-inline`]: {
            background: subMenuItemBg
          },
          [`${componentCls}-item`]: {
            position: "relative",
            "&::after": {
              position: "absolute",
              insetBlock: 0,
              insetInlineEnd: 0,
              borderInlineEnd: `${unit(activeBarWidth)} solid ${itemSelectedColor}`,
              transform: "scaleY(0.0001)",
              opacity: 0,
              transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
              content: '""'
            },
            // Danger
            [`&${componentCls}-item-danger`]: {
              "&::after": {
                borderInlineEndColor: dangerItemSelectedColor
              }
            }
          },
          [`${componentCls}-selected, ${componentCls}-item-selected`]: {
            "&::after": {
              transform: "scaleY(1)",
              opacity: 1,
              transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
            }
          }
        }
      }
    };
  };
  var theme_default2 = getThemeStyle;

  // node_modules/antd/es/menu/style/vertical.js
  var getVerticalInlineStyle = (token2) => {
    const {
      componentCls,
      itemHeight,
      itemMarginInline,
      padding,
      menuArrowSize,
      marginXS,
      itemMarginBlock,
      itemWidth,
      itemPaddingInline
    } = token2;
    const paddingWithArrow = token2.calc(menuArrowSize).add(padding).add(marginXS).equal();
    return {
      [`${componentCls}-item`]: {
        position: "relative",
        overflow: "hidden"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        height: itemHeight,
        lineHeight: unit(itemHeight),
        paddingInline: itemPaddingInline,
        overflow: "hidden",
        textOverflow: "ellipsis",
        marginInline: itemMarginInline,
        marginBlock: itemMarginBlock,
        width: itemWidth
      },
      [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
        height: itemHeight,
        lineHeight: unit(itemHeight)
      },
      [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
        paddingInlineEnd: paddingWithArrow
      }
    };
  };
  var getVerticalStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      itemHeight,
      colorTextLightSolid,
      dropdownWidth,
      controlHeightLG,
      motionEaseOut,
      paddingXL,
      itemMarginInline,
      fontSizeLG,
      motionDurationFast,
      motionDurationSlow,
      paddingXS,
      boxShadowSecondary,
      collapsedWidth,
      collapsedIconSize
    } = token2;
    const inlineItemStyle = {
      height: itemHeight,
      lineHeight: unit(itemHeight),
      listStylePosition: "inside",
      listStyleType: "disc"
    };
    return [
      {
        [componentCls]: {
          "&-inline, &-vertical": Object.assign({
            [`&${componentCls}-root`]: {
              boxShadow: "none"
            }
          }, getVerticalInlineStyle(token2))
        },
        [`${componentCls}-submenu-popup`]: {
          [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token2)), {
            boxShadow: boxShadowSecondary
          })
        }
      },
      // Vertical only
      {
        [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
          minWidth: dropdownWidth,
          maxHeight: `calc(100vh - ${unit(token2.calc(controlHeightLG).mul(2.5).equal())})`,
          padding: "0",
          overflow: "hidden",
          borderInlineEnd: 0,
          // https://github.com/ant-design/ant-design/issues/22244
          // https://github.com/ant-design/ant-design/issues/26812
          "&:not([class*='-active'])": {
            overflowX: "hidden",
            overflowY: "auto"
          }
        }
      },
      // Inline Only
      {
        [`${componentCls}-inline`]: {
          width: "100%",
          // Motion enhance for first level
          [`&${componentCls}-root`]: {
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              display: "flex",
              alignItems: "center",
              transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationFast} ${motionEaseOut}`].join(","),
              [`> ${componentCls}-title-content`]: {
                flex: "auto",
                minWidth: 0,
                overflow: "hidden",
                textOverflow: "ellipsis"
              },
              "> *": {
                flex: "none"
              }
            }
          },
          // >>>>> Sub
          [`${componentCls}-sub${componentCls}-inline`]: {
            padding: 0,
            border: 0,
            borderRadius: 0,
            boxShadow: "none",
            [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
            [`& ${componentCls}-item-group-title`]: {
              paddingInlineStart: paddingXL
            }
          },
          // >>>>> Item
          [`${componentCls}-item`]: inlineItemStyle
        }
      },
      // Inline Collapse Only
      {
        [`${componentCls}-inline-collapsed`]: {
          width: collapsedWidth,
          [`&${componentCls}-root`]: {
            [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
              [`> ${componentCls}-inline-collapsed-noicon`]: {
                fontSize: fontSizeLG,
                textAlign: "center"
              }
            }
          },
          [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
            insetInlineStart: 0,
            paddingInline: `calc(50% - ${unit(token2.calc(collapsedIconSize).div(2).equal())} - ${unit(itemMarginInline)})`,
            textOverflow: "clip",
            [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
              opacity: 0
            },
            [`${componentCls}-item-icon, ${iconCls}`]: {
              margin: 0,
              fontSize: collapsedIconSize,
              lineHeight: unit(itemHeight),
              "+ span": {
                display: "inline-block",
                opacity: 0
              }
            }
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "inline-block"
          },
          "&-tooltip": {
            pointerEvents: "none",
            [`${componentCls}-item-icon, ${iconCls}`]: {
              display: "none"
            },
            "a, a:hover": {
              color: colorTextLightSolid
            }
          },
          [`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), {
            paddingInline: paddingXS
          })
        }
      }
    ];
  };
  var vertical_default = getVerticalStyle;

  // node_modules/antd/es/menu/style/index.js
  var genMenuItemStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOut,
      motionEaseOut,
      iconCls,
      iconSize,
      iconMarginInlineEnd
    } = token2;
    return {
      // >>>>> Item
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        position: "relative",
        display: "block",
        margin: 0,
        whiteSpace: "nowrap",
        cursor: "pointer",
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`].join(","),
        [`${componentCls}-item-icon, ${iconCls}`]: {
          minWidth: iconSize,
          fontSize: iconSize,
          transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
          "+ span": {
            marginInlineStart: iconMarginInlineEnd,
            opacity: 1,
            transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
          }
        },
        [`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
        [`&${componentCls}-item-only-child`]: {
          [`> ${iconCls}, > ${componentCls}-item-icon`]: {
            marginInlineEnd: 0
          }
        }
      },
      // Disabled state sets text to gray and nukes hover/tab effects
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        background: "none !important",
        cursor: "not-allowed",
        "&::after": {
          borderColor: "transparent !important"
        },
        a: {
          color: "inherit !important",
          cursor: "not-allowed",
          pointerEvents: "none"
        },
        [`> ${componentCls}-submenu-title`]: {
          color: "inherit !important",
          cursor: "not-allowed"
        }
      }
    };
  };
  var genSubMenuArrowStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      motionEaseInOut,
      borderRadius,
      menuArrowSize,
      menuArrowOffset
    } = token2;
    return {
      [`${componentCls}-submenu`]: {
        "&-expand-icon, &-arrow": {
          position: "absolute",
          top: "50%",
          insetInlineEnd: token2.margin,
          width: menuArrowSize,
          color: "currentcolor",
          transform: "translateY(-50%)",
          transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
        },
        "&-arrow": {
          // →
          "&::before, &::after": {
            position: "absolute",
            width: token2.calc(menuArrowSize).mul(0.6).equal(),
            height: token2.calc(menuArrowSize).mul(0.15).equal(),
            backgroundColor: "currentcolor",
            borderRadius,
            transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
            content: '""'
          },
          "&::before": {
            transform: `rotate(45deg) translateY(${unit(token2.calc(menuArrowOffset).mul(-1).equal())})`
          },
          "&::after": {
            transform: `rotate(-45deg) translateY(${unit(menuArrowOffset)})`
          }
        }
      }
    };
  };
  var getBaseStyle = (token2) => {
    const {
      antCls,
      componentCls,
      fontSize,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOut,
      paddingXS,
      padding,
      colorSplit,
      lineWidth,
      zIndexPopup,
      borderRadiusLG,
      subMenuItemBorderRadius,
      menuArrowSize,
      menuArrowOffset,
      lineType,
      groupTitleLineHeight,
      groupTitleFontSize
    } = token2;
    return [
      // Misc
      {
        "": {
          [componentCls]: Object.assign(Object.assign({}, clearFix()), {
            // Hidden
            "&-hidden": {
              display: "none"
            }
          })
        },
        [`${componentCls}-submenu-hidden`]: {
          display: "none"
        }
      },
      {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), clearFix()), {
          marginBottom: 0,
          paddingInlineStart: 0,
          // Override default ul/ol
          fontSize,
          lineHeight: 0,
          listStyle: "none",
          outline: "none",
          // Magic cubic here but smooth transition
          transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
          "ul, ol": {
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          // Overflow ellipsis
          "&-overflow": {
            display: "flex",
            [`${componentCls}-item`]: {
              flex: "none"
            }
          },
          [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
            borderRadius: token2.itemBorderRadius
          },
          [`${componentCls}-item-group-title`]: {
            padding: `${unit(paddingXS)} ${unit(padding)}`,
            fontSize: groupTitleFontSize,
            lineHeight: groupTitleLineHeight,
            transition: `all ${motionDurationSlow}`
          },
          [`&-horizontal ${componentCls}-submenu`]: {
            transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
          },
          [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
            transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
          },
          [`${componentCls}-submenu ${componentCls}-sub`]: {
            cursor: "initial",
            transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
          },
          [`${componentCls}-title-content`]: {
            transition: `color ${motionDurationSlow}`,
            "&-with-extra": {
              display: "inline-flex",
              alignItems: "center",
              width: "100%"
            },
            // https://github.com/ant-design/ant-design/issues/41143
            [`> ${antCls}-typography-ellipsis-single-line`]: {
              display: "inline",
              verticalAlign: "unset"
            },
            [`${componentCls}-item-extra`]: {
              marginInlineStart: "auto",
              paddingInlineStart: token2.padding
            }
          },
          [`${componentCls}-item a`]: {
            "&::before": {
              position: "absolute",
              inset: 0,
              backgroundColor: "transparent",
              content: '""'
            }
          },
          // Removed a Badge related style seems it's safe
          // https://github.com/ant-design/ant-design/issues/19809
          // >>>>> Divider
          [`${componentCls}-item-divider`]: {
            overflow: "hidden",
            lineHeight: 0,
            borderColor: colorSplit,
            borderStyle: lineType,
            borderWidth: 0,
            borderTopWidth: lineWidth,
            marginBlock: lineWidth,
            padding: 0,
            "&-dashed": {
              borderStyle: "dashed"
            }
          }
        }), genMenuItemStyle(token2)), {
          [`${componentCls}-item-group`]: {
            [`${componentCls}-item-group-list`]: {
              margin: 0,
              padding: 0,
              [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                paddingInline: `${unit(token2.calc(fontSize).mul(2).equal())} ${unit(padding)}`
              }
            }
          },
          // ======================= Sub Menu =======================
          "&-submenu": {
            "&-popup": {
              position: "absolute",
              zIndex: zIndexPopup,
              borderRadius: borderRadiusLG,
              boxShadow: "none",
              transformOrigin: "0 0",
              [`&${componentCls}-submenu`]: {
                background: "transparent"
              },
              // https://github.com/ant-design/ant-design/issues/13955
              "&::before": {
                position: "absolute",
                inset: 0,
                zIndex: -1,
                width: "100%",
                height: "100%",
                opacity: 0,
                content: '""'
              },
              [`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({
                borderRadius: borderRadiusLG
              }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
                [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                  borderRadius: subMenuItemBorderRadius
                },
                [`${componentCls}-submenu-title::after`]: {
                  transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
                }
              })
            },
            [`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: {
              transformOrigin: "100% 0"
            },
            [`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: {
              transformOrigin: "100% 100%"
            },
            [`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: {
              transformOrigin: "0 100%"
            },
            [`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: {
              transformOrigin: "0 0"
            },
            [`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: {
              paddingInlineEnd: token2.paddingXS
            },
            [`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: {
              paddingInlineStart: token2.paddingXS
            },
            [`
          &-placement-topRight,
          &-placement-topLeft
          `]: {
              paddingBottom: token2.paddingXS
            },
            [`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: {
              paddingTop: token2.paddingXS
            }
          }
        }), genSubMenuArrowStyle(token2)), {
          [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
            // ↓
            "&::before": {
              transform: `rotate(-45deg) translateX(${unit(menuArrowOffset)})`
            },
            "&::after": {
              transform: `rotate(45deg) translateX(${unit(token2.calc(menuArrowOffset).mul(-1).equal())})`
            }
          },
          [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
            // ↑
            transform: `translateY(${unit(token2.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
            "&::after": {
              transform: `rotate(-45deg) translateX(${unit(token2.calc(menuArrowOffset).mul(-1).equal())})`
            },
            "&::before": {
              transform: `rotate(45deg) translateX(${unit(menuArrowOffset)})`
            }
          }
        })
      },
      // Integration with header element so menu items have the same height
      {
        [`${antCls}-layout-header`]: {
          [componentCls]: {
            lineHeight: "inherit"
          }
        }
      }
    ];
  };
  var prepareComponentToken8 = (token2) => {
    var _a, _b, _c;
    const {
      colorPrimary,
      colorError,
      colorTextDisabled,
      colorErrorBg,
      colorText,
      colorTextDescription,
      colorBgContainer,
      colorFillAlter,
      colorFillContent,
      lineWidth,
      lineWidthBold,
      controlItemBgActive,
      colorBgTextHover,
      controlHeightLG,
      lineHeight,
      colorBgElevated,
      marginXXS,
      padding,
      fontSize,
      controlHeightSM,
      fontSizeLG,
      colorTextLightSolid,
      colorErrorHover
    } = token2;
    const activeBarWidth = (_a = token2.activeBarWidth) !== null && _a !== void 0 ? _a : 0;
    const activeBarBorderWidth = (_b = token2.activeBarBorderWidth) !== null && _b !== void 0 ? _b : lineWidth;
    const itemMarginInline = (_c = token2.itemMarginInline) !== null && _c !== void 0 ? _c : token2.marginXXS;
    const colorTextDark = new FastColor(colorTextLightSolid).setA(0.65).toRgbString();
    return {
      dropdownWidth: 160,
      zIndexPopup: token2.zIndexPopupBase + 50,
      radiusItem: token2.borderRadiusLG,
      itemBorderRadius: token2.borderRadiusLG,
      radiusSubMenuItem: token2.borderRadiusSM,
      subMenuItemBorderRadius: token2.borderRadiusSM,
      colorItemText: colorText,
      itemColor: colorText,
      colorItemTextHover: colorText,
      itemHoverColor: colorText,
      colorItemTextHoverHorizontal: colorPrimary,
      horizontalItemHoverColor: colorPrimary,
      colorGroupTitle: colorTextDescription,
      groupTitleColor: colorTextDescription,
      colorItemTextSelected: colorPrimary,
      itemSelectedColor: colorPrimary,
      subMenuItemSelectedColor: colorPrimary,
      colorItemTextSelectedHorizontal: colorPrimary,
      horizontalItemSelectedColor: colorPrimary,
      colorItemBg: colorBgContainer,
      itemBg: colorBgContainer,
      colorItemBgHover: colorBgTextHover,
      itemHoverBg: colorBgTextHover,
      colorItemBgActive: colorFillContent,
      itemActiveBg: controlItemBgActive,
      colorSubItemBg: colorFillAlter,
      subMenuItemBg: colorFillAlter,
      colorItemBgSelected: controlItemBgActive,
      itemSelectedBg: controlItemBgActive,
      colorItemBgSelectedHorizontal: "transparent",
      horizontalItemSelectedBg: "transparent",
      colorActiveBarWidth: 0,
      activeBarWidth,
      colorActiveBarHeight: lineWidthBold,
      activeBarHeight: lineWidthBold,
      colorActiveBarBorderSize: lineWidth,
      activeBarBorderWidth,
      // Disabled
      colorItemTextDisabled: colorTextDisabled,
      itemDisabledColor: colorTextDisabled,
      // Danger
      colorDangerItemText: colorError,
      dangerItemColor: colorError,
      colorDangerItemTextHover: colorError,
      dangerItemHoverColor: colorError,
      colorDangerItemTextSelected: colorError,
      dangerItemSelectedColor: colorError,
      colorDangerItemBgActive: colorErrorBg,
      dangerItemActiveBg: colorErrorBg,
      colorDangerItemBgSelected: colorErrorBg,
      dangerItemSelectedBg: colorErrorBg,
      itemMarginInline,
      horizontalItemBorderRadius: 0,
      horizontalItemHoverBg: "transparent",
      itemHeight: controlHeightLG,
      groupTitleLineHeight: lineHeight,
      collapsedWidth: controlHeightLG * 2,
      popupBg: colorBgElevated,
      itemMarginBlock: marginXXS,
      itemPaddingInline: padding,
      horizontalLineHeight: `${controlHeightLG * 1.15}px`,
      iconSize: fontSize,
      iconMarginInlineEnd: controlHeightSM - fontSize,
      collapsedIconSize: fontSizeLG,
      groupTitleFontSize: fontSize,
      // Disabled
      darkItemDisabledColor: new FastColor(colorTextLightSolid).setA(0.25).toRgbString(),
      // Dark
      darkItemColor: colorTextDark,
      darkDangerItemColor: colorError,
      darkItemBg: "#001529",
      darkPopupBg: "#001529",
      darkSubMenuItemBg: "#000c17",
      darkItemSelectedColor: colorTextLightSolid,
      darkItemSelectedBg: colorPrimary,
      darkDangerItemSelectedBg: colorError,
      darkItemHoverBg: "transparent",
      darkGroupTitleColor: colorTextDark,
      darkItemHoverColor: colorTextLightSolid,
      darkDangerItemHoverColor: colorErrorHover,
      darkDangerItemSelectedColor: colorTextLightSolid,
      darkDangerItemActiveBg: colorError,
      // internal
      itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
    };
  };
  var style_default11 = (prefixCls, rootCls = prefixCls, injectStyle = true) => {
    const useStyle = genStyleHooks("Menu", (token2) => {
      const {
        colorBgElevated,
        controlHeightLG,
        fontSize,
        darkItemColor,
        darkDangerItemColor,
        darkItemBg,
        darkSubMenuItemBg,
        darkItemSelectedColor,
        darkItemSelectedBg,
        darkDangerItemSelectedBg,
        darkItemHoverBg,
        darkGroupTitleColor,
        darkItemHoverColor,
        darkItemDisabledColor,
        darkDangerItemHoverColor,
        darkDangerItemSelectedColor,
        darkDangerItemActiveBg,
        popupBg,
        darkPopupBg
      } = token2;
      const menuArrowSize = token2.calc(fontSize).div(7).mul(5).equal();
      const menuToken = merge2(token2, {
        menuArrowSize,
        menuHorizontalHeight: token2.calc(controlHeightLG).mul(1.15).equal(),
        menuArrowOffset: token2.calc(menuArrowSize).mul(0.25).equal(),
        menuSubMenuBg: colorBgElevated,
        calc: token2.calc,
        popupBg
      });
      const menuDarkToken = merge2(menuToken, {
        itemColor: darkItemColor,
        itemHoverColor: darkItemHoverColor,
        groupTitleColor: darkGroupTitleColor,
        itemSelectedColor: darkItemSelectedColor,
        subMenuItemSelectedColor: darkItemSelectedColor,
        itemBg: darkItemBg,
        popupBg: darkPopupBg,
        subMenuItemBg: darkSubMenuItemBg,
        itemActiveBg: "transparent",
        itemSelectedBg: darkItemSelectedBg,
        activeBarHeight: 0,
        activeBarBorderWidth: 0,
        itemHoverBg: darkItemHoverBg,
        // Disabled
        itemDisabledColor: darkItemDisabledColor,
        // Danger
        dangerItemColor: darkDangerItemColor,
        dangerItemHoverColor: darkDangerItemHoverColor,
        dangerItemSelectedColor: darkDangerItemSelectedColor,
        dangerItemActiveBg: darkDangerItemActiveBg,
        dangerItemSelectedBg: darkDangerItemSelectedBg,
        menuSubMenuBg: darkSubMenuItemBg,
        // Horizontal
        horizontalItemSelectedColor: darkItemSelectedColor,
        horizontalItemSelectedBg: darkItemSelectedBg
      });
      return [
        // Basic
        getBaseStyle(menuToken),
        // Horizontal
        horizontal_default(menuToken),
        // Hard code for some light style
        // Vertical
        vertical_default(menuToken),
        // Hard code for some light style
        // Theme
        theme_default2(menuToken, "light"),
        theme_default2(menuDarkToken, "dark"),
        // RTL
        rtl_default(menuToken),
        // Motion
        collapse_default(menuToken),
        initSlideMotion(menuToken, "slide-up"),
        initSlideMotion(menuToken, "slide-down"),
        initZoomMotion(menuToken, "zoom-big")
      ];
    }, prepareComponentToken8, {
      deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
      // Dropdown will handle menu style self. We do not need to handle this.
      injectStyle,
      unitless: {
        groupTitleLineHeight: true
      }
    });
    return useStyle(prefixCls, rootCls);
  };

  // node_modules/antd/es/menu/SubMenu.js
  var React226 = __toESM(require_react());
  var import_classnames69 = __toESM(require_classnames());
  var SubMenu2 = (props) => {
    var _a;
    const {
      popupClassName,
      icon,
      title,
      theme: customTheme
    } = props;
    const context = React226.useContext(MenuContext_default);
    const {
      prefixCls,
      inlineCollapsed,
      theme: contextTheme
    } = context;
    const parentPath = useFullPath();
    let titleNode;
    if (!icon) {
      titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ React226.createElement("div", {
        className: `${prefixCls}-inline-collapsed-noicon`
      }, title.charAt(0)) : /* @__PURE__ */ React226.createElement("span", {
        className: `${prefixCls}-title-content`
      }, title);
    } else {
      const titleIsSpan = /* @__PURE__ */ React226.isValidElement(title) && title.type === "span";
      titleNode = /* @__PURE__ */ React226.createElement(React226.Fragment, null, cloneElement3(icon, {
        className: (0, import_classnames69.default)(/* @__PURE__ */ React226.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : void 0, `${prefixCls}-item-icon`)
      }), titleIsSpan ? title : /* @__PURE__ */ React226.createElement("span", {
        className: `${prefixCls}-title-content`
      }, title));
    }
    const contextValue = React226.useMemo(() => Object.assign(Object.assign({}, context), {
      firstLevel: false
    }), [context]);
    const [zIndex] = useZIndex("Menu");
    return /* @__PURE__ */ React226.createElement(MenuContext_default.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React226.createElement(SubMenu_default, Object.assign({}, omit(props, ["icon"]), {
      title: titleNode,
      popupClassName: (0, import_classnames69.default)(prefixCls, popupClassName, `${prefixCls}-${customTheme || contextTheme}`),
      popupStyle: Object.assign({
        zIndex
      }, props.popupStyle)
    })));
  };
  var SubMenu_default2 = SubMenu2;

  // node_modules/antd/es/menu/menu.js
  var __rest18 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function isEmptyIcon(icon) {
    return icon === null || icon === false;
  }
  var MENU_COMPONENTS = {
    item: MenuItem_default2,
    submenu: SubMenu_default2,
    divider: MenuDivider_default
  };
  var InternalMenu = /* @__PURE__ */ (0, import_react78.forwardRef)((props, ref) => {
    var _a;
    const override = React227.useContext(OverrideContext_default);
    const overrideObj = override || {};
    const {
      getPrefixCls,
      getPopupContainer,
      direction,
      menu
    } = React227.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const {
      prefixCls: customizePrefixCls,
      className,
      style: style2,
      theme = "light",
      expandIcon,
      _internalDisableMenuItemTitleTooltip,
      inlineCollapsed,
      siderCollapsed,
      rootClassName,
      mode,
      selectable,
      onClick,
      overflowedIndicatorPopupClassName
    } = props, restProps = __rest18(props, ["prefixCls", "className", "style", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "rootClassName", "mode", "selectable", "onClick", "overflowedIndicatorPopupClassName"]);
    const passedProps = omit(restProps, ["collapsedWidth"]);
    if (true) {
      const warning6 = devUseWarning("Menu");
      true ? warning6(!("inlineCollapsed" in props && mode !== "inline"), "usage", "`inlineCollapsed` should only be used when `mode` is inline.") : void 0;
      warning6.deprecated("items" in props && !props.children, "children", "items");
    }
    (_a = overrideObj.validator) === null || _a === void 0 ? void 0 : _a.call(overrideObj, {
      mode
    });
    const onItemClick = useEvent((...args) => {
      var _a2;
      onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, args);
      (_a2 = overrideObj.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(overrideObj);
    });
    const mergedMode = overrideObj.mode || mode;
    const mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
    const mergedInlineCollapsed = inlineCollapsed !== null && inlineCollapsed !== void 0 ? inlineCollapsed : siderCollapsed;
    const defaultMotions = {
      horizontal: {
        motionName: `${rootPrefixCls}-slide-up`
      },
      inline: motion_default(rootPrefixCls),
      other: {
        motionName: `${rootPrefixCls}-zoom-big`
      }
    };
    const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default11(prefixCls, rootCls, !override);
    const menuClassName = (0, import_classnames70.default)(`${prefixCls}-${theme}`, menu === null || menu === void 0 ? void 0 : menu.className, className);
    const mergedExpandIcon = React227.useMemo(() => {
      var _a2, _b;
      if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) {
        return expandIcon || null;
      }
      if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) {
        return overrideObj.expandIcon || null;
      }
      if (typeof (menu === null || menu === void 0 ? void 0 : menu.expandIcon) === "function" || isEmptyIcon(menu === null || menu === void 0 ? void 0 : menu.expandIcon)) {
        return (menu === null || menu === void 0 ? void 0 : menu.expandIcon) || null;
      }
      const mergedIcon = (_a2 = expandIcon !== null && expandIcon !== void 0 ? expandIcon : overrideObj === null || overrideObj === void 0 ? void 0 : overrideObj.expandIcon) !== null && _a2 !== void 0 ? _a2 : menu === null || menu === void 0 ? void 0 : menu.expandIcon;
      return cloneElement3(mergedIcon, {
        className: (0, import_classnames70.default)(`${prefixCls}-submenu-expand-icon`, /* @__PURE__ */ React227.isValidElement(mergedIcon) ? (_b = mergedIcon.props) === null || _b === void 0 ? void 0 : _b.className : void 0)
      });
    }, [expandIcon, overrideObj === null || overrideObj === void 0 ? void 0 : overrideObj.expandIcon, menu === null || menu === void 0 ? void 0 : menu.expandIcon, prefixCls]);
    const contextValue = React227.useMemo(() => ({
      prefixCls,
      inlineCollapsed: mergedInlineCollapsed || false,
      direction,
      firstLevel: true,
      theme,
      mode: mergedMode,
      disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
    }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme]);
    return wrapCSSVar(/* @__PURE__ */ React227.createElement(OverrideContext_default.Provider, {
      value: null
    }, /* @__PURE__ */ React227.createElement(MenuContext_default.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React227.createElement(es_default13, Object.assign({
      getPopupContainer,
      overflowedIndicator: /* @__PURE__ */ React227.createElement(EllipsisOutlined_default2, null),
      overflowedIndicatorPopupClassName: (0, import_classnames70.default)(prefixCls, `${prefixCls}-${theme}`, overflowedIndicatorPopupClassName),
      mode: mergedMode,
      selectable: mergedSelectable,
      onClick: onItemClick
    }, passedProps, {
      inlineCollapsed: mergedInlineCollapsed,
      style: Object.assign(Object.assign({}, menu === null || menu === void 0 ? void 0 : menu.style), style2),
      className: menuClassName,
      prefixCls,
      direction,
      defaultMotions,
      expandIcon: mergedExpandIcon,
      ref,
      rootClassName: (0, import_classnames70.default)(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls),
      _internalComponents: MENU_COMPONENTS
    })))));
  });
  var menu_default = InternalMenu;

  // node_modules/antd/es/menu/index.js
  var Menu2 = /* @__PURE__ */ (0, import_react79.forwardRef)((props, ref) => {
    const menuRef = (0, import_react79.useRef)(null);
    const context = React228.useContext(SiderContext);
    (0, import_react79.useImperativeHandle)(ref, () => ({
      menu: menuRef.current,
      focus: (options) => {
        var _a;
        (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.focus(options);
      }
    }));
    return /* @__PURE__ */ React228.createElement(menu_default, Object.assign({
      ref: menuRef
    }, props, context));
  });
  Menu2.Item = MenuItem_default2;
  Menu2.SubMenu = SubMenu_default2;
  Menu2.Divider = MenuDivider_default;
  Menu2.ItemGroup = MenuItemGroup_default;
  if (true) {
    Menu2.displayName = "Menu";
  }
  var menu_default2 = Menu2;

  // node_modules/antd/es/dropdown/style/status.js
  var genStatusStyle = (token2) => {
    const {
      componentCls,
      menuCls,
      colorError,
      colorTextLightSolid
    } = token2;
    const itemCls = `${menuCls}-item`;
    return {
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        [`${menuCls} ${itemCls}`]: {
          [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
            color: colorError,
            "&:hover": {
              color: colorTextLightSolid,
              backgroundColor: colorError
            }
          }
        }
      }
    };
  };
  var status_default = genStatusStyle;

  // node_modules/antd/es/dropdown/style/index.js
  var genBaseStyle3 = (token2) => {
    const {
      componentCls,
      menuCls,
      zIndexPopup,
      dropdownArrowDistance,
      sizePopupArrow,
      antCls,
      iconCls,
      motionDurationMid,
      paddingBlock,
      fontSize,
      dropdownEdgeChildPadding,
      colorTextDisabled,
      fontSizeIcon,
      controlPaddingHorizontal,
      colorBgElevated
    } = token2;
    return [
      {
        [componentCls]: {
          position: "absolute",
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          display: "block",
          // A placeholder out of dropdown visible range to avoid close when user moving
          "&::before": {
            position: "absolute",
            insetBlock: token2.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
            // insetInlineStart: -7, // FIXME: Seems not work for hidden element
            zIndex: -9999,
            opacity: 1e-4,
            content: '""'
          },
          // Makes vertical dropdowns have a scrollbar once they become taller than the viewport.
          "&-menu-vertical": {
            maxHeight: "100vh",
            overflowY: "auto"
          },
          [`&-trigger${antCls}-btn`]: {
            [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: {
              fontSize: fontSizeIcon
            }
          },
          [`${componentCls}-wrap`]: {
            position: "relative",
            [`${antCls}-btn > ${iconCls}-down`]: {
              fontSize: fontSizeIcon
            },
            [`${iconCls}-down::before`]: {
              transition: `transform ${motionDurationMid}`
            }
          },
          [`${componentCls}-wrap-open`]: {
            [`${iconCls}-down::before`]: {
              transform: `rotate(180deg)`
            }
          },
          [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
            display: "none"
          },
          // =============================================================
          // ==                         Motion                          ==
          // =============================================================
          // When position is not enough for dropdown, the placement will revert.
          // We will handle this with revert motion name.
          [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
            animationName: slideDownOut
          }
        }
      },
      // =============================================================
      // ==                        Arrow style                      ==
      // =============================================================
      getArrowStyle(token2, colorBgElevated, {
        arrowPlacement: {
          top: true,
          bottom: true
        }
      }),
      {
        // =============================================================
        // ==                          Menu                           ==
        // =============================================================
        [`${componentCls} ${menuCls}`]: {
          position: "relative",
          margin: 0
        },
        [`${menuCls}-submenu-popup`]: {
          position: "absolute",
          zIndex: zIndexPopup,
          background: "transparent",
          boxShadow: "none",
          transformOrigin: "0 0",
          "ul, li": {
            listStyle: "none",
            margin: 0
          }
        },
        [`${componentCls}, ${componentCls}-menu-submenu`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          [menuCls]: Object.assign(Object.assign({
            padding: dropdownEdgeChildPadding,
            listStyleType: "none",
            backgroundColor: colorBgElevated,
            backgroundClip: "padding-box",
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary
          }, genFocusStyle(token2)), {
            "&:empty": {
              padding: 0,
              boxShadow: "none"
            },
            [`${menuCls}-item-group-title`]: {
              padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
              color: token2.colorTextDescription,
              transition: `all ${motionDurationMid}`
            },
            // ======================= Item Content =======================
            [`${menuCls}-item`]: {
              position: "relative",
              display: "flex",
              alignItems: "center"
            },
            [`${menuCls}-item-icon`]: {
              minWidth: fontSize,
              marginInlineEnd: token2.marginXS,
              fontSize: token2.fontSizeSM
            },
            [`${menuCls}-title-content`]: {
              flex: "auto",
              "&-with-extra": {
                display: "inline-flex",
                alignItems: "center",
                width: "100%"
              },
              "> a": {
                color: "inherit",
                transition: `all ${motionDurationMid}`,
                "&:hover": {
                  color: "inherit"
                },
                "&::after": {
                  position: "absolute",
                  inset: 0,
                  content: '""'
                }
              },
              [`${menuCls}-item-extra`]: {
                paddingInlineStart: token2.padding,
                marginInlineStart: "auto",
                fontSize: token2.fontSizeSM,
                color: token2.colorTextDescription
              }
            },
            // =========================== Item ===========================
            [`${menuCls}-item, ${menuCls}-submenu-title`]: Object.assign(Object.assign({
              display: "flex",
              margin: 0,
              padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
              color: token2.colorText,
              fontWeight: "normal",
              fontSize,
              lineHeight: token2.lineHeight,
              cursor: "pointer",
              transition: `all ${motionDurationMid}`,
              borderRadius: token2.borderRadiusSM,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgHover
              }
            }, genFocusStyle(token2)), {
              "&-selected": {
                color: token2.colorPrimary,
                backgroundColor: token2.controlItemBgActive,
                "&:hover, &-active": {
                  backgroundColor: token2.controlItemBgActiveHover
                }
              },
              "&-disabled": {
                color: colorTextDisabled,
                cursor: "not-allowed",
                "&:hover": {
                  color: colorTextDisabled,
                  backgroundColor: colorBgElevated,
                  cursor: "not-allowed"
                },
                a: {
                  pointerEvents: "none"
                }
              },
              "&-divider": {
                height: 1,
                // By design
                margin: `${unit(token2.marginXXS)} 0`,
                overflow: "hidden",
                lineHeight: 0,
                backgroundColor: token2.colorSplit
              },
              [`${componentCls}-menu-submenu-expand-icon`]: {
                position: "absolute",
                insetInlineEnd: token2.paddingXS,
                [`${componentCls}-menu-submenu-arrow-icon`]: {
                  marginInlineEnd: "0 !important",
                  color: token2.colorIcon,
                  fontSize: fontSizeIcon,
                  fontStyle: "normal"
                }
              }
            }),
            [`${menuCls}-item-group-list`]: {
              margin: `0 ${unit(token2.marginXS)}`,
              padding: 0,
              listStyle: "none"
            },
            [`${menuCls}-submenu-title`]: {
              paddingInlineEnd: token2.calc(controlPaddingHorizontal).add(token2.fontSizeSM).equal()
            },
            [`${menuCls}-submenu-vertical`]: {
              position: "relative"
            },
            [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
              [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              }
            },
            // https://github.com/ant-design/ant-design/issues/19264
            [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
              color: token2.colorPrimary
            }
          })
        })
      },
      // Follow code may reuse in other components
      [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
    ];
  };
  var prepareComponentToken9 = (token2) => Object.assign(Object.assign({
    zIndexPopup: token2.zIndexPopupBase + 50,
    paddingBlock: (token2.controlHeight - token2.fontSize * token2.lineHeight) / 2
  }, getArrowOffsetToken({
    contentRadius: token2.borderRadiusLG,
    limitVerticalRadius: true
  })), getArrowToken(token2));
  var style_default12 = genStyleHooks("Dropdown", (token2) => {
    const {
      marginXXS,
      sizePopupArrow,
      paddingXXS,
      componentCls
    } = token2;
    const dropdownToken = merge2(token2, {
      menuCls: `${componentCls}-menu`,
      dropdownArrowDistance: token2.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
      dropdownEdgeChildPadding: paddingXXS
    });
    return [genBaseStyle3(dropdownToken), status_default(dropdownToken)];
  }, prepareComponentToken9, {
    resetStyle: false
  });

  // node_modules/antd/es/dropdown/dropdown.js
  var Dropdown2 = (props) => {
    var _a;
    const {
      menu,
      arrow,
      prefixCls: customizePrefixCls,
      children,
      trigger,
      disabled,
      dropdownRender,
      popupRender,
      getPopupContainer,
      overlayClassName,
      rootClassName,
      overlayStyle,
      open: open2,
      onOpenChange,
      // Deprecated
      visible,
      onVisibleChange,
      mouseEnterDelay = 0.15,
      mouseLeaveDelay = 0.1,
      autoAdjustOverflow: autoAdjustOverflow3 = true,
      placement = "",
      overlay,
      transitionName,
      destroyOnHidden,
      destroyPopupOnHide
    } = props;
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction,
      dropdown
    } = React229.useContext(ConfigContext);
    const mergedPopupRender = popupRender || dropdownRender;
    const warning6 = devUseWarning("Dropdown");
    if (true) {
      const deprecatedProps = {
        visible: "open",
        onVisibleChange: "onOpenChange",
        overlay: "menu",
        dropdownRender: "popupRender",
        destroyPopupOnHide: "destroyOnHidden"
      };
      Object.entries(deprecatedProps).forEach(([deprecatedName, newName]) => {
        warning6.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
      if (placement.includes("Center")) {
        warning6.deprecated(!placement.includes("Center"), `placement: ${placement}`, `placement: ${placement.slice(0, placement.indexOf("Center"))}`);
      }
    }
    const memoTransitionName = React229.useMemo(() => {
      const rootPrefixCls = getPrefixCls();
      if (transitionName !== void 0) {
        return transitionName;
      }
      if (placement.includes("top")) {
        return `${rootPrefixCls}-slide-down`;
      }
      return `${rootPrefixCls}-slide-up`;
    }, [getPrefixCls, placement, transitionName]);
    const memoPlacement = React229.useMemo(() => {
      if (!placement) {
        return direction === "rtl" ? "bottomRight" : "bottomLeft";
      }
      if (placement.includes("Center")) {
        return placement.slice(0, placement.indexOf("Center"));
      }
      return placement;
    }, [placement, direction]);
    const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default12(prefixCls, rootCls);
    const [, token2] = useToken();
    const child = React229.Children.only(isPrimitive_default(children) ? /* @__PURE__ */ React229.createElement("span", null, children) : children);
    const popupTrigger = cloneElement3(child, {
      className: (0, import_classnames71.default)(`${prefixCls}-trigger`, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, child.props.className),
      disabled: (_a = child.props.disabled) !== null && _a !== void 0 ? _a : disabled
    });
    const triggerActions = disabled ? [] : trigger;
    const alignPoint = !!(triggerActions === null || triggerActions === void 0 ? void 0 : triggerActions.includes("contextMenu"));
    const [mergedOpen, setOpen] = useMergedState(false, {
      value: open2 !== null && open2 !== void 0 ? open2 : visible
    });
    const onInnerOpenChange = useEvent((nextOpen) => {
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen, {
        source: "trigger"
      });
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextOpen);
      setOpen(nextOpen);
    });
    const overlayClassNameCustomized = (0, import_classnames71.default)(overlayClassName, rootClassName, hashId, cssVarCls, rootCls, dropdown === null || dropdown === void 0 ? void 0 : dropdown.className, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    const builtinPlacements = getPlacements({
      arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow3,
      offset: token2.marginXXS,
      arrowWidth: arrow ? token2.sizePopupArrow : 0,
      borderRadius: token2.borderRadius
    });
    const onMenuClick = React229.useCallback(() => {
      if ((menu === null || menu === void 0 ? void 0 : menu.selectable) && (menu === null || menu === void 0 ? void 0 : menu.multiple)) {
        return;
      }
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false, {
        source: "menu"
      });
      setOpen(false);
    }, [menu === null || menu === void 0 ? void 0 : menu.selectable, menu === null || menu === void 0 ? void 0 : menu.multiple]);
    const renderOverlay = () => {
      let overlayNode;
      if (menu === null || menu === void 0 ? void 0 : menu.items) {
        overlayNode = /* @__PURE__ */ React229.createElement(menu_default2, Object.assign({}, menu));
      } else if (typeof overlay === "function") {
        overlayNode = overlay();
      } else {
        overlayNode = overlay;
      }
      if (mergedPopupRender) {
        overlayNode = mergedPopupRender(overlayNode);
      }
      overlayNode = React229.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ React229.createElement("span", null, overlayNode) : overlayNode);
      return /* @__PURE__ */ React229.createElement(OverrideProvider, {
        prefixCls: `${prefixCls}-menu`,
        rootClassName: (0, import_classnames71.default)(cssVarCls, rootCls),
        expandIcon: /* @__PURE__ */ React229.createElement("span", {
          className: `${prefixCls}-menu-submenu-arrow`
        }, direction === "rtl" ? /* @__PURE__ */ React229.createElement(LeftOutlined_default2, {
          className: `${prefixCls}-menu-submenu-arrow-icon`
        }) : /* @__PURE__ */ React229.createElement(RightOutlined_default2, {
          className: `${prefixCls}-menu-submenu-arrow-icon`
        })),
        mode: "vertical",
        selectable: false,
        onClick: onMenuClick,
        validator: ({
          mode
        }) => {
          true ? warning6(!mode || mode === "vertical", "usage", `mode="${mode}" is not supported for Dropdown's Menu.`) : void 0;
        }
      }, overlayNode);
    };
    const [zIndex, contextZIndex] = useZIndex("Dropdown", overlayStyle === null || overlayStyle === void 0 ? void 0 : overlayStyle.zIndex);
    let renderNode = /* @__PURE__ */ React229.createElement(es_default12, Object.assign({
      alignPoint
    }, omit(props, ["rootClassName"]), {
      mouseEnterDelay,
      mouseLeaveDelay,
      visible: mergedOpen,
      builtinPlacements,
      arrow: !!arrow,
      overlayClassName: overlayClassNameCustomized,
      prefixCls,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      transitionName: memoTransitionName,
      trigger: triggerActions,
      overlay: renderOverlay,
      placement: memoPlacement,
      onVisibleChange: onInnerOpenChange,
      overlayStyle: Object.assign(Object.assign(Object.assign({}, dropdown === null || dropdown === void 0 ? void 0 : dropdown.style), overlayStyle), {
        zIndex
      }),
      autoDestroy: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyPopupOnHide
    }), popupTrigger);
    if (zIndex) {
      renderNode = /* @__PURE__ */ React229.createElement(zindexContext_default.Provider, {
        value: contextZIndex
      }, renderNode);
    }
    return wrapCSSVar(renderNode);
  };
  var PurePanel4 = PurePanel_default2(Dropdown2, "align", void 0, "dropdown", (prefixCls) => prefixCls);
  var WrapPurePanel = (props) => /* @__PURE__ */ React229.createElement(PurePanel4, Object.assign({}, props), /* @__PURE__ */ React229.createElement("span", null));
  Dropdown2._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
  if (true) {
    Dropdown2.displayName = "Dropdown";
  }
  var dropdown_default2 = Dropdown2;

  // node_modules/antd/es/radio/group.js
  var React235 = __toESM(require_react());
  var import_classnames74 = __toESM(require_classnames());

  // node_modules/antd/es/radio/context.js
  var React230 = __toESM(require_react());
  var RadioGroupContext = /* @__PURE__ */ React230.createContext(null);
  var RadioGroupContextProvider = RadioGroupContext.Provider;
  var context_default3 = RadioGroupContext;
  var RadioOptionTypeContext = /* @__PURE__ */ React230.createContext(null);
  var RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;

  // node_modules/antd/es/radio/radio.js
  var React233 = __toESM(require_react());
  var import_classnames73 = __toESM(require_classnames());

  // node_modules/rc-checkbox/es/index.js
  var import_classnames72 = __toESM(require_classnames());
  var React231 = __toESM(require_react());
  var import_react80 = __toESM(require_react());
  var _excluded38 = ["prefixCls", "className", "style", "checked", "disabled", "defaultChecked", "type", "title", "onChange"];
  var Checkbox = /* @__PURE__ */ (0, import_react80.forwardRef)(function(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-checkbox" : _props$prefixCls, className = props.className, style2 = props.style, checked = props.checked, disabled = props.disabled, _props$defaultChecked = props.defaultChecked, defaultChecked = _props$defaultChecked === void 0 ? false : _props$defaultChecked, _props$type = props.type, type5 = _props$type === void 0 ? "checkbox" : _props$type, title = props.title, onChange = props.onChange, inputProps = _objectWithoutProperties(props, _excluded38);
    var inputRef = (0, import_react80.useRef)(null);
    var holderRef = (0, import_react80.useRef)(null);
    var _useMergedState = useMergedState(defaultChecked, {
      value: checked
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1];
    (0, import_react80.useImperativeHandle)(ref, function() {
      return {
        focus: function focus(options) {
          var _inputRef$current;
          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
        },
        blur: function blur() {
          var _inputRef$current2;
          (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
        },
        input: inputRef.current,
        nativeElement: holderRef.current
      };
    });
    var classString = (0, import_classnames72.default)(prefixCls, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-checked"), rawValue), "".concat(prefixCls, "-disabled"), disabled));
    var handleChange = function handleChange2(e3) {
      if (disabled) {
        return;
      }
      if (!("checked" in props)) {
        setRawValue(e3.target.checked);
      }
      onChange === null || onChange === void 0 || onChange({
        target: _objectSpread2(_objectSpread2({}, props), {}, {
          type: type5,
          checked: e3.target.checked
        }),
        stopPropagation: function stopPropagation() {
          e3.stopPropagation();
        },
        preventDefault: function preventDefault() {
          e3.preventDefault();
        },
        nativeEvent: e3.nativeEvent
      });
    };
    return /* @__PURE__ */ React231.createElement("span", {
      className: classString,
      title,
      style: style2,
      ref: holderRef
    }, /* @__PURE__ */ React231.createElement("input", _extends({}, inputProps, {
      className: "".concat(prefixCls, "-input"),
      ref: inputRef,
      onChange: handleChange,
      disabled,
      checked: !!rawValue,
      type: type5
    })), /* @__PURE__ */ React231.createElement("span", {
      className: "".concat(prefixCls, "-inner")
    }));
  });
  var es_default14 = Checkbox;

  // node_modules/antd/es/checkbox/useBubbleLock.js
  var import_react81 = __toESM(require_react());
  function useBubbleLock(onOriginInputClick) {
    const labelClickLockRef = import_react81.default.useRef(null);
    const clearLock = () => {
      raf_default.cancel(labelClickLockRef.current);
      labelClickLockRef.current = null;
    };
    const onLabelClick = () => {
      clearLock();
      labelClickLockRef.current = raf_default(() => {
        labelClickLockRef.current = null;
      });
    };
    const onInputClick = (e3) => {
      if (labelClickLockRef.current) {
        e3.stopPropagation();
        clearLock();
      }
      onOriginInputClick === null || onOriginInputClick === void 0 ? void 0 : onOriginInputClick(e3);
    };
    return [onLabelClick, onInputClick];
  }

  // node_modules/antd/es/radio/style/index.js
  var getGroupRadioStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const groupPrefixCls = `${componentCls}-group`;
    return {
      [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-block",
        fontSize: 0,
        // RTL
        [`&${groupPrefixCls}-rtl`]: {
          direction: "rtl"
        },
        [`&${groupPrefixCls}-block`]: {
          display: "flex"
        },
        [`${antCls}-badge ${antCls}-badge-count`]: {
          zIndex: 1
        },
        [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
          borderInlineStart: "none"
        }
      })
    };
  };
  var getRadioBasicStyle = (token2) => {
    const {
      componentCls,
      wrapperMarginInlineEnd,
      colorPrimary,
      radioSize,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOutCirc,
      colorBgContainer,
      colorBorder,
      lineWidth,
      colorBgContainerDisabled,
      colorTextDisabled,
      paddingXS,
      dotColorDisabled,
      lineType,
      radioColor,
      radioBgColor,
      calc
    } = token2;
    const radioInnerPrefixCls = `${componentCls}-inner`;
    const dotPadding = 4;
    const radioDotDisabledSize = calc(radioSize).sub(calc(dotPadding).mul(2));
    const radioSizeCalc = calc(1).mul(radioSize).equal({
      unit: true
    });
    return {
      [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-flex",
        alignItems: "baseline",
        marginInlineStart: 0,
        marginInlineEnd: wrapperMarginInlineEnd,
        cursor: "pointer",
        "&:last-child": {
          marginInlineEnd: 0
        },
        // RTL
        [`&${componentCls}-wrapper-rtl`]: {
          direction: "rtl"
        },
        "&-disabled": {
          cursor: "not-allowed",
          color: token2.colorTextDisabled
        },
        "&::after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: '"\\a0"'
        },
        "&-block": {
          flex: 1,
          justifyContent: "center"
        },
        // hashId 在 wrapper 上，只能铺平
        [`${componentCls}-checked::after`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
          borderRadius: "50%",
          visibility: "hidden",
          opacity: 0,
          content: '""'
        },
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "relative",
          display: "inline-block",
          outline: "none",
          cursor: "pointer",
          alignSelf: "center",
          borderRadius: "50%"
        }),
        [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
          borderColor: colorPrimary
        },
        [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: Object.assign({}, genFocusOutline(token2)),
        [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
          visibility: "visible"
        },
        [`${componentCls}-inner`]: {
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineStart: "50%",
            display: "block",
            width: radioSizeCalc,
            height: radioSizeCalc,
            marginBlockStart: calc(1).mul(radioSize).div(-2).equal({
              unit: true
            }),
            marginInlineStart: calc(1).mul(radioSize).div(-2).equal({
              unit: true
            }),
            backgroundColor: radioColor,
            borderBlockStart: 0,
            borderInlineStart: 0,
            borderRadius: radioSizeCalc,
            transform: "scale(0)",
            opacity: 0,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
            content: '""'
          },
          boxSizing: "border-box",
          position: "relative",
          insetBlockStart: 0,
          insetInlineStart: 0,
          display: "block",
          width: radioSizeCalc,
          height: radioSizeCalc,
          backgroundColor: colorBgContainer,
          borderColor: colorBorder,
          borderStyle: "solid",
          borderWidth: lineWidth,
          borderRadius: "50%",
          transition: `all ${motionDurationMid}`
        },
        [`${componentCls}-input`]: {
          position: "absolute",
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0
        },
        // 选中状态
        [`${componentCls}-checked`]: {
          [radioInnerPrefixCls]: {
            borderColor: colorPrimary,
            backgroundColor: radioBgColor,
            "&::after": {
              transform: `scale(${token2.calc(token2.dotSize).div(radioSize).equal()})`,
              opacity: 1,
              transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
            }
          }
        },
        [`${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [radioInnerPrefixCls]: {
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder,
            cursor: "not-allowed",
            "&::after": {
              backgroundColor: dotColorDisabled
            }
          },
          [`${componentCls}-input`]: {
            cursor: "not-allowed"
          },
          [`${componentCls}-disabled + span`]: {
            color: colorTextDisabled,
            cursor: "not-allowed"
          },
          [`&${componentCls}-checked`]: {
            [radioInnerPrefixCls]: {
              "&::after": {
                transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal()})`
              }
            }
          }
        },
        [`span${componentCls} + *`]: {
          paddingInlineStart: paddingXS,
          paddingInlineEnd: paddingXS
        }
      })
    };
  };
  var getRadioButtonStyle = (token2) => {
    const {
      buttonColor,
      controlHeight,
      componentCls,
      lineWidth,
      lineType,
      colorBorder,
      motionDurationSlow,
      motionDurationMid,
      buttonPaddingInline,
      fontSize,
      buttonBg,
      fontSizeLG,
      controlHeightLG,
      controlHeightSM,
      paddingXS,
      borderRadius,
      borderRadiusSM,
      borderRadiusLG,
      buttonCheckedBg,
      buttonSolidCheckedColor,
      colorTextDisabled,
      colorBgContainerDisabled,
      buttonCheckedBgDisabled,
      buttonCheckedColorDisabled,
      colorPrimary,
      colorPrimaryHover,
      colorPrimaryActive,
      buttonSolidCheckedBg,
      buttonSolidCheckedHoverBg,
      buttonSolidCheckedActiveBg,
      calc
    } = token2;
    return {
      [`${componentCls}-button-wrapper`]: {
        position: "relative",
        display: "inline-block",
        height: controlHeight,
        margin: 0,
        paddingInline: buttonPaddingInline,
        paddingBlock: 0,
        color: buttonColor,
        fontSize,
        lineHeight: unit(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
        background: buttonBg,
        border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
        // strange align fix for chrome but works
        // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
        borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
        borderInlineStartWidth: 0,
        borderInlineEndWidth: lineWidth,
        cursor: "pointer",
        transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
        a: {
          color: buttonColor
        },
        [`> ${componentCls}-button`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          zIndex: -1,
          width: "100%",
          height: "100%"
        },
        "&:not(:first-child)": {
          "&::before": {
            position: "absolute",
            insetBlockStart: calc(lineWidth).mul(-1).equal(),
            insetInlineStart: calc(lineWidth).mul(-1).equal(),
            display: "block",
            boxSizing: "content-box",
            width: 1,
            height: "100%",
            paddingBlock: lineWidth,
            paddingInline: 0,
            backgroundColor: colorBorder,
            transition: `background-color ${motionDurationSlow}`,
            content: '""'
          }
        },
        "&:first-child": {
          borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
          borderStartStartRadius: borderRadius,
          borderEndStartRadius: borderRadius
        },
        "&:last-child": {
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius
        },
        "&:first-child:last-child": {
          borderRadius
        },
        [`${componentCls}-group-large &`]: {
          height: controlHeightLG,
          fontSize: fontSizeLG,
          lineHeight: unit(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderEndStartRadius: borderRadiusLG
          },
          "&:last-child": {
            borderStartEndRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          }
        },
        [`${componentCls}-group-small &`]: {
          height: controlHeightSM,
          paddingInline: calc(paddingXS).sub(lineWidth).equal(),
          paddingBlock: 0,
          lineHeight: unit(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: borderRadiusSM,
            borderEndStartRadius: borderRadiusSM
          },
          "&:last-child": {
            borderStartEndRadius: borderRadiusSM,
            borderEndEndRadius: borderRadiusSM
          }
        },
        "&:hover": {
          position: "relative",
          color: colorPrimary
        },
        "&:has(:focus-visible)": Object.assign({}, genFocusOutline(token2)),
        [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        },
        [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
          zIndex: 1,
          color: colorPrimary,
          background: buttonCheckedBg,
          borderColor: colorPrimary,
          "&::before": {
            backgroundColor: colorPrimary
          },
          "&:first-child": {
            borderColor: colorPrimary
          },
          "&:hover": {
            color: colorPrimaryHover,
            borderColor: colorPrimaryHover,
            "&::before": {
              backgroundColor: colorPrimaryHover
            }
          },
          "&:active": {
            color: colorPrimaryActive,
            borderColor: colorPrimaryActive,
            "&::before": {
              backgroundColor: colorPrimaryActive
            }
          }
        },
        [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedBg,
          borderColor: buttonSolidCheckedBg,
          "&:hover": {
            color: buttonSolidCheckedColor,
            background: buttonSolidCheckedHoverBg,
            borderColor: buttonSolidCheckedHoverBg
          },
          "&:active": {
            color: buttonSolidCheckedColor,
            background: buttonSolidCheckedActiveBg,
            borderColor: buttonSolidCheckedActiveBg
          }
        },
        "&-disabled": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&:first-child, &:hover": {
            color: colorTextDisabled,
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder
          }
        },
        [`&-disabled${componentCls}-button-wrapper-checked`]: {
          color: buttonCheckedColorDisabled,
          backgroundColor: buttonCheckedBgDisabled,
          borderColor: colorBorder,
          boxShadow: "none"
        },
        "&-block": {
          flex: 1,
          textAlign: "center"
        }
      }
    };
  };
  var prepareComponentToken10 = (token2) => {
    const {
      wireframe,
      padding,
      marginXS,
      lineWidth,
      fontSizeLG,
      colorText,
      colorBgContainer,
      colorTextDisabled,
      controlItemBgActiveDisabled,
      colorTextLightSolid,
      colorPrimary,
      colorPrimaryHover,
      colorPrimaryActive,
      colorWhite
    } = token2;
    const dotPadding = 4;
    const radioSize = fontSizeLG;
    const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
    return {
      // Radio
      radioSize,
      dotSize: radioDotSize,
      dotColorDisabled: colorTextDisabled,
      // Radio buttons
      buttonSolidCheckedColor: colorTextLightSolid,
      buttonSolidCheckedBg: colorPrimary,
      buttonSolidCheckedHoverBg: colorPrimaryHover,
      buttonSolidCheckedActiveBg: colorPrimaryActive,
      buttonBg: colorBgContainer,
      buttonCheckedBg: colorBgContainer,
      buttonColor: colorText,
      buttonCheckedBgDisabled: controlItemBgActiveDisabled,
      buttonCheckedColorDisabled: colorTextDisabled,
      buttonPaddingInline: padding - lineWidth,
      wrapperMarginInlineEnd: marginXS,
      // internal
      radioColor: wireframe ? colorPrimary : colorWhite,
      radioBgColor: wireframe ? colorBgContainer : colorPrimary
    };
  };
  var style_default13 = genStyleHooks("Radio", (token2) => {
    const {
      controlOutline,
      controlOutlineWidth
    } = token2;
    const radioFocusShadow = `0 0 0 ${unit(controlOutlineWidth)} ${controlOutline}`;
    const radioButtonFocusShadow = radioFocusShadow;
    const radioToken = merge2(token2, {
      radioFocusShadow,
      radioButtonFocusShadow
    });
    return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
  }, prepareComponentToken10, {
    unitless: {
      radioSize: true,
      dotSize: true
    }
  });

  // node_modules/antd/es/radio/radio.js
  var __rest19 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var InternalRadio = (props, ref) => {
    var _a, _b;
    const groupContext = React233.useContext(context_default3);
    const radioOptionTypeContext = React233.useContext(RadioOptionTypeContext);
    const {
      getPrefixCls,
      direction,
      radio
    } = React233.useContext(ConfigContext);
    const innerRef = React233.useRef(null);
    const mergedRef = composeRef(ref, innerRef);
    const {
      isFormItemInput
    } = React233.useContext(FormItemInputContext);
    if (true) {
      const warning6 = devUseWarning("Radio");
      true ? warning6(!("optionType" in props), "usage", "`optionType` is only support in Radio.Group.") : void 0;
    }
    const onChange = (e3) => {
      var _a2, _b2;
      (_a2 = props.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, e3);
      (_b2 = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b2 === void 0 ? void 0 : _b2.call(groupContext, e3);
    };
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      children,
      style: style2,
      title
    } = props, restProps = __rest19(props, ["prefixCls", "className", "rootClassName", "children", "style", "title"]);
    const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
    const isButtonType = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button";
    const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
    const rootCls = useCSSVarCls_default(radioPrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default13(radioPrefixCls, rootCls);
    const radioProps = Object.assign({}, restProps);
    const disabled = React233.useContext(DisabledContext_default);
    if (groupContext) {
      radioProps.name = groupContext.name;
      radioProps.onChange = onChange;
      radioProps.checked = props.value === groupContext.value;
      radioProps.disabled = (_a = radioProps.disabled) !== null && _a !== void 0 ? _a : groupContext.disabled;
    }
    radioProps.disabled = (_b = radioProps.disabled) !== null && _b !== void 0 ? _b : disabled;
    const wrapperClassString = (0, import_classnames73.default)(`${prefixCls}-wrapper`, {
      [`${prefixCls}-wrapper-checked`]: radioProps.checked,
      [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
      [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
      [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
      [`${prefixCls}-wrapper-block`]: !!(groupContext === null || groupContext === void 0 ? void 0 : groupContext.block)
    }, radio === null || radio === void 0 ? void 0 : radio.className, className, rootClassName, hashId, cssVarCls, rootCls);
    const [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
    return wrapCSSVar(/* @__PURE__ */ React233.createElement(wave_default, {
      component: "Radio",
      disabled: radioProps.disabled
    }, /* @__PURE__ */ React233.createElement("label", {
      className: wrapperClassString,
      style: Object.assign(Object.assign({}, radio === null || radio === void 0 ? void 0 : radio.style), style2),
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      title,
      onClick: onLabelClick
    }, /* @__PURE__ */ React233.createElement(es_default14, Object.assign({}, radioProps, {
      className: (0, import_classnames73.default)(radioProps.className, {
        [TARGET_CLS]: !isButtonType
      }),
      type: "radio",
      prefixCls,
      ref: mergedRef,
      onClick: onInputClick
    })), children !== void 0 ? /* @__PURE__ */ React233.createElement("span", {
      className: `${prefixCls}-label`
    }, children) : null)));
  };
  var Radio = /* @__PURE__ */ React233.forwardRef(InternalRadio);
  if (true) {
    Radio.displayName = "Radio";
  }
  var radio_default = Radio;

  // node_modules/antd/es/form/hooks/useForm.js
  var React234 = __toESM(require_react());

  // node_modules/antd/es/form/util.js
  var formItemNameBlackList = ["parentNode"];
  var defaultItemNamePrefixCls = "form_item";
  function toArray5(candidate) {
    if (candidate === void 0 || candidate === false) return [];
    return Array.isArray(candidate) ? candidate : [candidate];
  }
  function getFieldId(namePath, formName) {
    if (!namePath.length) {
      return void 0;
    }
    const mergedId = namePath.join("_");
    if (formName) {
      return `${formName}_${mergedId}`;
    }
    const isIllegalName = formItemNameBlackList.includes(mergedId);
    return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
  }
  function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus2) {
    let status = defaultValidateStatus;
    if (validateStatus2 !== void 0) {
      status = validateStatus2;
    } else if (meta.validating) {
      status = "validating";
    } else if (errors.length) {
      status = "error";
    } else if (warnings.length) {
      status = "warning";
    } else if (meta.touched || hasFeedback && meta.validated) {
      status = "success";
    }
    return status;
  }

  // node_modules/antd/es/form/hooks/useForm.js
  var __rest20 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function toNamePathStr(name) {
    const namePath = toArray5(name);
    return namePath.join("_");
  }
  function getFieldDOMNode(name, wrapForm) {
    const field = wrapForm.getFieldInstance(name);
    const fieldDom = getDOM(field);
    if (fieldDom) {
      return fieldDom;
    }
    const fieldId = getFieldId(toArray5(name), wrapForm.__INTERNAL__.name);
    if (fieldId) {
      return document.getElementById(fieldId);
    }
  }
  function useForm2(form) {
    const [rcForm] = useForm_default();
    const itemsRef = React234.useRef({});
    const wrapForm = React234.useMemo(() => form !== null && form !== void 0 ? form : Object.assign(Object.assign({}, rcForm), {
      __INTERNAL__: {
        itemRef: (name) => (node2) => {
          const namePathStr = toNamePathStr(name);
          if (node2) {
            itemsRef.current[namePathStr] = node2;
          } else {
            delete itemsRef.current[namePathStr];
          }
        }
      },
      scrollToField: (name, options = {}) => {
        const {
          focus
        } = options, restOpt = __rest20(options, ["focus"]);
        const node2 = getFieldDOMNode(name, wrapForm);
        if (node2) {
          e2(node2, Object.assign({
            scrollMode: "if-needed",
            block: "nearest"
          }, restOpt));
          if (focus) {
            wrapForm.focusField(name);
          }
        }
      },
      focusField: (name) => {
        var _a, _b;
        const itemRef = wrapForm.getFieldInstance(name);
        if (typeof (itemRef === null || itemRef === void 0 ? void 0 : itemRef.focus) === "function") {
          itemRef.focus();
        } else {
          (_b = (_a = getFieldDOMNode(name, wrapForm)) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      },
      getFieldInstance: (name) => {
        const namePathStr = toNamePathStr(name);
        return itemsRef.current[namePathStr];
      }
    }), [form, rcForm]);
    return [wrapForm];
  }

  // node_modules/antd/es/radio/group.js
  var RadioGroup = /* @__PURE__ */ React235.forwardRef((props, ref) => {
    const {
      getPrefixCls,
      direction
    } = React235.useContext(ConfigContext);
    const {
      name: formItemName
    } = React235.useContext(FormItemInputContext);
    const defaultName = useId_default(toNamePathStr(formItemName));
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      options,
      buttonStyle = "outline",
      disabled,
      children,
      size: customizeSize,
      style: style2,
      id,
      optionType,
      name = defaultName,
      defaultValue,
      value: customizedValue,
      block = false,
      onChange,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur
    } = props;
    const [value, setValue] = useMergedState(defaultValue, {
      value: customizedValue
    });
    const onRadioChange = React235.useCallback((event) => {
      const lastValue = value;
      const val = event.target.value;
      if (!("value" in props)) {
        setValue(val);
      }
      if (val !== lastValue) {
        onChange === null || onChange === void 0 ? void 0 : onChange(event);
      }
    }, [value, setValue, onChange]);
    const prefixCls = getPrefixCls("radio", customizePrefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default13(prefixCls, rootCls);
    let childrenToRender = children;
    if (options && options.length > 0) {
      childrenToRender = options.map((option) => {
        if (typeof option === "string" || typeof option === "number") {
          return /* @__PURE__ */ React235.createElement(radio_default, {
            key: option.toString(),
            prefixCls,
            disabled,
            value: option,
            checked: value === option
          }, option);
        }
        return /* @__PURE__ */ React235.createElement(radio_default, {
          key: `radio-group-value-options-${option.value}`,
          prefixCls,
          disabled: option.disabled || disabled,
          value: option.value,
          checked: value === option.value,
          title: option.title,
          style: option.style,
          className: option.className,
          id: option.id,
          required: option.required
        }, option.label);
      });
    }
    const mergedSize = useSize_default(customizeSize);
    const classString = (0, import_classnames74.default)(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
      [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
      [`${groupPrefixCls}-rtl`]: direction === "rtl",
      [`${groupPrefixCls}-block`]: block
    }, className, rootClassName, hashId, cssVarCls, rootCls);
    const memoizedValue = React235.useMemo(() => ({
      onChange: onRadioChange,
      value,
      disabled,
      name,
      optionType,
      block
    }), [onRadioChange, value, disabled, name, optionType, block]);
    return wrapCSSVar(/* @__PURE__ */ React235.createElement("div", Object.assign({}, pickAttrs(props, {
      aria: true,
      data: true
    }), {
      className: classString,
      style: style2,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      id,
      ref
    }), /* @__PURE__ */ React235.createElement(RadioGroupContextProvider, {
      value: memoizedValue
    }, childrenToRender)));
  });
  var group_default2 = /* @__PURE__ */ React235.memo(RadioGroup);

  // node_modules/antd/es/radio/radioButton.js
  var React236 = __toESM(require_react());
  var __rest21 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var RadioButton = (props, ref) => {
    const {
      getPrefixCls
    } = React236.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls
    } = props, radioProps = __rest21(props, ["prefixCls"]);
    const prefixCls = getPrefixCls("radio", customizePrefixCls);
    return /* @__PURE__ */ React236.createElement(RadioOptionTypeContextProvider, {
      value: "button"
    }, /* @__PURE__ */ React236.createElement(radio_default, Object.assign({
      prefixCls
    }, radioProps, {
      type: "radio",
      ref
    })));
  };
  var radioButton_default = /* @__PURE__ */ React236.forwardRef(RadioButton);

  // node_modules/antd/es/radio/index.js
  var Radio2 = radio_default;
  Radio2.Button = radioButton_default;
  Radio2.Group = group_default2;
  Radio2.__ANT_RADIO = true;
  var radio_default2 = Radio2;

  // node_modules/antd/es/input/style/token.js
  function initInputToken(token2) {
    return merge2(token2, {
      inputAffixPadding: token2.paddingXXS
    });
  }
  var initComponentToken = (token2) => {
    const {
      controlHeight,
      fontSize,
      lineHeight,
      lineWidth,
      controlHeightSM,
      controlHeightLG,
      fontSizeLG,
      lineHeightLG,
      paddingSM,
      controlPaddingHorizontalSM,
      controlPaddingHorizontal,
      colorFillAlter,
      colorPrimaryHover,
      colorPrimary,
      controlOutlineWidth,
      controlOutline,
      colorErrorOutline,
      colorWarningOutline,
      colorBgContainer,
      inputFontSize,
      inputFontSizeLG,
      inputFontSizeSM
    } = token2;
    const mergedFontSize = inputFontSize || fontSize;
    const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
    const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
    const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
    const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
    const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
    return {
      paddingBlock: Math.max(paddingBlock, 0),
      paddingBlockSM: Math.max(paddingBlockSM, 0),
      paddingBlockLG: Math.max(paddingBlockLG, 0),
      paddingInline: paddingSM - lineWidth,
      paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
      paddingInlineLG: controlPaddingHorizontal - lineWidth,
      addonBg: colorFillAlter,
      activeBorderColor: colorPrimary,
      hoverBorderColor: colorPrimaryHover,
      activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
      errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
      warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
      hoverBg: colorBgContainer,
      activeBg: colorBgContainer,
      inputFontSize: mergedFontSize,
      inputFontSizeLG: mergedFontSizeLG,
      inputFontSizeSM: mergedFontSizeSM
    };
  };

  // node_modules/antd/es/input/style/variants.js
  var genHoverStyle = (token2) => ({
    borderColor: token2.hoverBorderColor,
    backgroundColor: token2.hoverBg
  });
  var genDisabledStyle2 = (token2) => ({
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    borderColor: token2.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "input[disabled], textarea[disabled]": {
      cursor: "not-allowed"
    },
    "&:hover:not([disabled])": Object.assign({}, genHoverStyle(merge2(token2, {
      hoverBorderColor: token2.colorBorder,
      hoverBg: token2.colorBgContainerDisabled
    })))
  });
  var genBaseOutlinedStyle2 = (token2, options) => ({
    background: token2.colorBgContainer,
    borderWidth: token2.lineWidth,
    borderStyle: token2.lineType,
    borderColor: options.borderColor,
    "&:hover": {
      borderColor: options.hoverBorderColor,
      backgroundColor: token2.hoverBg
    },
    "&:focus, &:focus-within": {
      borderColor: options.activeBorderColor,
      boxShadow: options.activeShadow,
      outline: 0,
      backgroundColor: token2.activeBg
    }
  });
  var genOutlinedStatusStyle2 = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseOutlinedStyle2(token2, options)), {
      [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
        color: options.affixColor
      }
    }),
    [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
      borderColor: options.borderColor
    }
  });
  var genOutlinedStyle2 = (token2, extraStyles) => ({
    "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle2(token2, {
      borderColor: token2.colorBorder,
      hoverBorderColor: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeShadow: token2.activeShadow
    })), {
      [`&${token2.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle2(token2))
    }), genOutlinedStatusStyle2(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderColor: token2.colorErrorBorderHover,
      activeBorderColor: token2.colorError,
      activeShadow: token2.errorActiveShadow,
      affixColor: token2.colorError
    })), genOutlinedStatusStyle2(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderColor: token2.colorWarningBorderHover,
      activeBorderColor: token2.colorWarning,
      activeShadow: token2.warningActiveShadow,
      affixColor: token2.colorWarning
    })), extraStyles)
  });
  var genOutlinedGroupStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
      [`${token2.componentCls}-group-addon`]: {
        borderColor: options.addonBorderColor,
        color: options.addonColor
      }
    }
  });
  var genOutlinedGroupStyle = (token2) => ({
    "&-outlined": Object.assign(Object.assign(Object.assign({
      [`${token2.componentCls}-group`]: {
        "&-addon": {
          background: token2.addonBg,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        "&-addon:first-child": {
          borderInlineEnd: 0
        },
        "&-addon:last-child": {
          borderInlineStart: 0
        }
      }
    }, genOutlinedGroupStatusStyle(token2, {
      status: "error",
      addonBorderColor: token2.colorError,
      addonColor: token2.colorErrorText
    })), genOutlinedGroupStatusStyle(token2, {
      status: "warning",
      addonBorderColor: token2.colorWarning,
      addonColor: token2.colorWarningText
    })), {
      [`&${token2.componentCls}-group-wrapper-disabled`]: {
        [`${token2.componentCls}-group-addon`]: Object.assign({}, genDisabledStyle2(token2))
      }
    })
  });
  var genBorderlessStyle2 = (token2, extraStyles) => {
    const {
      componentCls
    } = token2;
    return {
      "&-borderless": Object.assign({
        background: "transparent",
        border: "none",
        "&:focus, &:focus-within": {
          outline: "none"
        },
        // >>>>> Disabled
        [`&${componentCls}-disabled, &[disabled]`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        },
        // >>>>> Status
        [`&${componentCls}-status-error`]: {
          "&, & input, & textarea": {
            color: token2.colorError
          }
        },
        [`&${componentCls}-status-warning`]: {
          "&, & input, & textarea": {
            color: token2.colorWarning
          }
        }
      }, extraStyles)
    };
  };
  var genBaseFilledStyle2 = (token2, options) => {
    var _a;
    return {
      background: options.bg,
      borderWidth: token2.lineWidth,
      borderStyle: token2.lineType,
      borderColor: "transparent",
      "input&, & input, textarea&, & textarea": {
        color: (_a = options === null || options === void 0 ? void 0 : options.inputColor) !== null && _a !== void 0 ? _a : "unset"
      },
      "&:hover": {
        background: options.hoverBg
      },
      "&:focus, &:focus-within": {
        outline: 0,
        borderColor: options.activeBorderColor,
        backgroundColor: token2.activeBg
      }
    };
  };
  var genFilledStatusStyle2 = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseFilledStyle2(token2, options)), {
      [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
        color: options.affixColor
      }
    })
  });
  var genFilledStyle2 = (token2, extraStyles) => ({
    "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle2(token2, {
      bg: token2.colorFillTertiary,
      hoverBg: token2.colorFillSecondary,
      activeBorderColor: token2.activeBorderColor
    })), {
      [`&${token2.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle2(token2))
    }), genFilledStatusStyle2(token2, {
      status: "error",
      bg: token2.colorErrorBg,
      hoverBg: token2.colorErrorBgHover,
      activeBorderColor: token2.colorError,
      inputColor: token2.colorErrorText,
      affixColor: token2.colorError
    })), genFilledStatusStyle2(token2, {
      status: "warning",
      bg: token2.colorWarningBg,
      hoverBg: token2.colorWarningBgHover,
      activeBorderColor: token2.colorWarning,
      inputColor: token2.colorWarningText,
      affixColor: token2.colorWarning
    })), extraStyles)
  });
  var genFilledGroupStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
      [`${token2.componentCls}-group-addon`]: {
        background: options.addonBg,
        color: options.addonColor
      }
    }
  });
  var genFilledGroupStyle = (token2) => ({
    "&-filled": Object.assign(Object.assign(Object.assign({
      [`${token2.componentCls}-group-addon`]: {
        background: token2.colorFillTertiary,
        "&:last-child": {
          position: "static"
        }
      }
    }, genFilledGroupStatusStyle(token2, {
      status: "error",
      addonBg: token2.colorErrorBg,
      addonColor: token2.colorErrorText
    })), genFilledGroupStatusStyle(token2, {
      status: "warning",
      addonBg: token2.colorWarningBg,
      addonColor: token2.colorWarningText
    })), {
      [`&${token2.componentCls}-group-wrapper-disabled`]: {
        [`${token2.componentCls}-group`]: {
          "&-addon": {
            background: token2.colorFillTertiary,
            color: token2.colorTextDisabled
          },
          "&-addon:first-child": {
            borderInlineStart: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          },
          "&-addon:last-child": {
            borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          }
        }
      }
    })
  });
  var genBaseUnderlinedStyle2 = (token2, options) => ({
    background: token2.colorBgContainer,
    borderWidth: `${unit(token2.lineWidth)} 0`,
    borderStyle: `${token2.lineType} none`,
    borderColor: `transparent transparent ${options.borderColor} transparent`,
    borderRadius: 0,
    "&:hover": {
      borderColor: `transparent transparent ${options.borderColor} transparent`,
      backgroundColor: token2.hoverBg
    },
    "&:focus, &:focus-within": {
      borderColor: `transparent transparent ${options.activeBorderColor} transparent`,
      outline: 0,
      backgroundColor: token2.activeBg
    }
  });
  var genUnderlinedStatusStyle2 = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseUnderlinedStyle2(token2, options)), {
      [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
        color: options.affixColor
      }
    }),
    [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
      borderColor: `transparent transparent ${options.borderColor} transparent`
    }
  });
  var genUnderlinedStyle2 = (token2, extraStyles) => ({
    "&-underlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseUnderlinedStyle2(token2, {
      borderColor: token2.colorBorder,
      hoverBorderColor: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeShadow: token2.activeShadow
    })), {
      // >>>>> Disabled
      [`&${token2.componentCls}-disabled, &[disabled]`]: {
        color: token2.colorTextDisabled,
        boxShadow: "none",
        cursor: "not-allowed",
        "&:hover": {
          borderColor: `transparent transparent ${token2.colorBorder} transparent`
        }
      },
      "input[disabled], textarea[disabled]": {
        cursor: "not-allowed"
      }
    }), genUnderlinedStatusStyle2(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderColor: token2.colorErrorBorderHover,
      activeBorderColor: token2.colorError,
      activeShadow: token2.errorActiveShadow,
      affixColor: token2.colorError
    })), genUnderlinedStatusStyle2(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderColor: token2.colorWarningBorderHover,
      activeBorderColor: token2.colorWarning,
      activeShadow: token2.warningActiveShadow,
      affixColor: token2.colorWarning
    })), extraStyles)
  });

  // node_modules/antd/es/input/style/index.js
  var genPlaceholderStyle = (color) => ({
    // Firefox
    "&::-moz-placeholder": {
      opacity: 1
    },
    "&::placeholder": {
      color,
      userSelect: "none"
      // https://github.com/ant-design/ant-design/pull/32639
    },
    "&:placeholder-shown": {
      textOverflow: "ellipsis"
    }
  });
  var genInputLargeStyle = (token2) => {
    const {
      paddingBlockLG,
      lineHeightLG,
      borderRadiusLG,
      paddingInlineLG
    } = token2;
    return {
      padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`,
      fontSize: token2.inputFontSizeLG,
      lineHeight: lineHeightLG,
      borderRadius: borderRadiusLG
    };
  };
  var genInputSmallStyle = (token2) => ({
    padding: `${unit(token2.paddingBlockSM)} ${unit(token2.paddingInlineSM)}`,
    fontSize: token2.inputFontSizeSM,
    borderRadius: token2.borderRadiusSM
  });
  var genBasicInputStyle = (token2) => Object.assign(Object.assign({
    position: "relative",
    display: "inline-block",
    width: "100%",
    minWidth: 0,
    padding: `${unit(token2.paddingBlock)} ${unit(token2.paddingInline)}`,
    color: token2.colorText,
    fontSize: token2.inputFontSize,
    lineHeight: token2.lineHeight,
    borderRadius: token2.borderRadius,
    transition: `all ${token2.motionDurationMid}`
  }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
    // Size
    "&-lg": Object.assign({}, genInputLargeStyle(token2)),
    "&-sm": Object.assign({}, genInputSmallStyle(token2)),
    // RTL
    "&-rtl, &-textarea-rtl": {
      direction: "rtl"
    }
  });
  var genInputGroupStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
      // Undo padding and float of grid classes
      "&[class*='col-']": {
        paddingInlineEnd: token2.paddingXS,
        "&:last-child": {
          paddingInlineEnd: 0
        }
      },
      // Sizing options
      [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
      [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
      // Fix https://github.com/ant-design/ant-design/issues/5754
      [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
        height: token2.controlHeightLG
      },
      [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
        height: token2.controlHeightSM
      },
      [`> ${componentCls}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      [`${componentCls}-group`]: {
        "&-addon, &-wrap": {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        "&-wrap > *": {
          display: "block !important"
        },
        "&-addon": {
          position: "relative",
          padding: `0 ${unit(token2.paddingInline)}`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.inputFontSize,
          textAlign: "center",
          borderRadius: token2.borderRadius,
          transition: `all ${token2.motionDurationSlow}`,
          lineHeight: 1,
          // Reset Select's style in addon
          [`${antCls}-select`]: {
            margin: `${unit(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit(token2.calc(token2.paddingInline).mul(-1).equal())}`,
            [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
              [`${antCls}-select-selector`]: {
                backgroundColor: "inherit",
                border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
                boxShadow: "none"
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/31333
          [`${antCls}-cascader-picker`]: {
            margin: `-9px ${unit(token2.calc(token2.paddingInline).mul(-1).equal())}`,
            backgroundColor: "transparent",
            [`${antCls}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none"
            }
          }
        }
      },
      [componentCls]: {
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": {
          zIndex: 1,
          // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
          borderInlineEndWidth: 1
        },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        }
      },
      // Reset rounded corners
      [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}-affix-wrapper`]: {
        [`&:not(:first-child) ${componentCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        },
        [`&:not(:last-child) ${componentCls}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${componentCls}-search &`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          }
        },
        [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
        display: "block"
      }, clearFix()), {
        [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
          "&:not(:first-child):not(:last-child)": {
            borderInlineEndWidth: token2.lineWidth,
            "&:hover, &:focus": {
              zIndex: 1
            }
          }
        },
        "& > *": {
          display: "inline-flex",
          float: "none",
          verticalAlign: "top",
          // https://github.com/ant-design/ant-design-pro/issues/139
          borderRadius: 0
        },
        [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
          display: "inline-flex"
        },
        "& > *:not(:last-child)": {
          marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
          borderInlineEndWidth: token2.lineWidth
        },
        // Undo float for .ant-input-group .ant-input
        [componentCls]: {
          float: "none"
        },
        // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
        [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderRadius: 0,
          "&:hover, &:focus": {
            zIndex: 1
          }
        },
        [`& > ${antCls}-select-focused`]: {
          zIndex: 1
        },
        // update z-index for arrow icon
        [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
          zIndex: 1
          // https://github.com/ant-design/ant-design/issues/20371
        },
        [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        },
        [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderStartEndRadius: token2.borderRadius,
          borderEndEndRadius: token2.borderRadius
        },
        // https://github.com/ant-design/ant-design/issues/12493
        [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
          verticalAlign: "top"
        },
        [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
          marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
          [`${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`${componentCls}-group-wrapper:not(:last-child)`]: {
          [`&${componentCls}-search > ${componentCls}-group`]: {
            [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
              borderRadius: 0
            },
            [`& > ${componentCls}`]: {
              borderStartStartRadius: token2.borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: token2.borderRadius
            }
          }
        }
      })
    };
  };
  var genInputStyle = (token2) => {
    const {
      componentCls,
      controlHeightSM,
      lineWidth,
      calc
    } = token2;
    const FIXED_CHROME_COLOR_HEIGHT = 16;
    const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genOutlinedStyle2(token2)), genFilledStyle2(token2)), genBorderlessStyle2(token2)), genUnderlinedStyle2(token2)), {
        '&[type="color"]': {
          height: token2.controlHeight,
          [`&${componentCls}-lg`]: {
            height: token2.controlHeightLG
          },
          [`&${componentCls}-sm`]: {
            height: controlHeightSM,
            paddingTop: colorSmallPadding,
            paddingBottom: colorSmallPadding
          }
        },
        '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
          appearance: "none"
        }
      })
    };
  };
  var genAllowClearStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // ========================= Input =========================
      [`${componentCls}-clear-icon`]: {
        margin: 0,
        padding: 0,
        lineHeight: 0,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        verticalAlign: -1,
        // https://github.com/ant-design/ant-design/pull/18151
        // https://codesandbox.io/s/wizardly-sun-u10br
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        border: "none",
        outline: "none",
        backgroundColor: "transparent",
        "&:hover": {
          color: token2.colorIcon
        },
        "&:active": {
          color: token2.colorText
        },
        "&-hidden": {
          visibility: "hidden"
        },
        "&-has-suffix": {
          margin: `0 ${unit(token2.inputAffixPadding)}`
        }
      }
    };
  };
  var genAffixStyle = (token2) => {
    const {
      componentCls,
      inputAffixPadding,
      colorTextDescription,
      motionDurationSlow,
      colorIcon,
      colorIconHover,
      iconCls
    } = token2;
    const affixCls = `${componentCls}-affix-wrapper`;
    const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
    return {
      [affixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
        display: "inline-flex",
        [`&:not(${componentCls}-disabled):hover`]: {
          zIndex: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        },
        "&-focused, &:focus": {
          zIndex: 1
        },
        [`> input${componentCls}`]: {
          padding: 0
        },
        [`> input${componentCls}, > textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          borderRadius: 0,
          outline: "none",
          background: "transparent",
          color: "inherit",
          "&::-ms-reveal": {
            display: "none"
          },
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        "&::before": {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        },
        [componentCls]: {
          "&-prefix, &-suffix": {
            display: "flex",
            flex: "none",
            alignItems: "center",
            "> *:not(:last-child)": {
              marginInlineEnd: token2.paddingXS
            }
          },
          "&-show-count-suffix": {
            color: colorTextDescription,
            direction: "ltr"
          },
          "&-show-count-has-suffix": {
            marginInlineEnd: token2.paddingXXS
          },
          "&-prefix": {
            marginInlineEnd: inputAffixPadding
          },
          "&-suffix": {
            marginInlineStart: inputAffixPadding
          }
        }
      }), genAllowClearStyle(token2)), {
        // password
        [`${iconCls}${componentCls}-password-icon`]: {
          color: colorIcon,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      }),
      // 覆盖 affix-wrapper borderRadius！
      [`${componentCls}-underlined`]: {
        borderRadius: 0
      },
      [affixClsDisabled]: {
        // password disabled
        [`${iconCls}${componentCls}-password-icon`]: {
          color: colorIcon,
          cursor: "not-allowed",
          "&:hover": {
            color: colorIcon
          }
        }
      }
    };
  };
  var genGroupStyle2 = (token2) => {
    const {
      componentCls,
      borderRadiusLG,
      borderRadiusSM
    } = token2;
    return {
      [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
        "&-rtl": {
          direction: "rtl"
        },
        "&-wrapper": Object.assign(Object.assign(Object.assign({
          display: "inline-block",
          width: "100%",
          textAlign: "start",
          verticalAlign: "top",
          "&-rtl": {
            direction: "rtl"
          },
          // Size
          "&-lg": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusLG,
              fontSize: token2.inputFontSizeLG
            }
          },
          "&-sm": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusSM
            }
          }
        }, genOutlinedGroupStyle(token2)), genFilledGroupStyle(token2)), {
          // '&-disabled': {
          //   [`${componentCls}-group-addon`]: {
          //     ...genDisabledStyle(token),
          //   },
          // },
          // Fix the issue of using icons in Space Compact mode
          // https://github.com/ant-design/ant-design/issues/42122
          [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          },
          // Fix the issue of input use show-count param in space compact mode
          // https://github.com/ant-design/ant-design/issues/46872
          [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
            [`${componentCls}-affix-wrapper`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          // Fix the issue of input use `addonAfter` param in space compact mode
          // https://github.com/ant-design/ant-design/issues/52483
          [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: {
            [`${componentCls}-affix-wrapper`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        })
      })
    };
  };
  var genSearchInputStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const searchPrefixCls = `${componentCls}-search`;
    return {
      [searchPrefixCls]: {
        [componentCls]: {
          "&:hover, &:focus": {
            [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-color-primary):not(${antCls}-btn-variant-text)`]: {
              borderInlineStartColor: token2.colorPrimaryHover
            }
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          height: token2.controlHeight,
          borderRadius: 0
        },
        // fix slight height diff in Firefox:
        // https://ant.design/components/auto-complete-cn/#auto-complete-demo-certain-category
        [`${componentCls}-lg`]: {
          lineHeight: token2.calc(token2.lineHeightLG).sub(2e-4).equal()
        },
        [`> ${componentCls}-group`]: {
          [`> ${componentCls}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${searchPrefixCls}-button`]: {
              // Fix https://github.com/ant-design/ant-design/issues/47150
              marginInlineEnd: -1,
              borderStartStartRadius: 0,
              borderEndStartRadius: 0,
              boxShadow: "none"
            },
            [`${searchPrefixCls}-button:not(${antCls}-btn-color-primary)`]: {
              color: token2.colorTextDescription,
              "&:hover": {
                color: token2.colorPrimaryHover
              },
              "&:active": {
                color: token2.colorPrimaryActive
              },
              [`&${antCls}-btn-loading::before`]: {
                inset: 0
              }
            }
          }
        },
        [`${searchPrefixCls}-button`]: {
          height: token2.controlHeight,
          "&:hover, &:focus": {
            zIndex: 1
          }
        },
        "&-large": {
          [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
            height: token2.controlHeightLG
          }
        },
        "&-small": {
          [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
            height: token2.controlHeightSM
          }
        },
        "&-rtl": {
          direction: "rtl"
        },
        // ===================== Compact Item Customized Styles =====================
        [`&${componentCls}-compact-item`]: {
          [`&:not(${componentCls}-compact-last-item)`]: {
            [`${componentCls}-group-addon`]: {
              [`${componentCls}-search-button`]: {
                marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
                borderRadius: 0
              }
            }
          },
          [`&:not(${componentCls}-compact-first-item)`]: {
            [`${componentCls},${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
            "&:hover, &:focus, &:active": {
              zIndex: 2
            }
          },
          [`> ${componentCls}-affix-wrapper-focused`]: {
            zIndex: 2
          }
        }
      }
    };
  };
  var genRangeStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-out-of-range`]: {
        [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
          color: token2.colorError
        }
      }
    };
  };
  var useSharedStyle = genStyleHooks(["Input", "Shared"], (token2) => {
    const inputToken = merge2(token2, initInputToken(token2));
    return [genInputStyle(inputToken), genAffixStyle(inputToken)];
  }, initComponentToken, {
    resetFont: false
  });
  var style_default14 = genStyleHooks(["Input", "Component"], (token2) => {
    const inputToken = merge2(token2, initInputToken(token2));
    return [
      genGroupStyle2(inputToken),
      genSearchInputStyle(inputToken),
      genRangeStyle(inputToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputToken)
    ];
  }, initComponentToken, {
    resetFont: false
  });

  // node_modules/antd/es/card/Card.js
  var React253 = __toESM(require_react());
  var import_classnames83 = __toESM(require_classnames());

  // node_modules/antd/es/tabs/index.js
  var React251 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/PlusOutlined.js
  var React237 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/PlusOutlined.js
  var PlusOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
  var PlusOutlined_default = PlusOutlined;

  // node_modules/@ant-design/icons/es/icons/PlusOutlined.js
  var PlusOutlined2 = function PlusOutlined3(props, ref) {
    return /* @__PURE__ */ React237.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: PlusOutlined_default
    }));
  };
  var RefIcon14 = /* @__PURE__ */ React237.forwardRef(PlusOutlined2);
  if (true) {
    RefIcon14.displayName = "PlusOutlined";
  }
  var PlusOutlined_default2 = RefIcon14;

  // node_modules/antd/es/tabs/index.js
  var import_classnames81 = __toESM(require_classnames());

  // node_modules/rc-tabs/es/Tabs.js
  var import_classnames80 = __toESM(require_classnames());
  var React249 = __toESM(require_react());
  var import_react90 = __toESM(require_react());

  // node_modules/rc-tabs/es/TabContext.js
  var import_react82 = __toESM(require_react());
  var TabContext_default = /* @__PURE__ */ (0, import_react82.createContext)(null);

  // node_modules/rc-tabs/es/TabNavList/Wrapper.js
  var React247 = __toESM(require_react());

  // node_modules/rc-tabs/es/TabNavList/index.js
  var import_classnames77 = __toESM(require_classnames());
  var React245 = __toESM(require_react());
  var import_react89 = __toESM(require_react());

  // node_modules/rc-tabs/es/hooks/useIndicator.js
  var import_react83 = __toESM(require_react());
  var useIndicator = function useIndicator2(options) {
    var activeTabOffset = options.activeTabOffset, horizontal = options.horizontal, rtl = options.rtl, _options$indicator = options.indicator, indicator = _options$indicator === void 0 ? {} : _options$indicator;
    var size = indicator.size, _indicator$align = indicator.align, align = _indicator$align === void 0 ? "center" : _indicator$align;
    var _useState = (0, import_react83.useState)(), _useState2 = _slicedToArray(_useState, 2), inkStyle = _useState2[0], setInkStyle = _useState2[1];
    var inkBarRafRef = (0, import_react83.useRef)();
    var getLength = import_react83.default.useCallback(function(origin2) {
      if (typeof size === "function") {
        return size(origin2);
      }
      if (typeof size === "number") {
        return size;
      }
      return origin2;
    }, [size]);
    function cleanInkBarRaf() {
      raf_default.cancel(inkBarRafRef.current);
    }
    (0, import_react83.useEffect)(function() {
      var newInkStyle = {};
      if (activeTabOffset) {
        if (horizontal) {
          newInkStyle.width = getLength(activeTabOffset.width);
          var key = rtl ? "right" : "left";
          if (align === "start") {
            newInkStyle[key] = activeTabOffset[key];
          }
          if (align === "center") {
            newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
            newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
          }
          if (align === "end") {
            newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
            newInkStyle.transform = "translateX(-100%)";
          }
        } else {
          newInkStyle.height = getLength(activeTabOffset.height);
          if (align === "start") {
            newInkStyle.top = activeTabOffset.top;
          }
          if (align === "center") {
            newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
            newInkStyle.transform = "translateY(-50%)";
          }
          if (align === "end") {
            newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
            newInkStyle.transform = "translateY(-100%)";
          }
        }
      }
      cleanInkBarRaf();
      inkBarRafRef.current = raf_default(function() {
        var isEqual2 = inkStyle && newInkStyle && Object.keys(newInkStyle).every(function(key2) {
          var newValue = newInkStyle[key2];
          var oldValue = inkStyle[key2];
          return typeof newValue === "number" && typeof oldValue === "number" ? Math.round(newValue) === Math.round(oldValue) : newValue === oldValue;
        });
        if (!isEqual2) {
          setInkStyle(newInkStyle);
        }
      });
      return cleanInkBarRaf;
    }, [JSON.stringify(activeTabOffset), horizontal, rtl, align, getLength]);
    return {
      style: inkStyle
    };
  };
  var useIndicator_default = useIndicator;

  // node_modules/rc-tabs/es/hooks/useOffsets.js
  var import_react84 = __toESM(require_react());
  var DEFAULT_SIZE = {
    width: 0,
    height: 0,
    left: 0,
    top: 0
  };
  function useOffsets(tabs, tabSizes, holderScrollWidth) {
    return (0, import_react84.useMemo)(function() {
      var _tabs$;
      var map = /* @__PURE__ */ new Map();
      var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE;
      var rightOffset = lastOffset.left + lastOffset.width;
      for (var i = 0; i < tabs.length; i += 1) {
        var key = tabs[i].key;
        var data = tabSizes.get(key);
        if (!data) {
          var _tabs;
          data = tabSizes.get((_tabs = tabs[i - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE;
        }
        var entity = map.get(key) || _objectSpread2({}, data);
        entity.right = rightOffset - entity.left - entity.width;
        map.set(key, entity);
      }
      return map;
    }, [tabs.map(function(tab) {
      return tab.key;
    }).join("_"), tabSizes, holderScrollWidth]);
  }

  // node_modules/rc-tabs/es/hooks/useSyncState.js
  var React239 = __toESM(require_react());
  function useSyncState2(defaultState, onChange) {
    var stateRef = React239.useRef(defaultState);
    var _React$useState = React239.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
    function setState(updater) {
      var newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
      if (newValue !== stateRef.current) {
        onChange(newValue, stateRef.current);
      }
      stateRef.current = newValue;
      forceUpdate({});
    }
    return [stateRef.current, setState];
  }

  // node_modules/rc-tabs/es/hooks/useTouchMove.js
  var React240 = __toESM(require_react());
  var import_react85 = __toESM(require_react());
  var MIN_SWIPE_DISTANCE = 0.1;
  var STOP_SWIPE_DISTANCE = 0.01;
  var REFRESH_INTERVAL = 20;
  var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
  function useTouchMove(ref, onOffset) {
    var _useState = (0, import_react85.useState)(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
    var _useState3 = (0, import_react85.useState)(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
    var _useState5 = (0, import_react85.useState)(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
    var _useState7 = (0, import_react85.useState)(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
    var motionRef = (0, import_react85.useRef)();
    function onTouchStart(e3) {
      var _e$touches$ = e3.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
      setTouchPosition({
        x: screenX,
        y: screenY
      });
      window.clearInterval(motionRef.current);
    }
    function onTouchMove(e3) {
      if (!touchPosition) return;
      var _e$touches$2 = e3.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
      setTouchPosition({
        x: screenX,
        y: screenY
      });
      var offsetX = screenX - touchPosition.x;
      var offsetY = screenY - touchPosition.y;
      onOffset(offsetX, offsetY);
      var now2 = Date.now();
      setLastTimestamp(now2);
      setLastTimeDiff(now2 - lastTimestamp);
      setLastOffset({
        x: offsetX,
        y: offsetY
      });
    }
    function onTouchEnd() {
      if (!touchPosition) return;
      setTouchPosition(null);
      setLastOffset(null);
      if (lastOffset) {
        var distanceX = lastOffset.x / lastTimeDiff;
        var distanceY = lastOffset.y / lastTimeDiff;
        var absX = Math.abs(distanceX);
        var absY = Math.abs(distanceY);
        if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
        var currentX = distanceX;
        var currentY = distanceY;
        motionRef.current = window.setInterval(function() {
          if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
            window.clearInterval(motionRef.current);
            return;
          }
          currentX *= SPEED_OFF_MULTIPLE;
          currentY *= SPEED_OFF_MULTIPLE;
          onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
        }, REFRESH_INTERVAL);
      }
    }
    var lastWheelDirectionRef = (0, import_react85.useRef)();
    function onWheel(e3) {
      var deltaX = e3.deltaX, deltaY = e3.deltaY;
      var mixed = 0;
      var absX = Math.abs(deltaX);
      var absY = Math.abs(deltaY);
      if (absX === absY) {
        mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
      } else if (absX > absY) {
        mixed = deltaX;
        lastWheelDirectionRef.current = "x";
      } else {
        mixed = deltaY;
        lastWheelDirectionRef.current = "y";
      }
      if (onOffset(-mixed, -mixed)) {
        e3.preventDefault();
      }
    }
    var touchEventsRef = (0, import_react85.useRef)(null);
    touchEventsRef.current = {
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onWheel
    };
    React240.useEffect(function() {
      function onProxyTouchStart(e3) {
        touchEventsRef.current.onTouchStart(e3);
      }
      function onProxyTouchMove(e3) {
        touchEventsRef.current.onTouchMove(e3);
      }
      function onProxyTouchEnd(e3) {
        touchEventsRef.current.onTouchEnd(e3);
      }
      function onProxyWheel(e3) {
        touchEventsRef.current.onWheel(e3);
      }
      document.addEventListener("touchmove", onProxyTouchMove, {
        passive: false
      });
      document.addEventListener("touchend", onProxyTouchEnd, {
        passive: true
      });
      ref.current.addEventListener("touchstart", onProxyTouchStart, {
        passive: true
      });
      ref.current.addEventListener("wheel", onProxyWheel, {
        passive: false
      });
      return function() {
        document.removeEventListener("touchmove", onProxyTouchMove);
        document.removeEventListener("touchend", onProxyTouchEnd);
      };
    }, []);
  }

  // node_modules/rc-tabs/es/hooks/useUpdate.js
  var import_react86 = __toESM(require_react());
  function useUpdate(callback) {
    var _useState = (0, import_react86.useState)(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1];
    var effectRef = (0, import_react86.useRef)(0);
    var callbackRef = (0, import_react86.useRef)();
    callbackRef.current = callback;
    useLayoutUpdateEffect(function() {
      var _callbackRef$current;
      (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 || _callbackRef$current.call(callbackRef);
    }, [count]);
    return function() {
      if (effectRef.current !== count) {
        return;
      }
      effectRef.current += 1;
      setCount(effectRef.current);
    };
  }
  function useUpdateState(defaultState) {
    var batchRef = (0, import_react86.useRef)([]);
    var _useState3 = (0, import_react86.useState)({}), _useState4 = _slicedToArray(_useState3, 2), forceUpdate = _useState4[1];
    var state = (0, import_react86.useRef)(typeof defaultState === "function" ? defaultState() : defaultState);
    var flushUpdate = useUpdate(function() {
      var current = state.current;
      batchRef.current.forEach(function(callback) {
        current = callback(current);
      });
      batchRef.current = [];
      state.current = current;
      forceUpdate({});
    });
    function updater(callback) {
      batchRef.current.push(callback);
      flushUpdate();
    }
    return [state.current, updater];
  }

  // node_modules/rc-tabs/es/hooks/useVisibleRange.js
  var import_react87 = __toESM(require_react());
  var DEFAULT_SIZE2 = {
    width: 0,
    height: 0,
    left: 0,
    top: 0,
    right: 0
  };
  function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
    var tabs = _ref.tabs, tabPosition = _ref.tabPosition, rtl = _ref.rtl;
    var charUnit;
    var position3;
    var transformSize;
    if (["top", "bottom"].includes(tabPosition)) {
      charUnit = "width";
      position3 = rtl ? "right" : "left";
      transformSize = Math.abs(transform);
    } else {
      charUnit = "height";
      position3 = "top";
      transformSize = -transform;
    }
    return (0, import_react87.useMemo)(function() {
      if (!tabs.length) {
        return [0, 0];
      }
      var len = tabs.length;
      var endIndex = len;
      for (var i = 0; i < len; i += 1) {
        var offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE2;
        if (Math.floor(offset3[position3] + offset3[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
          endIndex = i - 1;
          break;
        }
      }
      var startIndex = 0;
      for (var _i = len - 1; _i >= 0; _i -= 1) {
        var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE2;
        if (_offset[position3] < transformSize) {
          startIndex = _i + 1;
          break;
        }
      }
      return startIndex >= endIndex ? [0, 0] : [startIndex, endIndex];
    }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function(tab) {
      return tab.key;
    }).join("_"), rtl]);
  }

  // node_modules/rc-tabs/es/util.js
  function stringify3(obj) {
    var tgt;
    if (obj instanceof Map) {
      tgt = {};
      obj.forEach(function(v, k) {
        tgt[k] = v;
      });
    } else {
      tgt = obj;
    }
    return JSON.stringify(tgt);
  }
  var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
  function genDataNodeKey(key) {
    return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
  }
  function getRemovable(closable, closeIcon, editable, disabled) {
    if (
      // Only editable tabs can be removed
      !editable || // Tabs cannot be removed when disabled
      disabled || // closable is false
      closable === false || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
      closable === void 0 && (closeIcon === false || closeIcon === null)
    ) {
      return false;
    }
    return true;
  }

  // node_modules/rc-tabs/es/TabNavList/AddButton.js
  var React241 = __toESM(require_react());
  var AddButton = /* @__PURE__ */ React241.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, editable = props.editable, locale6 = props.locale, style2 = props.style;
    if (!editable || editable.showAdd === false) {
      return null;
    }
    return /* @__PURE__ */ React241.createElement("button", {
      ref,
      type: "button",
      className: "".concat(prefixCls, "-nav-add"),
      style: style2,
      "aria-label": (locale6 === null || locale6 === void 0 ? void 0 : locale6.addAriaLabel) || "Add tab",
      onClick: function onClick(event) {
        editable.onEdit("add", {
          event
        });
      }
    }, editable.addIcon || "+");
  });
  var AddButton_default = AddButton;

  // node_modules/rc-tabs/es/TabNavList/ExtraContent.js
  var React242 = __toESM(require_react());
  var ExtraContent = /* @__PURE__ */ React242.forwardRef(function(props, ref) {
    var position3 = props.position, prefixCls = props.prefixCls, extra = props.extra;
    if (!extra) {
      return null;
    }
    var content;
    var assertExtra = {};
    if (_typeof(extra) === "object" && !/* @__PURE__ */ React242.isValidElement(extra)) {
      assertExtra = extra;
    } else {
      assertExtra.right = extra;
    }
    if (position3 === "right") {
      content = assertExtra.right;
    }
    if (position3 === "left") {
      content = assertExtra.left;
    }
    return content ? /* @__PURE__ */ React242.createElement("div", {
      className: "".concat(prefixCls, "-extra-content"),
      ref
    }, content) : null;
  });
  if (true) {
    ExtraContent.displayName = "ExtraContent";
  }
  var ExtraContent_default = ExtraContent;

  // node_modules/rc-tabs/es/TabNavList/OperationNode.js
  var import_classnames75 = __toESM(require_classnames());
  var React243 = __toESM(require_react());
  var import_react88 = __toESM(require_react());
  var OperationNode = /* @__PURE__ */ React243.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, id = props.id, tabs = props.tabs, locale6 = props.locale, mobile = props.mobile, _props$more = props.more, moreProps = _props$more === void 0 ? {} : _props$more, style2 = props.style, className = props.className, editable = props.editable, tabBarGutter = props.tabBarGutter, rtl = props.rtl, removeAriaLabel = props.removeAriaLabel, onTabClick = props.onTabClick, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName;
    var _useState = (0, import_react88.useState)(false), _useState2 = _slicedToArray(_useState, 2), open2 = _useState2[0], setOpen = _useState2[1];
    var _useState3 = (0, import_react88.useState)(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
    var _moreProps$icon = moreProps.icon, moreIcon = _moreProps$icon === void 0 ? "More" : _moreProps$icon;
    var popupId = "".concat(id, "-more-popup");
    var dropdownPrefix = "".concat(prefixCls, "-dropdown");
    var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
    var dropdownAriaLabel = locale6 === null || locale6 === void 0 ? void 0 : locale6.dropdownAriaLabel;
    function onRemoveTab(event, key) {
      event.preventDefault();
      event.stopPropagation();
      editable.onEdit("remove", {
        key,
        event
      });
    }
    var menu = /* @__PURE__ */ React243.createElement(es_default13, {
      onClick: function onClick(_ref) {
        var key = _ref.key, domEvent = _ref.domEvent;
        onTabClick(key, domEvent);
        setOpen(false);
      },
      prefixCls: "".concat(dropdownPrefix, "-menu"),
      id: popupId,
      tabIndex: -1,
      role: "listbox",
      "aria-activedescendant": selectedItemId,
      selectedKeys: [selectedKey],
      "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
    }, tabs.map(function(tab) {
      var closable = tab.closable, disabled = tab.disabled, closeIcon = tab.closeIcon, key = tab.key, label = tab.label;
      var removable = getRemovable(closable, closeIcon, editable, disabled);
      return /* @__PURE__ */ React243.createElement(MenuItem_default, {
        key,
        id: "".concat(popupId, "-").concat(key),
        role: "option",
        "aria-controls": id && "".concat(id, "-panel-").concat(key),
        disabled
      }, /* @__PURE__ */ React243.createElement("span", null, label), removable && /* @__PURE__ */ React243.createElement("button", {
        type: "button",
        "aria-label": removeAriaLabel || "remove",
        tabIndex: 0,
        className: "".concat(dropdownPrefix, "-menu-item-remove"),
        onClick: function onClick(e3) {
          e3.stopPropagation();
          onRemoveTab(e3, key);
        }
      }, closeIcon || editable.removeIcon || "\xD7"));
    }));
    function selectOffset(offset3) {
      var enabledTabs = tabs.filter(function(tab2) {
        return !tab2.disabled;
      });
      var selectedIndex = enabledTabs.findIndex(function(tab2) {
        return tab2.key === selectedKey;
      }) || 0;
      var len = enabledTabs.length;
      for (var i = 0; i < len; i += 1) {
        selectedIndex = (selectedIndex + offset3 + len) % len;
        var tab = enabledTabs[selectedIndex];
        if (!tab.disabled) {
          setSelectedKey(tab.key);
          return;
        }
      }
    }
    function onKeyDown2(e3) {
      var which = e3.which;
      if (!open2) {
        if ([KeyCode_default.DOWN, KeyCode_default.SPACE, KeyCode_default.ENTER].includes(which)) {
          setOpen(true);
          e3.preventDefault();
        }
        return;
      }
      switch (which) {
        case KeyCode_default.UP:
          selectOffset(-1);
          e3.preventDefault();
          break;
        case KeyCode_default.DOWN:
          selectOffset(1);
          e3.preventDefault();
          break;
        case KeyCode_default.ESC:
          setOpen(false);
          break;
        case KeyCode_default.SPACE:
        case KeyCode_default.ENTER:
          if (selectedKey !== null) {
            onTabClick(selectedKey, e3);
          }
          break;
      }
    }
    (0, import_react88.useEffect)(function() {
      var ele = document.getElementById(selectedItemId);
      if (ele && ele.scrollIntoView) {
        ele.scrollIntoView(false);
      }
    }, [selectedKey]);
    (0, import_react88.useEffect)(function() {
      if (!open2) {
        setSelectedKey(null);
      }
    }, [open2]);
    var moreStyle = _defineProperty({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
    if (!tabs.length) {
      moreStyle.visibility = "hidden";
      moreStyle.order = 1;
    }
    var overlayClassName = (0, import_classnames75.default)(_defineProperty({}, "".concat(dropdownPrefix, "-rtl"), rtl));
    var moreNode = mobile ? null : /* @__PURE__ */ React243.createElement(es_default12, _extends({
      prefixCls: dropdownPrefix,
      overlay: menu,
      visible: tabs.length ? open2 : false,
      onVisibleChange: setOpen,
      overlayClassName: (0, import_classnames75.default)(overlayClassName, popupClassName),
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      getPopupContainer
    }, moreProps), /* @__PURE__ */ React243.createElement("button", {
      type: "button",
      className: "".concat(prefixCls, "-nav-more"),
      style: moreStyle,
      "aria-haspopup": "listbox",
      "aria-controls": popupId,
      id: "".concat(id, "-more"),
      "aria-expanded": open2,
      onKeyDown: onKeyDown2
    }, moreIcon));
    return /* @__PURE__ */ React243.createElement("div", {
      className: (0, import_classnames75.default)("".concat(prefixCls, "-nav-operations"), className),
      style: style2,
      ref
    }, moreNode, /* @__PURE__ */ React243.createElement(AddButton_default, {
      prefixCls,
      locale: locale6,
      editable
    }));
  });
  var OperationNode_default = /* @__PURE__ */ React243.memo(OperationNode, function(_, next2) {
    return (
      // https://github.com/ant-design/ant-design/issues/32544
      // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
      next2.tabMoving
    );
  });

  // node_modules/rc-tabs/es/TabNavList/TabNode.js
  var import_classnames76 = __toESM(require_classnames());
  var React244 = __toESM(require_react());
  var TabNode = function TabNode2(props) {
    var prefixCls = props.prefixCls, id = props.id, active = props.active, focus = props.focus, _props$tab = props.tab, key = _props$tab.key, label = _props$tab.label, disabled = _props$tab.disabled, closeIcon = _props$tab.closeIcon, icon = _props$tab.icon, closable = props.closable, renderWrapper = props.renderWrapper, removeAriaLabel = props.removeAriaLabel, editable = props.editable, onClick = props.onClick, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown2 = props.onKeyDown, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, style2 = props.style, tabCount = props.tabCount, currentPosition = props.currentPosition;
    var tabPrefix = "".concat(prefixCls, "-tab");
    var removable = getRemovable(closable, closeIcon, editable, disabled);
    function onInternalClick(e3) {
      if (disabled) {
        return;
      }
      onClick(e3);
    }
    function onRemoveTab(event) {
      event.preventDefault();
      event.stopPropagation();
      editable.onEdit("remove", {
        key,
        event
      });
    }
    var labelNode = React244.useMemo(function() {
      return icon && typeof label === "string" ? /* @__PURE__ */ React244.createElement("span", null, label) : label;
    }, [label, icon]);
    var btnRef = React244.useRef(null);
    React244.useEffect(function() {
      if (focus && btnRef.current) {
        btnRef.current.focus();
      }
    }, [focus]);
    var node2 = /* @__PURE__ */ React244.createElement("div", {
      key,
      "data-node-key": genDataNodeKey(key),
      className: (0, import_classnames76.default)(tabPrefix, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(tabPrefix, "-with-remove"), removable), "".concat(tabPrefix, "-active"), active), "".concat(tabPrefix, "-disabled"), disabled), "".concat(tabPrefix, "-focus"), focus)),
      style: style2,
      onClick: onInternalClick
    }, /* @__PURE__ */ React244.createElement("div", {
      ref: btnRef,
      role: "tab",
      "aria-selected": active,
      id: id && "".concat(id, "-tab-").concat(key),
      className: "".concat(tabPrefix, "-btn"),
      "aria-controls": id && "".concat(id, "-panel-").concat(key),
      "aria-disabled": disabled,
      tabIndex: disabled ? null : active ? 0 : -1,
      onClick: function onClick2(e3) {
        e3.stopPropagation();
        onInternalClick(e3);
      },
      onKeyDown: onKeyDown2,
      onMouseDown,
      onMouseUp,
      onFocus,
      onBlur
    }, focus && /* @__PURE__ */ React244.createElement("div", {
      "aria-live": "polite",
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      }
    }, "Tab ".concat(currentPosition, " of ").concat(tabCount)), icon && /* @__PURE__ */ React244.createElement("span", {
      className: "".concat(tabPrefix, "-icon")
    }, icon), label && labelNode), removable && /* @__PURE__ */ React244.createElement("button", {
      type: "button",
      role: "tab",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: active ? 0 : -1,
      className: "".concat(tabPrefix, "-remove"),
      onClick: function onClick2(e3) {
        e3.stopPropagation();
        onRemoveTab(e3);
      }
    }, closeIcon || editable.removeIcon || "\xD7"));
    return renderWrapper ? renderWrapper(node2) : node2;
  };
  var TabNode_default = TabNode;

  // node_modules/rc-tabs/es/TabNavList/index.js
  var getTabSize = function getTabSize2(tab, containerRect) {
    var offsetWidth = tab.offsetWidth, offsetHeight = tab.offsetHeight, offsetTop = tab.offsetTop, offsetLeft = tab.offsetLeft;
    var _tab$getBoundingClien = tab.getBoundingClientRect(), width = _tab$getBoundingClien.width, height = _tab$getBoundingClien.height, left = _tab$getBoundingClien.left, top = _tab$getBoundingClien.top;
    if (Math.abs(width - offsetWidth) < 1) {
      return [width, height, left - containerRect.left, top - containerRect.top];
    }
    return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
  };
  var getSize = function getSize2(refObj) {
    var _ref = refObj.current || {}, _ref$offsetWidth = _ref.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
    if (refObj.current) {
      var _refObj$current$getBo = refObj.current.getBoundingClientRect(), width = _refObj$current$getBo.width, height = _refObj$current$getBo.height;
      if (Math.abs(width - offsetWidth) < 1) {
        return [width, height];
      }
    }
    return [offsetWidth, offsetHeight];
  };
  var getUnitValue = function getUnitValue2(size, tabPositionTopOrBottom) {
    return size[tabPositionTopOrBottom ? 0 : 1];
  };
  var TabNavList = /* @__PURE__ */ React245.forwardRef(function(props, ref) {
    var className = props.className, style2 = props.style, id = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale6 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, indicator = props.indicator;
    var _React$useContext = React245.useContext(TabContext_default), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
    var containerRef = (0, import_react89.useRef)(null);
    var extraLeftRef = (0, import_react89.useRef)(null);
    var extraRightRef = (0, import_react89.useRef)(null);
    var tabsWrapperRef = (0, import_react89.useRef)(null);
    var tabListRef = (0, import_react89.useRef)(null);
    var operationsRef = (0, import_react89.useRef)(null);
    var innerAddButtonRef = (0, import_react89.useRef)(null);
    var tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
    var _useSyncState = useSyncState2(0, function(next2, prev2) {
      if (tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next2 > prev2 ? "left" : "right"
        });
      }
    }), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
    var _useSyncState3 = useSyncState2(0, function(next2, prev2) {
      if (!tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next2 > prev2 ? "top" : "bottom"
        });
      }
    }), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
    var _useState = (0, import_react89.useState)([0, 0]), _useState2 = _slicedToArray(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1];
    var _useState3 = (0, import_react89.useState)([0, 0]), _useState4 = _slicedToArray(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1];
    var _useState5 = (0, import_react89.useState)([0, 0]), _useState6 = _slicedToArray(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1];
    var _useState7 = (0, import_react89.useState)([0, 0]), _useState8 = _slicedToArray(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1];
    var _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1];
    var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
    var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
    var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
    var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
    var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
    var needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);
    var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
    var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
    var transformMin = 0;
    var transformMax = 0;
    if (!tabPositionTopOrBottom) {
      transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
      transformMax = 0;
    } else if (rtl) {
      transformMin = 0;
      transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
    } else {
      transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
      transformMax = 0;
    }
    function alignInRange(value) {
      if (value < transformMin) {
        return transformMin;
      }
      if (value > transformMax) {
        return transformMax;
      }
      return value;
    }
    var touchMovingRef = (0, import_react89.useRef)(null);
    var _useState9 = (0, import_react89.useState)(), _useState10 = _slicedToArray(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
    function doLockAnimation() {
      setLockAnimation(Date.now());
    }
    function clearTouchMoving() {
      if (touchMovingRef.current) {
        clearTimeout(touchMovingRef.current);
      }
    }
    useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
      function doMove(setState, offset3) {
        setState(function(value) {
          var newValue = alignInRange(value + offset3);
          return newValue;
        });
      }
      if (!needScroll) {
        return false;
      }
      if (tabPositionTopOrBottom) {
        doMove(setTransformLeft, offsetX);
      } else {
        doMove(setTransformTop, offsetY);
      }
      clearTouchMoving();
      doLockAnimation();
      return true;
    });
    (0, import_react89.useEffect)(function() {
      clearTouchMoving();
      if (lockAnimation) {
        touchMovingRef.current = setTimeout(function() {
          setLockAnimation(0);
        }, 100);
      }
      return clearTouchMoving;
    }, [lockAnimation]);
    var _useVisibleRange = useVisibleRange(
      tabOffsets,
      // Container
      visibleTabContentValue,
      // Transform
      tabPositionTopOrBottom ? transformLeft : transformTop,
      // Tabs
      tabContentSizeValue,
      // Add
      addSizeValue,
      // Operation
      operationSizeValue,
      _objectSpread2(_objectSpread2({}, props), {}, {
        tabs
      })
    ), _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1];
    var scrollToTab = useEvent(function() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey;
      var tabOffset = tabOffsets.get(key) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (tabPositionTopOrBottom) {
        var newTransform = transformLeft;
        if (rtl) {
          if (tabOffset.right < transformLeft) {
            newTransform = tabOffset.right;
          } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
            newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
          }
        } else if (tabOffset.left < -transformLeft) {
          newTransform = -tabOffset.left;
        } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
          newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
        }
        setTransformTop(0);
        setTransformLeft(alignInRange(newTransform));
      } else {
        var _newTransform = transformTop;
        if (tabOffset.top < -transformTop) {
          _newTransform = -tabOffset.top;
        } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
          _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
        }
        setTransformLeft(0);
        setTransformTop(alignInRange(_newTransform));
      }
    });
    var _useState11 = (0, import_react89.useState)(), _useState12 = _slicedToArray(_useState11, 2), focusKey = _useState12[0], setFocusKey = _useState12[1];
    var _useState13 = (0, import_react89.useState)(false), _useState14 = _slicedToArray(_useState13, 2), isMouse = _useState14[0], setIsMouse = _useState14[1];
    var enabledTabs = tabs.filter(function(tab) {
      return !tab.disabled;
    }).map(function(tab) {
      return tab.key;
    });
    var onOffset = function onOffset2(offset3) {
      var currentIndex = enabledTabs.indexOf(focusKey || activeKey);
      var len = enabledTabs.length;
      var nextIndex = (currentIndex + offset3 + len) % len;
      var newKey = enabledTabs[nextIndex];
      setFocusKey(newKey);
    };
    var handleKeyDown = function handleKeyDown2(e3) {
      var code = e3.code;
      var isRTL = rtl && tabPositionTopOrBottom;
      var firstEnabledTab = enabledTabs[0];
      var lastEnabledTab = enabledTabs[enabledTabs.length - 1];
      switch (code) {
        // LEFT
        case "ArrowLeft": {
          if (tabPositionTopOrBottom) {
            onOffset(isRTL ? 1 : -1);
          }
          break;
        }
        // RIGHT
        case "ArrowRight": {
          if (tabPositionTopOrBottom) {
            onOffset(isRTL ? -1 : 1);
          }
          break;
        }
        // UP
        case "ArrowUp": {
          e3.preventDefault();
          if (!tabPositionTopOrBottom) {
            onOffset(-1);
          }
          break;
        }
        // DOWN
        case "ArrowDown": {
          e3.preventDefault();
          if (!tabPositionTopOrBottom) {
            onOffset(1);
          }
          break;
        }
        // HOME
        case "Home": {
          e3.preventDefault();
          setFocusKey(firstEnabledTab);
          break;
        }
        // END
        case "End": {
          e3.preventDefault();
          setFocusKey(lastEnabledTab);
          break;
        }
        // Enter & Space
        case "Enter":
        case "Space": {
          e3.preventDefault();
          onTabClick(focusKey !== null && focusKey !== void 0 ? focusKey : activeKey, e3);
          break;
        }
        // Backspace
        case "Backspace":
        case "Delete": {
          var removeIndex = enabledTabs.indexOf(focusKey);
          var removeTab = tabs.find(function(tab) {
            return tab.key === focusKey;
          });
          var removable = getRemovable(removeTab === null || removeTab === void 0 ? void 0 : removeTab.closable, removeTab === null || removeTab === void 0 ? void 0 : removeTab.closeIcon, editable, removeTab === null || removeTab === void 0 ? void 0 : removeTab.disabled);
          if (removable) {
            e3.preventDefault();
            e3.stopPropagation();
            editable.onEdit("remove", {
              key: focusKey,
              event: e3
            });
            if (removeIndex === enabledTabs.length - 1) {
              onOffset(-1);
            } else {
              onOffset(1);
            }
          }
          break;
        }
      }
    };
    var tabNodeStyle = {};
    if (tabPositionTopOrBottom) {
      tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
    } else {
      tabNodeStyle.marginTop = tabBarGutter;
    }
    var tabNodes = tabs.map(function(tab, i) {
      var key = tab.key;
      return /* @__PURE__ */ React245.createElement(TabNode_default, {
        id,
        prefixCls,
        key,
        tab,
        style: i === 0 ? void 0 : tabNodeStyle,
        closable: tab.closable,
        editable,
        active: key === activeKey,
        focus: key === focusKey,
        renderWrapper: children,
        removeAriaLabel: locale6 === null || locale6 === void 0 ? void 0 : locale6.removeAriaLabel,
        tabCount: enabledTabs.length,
        currentPosition: i + 1,
        onClick: function onClick(e3) {
          onTabClick(key, e3);
        },
        onKeyDown: handleKeyDown,
        onFocus: function onFocus() {
          if (!isMouse) {
            setFocusKey(key);
          }
          scrollToTab(key);
          doLockAnimation();
          if (!tabsWrapperRef.current) {
            return;
          }
          if (!rtl) {
            tabsWrapperRef.current.scrollLeft = 0;
          }
          tabsWrapperRef.current.scrollTop = 0;
        },
        onBlur: function onBlur() {
          setFocusKey(void 0);
        },
        onMouseDown: function onMouseDown() {
          setIsMouse(true);
        },
        onMouseUp: function onMouseUp() {
          setIsMouse(false);
        }
      });
    });
    var updateTabSizes = function updateTabSizes2() {
      return setTabSizes(function() {
        var _tabListRef$current;
        var newSizes = /* @__PURE__ */ new Map();
        var listRect = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.getBoundingClientRect();
        tabs.forEach(function(_ref2) {
          var _tabListRef$current2;
          var key = _ref2.key;
          var btnNode = (_tabListRef$current2 = tabListRef.current) === null || _tabListRef$current2 === void 0 ? void 0 : _tabListRef$current2.querySelector('[data-node-key="'.concat(genDataNodeKey(key), '"]'));
          if (btnNode) {
            var _getTabSize = getTabSize(btnNode, listRect), _getTabSize2 = _slicedToArray(_getTabSize, 4), width = _getTabSize2[0], height = _getTabSize2[1], left = _getTabSize2[2], top = _getTabSize2[3];
            newSizes.set(key, {
              width,
              height,
              left,
              top
            });
          }
        });
        return newSizes;
      });
    };
    (0, import_react89.useEffect)(function() {
      updateTabSizes();
    }, [tabs.map(function(tab) {
      return tab.key;
    }).join("_")]);
    var onListHolderResize = useUpdate(function() {
      var containerSize = getSize(containerRef);
      var extraLeftSize = getSize(extraLeftRef);
      var extraRightSize = getSize(extraRightRef);
      setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
      var newAddSize = getSize(innerAddButtonRef);
      setAddSize(newAddSize);
      var newOperationSize = getSize(operationsRef);
      setOperationSize(newOperationSize);
      var tabContentFullSize = getSize(tabListRef);
      setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
      updateTabSizes();
    });
    var startHiddenTabs = tabs.slice(0, visibleStart);
    var endHiddenTabs = tabs.slice(visibleEnd + 1);
    var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs));
    var activeTabOffset = tabOffsets.get(activeKey);
    var _useIndicator = useIndicator_default({
      activeTabOffset,
      horizontal: tabPositionTopOrBottom,
      indicator,
      rtl
    }), indicatorStyle = _useIndicator.style;
    (0, import_react89.useEffect)(function() {
      scrollToTab();
    }, [activeKey, transformMin, transformMax, stringify3(activeTabOffset), stringify3(tabOffsets), tabPositionTopOrBottom]);
    (0, import_react89.useEffect)(function() {
      onListHolderResize();
    }, [rtl]);
    var hasDropdown = !!hiddenTabs.length;
    var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
    var pingLeft;
    var pingRight;
    var pingTop;
    var pingBottom;
    if (tabPositionTopOrBottom) {
      if (rtl) {
        pingRight = transformLeft > 0;
        pingLeft = transformLeft !== transformMax;
      } else {
        pingLeft = transformLeft < 0;
        pingRight = transformLeft !== transformMin;
      }
    } else {
      pingTop = transformTop < 0;
      pingBottom = transformTop !== transformMin;
    }
    return /* @__PURE__ */ React245.createElement(es_default, {
      onResize: onListHolderResize
    }, /* @__PURE__ */ React245.createElement("div", {
      ref: useComposeRef(ref, containerRef),
      role: "tablist",
      "aria-orientation": tabPositionTopOrBottom ? "horizontal" : "vertical",
      className: (0, import_classnames77.default)("".concat(prefixCls, "-nav"), className),
      style: style2,
      onKeyDown: function onKeyDown2() {
        doLockAnimation();
      }
    }, /* @__PURE__ */ React245.createElement(ExtraContent_default, {
      ref: extraLeftRef,
      position: "left",
      extra,
      prefixCls
    }), /* @__PURE__ */ React245.createElement(es_default, {
      onResize: onListHolderResize
    }, /* @__PURE__ */ React245.createElement("div", {
      className: (0, import_classnames77.default)(wrapPrefix, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(wrapPrefix, "-ping-left"), pingLeft), "".concat(wrapPrefix, "-ping-right"), pingRight), "".concat(wrapPrefix, "-ping-top"), pingTop), "".concat(wrapPrefix, "-ping-bottom"), pingBottom)),
      ref: tabsWrapperRef
    }, /* @__PURE__ */ React245.createElement(es_default, {
      onResize: onListHolderResize
    }, /* @__PURE__ */ React245.createElement("div", {
      ref: tabListRef,
      className: "".concat(prefixCls, "-nav-list"),
      style: {
        transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
        transition: lockAnimation ? "none" : void 0
      }
    }, tabNodes, /* @__PURE__ */ React245.createElement(AddButton_default, {
      ref: innerAddButtonRef,
      prefixCls,
      locale: locale6,
      editable,
      style: _objectSpread2(_objectSpread2({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
        visibility: hasDropdown ? "hidden" : null
      })
    }), /* @__PURE__ */ React245.createElement("div", {
      className: (0, import_classnames77.default)("".concat(prefixCls, "-ink-bar"), _defineProperty({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
      style: indicatorStyle
    }))))), /* @__PURE__ */ React245.createElement(OperationNode_default, _extends({}, props, {
      removeAriaLabel: locale6 === null || locale6 === void 0 ? void 0 : locale6.removeAriaLabel,
      ref: operationsRef,
      prefixCls,
      tabs: hiddenTabs,
      className: !hasDropdown && operationsHiddenClassName,
      tabMoving: !!lockAnimation
    })), /* @__PURE__ */ React245.createElement(ExtraContent_default, {
      ref: extraRightRef,
      position: "right",
      extra,
      prefixCls
    })));
  });
  var TabNavList_default = TabNavList;

  // node_modules/rc-tabs/es/TabPanelList/TabPane.js
  var import_classnames78 = __toESM(require_classnames());
  var React246 = __toESM(require_react());
  var TabPane = /* @__PURE__ */ React246.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, className = props.className, style2 = props.style, id = props.id, active = props.active, tabKey = props.tabKey, children = props.children;
    return /* @__PURE__ */ React246.createElement("div", {
      id: id && "".concat(id, "-panel-").concat(tabKey),
      role: "tabpanel",
      tabIndex: active ? 0 : -1,
      "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
      "aria-hidden": !active,
      style: style2,
      className: (0, import_classnames78.default)(prefixCls, active && "".concat(prefixCls, "-active"), className),
      ref
    }, children);
  });
  if (true) {
    TabPane.displayName = "TabPane";
  }
  var TabPane_default = TabPane;

  // node_modules/rc-tabs/es/TabNavList/Wrapper.js
  var _excluded39 = ["renderTabBar"];
  var _excluded212 = ["label", "key"];
  var TabNavListWrapper = function TabNavListWrapper2(_ref) {
    var renderTabBar = _ref.renderTabBar, restProps = _objectWithoutProperties(_ref, _excluded39);
    var _React$useContext = React247.useContext(TabContext_default), tabs = _React$useContext.tabs;
    if (renderTabBar) {
      var tabNavBarProps = _objectSpread2(_objectSpread2({}, restProps), {}, {
        // Legacy support. We do not use this actually
        panes: tabs.map(function(_ref2) {
          var label = _ref2.label, key = _ref2.key, restTabProps = _objectWithoutProperties(_ref2, _excluded212);
          return /* @__PURE__ */ React247.createElement(TabPane_default, _extends({
            tab: label,
            key,
            tabKey: key
          }, restTabProps));
        })
      });
      return renderTabBar(tabNavBarProps, TabNavList_default);
    }
    return /* @__PURE__ */ React247.createElement(TabNavList_default, restProps);
  };
  if (true) {
    TabNavListWrapper.displayName = "TabNavListWrapper";
  }
  var Wrapper_default = TabNavListWrapper;

  // node_modules/rc-tabs/es/TabPanelList/index.js
  var import_classnames79 = __toESM(require_classnames());
  var React248 = __toESM(require_react());
  var _excluded40 = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"];
  var TabPanelList = function TabPanelList2(props) {
    var id = props.id, activeKey = props.activeKey, animated = props.animated, tabPosition = props.tabPosition, destroyInactiveTabPane = props.destroyInactiveTabPane;
    var _React$useContext = React248.useContext(TabContext_default), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
    var tabPaneAnimated = animated.tabPane;
    var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
    return /* @__PURE__ */ React248.createElement("div", {
      className: (0, import_classnames79.default)("".concat(prefixCls, "-content-holder"))
    }, /* @__PURE__ */ React248.createElement("div", {
      className: (0, import_classnames79.default)("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated))
    }, tabs.map(function(item) {
      var key = item.key, forceRender = item.forceRender, paneStyle = item.style, paneClassName = item.className, itemDestroyInactiveTabPane = item.destroyInactiveTabPane, restTabProps = _objectWithoutProperties(item, _excluded40);
      var active = key === activeKey;
      return /* @__PURE__ */ React248.createElement(es_default2, _extends({
        key,
        visible: active,
        forceRender,
        removeOnLeave: !!(destroyInactiveTabPane || itemDestroyInactiveTabPane),
        leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
      }, animated.tabPaneMotion), function(_ref, ref) {
        var motionStyle = _ref.style, motionClassName = _ref.className;
        return /* @__PURE__ */ React248.createElement(TabPane_default, _extends({}, restTabProps, {
          prefixCls: tabPanePrefixCls,
          id,
          tabKey: key,
          animated: tabPaneAnimated,
          active,
          style: _objectSpread2(_objectSpread2({}, paneStyle), motionStyle),
          className: (0, import_classnames79.default)(paneClassName, motionClassName),
          ref
        }));
      });
    })));
  };
  var TabPanelList_default = TabPanelList;

  // node_modules/rc-tabs/es/hooks/useAnimateConfig.js
  function useAnimateConfig() {
    var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      inkBar: true,
      tabPane: false
    };
    var mergedAnimated;
    if (animated === false) {
      mergedAnimated = {
        inkBar: false,
        tabPane: false
      };
    } else if (animated === true) {
      mergedAnimated = {
        inkBar: true,
        tabPane: false
      };
    } else {
      mergedAnimated = _objectSpread2({
        inkBar: true
      }, _typeof(animated) === "object" ? animated : {});
    }
    if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
      mergedAnimated.tabPane = true;
    }
    if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
      if (true) {
        warning_default(false, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work.");
      }
      mergedAnimated.tabPane = false;
    }
    return mergedAnimated;
  }

  // node_modules/rc-tabs/es/Tabs.js
  var _excluded41 = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "more", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicator"];
  var uuid6 = 0;
  var Tabs = /* @__PURE__ */ React249.forwardRef(function(props, ref) {
    var id = props.id, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tabs" : _props$prefixCls, className = props.className, items = props.items, direction = props.direction, activeKey = props.activeKey, defaultActiveKey = props.defaultActiveKey, editable = props.editable, animated = props.animated, _props$tabPosition = props.tabPosition, tabPosition = _props$tabPosition === void 0 ? "top" : _props$tabPosition, tabBarGutter = props.tabBarGutter, tabBarStyle = props.tabBarStyle, tabBarExtraContent = props.tabBarExtraContent, locale6 = props.locale, more = props.more, destroyInactiveTabPane = props.destroyInactiveTabPane, renderTabBar = props.renderTabBar, onChange = props.onChange, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName, indicator = props.indicator, restProps = _objectWithoutProperties(props, _excluded41);
    var tabs = React249.useMemo(function() {
      return (items || []).filter(function(item) {
        return item && _typeof(item) === "object" && "key" in item;
      });
    }, [items]);
    var rtl = direction === "rtl";
    var mergedAnimated = useAnimateConfig(animated);
    var _useState = (0, import_react90.useState)(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
    (0, import_react90.useEffect)(function() {
      setMobile(isMobile_default());
    }, []);
    var _useMergedState = useMergedState(function() {
      var _tabs$;
      return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
    }, {
      value: activeKey,
      defaultValue: defaultActiveKey
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
    var _useState3 = (0, import_react90.useState)(function() {
      return tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey;
      });
    }), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
    (0, import_react90.useEffect)(function() {
      var newActiveIndex = tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey;
      });
      if (newActiveIndex === -1) {
        var _tabs$newActiveIndex;
        newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
        setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
      }
      setActiveIndex(newActiveIndex);
    }, [tabs.map(function(tab) {
      return tab.key;
    }).join("_"), mergedActiveKey, activeIndex]);
    var _useMergedState3 = useMergedState(null, {
      value: id
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
    (0, import_react90.useEffect)(function() {
      if (!id) {
        setMergedId("rc-tabs-".concat(false ? "test" : uuid6));
        uuid6 += 1;
      }
    }, []);
    function onInternalTabClick(key, e3) {
      onTabClick === null || onTabClick === void 0 || onTabClick(key, e3);
      var isActiveChanged = key !== mergedActiveKey;
      setMergedActiveKey(key);
      if (isActiveChanged) {
        onChange === null || onChange === void 0 || onChange(key);
      }
    }
    var sharedProps = {
      id: mergedId,
      activeKey: mergedActiveKey,
      animated: mergedAnimated,
      tabPosition,
      rtl,
      mobile
    };
    var tabNavBarProps = _objectSpread2(_objectSpread2({}, sharedProps), {}, {
      editable,
      locale: locale6,
      more,
      tabBarGutter,
      onTabClick: onInternalTabClick,
      onTabScroll,
      extra: tabBarExtraContent,
      style: tabBarStyle,
      panes: null,
      getPopupContainer,
      popupClassName,
      indicator
    });
    return /* @__PURE__ */ React249.createElement(TabContext_default.Provider, {
      value: {
        tabs,
        prefixCls
      }
    }, /* @__PURE__ */ React249.createElement("div", _extends({
      ref,
      id,
      className: (0, import_classnames80.default)(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), _defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-mobile"), mobile), "".concat(prefixCls, "-editable"), editable), "".concat(prefixCls, "-rtl"), rtl), className)
    }, restProps), /* @__PURE__ */ React249.createElement(Wrapper_default, _extends({}, tabNavBarProps, {
      renderTabBar
    })), /* @__PURE__ */ React249.createElement(TabPanelList_default, _extends({
      destroyInactiveTabPane
    }, sharedProps, {
      animated: mergedAnimated
    }))));
  });
  if (true) {
    Tabs.displayName = "Tabs";
  }
  var Tabs_default = Tabs;

  // node_modules/rc-tabs/es/index.js
  var es_default15 = Tabs_default;

  // node_modules/antd/es/tabs/hooks/useAnimateConfig.js
  var motion = {
    motionAppear: false,
    motionEnter: true,
    motionLeave: true
  };
  function useAnimateConfig2(prefixCls, animated = {
    inkBar: true,
    tabPane: false
  }) {
    let mergedAnimated;
    if (animated === false) {
      mergedAnimated = {
        inkBar: false,
        tabPane: false
      };
    } else if (animated === true) {
      mergedAnimated = {
        inkBar: true,
        tabPane: true
      };
    } else {
      mergedAnimated = Object.assign({
        inkBar: true
      }, typeof animated === "object" ? animated : {});
    }
    if (mergedAnimated.tabPane) {
      mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), {
        motionName: getTransitionName2(prefixCls, "switch")
      });
    }
    return mergedAnimated;
  }

  // node_modules/antd/es/tabs/hooks/useLegacyItems.js
  var React250 = __toESM(require_react());
  var __rest22 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function filter(items) {
    return items.filter((item) => item);
  }
  function useLegacyItems(items, children) {
    if (true) {
      const warning6 = devUseWarning("Tabs");
      warning6.deprecated(!children, "Tabs.TabPane", "items");
    }
    if (items) {
      return items.map((item) => {
        var _a;
        const mergedDestroyOnHidden = (_a = item.destroyOnHidden) !== null && _a !== void 0 ? _a : item.destroyInactiveTabPane;
        return Object.assign(Object.assign({}, item), {
          // TODO: In the future, destroyInactiveTabPane in rc-tabs needs to be upgrade to destroyOnHidden
          destroyInactiveTabPane: mergedDestroyOnHidden
        });
      });
    }
    const childrenItems = toArray(children).map((node2) => {
      if (/* @__PURE__ */ React250.isValidElement(node2)) {
        const {
          key,
          props
        } = node2;
        const _a = props || {}, {
          tab
        } = _a, restProps = __rest22(_a, ["tab"]);
        const item = Object.assign(Object.assign({
          key: String(key)
        }, restProps), {
          label: tab
        });
        return item;
      }
      return null;
    });
    return filter(childrenItems);
  }
  var useLegacyItems_default = useLegacyItems;

  // node_modules/antd/es/tabs/style/motion.js
  var genMotionStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow
    } = token2;
    return [
      {
        [componentCls]: {
          [`${componentCls}-switch`]: {
            "&-appear, &-enter": {
              transition: "none",
              "&-start": {
                opacity: 0
              },
              "&-active": {
                opacity: 1,
                transition: `opacity ${motionDurationSlow}`
              }
            },
            "&-leave": {
              position: "absolute",
              transition: "none",
              inset: 0,
              "&-start": {
                opacity: 1
              },
              "&-active": {
                opacity: 0,
                transition: `opacity ${motionDurationSlow}`
              }
            }
          }
        }
      },
      // Follow code may reuse in other components
      [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
    ];
  };
  var motion_default2 = genMotionStyle;

  // node_modules/antd/es/tabs/style/index.js
  var genCardStyle = (token2) => {
    const {
      componentCls,
      tabsCardPadding,
      cardBg,
      cardGutter,
      colorBorderSecondary,
      itemSelectedColor
    } = token2;
    return {
      [`${componentCls}-card`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            margin: 0,
            padding: tabsCardPadding,
            background: cardBg,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          },
          [`${componentCls}-tab-active`]: {
            color: itemSelectedColor,
            background: token2.colorBgContainer
          },
          [`${componentCls}-tab-focus:has(${componentCls}-tab-btn:focus-visible)`]: genFocusOutline(token2, -3),
          [`& ${componentCls}-tab${componentCls}-tab-focus ${componentCls}-tab-btn:focus-visible`]: {
            outline: "none"
          },
          [`${componentCls}-ink-bar`]: {
            visibility: "hidden"
          }
        },
        // ========================== Top & Bottom ==========================
        [`&${componentCls}-top, &${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginLeft: {
                _skip_check_: true,
                value: unit(cardGutter)
              }
            }
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`
            },
            [`${componentCls}-tab-active`]: {
              borderBottomColor: token2.colorBgContainer
            }
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
            },
            [`${componentCls}-tab-active`]: {
              borderTopColor: token2.colorBgContainer
            }
          }
        },
        // ========================== Left & Right ==========================
        [`&${componentCls}-left, &${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginTop: unit(cardGutter)
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `${unit(token2.borderRadiusLG)} 0 0 ${unit(token2.borderRadiusLG)}`
              }
            },
            [`${componentCls}-tab-active`]: {
              borderRightColor: {
                _skip_check_: true,
                value: token2.colorBgContainer
              }
            }
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0`
              }
            },
            [`${componentCls}-tab-active`]: {
              borderLeftColor: {
                _skip_check_: true,
                value: token2.colorBgContainer
              }
            }
          }
        }
      }
    };
  };
  var genDropdownStyle = (token2) => {
    const {
      componentCls,
      itemHoverColor,
      dropdownEdgeChildVerticalPadding
    } = token2;
    return {
      [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: token2.zIndexPopup,
        display: "block",
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-dropdown-menu`]: {
          maxHeight: token2.tabsDropdownHeight,
          margin: 0,
          padding: `${unit(dropdownEdgeChildVerticalPadding)} 0`,
          overflowX: "hidden",
          overflowY: "auto",
          textAlign: {
            _skip_check_: true,
            value: "left"
          },
          listStyleType: "none",
          backgroundColor: token2.colorBgContainer,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          "&-item": Object.assign(Object.assign({}, textEllipsis), {
            display: "flex",
            alignItems: "center",
            minWidth: token2.tabsDropdownWidth,
            margin: 0,
            padding: `${unit(token2.paddingXXS)} ${unit(token2.paddingSM)}`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            "> span": {
              flex: 1,
              whiteSpace: "nowrap"
            },
            "&-remove": {
              flex: "none",
              marginLeft: {
                _skip_check_: true,
                value: token2.marginSM
              },
              color: token2.colorIcon,
              fontSize: token2.fontSizeSM,
              background: "transparent",
              border: 0,
              cursor: "pointer",
              "&:hover": {
                color: itemHoverColor
              }
            },
            "&:hover": {
              background: token2.controlItemBgHover
            },
            "&-disabled": {
              "&, &:hover": {
                color: token2.colorTextDisabled,
                background: "transparent",
                cursor: "not-allowed"
              }
            }
          })
        }
      })
    };
  };
  var genPositionStyle = (token2) => {
    const {
      componentCls,
      margin,
      colorBorderSecondary,
      horizontalMargin,
      verticalItemPadding,
      verticalItemMargin,
      calc
    } = token2;
    return {
      // ========================== Top & Bottom ==========================
      [`${componentCls}-top, ${componentCls}-bottom`]: {
        flexDirection: "column",
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          margin: horizontalMargin,
          "&::before": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
            content: "''"
          },
          [`${componentCls}-ink-bar`]: {
            height: token2.lineWidthBold,
            "&-animated": {
              transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
            }
          },
          [`${componentCls}-nav-wrap`]: {
            "&::before, &::after": {
              top: 0,
              bottom: 0,
              width: token2.controlHeight
            },
            "&::before": {
              left: {
                _skip_check_: true,
                value: 0
              },
              boxShadow: token2.boxShadowTabsOverflowLeft
            },
            "&::after": {
              right: {
                _skip_check_: true,
                value: 0
              },
              boxShadow: token2.boxShadowTabsOverflowRight
            },
            [`&${componentCls}-nav-wrap-ping-left::before`]: {
              opacity: 1
            },
            [`&${componentCls}-nav-wrap-ping-right::after`]: {
              opacity: 1
            }
          }
        }
      },
      [`${componentCls}-top`]: {
        [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
          "&::before": {
            bottom: 0
          },
          [`${componentCls}-ink-bar`]: {
            bottom: 0
          }
        }
      },
      [`${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          order: 1,
          marginTop: margin,
          marginBottom: 0,
          "&::before": {
            top: 0
          },
          [`${componentCls}-ink-bar`]: {
            top: 0
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      // ========================== Left & Right ==========================
      [`${componentCls}-left, ${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          flexDirection: "column",
          minWidth: calc(token2.controlHeight).mul(1.25).equal(),
          // >>>>>>>>>>> Tab
          [`${componentCls}-tab`]: {
            padding: verticalItemPadding,
            textAlign: "center"
          },
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            margin: verticalItemMargin
          },
          // >>>>>>>>>>> Nav
          [`${componentCls}-nav-wrap`]: {
            flexDirection: "column",
            "&::before, &::after": {
              right: {
                _skip_check_: true,
                value: 0
              },
              left: {
                _skip_check_: true,
                value: 0
              },
              height: token2.controlHeight
            },
            "&::before": {
              top: 0,
              boxShadow: token2.boxShadowTabsOverflowTop
            },
            "&::after": {
              bottom: 0,
              boxShadow: token2.boxShadowTabsOverflowBottom
            },
            [`&${componentCls}-nav-wrap-ping-top::before`]: {
              opacity: 1
            },
            [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
              opacity: 1
            }
          },
          // >>>>>>>>>>> Ink Bar
          [`${componentCls}-ink-bar`]: {
            width: token2.lineWidthBold,
            "&-animated": {
              transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
            }
          },
          [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
            flex: "1 0 auto",
            // fix safari scroll problem
            flexDirection: "column"
          }
        }
      },
      [`${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-ink-bar`]: {
            right: {
              _skip_check_: true,
              value: 0
            }
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          marginLeft: {
            _skip_check_: true,
            value: unit(calc(token2.lineWidth).mul(-1).equal())
          },
          borderLeft: {
            _skip_check_: true,
            value: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          },
          [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
            paddingLeft: {
              _skip_check_: true,
              value: token2.paddingLG
            }
          }
        }
      },
      [`${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          order: 1,
          [`${componentCls}-ink-bar`]: {
            left: {
              _skip_check_: true,
              value: 0
            }
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          order: 0,
          marginRight: {
            _skip_check_: true,
            value: calc(token2.lineWidth).mul(-1).equal()
          },
          borderRight: {
            _skip_check_: true,
            value: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          },
          [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
            paddingRight: {
              _skip_check_: true,
              value: token2.paddingLG
            }
          }
        }
      }
    };
  };
  var genSizeStyle3 = (token2) => {
    const {
      componentCls,
      cardPaddingSM,
      cardPaddingLG,
      cardHeightSM,
      cardHeightLG,
      horizontalItemPaddingSM,
      horizontalItemPaddingLG
    } = token2;
    return {
      // >>>>> shared
      [componentCls]: {
        "&-small": {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: horizontalItemPaddingSM,
              fontSize: token2.titleFontSizeSM
            }
          }
        },
        "&-large": {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: horizontalItemPaddingLG,
              fontSize: token2.titleFontSizeLG,
              lineHeight: token2.lineHeightLG
            }
          }
        }
      },
      // >>>>> card
      [`${componentCls}-card`]: {
        // Small
        [`&${componentCls}-small`]: {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: cardPaddingSM
            },
            [`${componentCls}-nav-add`]: {
              minWidth: cardHeightSM,
              minHeight: cardHeightSM
            }
          },
          [`&${componentCls}-bottom`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: `0 0 ${unit(token2.borderRadius)} ${unit(token2.borderRadius)}`
            }
          },
          [`&${componentCls}-top`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: `${unit(token2.borderRadius)} ${unit(token2.borderRadius)} 0 0`
            }
          },
          [`&${componentCls}-right`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `0 ${unit(token2.borderRadius)} ${unit(token2.borderRadius)} 0`
              }
            }
          },
          [`&${componentCls}-left`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `${unit(token2.borderRadius)} 0 0 ${unit(token2.borderRadius)}`
              }
            }
          }
        },
        // Large
        [`&${componentCls}-large`]: {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: cardPaddingLG
            },
            [`${componentCls}-nav-add`]: {
              minWidth: cardHeightLG,
              minHeight: cardHeightLG
            }
          }
        }
      }
    };
  };
  var genTabStyle = (token2) => {
    const {
      componentCls,
      itemActiveColor,
      itemHoverColor,
      iconCls,
      tabsHorizontalItemMargin,
      horizontalItemPadding,
      itemSelectedColor,
      itemColor
    } = token2;
    const tabCls = `${componentCls}-tab`;
    return {
      [tabCls]: {
        position: "relative",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        display: "inline-flex",
        alignItems: "center",
        padding: horizontalItemPadding,
        fontSize: token2.titleFontSize,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        color: itemColor,
        "&-btn, &-remove": {
          "&:focus:not(:focus-visible), &:active": {
            color: itemActiveColor
          }
        },
        "&-btn": {
          outline: "none",
          transition: `all ${token2.motionDurationSlow}`,
          [`${tabCls}-icon:not(:last-child)`]: {
            marginInlineEnd: token2.marginSM
          }
        },
        "&-remove": Object.assign({
          flex: "none",
          marginRight: {
            _skip_check_: true,
            value: token2.calc(token2.marginXXS).mul(-1).equal()
          },
          marginLeft: {
            _skip_check_: true,
            value: token2.marginXS
          },
          color: token2.colorIcon,
          fontSize: token2.fontSizeSM,
          background: "transparent",
          border: "none",
          outline: "none",
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "&:hover": {
            color: token2.colorTextHeading
          }
        }, genFocusStyle(token2)),
        "&:hover": {
          color: itemHoverColor
        },
        [`&${tabCls}-active ${tabCls}-btn`]: {
          color: itemSelectedColor,
          textShadow: token2.tabsActiveTextShadow
        },
        [`&${tabCls}-focus ${tabCls}-btn:focus-visible`]: genFocusOutline(token2),
        [`&${tabCls}-disabled`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
          "&:focus, &:active": {
            color: token2.colorTextDisabled
          }
        },
        [`& ${tabCls}-remove ${iconCls}`]: {
          margin: 0
        },
        [`${iconCls}:not(:last-child)`]: {
          marginRight: {
            _skip_check_: true,
            value: token2.marginSM
          }
        }
      },
      [`${tabCls} + ${tabCls}`]: {
        margin: {
          _skip_check_: true,
          value: tabsHorizontalItemMargin
        }
      }
    };
  };
  var genRtlStyle = (token2) => {
    const {
      componentCls,
      tabsHorizontalItemMarginRTL,
      iconCls,
      cardGutter,
      calc
    } = token2;
    const rtlCls = `${componentCls}-rtl`;
    return {
      [rtlCls]: {
        direction: "rtl",
        [`${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            margin: {
              _skip_check_: true,
              value: tabsHorizontalItemMarginRTL
            },
            [`${componentCls}-tab:last-of-type`]: {
              marginLeft: {
                _skip_check_: true,
                value: 0
              }
            },
            [iconCls]: {
              marginRight: {
                _skip_check_: true,
                value: 0
              },
              marginLeft: {
                _skip_check_: true,
                value: unit(token2.marginSM)
              }
            },
            [`${componentCls}-tab-remove`]: {
              marginRight: {
                _skip_check_: true,
                value: unit(token2.marginXS)
              },
              marginLeft: {
                _skip_check_: true,
                value: unit(calc(token2.marginXXS).mul(-1).equal())
              },
              [iconCls]: {
                margin: 0
              }
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav`]: {
            order: 1
          },
          [`> ${componentCls}-content-holder`]: {
            order: 0
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav`]: {
            order: 0
          },
          [`> ${componentCls}-content-holder`]: {
            order: 1
          }
        },
        // ====================== Card ======================
        [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginRight: {
                _skip_check_: true,
                value: cardGutter
              },
              marginLeft: {
                _skip_check_: true,
                value: 0
              }
            }
          }
        }
      },
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-menu-item`]: {
        [`${componentCls}-dropdown-rtl`]: {
          textAlign: {
            _skip_check_: true,
            value: "right"
          }
        }
      }
    };
  };
  var genTabsStyle = (token2) => {
    const {
      componentCls,
      tabsCardPadding,
      cardHeight,
      cardGutter,
      itemHoverColor,
      itemActiveColor,
      colorBorderSecondary
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "flex",
        // ========================== Navigation ==========================
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          position: "relative",
          display: "flex",
          flex: "none",
          alignItems: "center",
          [`${componentCls}-nav-wrap`]: {
            position: "relative",
            display: "flex",
            flex: "auto",
            alignSelf: "stretch",
            overflow: "hidden",
            whiteSpace: "nowrap",
            transform: "translate(0)",
            // Fix chrome render bug
            // >>>>> Ping shadow
            "&::before, &::after": {
              position: "absolute",
              zIndex: 1,
              opacity: 0,
              transition: `opacity ${token2.motionDurationSlow}`,
              content: "''",
              pointerEvents: "none"
            }
          },
          [`${componentCls}-nav-list`]: {
            position: "relative",
            display: "flex",
            transition: `opacity ${token2.motionDurationSlow}`
          },
          // >>>>>>>> Operations
          [`${componentCls}-nav-operations`]: {
            display: "flex",
            alignSelf: "stretch"
          },
          [`${componentCls}-nav-operations-hidden`]: {
            position: "absolute",
            visibility: "hidden",
            pointerEvents: "none"
          },
          [`${componentCls}-nav-more`]: {
            position: "relative",
            padding: tabsCardPadding,
            background: "transparent",
            border: 0,
            color: token2.colorText,
            "&::after": {
              position: "absolute",
              right: {
                _skip_check_: true,
                value: 0
              },
              bottom: 0,
              left: {
                _skip_check_: true,
                value: 0
              },
              height: token2.calc(token2.controlHeightLG).div(8).equal(),
              transform: "translateY(100%)",
              content: "''"
            }
          },
          [`${componentCls}-nav-add`]: Object.assign({
            minWidth: cardHeight,
            minHeight: cardHeight,
            marginLeft: {
              _skip_check_: true,
              value: cardGutter
            },
            background: "transparent",
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
            borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
            outline: "none",
            cursor: "pointer",
            color: token2.colorText,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
            "&:hover": {
              color: itemHoverColor
            },
            "&:active, &:focus:not(:focus-visible)": {
              color: itemActiveColor
            }
          }, genFocusStyle(token2, -3))
        },
        [`${componentCls}-extra-content`]: {
          flex: "none"
        },
        // ============================ InkBar ============================
        [`${componentCls}-ink-bar`]: {
          position: "absolute",
          background: token2.inkBarColor,
          pointerEvents: "none"
        }
      }), genTabStyle(token2)), {
        // =========================== TabPanes ===========================
        [`${componentCls}-content`]: {
          position: "relative",
          width: "100%"
        },
        [`${componentCls}-content-holder`]: {
          flex: "auto",
          minWidth: 0,
          minHeight: 0
        },
        [`${componentCls}-tabpane`]: Object.assign(Object.assign({}, genFocusStyle(token2)), {
          "&-hidden": {
            display: "none"
          }
        })
      }),
      [`${componentCls}-centered`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-nav-wrap`]: {
            [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: {
              margin: "auto"
            }
          }
        }
      }
    };
  };
  var prepareComponentToken11 = (token2) => {
    const {
      cardHeight,
      cardHeightSM,
      cardHeightLG,
      controlHeight,
      controlHeightLG
    } = token2;
    const mergedCardHeight = cardHeight || controlHeightLG;
    const mergedCardHeightSM = cardHeightSM || controlHeight;
    const mergedCardHeightLG = cardHeightLG || controlHeightLG + 8;
    return {
      zIndexPopup: token2.zIndexPopupBase + 50,
      cardBg: token2.colorFillAlter,
      // We can not pass this as valid value,
      // Since `cardHeight` will lock nav add button height.
      cardHeight: mergedCardHeight,
      cardHeightSM: mergedCardHeightSM,
      cardHeightLG: mergedCardHeightLG,
      // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
      cardPadding: `${(mergedCardHeight - token2.fontHeight) / 2 - token2.lineWidth}px ${token2.padding}px`,
      cardPaddingSM: `${(mergedCardHeightSM - token2.fontHeight) / 2 - token2.lineWidth}px ${token2.paddingXS}px`,
      cardPaddingLG: `${(mergedCardHeightLG - token2.fontHeightLG) / 2 - token2.lineWidth}px ${token2.padding}px`,
      titleFontSize: token2.fontSize,
      titleFontSizeLG: token2.fontSizeLG,
      titleFontSizeSM: token2.fontSize,
      inkBarColor: token2.colorPrimary,
      horizontalMargin: `0 0 ${token2.margin}px 0`,
      horizontalItemGutter: 32,
      // Fixed Value
      // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
      horizontalItemMargin: ``,
      horizontalItemMarginRTL: ``,
      horizontalItemPadding: `${token2.paddingSM}px 0`,
      horizontalItemPaddingSM: `${token2.paddingXS}px 0`,
      horizontalItemPaddingLG: `${token2.padding}px 0`,
      verticalItemPadding: `${token2.paddingXS}px ${token2.paddingLG}px`,
      verticalItemMargin: `${token2.margin}px 0 0 0`,
      itemColor: token2.colorText,
      itemSelectedColor: token2.colorPrimary,
      itemHoverColor: token2.colorPrimaryHover,
      itemActiveColor: token2.colorPrimaryActive,
      cardGutter: token2.marginXXS / 2
    };
  };
  var style_default15 = genStyleHooks("Tabs", (token2) => {
    const tabsToken = merge2(token2, {
      // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
      tabsCardPadding: token2.cardPadding,
      dropdownEdgeChildVerticalPadding: token2.paddingXXS,
      tabsActiveTextShadow: "0 0 0.25px currentcolor",
      tabsDropdownHeight: 200,
      tabsDropdownWidth: 120,
      tabsHorizontalItemMargin: `0 0 0 ${unit(token2.horizontalItemGutter)}`,
      tabsHorizontalItemMarginRTL: `0 0 0 ${unit(token2.horizontalItemGutter)}`
    });
    return [genSizeStyle3(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), motion_default2(tabsToken)];
  }, prepareComponentToken11);

  // node_modules/antd/es/tabs/TabPane.js
  var TabPane2 = () => null;
  if (true) {
    TabPane2.displayName = "DeprecatedTabPane";
  }
  var TabPane_default2 = TabPane2;

  // node_modules/antd/es/tabs/index.js
  var __rest23 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Tabs2 = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const {
      type: type5,
      className,
      rootClassName,
      size: customSize,
      onEdit,
      hideAdd,
      centered,
      addIcon,
      removeIcon,
      moreIcon,
      more,
      popupClassName,
      children,
      items,
      animated,
      style: style2,
      indicatorSize,
      indicator,
      destroyInactiveTabPane,
      destroyOnHidden
    } = props, otherProps = __rest23(props, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "removeIcon", "moreIcon", "more", "popupClassName", "children", "items", "animated", "style", "indicatorSize", "indicator", "destroyInactiveTabPane", "destroyOnHidden"]);
    const {
      prefixCls: customizePrefixCls
    } = otherProps;
    const {
      direction,
      tabs,
      getPrefixCls,
      getPopupContainer
    } = React251.useContext(ConfigContext);
    const prefixCls = getPrefixCls("tabs", customizePrefixCls);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default15(prefixCls, rootCls);
    let editable;
    if (type5 === "editable-card") {
      editable = {
        onEdit: (editType, {
          key,
          event
        }) => {
          onEdit === null || onEdit === void 0 ? void 0 : onEdit(editType === "add" ? event : key, editType);
        },
        removeIcon: (_a = removeIcon !== null && removeIcon !== void 0 ? removeIcon : tabs === null || tabs === void 0 ? void 0 : tabs.removeIcon) !== null && _a !== void 0 ? _a : /* @__PURE__ */ React251.createElement(CloseOutlined_default2, null),
        addIcon: (addIcon !== null && addIcon !== void 0 ? addIcon : tabs === null || tabs === void 0 ? void 0 : tabs.addIcon) || /* @__PURE__ */ React251.createElement(PlusOutlined_default2, null),
        showAdd: hideAdd !== true
      };
    }
    const rootPrefixCls = getPrefixCls();
    if (true) {
      const warning6 = devUseWarning("Tabs");
      true ? warning6(!("onPrevClick" in props) && !("onNextClick" in props), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead.") : void 0;
      true ? warning6(!(indicatorSize || (tabs === null || tabs === void 0 ? void 0 : tabs.indicatorSize)), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.") : void 0;
      warning6.deprecated(!("destroyInactiveTabPane" in props || (items === null || items === void 0 ? void 0 : items.some((item) => "destroyInactiveTabPane" in item))), "destroyInactiveTabPane", "destroyOnHidden");
    }
    const size = useSize_default(customSize);
    const mergedItems = useLegacyItems_default(items, children);
    const mergedAnimated = useAnimateConfig2(prefixCls, animated);
    const mergedStyle = Object.assign(Object.assign({}, tabs === null || tabs === void 0 ? void 0 : tabs.style), style2);
    const mergedIndicator = {
      align: (_b = indicator === null || indicator === void 0 ? void 0 : indicator.align) !== null && _b !== void 0 ? _b : (_c = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _c === void 0 ? void 0 : _c.align,
      size: (_g = (_e = (_d = indicator === null || indicator === void 0 ? void 0 : indicator.size) !== null && _d !== void 0 ? _d : indicatorSize) !== null && _e !== void 0 ? _e : (_f = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _f === void 0 ? void 0 : _f.size) !== null && _g !== void 0 ? _g : tabs === null || tabs === void 0 ? void 0 : tabs.indicatorSize
    };
    return wrapCSSVar(/* @__PURE__ */ React251.createElement(es_default15, Object.assign({
      direction,
      getPopupContainer
    }, otherProps, {
      items: mergedItems,
      className: (0, import_classnames81.default)({
        [`${prefixCls}-${size}`]: size,
        [`${prefixCls}-card`]: ["card", "editable-card"].includes(type5),
        [`${prefixCls}-editable-card`]: type5 === "editable-card",
        [`${prefixCls}-centered`]: centered
      }, tabs === null || tabs === void 0 ? void 0 : tabs.className, className, rootClassName, hashId, cssVarCls, rootCls),
      popupClassName: (0, import_classnames81.default)(popupClassName, hashId, cssVarCls, rootCls),
      style: mergedStyle,
      editable,
      more: Object.assign({
        icon: (_l = (_k = (_j = (_h = tabs === null || tabs === void 0 ? void 0 : tabs.more) === null || _h === void 0 ? void 0 : _h.icon) !== null && _j !== void 0 ? _j : tabs === null || tabs === void 0 ? void 0 : tabs.moreIcon) !== null && _k !== void 0 ? _k : moreIcon) !== null && _l !== void 0 ? _l : /* @__PURE__ */ React251.createElement(EllipsisOutlined_default2, null),
        transitionName: `${rootPrefixCls}-slide-up`
      }, more),
      prefixCls,
      animated: mergedAnimated,
      indicator: mergedIndicator,
      // TODO: In the future, destroyInactiveTabPane in rc-tabs needs to be upgrade to destroyOnHidden
      destroyInactiveTabPane: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyInactiveTabPane
    })));
  };
  Tabs2.TabPane = TabPane_default2;
  if (true) {
    Tabs2.displayName = "Tabs";
  }
  var tabs_default = Tabs2;

  // node_modules/antd/es/card/Grid.js
  var React252 = __toESM(require_react());
  var import_classnames82 = __toESM(require_classnames());
  var __rest24 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Grid = (_a) => {
    var {
      prefixCls,
      className,
      hoverable = true
    } = _a, props = __rest24(_a, ["prefixCls", "className", "hoverable"]);
    const {
      getPrefixCls
    } = React252.useContext(ConfigContext);
    const prefix = getPrefixCls("card", prefixCls);
    const classString = (0, import_classnames82.default)(`${prefix}-grid`, className, {
      [`${prefix}-grid-hoverable`]: hoverable
    });
    return /* @__PURE__ */ React252.createElement("div", Object.assign({}, props, {
      className: classString
    }));
  };
  var Grid_default = Grid;

  // node_modules/antd/es/card/style/index.js
  var genCardHeadStyle = (token2) => {
    const {
      antCls,
      componentCls,
      headerHeight,
      headerPadding,
      tabsMarginBottom
    } = token2;
    return Object.assign(Object.assign({
      display: "flex",
      justifyContent: "center",
      flexDirection: "column",
      minHeight: headerHeight,
      marginBottom: -1,
      padding: `0 ${unit(headerPadding)}`,
      color: token2.colorTextHeading,
      fontWeight: token2.fontWeightStrong,
      fontSize: token2.headerFontSize,
      background: token2.headerBg,
      borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`,
      borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`
    }, clearFix()), {
      "&-wrapper": {
        width: "100%",
        display: "flex",
        alignItems: "center"
      },
      "&-title": Object.assign(Object.assign({
        display: "inline-block",
        flex: 1
      }, textEllipsis), {
        [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
          insetInlineStart: 0,
          marginTop: 0,
          marginBottom: 0
        }
      }),
      [`${antCls}-tabs-top`]: {
        clear: "both",
        marginBottom: tabsMarginBottom,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        "&-bar": {
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`
        }
      }
    });
  };
  var genCardGridStyle = (token2) => {
    const {
      cardPaddingBase,
      colorBorderSecondary,
      cardShadow,
      lineWidth
    } = token2;
    return {
      width: "33.33%",
      padding: cardPaddingBase,
      border: 0,
      borderRadius: 0,
      boxShadow: `
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
      transition: `all ${token2.motionDurationMid}`,
      "&-hoverable:hover": {
        position: "relative",
        zIndex: 1,
        boxShadow: cardShadow
      }
    };
  };
  var genCardActionsStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      actionsLiMargin,
      cardActionsIconSize,
      colorBorderSecondary,
      actionsBg
    } = token2;
    return Object.assign(Object.assign({
      margin: 0,
      padding: 0,
      listStyle: "none",
      background: actionsBg,
      borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
      display: "flex",
      borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
    }, clearFix()), {
      "& > li": {
        margin: actionsLiMargin,
        color: token2.colorTextDescription,
        textAlign: "center",
        "> span": {
          position: "relative",
          display: "block",
          minWidth: token2.calc(token2.cardActionsIconSize).mul(2).equal(),
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          cursor: "pointer",
          "&:hover": {
            color: token2.colorPrimary,
            transition: `color ${token2.motionDurationMid}`
          },
          [`a:not(${componentCls}-btn), > ${iconCls}`]: {
            display: "inline-block",
            width: "100%",
            color: token2.colorIcon,
            lineHeight: unit(token2.fontHeight),
            transition: `color ${token2.motionDurationMid}`,
            "&:hover": {
              color: token2.colorPrimary
            }
          },
          [`> ${iconCls}`]: {
            fontSize: cardActionsIconSize,
            lineHeight: unit(token2.calc(cardActionsIconSize).mul(token2.lineHeight).equal())
          }
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`
        }
      }
    });
  };
  var genCardMetaStyle = (token2) => Object.assign(Object.assign({
    margin: `${unit(token2.calc(token2.marginXXS).mul(-1).equal())} 0`,
    display: "flex"
  }, clearFix()), {
    "&-avatar": {
      paddingInlineEnd: token2.padding
    },
    "&-detail": {
      overflow: "hidden",
      flex: 1,
      "> div:not(:last-child)": {
        marginBottom: token2.marginXS
      }
    },
    "&-title": Object.assign({
      color: token2.colorTextHeading,
      fontWeight: token2.fontWeightStrong,
      fontSize: token2.fontSizeLG
    }, textEllipsis),
    "&-description": {
      color: token2.colorTextDescription
    }
  });
  var genCardTypeInnerStyle = (token2) => {
    const {
      componentCls,
      colorFillAlter,
      headerPadding,
      bodyPadding
    } = token2;
    return {
      [`${componentCls}-head`]: {
        padding: `0 ${unit(headerPadding)}`,
        background: colorFillAlter,
        "&-title": {
          fontSize: token2.fontSize
        }
      },
      [`${componentCls}-body`]: {
        padding: `${unit(token2.padding)} ${unit(bodyPadding)}`
      }
    };
  };
  var genCardLoadingStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      overflow: "hidden",
      [`${componentCls}-body`]: {
        userSelect: "none"
      }
    };
  };
  var genCardStyle2 = (token2) => {
    const {
      componentCls,
      cardShadow,
      cardHeadPadding,
      colorBorderSecondary,
      boxShadowTertiary,
      bodyPadding,
      extraColor
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "relative",
        background: token2.colorBgContainer,
        borderRadius: token2.borderRadiusLG,
        [`&:not(${componentCls}-bordered)`]: {
          boxShadow: boxShadowTertiary
        },
        [`${componentCls}-head`]: genCardHeadStyle(token2),
        [`${componentCls}-extra`]: {
          // https://stackoverflow.com/a/22429853/3040605
          marginInlineStart: "auto",
          color: extraColor,
          fontWeight: "normal",
          fontSize: token2.fontSize
        },
        [`${componentCls}-body`]: Object.assign({
          padding: bodyPadding,
          borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
        }, clearFix()),
        [`${componentCls}-grid`]: genCardGridStyle(token2),
        [`${componentCls}-cover`]: {
          "> *": {
            display: "block",
            width: "100%",
            borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`
          }
        },
        [`${componentCls}-actions`]: genCardActionsStyle(token2),
        [`${componentCls}-meta`]: genCardMetaStyle(token2)
      }),
      [`${componentCls}-bordered`]: {
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
        [`${componentCls}-cover`]: {
          marginTop: -1,
          marginInlineStart: -1,
          marginInlineEnd: -1
        }
      },
      [`${componentCls}-hoverable`]: {
        cursor: "pointer",
        transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
        "&:hover": {
          borderColor: "transparent",
          boxShadow: cardShadow
        }
      },
      [`${componentCls}-contain-grid`]: {
        borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0 `,
        [`${componentCls}-body`]: {
          display: "flex",
          flexWrap: "wrap"
        },
        [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
          marginBlockStart: token2.calc(token2.lineWidth).mul(-1).equal(),
          marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
          padding: 0
        }
      },
      [`${componentCls}-contain-tabs`]: {
        [`> div${componentCls}-head`]: {
          minHeight: 0,
          [`${componentCls}-head-title, ${componentCls}-extra`]: {
            paddingTop: cardHeadPadding
          }
        }
      },
      [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
      [`${componentCls}-loading`]: genCardLoadingStyle(token2),
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    };
  };
  var genCardSizeStyle = (token2) => {
    const {
      componentCls,
      bodyPaddingSM,
      headerPaddingSM,
      headerHeightSM,
      headerFontSizeSM
    } = token2;
    return {
      [`${componentCls}-small`]: {
        [`> ${componentCls}-head`]: {
          minHeight: headerHeightSM,
          padding: `0 ${unit(headerPaddingSM)}`,
          fontSize: headerFontSizeSM,
          [`> ${componentCls}-head-wrapper`]: {
            [`> ${componentCls}-extra`]: {
              fontSize: token2.fontSize
            }
          }
        },
        [`> ${componentCls}-body`]: {
          padding: bodyPaddingSM
        }
      },
      [`${componentCls}-small${componentCls}-contain-tabs`]: {
        [`> ${componentCls}-head`]: {
          [`${componentCls}-head-title, ${componentCls}-extra`]: {
            paddingTop: 0,
            display: "flex",
            alignItems: "center"
          }
        }
      }
    };
  };
  var prepareComponentToken12 = (token2) => {
    var _a, _b;
    return {
      headerBg: "transparent",
      headerFontSize: token2.fontSizeLG,
      headerFontSizeSM: token2.fontSize,
      headerHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
      headerHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
      actionsBg: token2.colorBgContainer,
      actionsLiMargin: `${token2.paddingSM}px 0`,
      tabsMarginBottom: -token2.padding - token2.lineWidth,
      extraColor: token2.colorText,
      bodyPaddingSM: 12,
      // Fixed padding.
      headerPaddingSM: 12,
      bodyPadding: (_a = token2.bodyPadding) !== null && _a !== void 0 ? _a : token2.paddingLG,
      headerPadding: (_b = token2.headerPadding) !== null && _b !== void 0 ? _b : token2.paddingLG
    };
  };
  var style_default16 = genStyleHooks("Card", (token2) => {
    const cardToken = merge2(token2, {
      cardShadow: token2.boxShadowCard,
      cardHeadPadding: token2.padding,
      cardPaddingBase: token2.paddingLG,
      cardActionsIconSize: token2.fontSize
    });
    return [
      // Style
      genCardStyle2(cardToken),
      // Size
      genCardSizeStyle(cardToken)
    ];
  }, prepareComponentToken12);

  // node_modules/antd/es/card/Card.js
  var __rest25 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var ActionNode = (props) => {
    const {
      actionClasses,
      actions = [],
      actionStyle
    } = props;
    return /* @__PURE__ */ React253.createElement("ul", {
      className: actionClasses,
      style: actionStyle
    }, actions.map((action, index3) => {
      const key = `action-${index3}`;
      return /* @__PURE__ */ React253.createElement("li", {
        style: {
          width: `${100 / actions.length}%`
        },
        key
      }, /* @__PURE__ */ React253.createElement("span", null, action));
    }));
  };
  var Card = /* @__PURE__ */ React253.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      extra,
      headStyle = {},
      bodyStyle = {},
      title,
      loading,
      bordered,
      variant: customVariant,
      size: customizeSize,
      type: type5,
      cover,
      actions,
      tabList,
      children,
      activeTabKey,
      defaultActiveTabKey,
      tabBarExtraContent,
      hoverable,
      tabProps = {},
      classNames: customClassNames,
      styles: customStyles
    } = props, others = __rest25(props, ["prefixCls", "className", "rootClassName", "style", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "variant", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps", "classNames", "styles"]);
    const {
      getPrefixCls,
      direction,
      card
    } = React253.useContext(ConfigContext);
    const [variant] = useVariants_default("card", customVariant, bordered);
    if (true) {
      const warning6 = devUseWarning("Card");
      [["headStyle", "styles.header"], ["bodyStyle", "styles.body"], ["bordered", "variant"]].forEach(([deprecatedName, newName]) => {
        warning6.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
    }
    const onTabChange = (key) => {
      var _a;
      (_a = props.onTabChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
    };
    const moduleClass = (moduleName) => {
      var _a;
      return (0, import_classnames83.default)((_a = card === null || card === void 0 ? void 0 : card.classNames) === null || _a === void 0 ? void 0 : _a[moduleName], customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames[moduleName]);
    };
    const moduleStyle = (moduleName) => {
      var _a;
      return Object.assign(Object.assign({}, (_a = card === null || card === void 0 ? void 0 : card.styles) === null || _a === void 0 ? void 0 : _a[moduleName]), customStyles === null || customStyles === void 0 ? void 0 : customStyles[moduleName]);
    };
    const isContainGrid = React253.useMemo(() => {
      let containGrid = false;
      React253.Children.forEach(children, (element) => {
        if ((element === null || element === void 0 ? void 0 : element.type) === Grid_default) {
          containGrid = true;
        }
      });
      return containGrid;
    }, [children]);
    const prefixCls = getPrefixCls("card", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default16(prefixCls);
    const loadingBlock = /* @__PURE__ */ React253.createElement(skeleton_default, {
      loading: true,
      active: true,
      paragraph: {
        rows: 4
      },
      title: false
    }, children);
    const hasActiveTabKey = activeTabKey !== void 0;
    const extraProps = Object.assign(Object.assign({}, tabProps), {
      [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
      tabBarExtraContent
    });
    let head;
    const mergedSize = useSize_default(customizeSize);
    const tabSize = !mergedSize || mergedSize === "default" ? "large" : mergedSize;
    const tabs = tabList ? /* @__PURE__ */ React253.createElement(tabs_default, Object.assign({
      size: tabSize
    }, extraProps, {
      className: `${prefixCls}-head-tabs`,
      onChange: onTabChange,
      items: tabList.map((_a) => {
        var {
          tab
        } = _a, item = __rest25(_a, ["tab"]);
        return Object.assign({
          label: tab
        }, item);
      })
    })) : null;
    if (title || extra || tabs) {
      const headClasses = (0, import_classnames83.default)(`${prefixCls}-head`, moduleClass("header"));
      const titleClasses = (0, import_classnames83.default)(`${prefixCls}-head-title`, moduleClass("title"));
      const extraClasses = (0, import_classnames83.default)(`${prefixCls}-extra`, moduleClass("extra"));
      const mergedHeadStyle = Object.assign(Object.assign({}, headStyle), moduleStyle("header"));
      head = /* @__PURE__ */ React253.createElement("div", {
        className: headClasses,
        style: mergedHeadStyle
      }, /* @__PURE__ */ React253.createElement("div", {
        className: `${prefixCls}-head-wrapper`
      }, title && /* @__PURE__ */ React253.createElement("div", {
        className: titleClasses,
        style: moduleStyle("title")
      }, title), extra && /* @__PURE__ */ React253.createElement("div", {
        className: extraClasses,
        style: moduleStyle("extra")
      }, extra)), tabs);
    }
    const coverClasses = (0, import_classnames83.default)(`${prefixCls}-cover`, moduleClass("cover"));
    const coverDom = cover ? /* @__PURE__ */ React253.createElement("div", {
      className: coverClasses,
      style: moduleStyle("cover")
    }, cover) : null;
    const bodyClasses = (0, import_classnames83.default)(`${prefixCls}-body`, moduleClass("body"));
    const mergedBodyStyle = Object.assign(Object.assign({}, bodyStyle), moduleStyle("body"));
    const body = /* @__PURE__ */ React253.createElement("div", {
      className: bodyClasses,
      style: mergedBodyStyle
    }, loading ? loadingBlock : children);
    const actionClasses = (0, import_classnames83.default)(`${prefixCls}-actions`, moduleClass("actions"));
    const actionDom = (actions === null || actions === void 0 ? void 0 : actions.length) ? /* @__PURE__ */ React253.createElement(ActionNode, {
      actionClasses,
      actionStyle: moduleStyle("actions"),
      actions
    }) : null;
    const divProps = omit(others, ["onTabChange"]);
    const classString = (0, import_classnames83.default)(prefixCls, card === null || card === void 0 ? void 0 : card.className, {
      [`${prefixCls}-loading`]: loading,
      [`${prefixCls}-bordered`]: variant !== "borderless",
      [`${prefixCls}-hoverable`]: hoverable,
      [`${prefixCls}-contain-grid`]: isContainGrid,
      [`${prefixCls}-contain-tabs`]: tabList === null || tabList === void 0 ? void 0 : tabList.length,
      [`${prefixCls}-${mergedSize}`]: mergedSize,
      [`${prefixCls}-type-${type5}`]: !!type5,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, hashId, cssVarCls);
    const mergedStyle = Object.assign(Object.assign({}, card === null || card === void 0 ? void 0 : card.style), style2);
    return wrapCSSVar(/* @__PURE__ */ React253.createElement("div", Object.assign({
      ref
    }, divProps, {
      className: classString,
      style: mergedStyle
    }), head, coverDom, body, actionDom));
  });
  var Card_default = Card;

  // node_modules/antd/es/card/Meta.js
  var React254 = __toESM(require_react());
  var import_classnames84 = __toESM(require_classnames());
  var __rest26 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Meta = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      avatar,
      title,
      description
    } = props, others = __rest26(props, ["prefixCls", "className", "avatar", "title", "description"]);
    const {
      getPrefixCls
    } = React254.useContext(ConfigContext);
    const prefixCls = getPrefixCls("card", customizePrefixCls);
    const classString = (0, import_classnames84.default)(`${prefixCls}-meta`, className);
    const avatarDom = avatar ? /* @__PURE__ */ React254.createElement("div", {
      className: `${prefixCls}-meta-avatar`
    }, avatar) : null;
    const titleDom = title ? /* @__PURE__ */ React254.createElement("div", {
      className: `${prefixCls}-meta-title`
    }, title) : null;
    const descriptionDom = description ? /* @__PURE__ */ React254.createElement("div", {
      className: `${prefixCls}-meta-description`
    }, description) : null;
    const MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ React254.createElement("div", {
      className: `${prefixCls}-meta-detail`
    }, titleDom, descriptionDom) : null;
    return /* @__PURE__ */ React254.createElement("div", Object.assign({}, others, {
      className: classString
    }), avatarDom, MetaDetail);
  };
  var Meta_default = Meta;

  // node_modules/antd/es/card/index.js
  var Card2 = Card_default;
  Card2.Grid = Grid_default;
  Card2.Meta = Meta_default;
  if (true) {
    Card2.displayName = "Card";
  }
  var card_default = Card2;

  // node_modules/throttle-debounce/esm/index.js
  function throttle2(delay, callback, options) {
    var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;
    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }
    function cancel(options2) {
      var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
      clearExistingTimeout();
      cancelled = !upcomingOnly;
    }
    function wrapper() {
      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
        arguments_[_key] = arguments[_key];
      }
      var self2 = this;
      var elapsed = Date.now() - lastExec;
      if (cancelled) {
        return;
      }
      function exec() {
        lastExec = Date.now();
        callback.apply(self2, arguments_);
      }
      function clear() {
        timeoutID = void 0;
      }
      if (!noLeading && debounceMode && !timeoutID) {
        exec();
      }
      clearExistingTimeout();
      if (debounceMode === void 0 && elapsed > delay) {
        if (noLeading) {
          lastExec = Date.now();
          if (!noTrailing) {
            timeoutID = setTimeout(debounceMode ? clear : exec, delay);
          }
        } else {
          exec();
        }
      } else if (noTrailing !== true) {
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
      }
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function debounce(delay, callback, options) {
    var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
    return throttle2(delay, callback, {
      debounceMode: atBegin !== false
    });
  }

  // node_modules/rc-tree/es/utils/keyUtil.js
  function getEntity(keyEntities, key) {
    return keyEntities[key];
  }

  // node_modules/rc-tree/es/utils/treeUtil.js
  var _excluded42 = ["children"];
  function getPosition2(level, index3) {
    return "".concat(level, "-").concat(index3);
  }
  function isTreeNode(node2) {
    return node2 && node2.type && node2.type.isTreeNode;
  }
  function getKey2(key, pos) {
    if (key !== null && key !== void 0) {
      return key;
    }
    return pos;
  }
  function fillFieldNames2(fieldNames) {
    var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key = _ref.key, children = _ref.children;
    var mergedTitle = title || "title";
    return {
      title: mergedTitle,
      _title: _title || [mergedTitle],
      key: key || "key",
      children: children || "children"
    };
  }
  function warningWithoutKey(treeData, fieldNames) {
    var keys2 = /* @__PURE__ */ new Map();
    function dig(list) {
      var path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (list || []).forEach(function(treeNode) {
        var key = treeNode[fieldNames.key];
        var children = treeNode[fieldNames.children];
        warning_default(key !== null && key !== void 0, "Tree node must have a certain key: [".concat(path2).concat(key, "]"));
        var recordKey = String(key);
        warning_default(!keys2.has(recordKey) || key === null || key === void 0, "Same 'key' exist in the Tree: ".concat(recordKey));
        keys2.set(recordKey, true);
        dig(children, "".concat(path2).concat(recordKey, " > "));
      });
    }
    dig(treeData);
  }
  function convertTreeToData(rootNodes) {
    function dig(node2) {
      var treeNodes = toArray(node2);
      return treeNodes.map(function(treeNode) {
        if (!isTreeNode(treeNode)) {
          warning_default(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
          return null;
        }
        var key = treeNode.key;
        var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties(_treeNode$props, _excluded42);
        var dataNode = _objectSpread2({
          key
        }, rest);
        var parsedChildren = dig(children);
        if (parsedChildren.length) {
          dataNode.children = parsedChildren;
        }
        return dataNode;
      }).filter(function(dataNode) {
        return dataNode;
      });
    }
    return dig(rootNodes);
  }
  function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
    var _fillFieldNames = fillFieldNames2(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
    var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
    var flattenList = [];
    function dig(list) {
      var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return list.map(function(treeNode, index3) {
        var pos = getPosition2(parent ? parent.pos : "0", index3);
        var mergedKey = getKey2(treeNode[fieldKey], pos);
        var mergedTitle;
        for (var i = 0; i < fieldTitles.length; i += 1) {
          var fieldTitle = fieldTitles[i];
          if (treeNode[fieldTitle] !== void 0) {
            mergedTitle = treeNode[fieldTitle];
            break;
          }
        }
        var flattenNode = Object.assign(omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren])), {
          title: mergedTitle,
          key: mergedKey,
          parent,
          pos,
          children: null,
          data: treeNode,
          isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index3 === 0]),
          isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index3 === list.length - 1])
        });
        flattenList.push(flattenNode);
        if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
          flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
        } else {
          flattenNode.children = [];
        }
        return flattenNode;
      });
    }
    dig(treeNodeList);
    return flattenList;
  }
  function traverseDataNodes(dataNodes, callback, config) {
    var mergedConfig = {};
    if (_typeof(config) === "object") {
      mergedConfig = config;
    } else {
      mergedConfig = {
        externalGetKey: config
      };
    }
    mergedConfig = mergedConfig || {};
    var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
    var _fillFieldNames2 = fillFieldNames2(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
    var mergeChildrenPropName = childrenPropName || fieldChildren;
    var syntheticGetKey;
    if (externalGetKey) {
      if (typeof externalGetKey === "string") {
        syntheticGetKey = function syntheticGetKey2(node2) {
          return node2[externalGetKey];
        };
      } else if (typeof externalGetKey === "function") {
        syntheticGetKey = function syntheticGetKey2(node2) {
          return externalGetKey(node2);
        };
      }
    } else {
      syntheticGetKey = function syntheticGetKey2(node2, pos) {
        return getKey2(node2[fieldKey], pos);
      };
    }
    function processNode(node2, index3, parent, pathNodes) {
      var children = node2 ? node2[mergeChildrenPropName] : dataNodes;
      var pos = node2 ? getPosition2(parent.pos, index3) : "0";
      var connectNodes = node2 ? [].concat(_toConsumableArray(pathNodes), [node2]) : [];
      if (node2) {
        var key = syntheticGetKey(node2, pos);
        var _data = {
          node: node2,
          index: index3,
          pos,
          key,
          parentPos: parent.node ? parent.pos : null,
          level: parent.level + 1,
          nodes: connectNodes
        };
        callback(_data);
      }
      if (children) {
        children.forEach(function(subNode, subIndex) {
          processNode(subNode, subIndex, {
            node: node2,
            pos,
            level: parent ? parent.level + 1 : -1
          }, connectNodes);
        });
      }
    }
    processNode(null);
  }
  function convertDataToEntities(dataNodes) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
    var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
    var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
    var posEntities = {};
    var keyEntities = {};
    var wrapper = {
      posEntities,
      keyEntities
    };
    if (initWrapper) {
      wrapper = initWrapper(wrapper) || wrapper;
    }
    traverseDataNodes(dataNodes, function(item) {
      var node2 = item.node, index3 = item.index, pos = item.pos, key = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
      var entity = {
        node: node2,
        nodes,
        index: index3,
        key,
        pos,
        level
      };
      var mergedKey = getKey2(key, pos);
      posEntities[pos] = entity;
      keyEntities[mergedKey] = entity;
      entity.parent = posEntities[parentPos];
      if (entity.parent) {
        entity.parent.children = entity.parent.children || [];
        entity.parent.children.push(entity);
      }
      if (processEntity) {
        processEntity(entity, wrapper);
      }
    }, {
      externalGetKey: mergedExternalGetKey,
      childrenPropName,
      fieldNames
    });
    if (onProcessFinished) {
      onProcessFinished(wrapper);
    }
    return wrapper;
  }
  function getTreeNodeProps(key, _ref3) {
    var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
    var entity = getEntity(keyEntities, key);
    var treeNodeProps = {
      eventKey: key,
      expanded: expandedKeys.indexOf(key) !== -1,
      selected: selectedKeys.indexOf(key) !== -1,
      loaded: loadedKeys.indexOf(key) !== -1,
      loading: loadingKeys.indexOf(key) !== -1,
      checked: checkedKeys.indexOf(key) !== -1,
      halfChecked: halfCheckedKeys.indexOf(key) !== -1,
      pos: String(entity ? entity.pos : ""),
      // [Legacy] Drag props
      // Since the interaction of drag is changed, the semantic of the props are
      // not accuracy, I think it should be finally removed
      dragOver: dragOverNodeKey === key && dropPosition === 0,
      dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
      dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
    };
    return treeNodeProps;
  }
  function convertNodePropsToEventData(props) {
    var data = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
    var eventData = _objectSpread2(_objectSpread2({}, data), {}, {
      expanded,
      selected,
      checked,
      loaded,
      loading,
      halfChecked,
      dragOver,
      dragOverGapTop,
      dragOverGapBottom,
      pos,
      active,
      key: eventKey
    });
    if (!("props" in eventData)) {
      Object.defineProperty(eventData, "props", {
        get: function get2() {
          warning_default(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
          return props;
        }
      });
    }
    return eventData;
  }

  // node_modules/rc-tree/es/utils/conductUtil.js
  function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
    var filteredKeys = /* @__PURE__ */ new Set();
    halfCheckedKeys.forEach(function(key) {
      if (!checkedKeys.has(key)) {
        filteredKeys.add(key);
      }
    });
    return filteredKeys;
  }
  function isCheckDisabled(node2) {
    var _ref = node2 || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
    return !!(disabled || disableCheckbox) || checkable === false;
  }
  function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
    var checkedKeys = new Set(keys2);
    var halfCheckedKeys = /* @__PURE__ */ new Set();
    for (var level = 0; level <= maxLevel; level += 1) {
      var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
      entities.forEach(function(entity) {
        var key = entity.key, node2 = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
        if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
          children.filter(function(childEntity) {
            return !syntheticGetCheckDisabled(childEntity.node);
          }).forEach(function(childEntity) {
            checkedKeys.add(childEntity.key);
          });
        }
      });
    }
    var visitedKeys = /* @__PURE__ */ new Set();
    for (var _level = maxLevel; _level >= 0; _level -= 1) {
      var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
      _entities.forEach(function(entity) {
        var parent = entity.parent, node2 = entity.node;
        if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
          return;
        }
        if (syntheticGetCheckDisabled(entity.parent.node)) {
          visitedKeys.add(parent.key);
          return;
        }
        var allChecked = true;
        var partialChecked = false;
        (parent.children || []).filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(_ref2) {
          var key = _ref2.key;
          var checked = checkedKeys.has(key);
          if (allChecked && !checked) {
            allChecked = false;
          }
          if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
            partialChecked = true;
          }
        });
        if (allChecked) {
          checkedKeys.add(parent.key);
        }
        if (partialChecked) {
          halfCheckedKeys.add(parent.key);
        }
        visitedKeys.add(parent.key);
      });
    }
    return {
      checkedKeys: Array.from(checkedKeys),
      halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
    };
  }
  function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
    var checkedKeys = new Set(keys2);
    var halfCheckedKeys = new Set(halfKeys);
    for (var level = 0; level <= maxLevel; level += 1) {
      var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
      entities.forEach(function(entity) {
        var key = entity.key, node2 = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
        if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
          children.filter(function(childEntity) {
            return !syntheticGetCheckDisabled(childEntity.node);
          }).forEach(function(childEntity) {
            checkedKeys.delete(childEntity.key);
          });
        }
      });
    }
    halfCheckedKeys = /* @__PURE__ */ new Set();
    var visitedKeys = /* @__PURE__ */ new Set();
    for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
      var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
      _entities2.forEach(function(entity) {
        var parent = entity.parent, node2 = entity.node;
        if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
          return;
        }
        if (syntheticGetCheckDisabled(entity.parent.node)) {
          visitedKeys.add(parent.key);
          return;
        }
        var allChecked = true;
        var partialChecked = false;
        (parent.children || []).filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(_ref3) {
          var key = _ref3.key;
          var checked = checkedKeys.has(key);
          if (allChecked && !checked) {
            allChecked = false;
          }
          if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
            partialChecked = true;
          }
        });
        if (!allChecked) {
          checkedKeys.delete(parent.key);
        }
        if (partialChecked) {
          halfCheckedKeys.add(parent.key);
        }
        visitedKeys.add(parent.key);
      });
    }
    return {
      checkedKeys: Array.from(checkedKeys),
      halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
    };
  }
  function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
    var warningMissKeys = [];
    var syntheticGetCheckDisabled;
    if (getCheckDisabled) {
      syntheticGetCheckDisabled = getCheckDisabled;
    } else {
      syntheticGetCheckDisabled = isCheckDisabled;
    }
    var keys2 = new Set(keyList.filter(function(key) {
      var hasEntity = !!getEntity(keyEntities, key);
      if (!hasEntity) {
        warningMissKeys.push(key);
      }
      return hasEntity;
    }));
    var levelEntities = /* @__PURE__ */ new Map();
    var maxLevel = 0;
    Object.keys(keyEntities).forEach(function(key) {
      var entity = keyEntities[key];
      var level = entity.level;
      var levelSet = levelEntities.get(level);
      if (!levelSet) {
        levelSet = /* @__PURE__ */ new Set();
        levelEntities.set(level, levelSet);
      }
      levelSet.add(entity);
      maxLevel = Math.max(maxLevel, level);
    });
    warning_default(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key) {
      return "'".concat(key, "'");
    }).join(", ")));
    var result;
    if (checked === true) {
      result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
    } else {
      result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
    }
    return result;
  }

  // node_modules/antd/es/checkbox/style/index.js
  var genCheckboxStyle = (token2) => {
    const {
      checkboxCls
    } = token2;
    const wrapperCls = `${checkboxCls}-wrapper`;
    return [
      // ===================== Basic =====================
      {
        // Group
        [`${checkboxCls}-group`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-flex",
          flexWrap: "wrap",
          columnGap: token2.marginXS,
          // Group > Grid
          [`> ${token2.antCls}-row`]: {
            flex: 1
          }
        }),
        // Wrapper
        [wrapperCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-flex",
          alignItems: "baseline",
          cursor: "pointer",
          // Fix checkbox & radio in flex align #30260
          "&:after": {
            display: "inline-block",
            width: 0,
            overflow: "hidden",
            content: "'\\a0'"
          },
          // Checkbox near checkbox
          [`& + ${wrapperCls}`]: {
            marginInlineStart: 0
          },
          [`&${wrapperCls}-in-form-item`]: {
            'input[type="checkbox"]': {
              width: 14,
              // FIXME: magic
              height: 14
              // FIXME: magic
            }
          }
        }),
        // Wrapper > Checkbox
        [checkboxCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "relative",
          whiteSpace: "nowrap",
          lineHeight: 1,
          cursor: "pointer",
          borderRadius: token2.borderRadiusSM,
          // To make alignment right when `controlHeight` is changed
          // Ref: https://github.com/ant-design/ant-design/issues/41564
          alignSelf: "center",
          // Wrapper > Checkbox > input
          [`${checkboxCls}-input`]: {
            position: "absolute",
            // Since baseline align will get additional space offset,
            // we need to move input to top to make it align with text.
            // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
            inset: 0,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0,
            margin: 0,
            [`&:focus-visible + ${checkboxCls}-inner`]: Object.assign({}, genFocusOutline(token2))
          },
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            boxSizing: "border-box",
            display: "block",
            width: token2.checkboxSize,
            height: token2.checkboxSize,
            direction: "ltr",
            backgroundColor: token2.colorBgContainer,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusSM,
            borderCollapse: "separate",
            transition: `all ${token2.motionDurationSlow}`,
            "&:after": {
              boxSizing: "border-box",
              position: "absolute",
              top: "50%",
              insetInlineStart: "25%",
              display: "table",
              width: token2.calc(token2.checkboxSize).div(14).mul(5).equal(),
              height: token2.calc(token2.checkboxSize).div(14).mul(8).equal(),
              border: `${unit(token2.lineWidthBold)} solid ${token2.colorWhite}`,
              borderTop: 0,
              borderInlineStart: 0,
              transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
              opacity: 0,
              content: '""',
              transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
            }
          },
          // Wrapper > Checkbox + Text
          "& + span": {
            paddingInlineStart: token2.paddingXS,
            paddingInlineEnd: token2.paddingXS
          }
        })
      },
      // ===================== Hover =====================
      {
        // Wrapper & Wrapper > Checkbox
        [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
          [`&:hover ${checkboxCls}-inner`]: {
            borderColor: token2.colorPrimary
          }
        },
        [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
          [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          },
          [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
            borderColor: token2.colorPrimaryHover
          }
        }
      },
      // ==================== Checked ====================
      {
        // Wrapper > Checkbox
        [`${checkboxCls}-checked`]: {
          [`${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimary,
            borderColor: token2.colorPrimary,
            "&:after": {
              opacity: 1,
              transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
              transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
            }
          }
        },
        [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
          [`&:hover ${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          }
        }
      },
      // ================= Indeterminate =================
      {
        [checkboxCls]: {
          "&-indeterminate": {
            "&": {
              // Wrapper > Checkbox > inner
              [`${checkboxCls}-inner`]: {
                backgroundColor: `${token2.colorBgContainer}`,
                borderColor: `${token2.colorBorder}`,
                "&:after": {
                  top: "50%",
                  insetInlineStart: "50%",
                  width: token2.calc(token2.fontSizeLG).div(2).equal(),
                  height: token2.calc(token2.fontSizeLG).div(2).equal(),
                  backgroundColor: token2.colorPrimary,
                  border: 0,
                  transform: "translate(-50%, -50%) scale(1)",
                  opacity: 1,
                  content: '""'
                }
              },
              // https://github.com/ant-design/ant-design/issues/50074
              [`&:hover ${checkboxCls}-inner`]: {
                backgroundColor: `${token2.colorBgContainer}`,
                borderColor: `${token2.colorPrimary}`
              }
            }
          }
        }
      },
      // ==================== Disable ====================
      {
        // Wrapper
        [`${wrapperCls}-disabled`]: {
          cursor: "not-allowed"
        },
        // Wrapper > Checkbox
        [`${checkboxCls}-disabled`]: {
          // Wrapper > Checkbox > input
          [`&, ${checkboxCls}-input`]: {
            cursor: "not-allowed",
            // Disabled for native input to enable Tooltip event handler
            // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
            pointerEvents: "none"
          },
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            background: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            "&:after": {
              borderColor: token2.colorTextDisabled
            }
          },
          "&:after": {
            display: "none"
          },
          "& + span": {
            color: token2.colorTextDisabled
          },
          [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
            background: token2.colorTextDisabled
          }
        }
      }
    ];
  };
  function getStyle2(prefixCls, token2) {
    const checkboxToken = merge2(token2, {
      checkboxCls: `.${prefixCls}`,
      checkboxSize: token2.controlInteractiveSize
    });
    return [genCheckboxStyle(checkboxToken)];
  }
  var style_default17 = genStyleHooks("Checkbox", (token2, {
    prefixCls
  }) => [getStyle2(prefixCls, token2)]);

  // node_modules/antd/es/checkbox/Checkbox.js
  var React256 = __toESM(require_react());
  var import_classnames85 = __toESM(require_classnames());

  // node_modules/antd/es/checkbox/GroupContext.js
  var import_react91 = __toESM(require_react());
  var GroupContext = /* @__PURE__ */ import_react91.default.createContext(null);
  var GroupContext_default = GroupContext;

  // node_modules/antd/es/checkbox/Checkbox.js
  var __rest27 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var InternalCheckbox = (props, ref) => {
    var _a;
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      children,
      indeterminate = false,
      style: style2,
      onMouseEnter,
      onMouseLeave,
      skipGroup = false,
      disabled
    } = props, restProps = __rest27(props, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
    const {
      getPrefixCls,
      direction,
      checkbox
    } = React256.useContext(ConfigContext);
    const checkboxGroup = React256.useContext(GroupContext_default);
    const {
      isFormItemInput
    } = React256.useContext(FormItemInputContext);
    const contextDisabled = React256.useContext(DisabledContext_default);
    const mergedDisabled = (_a = (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || disabled) !== null && _a !== void 0 ? _a : contextDisabled;
    const prevValue = React256.useRef(restProps.value);
    const checkboxRef = React256.useRef(null);
    const mergedRef = composeRef(ref, checkboxRef);
    if (true) {
      const warning6 = devUseWarning("Checkbox");
      true ? warning6("checked" in restProps || !!checkboxGroup || !("value" in restProps), "usage", "`value` is not a valid prop, do you mean `checked`?") : void 0;
    }
    React256.useEffect(() => {
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
    }, []);
    React256.useEffect(() => {
      if (skipGroup) {
        return;
      }
      if (restProps.value !== prevValue.current) {
        checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
        checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
        prevValue.current = restProps.value;
      }
      return () => checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
    }, [restProps.value]);
    React256.useEffect(() => {
      var _a2;
      if ((_a2 = checkboxRef.current) === null || _a2 === void 0 ? void 0 : _a2.input) {
        checkboxRef.current.input.indeterminate = indeterminate;
      }
    }, [indeterminate]);
    const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default17(prefixCls, rootCls);
    const checkboxProps = Object.assign({}, restProps);
    if (checkboxGroup && !skipGroup) {
      checkboxProps.onChange = (...args) => {
        if (restProps.onChange) {
          restProps.onChange.apply(restProps, args);
        }
        if (checkboxGroup.toggleOption) {
          checkboxGroup.toggleOption({
            label: children,
            value: restProps.value
          });
        }
      };
      checkboxProps.name = checkboxGroup.name;
      checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
    }
    const classString = (0, import_classnames85.default)(`${prefixCls}-wrapper`, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
      [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
      [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
    }, checkbox === null || checkbox === void 0 ? void 0 : checkbox.className, className, rootClassName, cssVarCls, rootCls, hashId);
    const checkboxClass = (0, import_classnames85.default)({
      [`${prefixCls}-indeterminate`]: indeterminate
    }, TARGET_CLS, hashId);
    const [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
    return wrapCSSVar(/* @__PURE__ */ React256.createElement(wave_default, {
      component: "Checkbox",
      disabled: mergedDisabled
    }, /* @__PURE__ */ React256.createElement("label", {
      className: classString,
      style: Object.assign(Object.assign({}, checkbox === null || checkbox === void 0 ? void 0 : checkbox.style), style2),
      onMouseEnter,
      onMouseLeave,
      onClick: onLabelClick
    }, /* @__PURE__ */ React256.createElement(es_default14, Object.assign({}, checkboxProps, {
      onClick: onInputClick,
      prefixCls,
      className: checkboxClass,
      disabled: mergedDisabled,
      ref: mergedRef
    })), children !== void 0 && children !== null && /* @__PURE__ */ React256.createElement("span", {
      className: `${prefixCls}-label`
    }, children))));
  };
  var Checkbox2 = /* @__PURE__ */ React256.forwardRef(InternalCheckbox);
  if (true) {
    Checkbox2.displayName = "Checkbox";
  }
  var Checkbox_default = Checkbox2;

  // node_modules/antd/es/checkbox/Group.js
  var React257 = __toESM(require_react());
  var import_classnames86 = __toESM(require_classnames());
  var __rest28 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var CheckboxGroup = /* @__PURE__ */ React257.forwardRef((props, ref) => {
    const {
      defaultValue,
      children,
      options = [],
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      onChange
    } = props, restProps = __rest28(props, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"]);
    const {
      getPrefixCls,
      direction
    } = React257.useContext(ConfigContext);
    const [value, setValue] = React257.useState(restProps.value || defaultValue || []);
    const [registeredValues, setRegisteredValues] = React257.useState([]);
    React257.useEffect(() => {
      if ("value" in restProps) {
        setValue(restProps.value || []);
      }
    }, [restProps.value]);
    const memoizedOptions = React257.useMemo(() => options.map((option) => {
      if (typeof option === "string" || typeof option === "number") {
        return {
          label: option,
          value: option
        };
      }
      return option;
    }), [options]);
    const cancelValue = (val) => {
      setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
    };
    const registerValue = (val) => {
      setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
    };
    const toggleOption = (option) => {
      const optionIndex = value.indexOf(option.value);
      const newValue = _toConsumableArray(value);
      if (optionIndex === -1) {
        newValue.push(option.value);
      } else {
        newValue.splice(optionIndex, 1);
      }
      if (!("value" in restProps)) {
        setValue(newValue);
      }
      onChange === null || onChange === void 0 ? void 0 : onChange(newValue.filter((val) => registeredValues.includes(val)).sort((a, b) => {
        const indexA = memoizedOptions.findIndex((opt) => opt.value === a);
        const indexB = memoizedOptions.findIndex((opt) => opt.value === b);
        return indexA - indexB;
      }));
    };
    const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default17(prefixCls, rootCls);
    const domProps = omit(restProps, ["value", "disabled"]);
    const childrenNode = options.length ? memoizedOptions.map((option) => /* @__PURE__ */ React257.createElement(Checkbox_default, {
      prefixCls,
      key: option.value.toString(),
      disabled: "disabled" in option ? option.disabled : restProps.disabled,
      value: option.value,
      checked: value.includes(option.value),
      onChange: option.onChange,
      className: (0, import_classnames86.default)(`${groupPrefixCls}-item`, option.className),
      style: option.style,
      title: option.title,
      id: option.id,
      required: option.required
    }, option.label)) : children;
    const memoizedContext = React257.useMemo(() => ({
      toggleOption,
      value,
      disabled: restProps.disabled,
      name: restProps.name,
      // https://github.com/ant-design/ant-design/issues/16376
      registerValue,
      cancelValue
    }), [toggleOption, value, restProps.disabled, restProps.name, registerValue, cancelValue]);
    const classString = (0, import_classnames86.default)(groupPrefixCls, {
      [`${groupPrefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, cssVarCls, rootCls, hashId);
    return wrapCSSVar(/* @__PURE__ */ React257.createElement("div", Object.assign({
      className: classString,
      style: style2
    }, domProps, {
      ref
    }), /* @__PURE__ */ React257.createElement(GroupContext_default.Provider, {
      value: memoizedContext
    }, childrenNode)));
  });
  var Group_default = CheckboxGroup;

  // node_modules/antd/es/checkbox/index.js
  var Checkbox3 = Checkbox_default;
  Checkbox3.Group = Group_default;
  Checkbox3.__ANT_CHECKBOX = true;
  if (true) {
    Checkbox3.displayName = "Checkbox";
  }
  var checkbox_default = Checkbox3;

  // node_modules/antd/es/grid/col.js
  var React258 = __toESM(require_react());
  var import_classnames87 = __toESM(require_classnames());

  // node_modules/antd/es/grid/RowContext.js
  var import_react92 = __toESM(require_react());
  var RowContext = /* @__PURE__ */ (0, import_react92.createContext)({});
  var RowContext_default = RowContext;

  // node_modules/antd/es/grid/col.js
  var __rest29 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function parseFlex(flex) {
    if (typeof flex === "number") {
      return `${flex} ${flex} auto`;
    }
    if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
      return `0 0 ${flex}`;
    }
    return flex;
  }
  var sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
  var Col = /* @__PURE__ */ React258.forwardRef((props, ref) => {
    const {
      getPrefixCls,
      direction
    } = React258.useContext(ConfigContext);
    const {
      gutter,
      wrap
    } = React258.useContext(RowContext_default);
    const {
      prefixCls: customizePrefixCls,
      span,
      order,
      offset: offset3,
      push,
      pull,
      className,
      children,
      flex,
      style: style2
    } = props, others = __rest29(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
    const prefixCls = getPrefixCls("col", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = useColStyle(prefixCls);
    const sizeStyle = {};
    let sizeClassObj = {};
    sizes.forEach((size) => {
      let sizeProps = {};
      const propSize = props[size];
      if (typeof propSize === "number") {
        sizeProps.span = propSize;
      } else if (typeof propSize === "object") {
        sizeProps = propSize || {};
      }
      delete others[size];
      sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
        [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
        [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
        [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
        [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
        [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
        [`${prefixCls}-rtl`]: direction === "rtl"
      });
      if (sizeProps.flex) {
        sizeClassObj[`${prefixCls}-${size}-flex`] = true;
        sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex);
      }
    });
    const classes = (0, import_classnames87.default)(prefixCls, {
      [`${prefixCls}-${span}`]: span !== void 0,
      [`${prefixCls}-order-${order}`]: order,
      [`${prefixCls}-offset-${offset3}`]: offset3,
      [`${prefixCls}-push-${push}`]: push,
      [`${prefixCls}-pull-${pull}`]: pull
    }, className, sizeClassObj, hashId, cssVarCls);
    const mergedStyle = {};
    if (gutter && gutter[0] > 0) {
      const horizontalGutter = gutter[0] / 2;
      mergedStyle.paddingLeft = horizontalGutter;
      mergedStyle.paddingRight = horizontalGutter;
    }
    if (flex) {
      mergedStyle.flex = parseFlex(flex);
      if (wrap === false && !mergedStyle.minWidth) {
        mergedStyle.minWidth = 0;
      }
    }
    return wrapCSSVar(/* @__PURE__ */ React258.createElement("div", Object.assign({}, others, {
      style: Object.assign(Object.assign(Object.assign({}, mergedStyle), style2), sizeStyle),
      className: classes,
      ref
    }), children));
  });
  if (true) {
    Col.displayName = "Col";
  }
  var col_default = Col;

  // node_modules/antd/es/grid/row.js
  var React259 = __toESM(require_react());
  var import_classnames88 = __toESM(require_classnames());

  // node_modules/antd/es/grid/hooks/useGutter.js
  function useGutter(gutter, screens) {
    const results = [void 0, void 0];
    const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
    const mergedScreens = screens || {
      xs: true,
      sm: true,
      md: true,
      lg: true,
      xl: true,
      xxl: true
    };
    normalizedGutter.forEach((g, index3) => {
      if (typeof g === "object" && g !== null) {
        for (let i = 0; i < responsiveArray.length; i++) {
          const breakpoint = responsiveArray[i];
          if (mergedScreens[breakpoint] && g[breakpoint] !== void 0) {
            results[index3] = g[breakpoint];
            break;
          }
        }
      } else {
        results[index3] = g;
      }
    });
    return results;
  }

  // node_modules/antd/es/grid/row.js
  var __rest30 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function useMergedPropByScreen(oriProp, screen) {
    const [prop, setProp] = React259.useState(typeof oriProp === "string" ? oriProp : "");
    const calcMergedAlignOrJustify = () => {
      if (typeof oriProp === "string") {
        setProp(oriProp);
      }
      if (typeof oriProp !== "object") {
        return;
      }
      for (let i = 0; i < responsiveArray.length; i++) {
        const breakpoint = responsiveArray[i];
        if (!screen || !screen[breakpoint]) {
          continue;
        }
        const curVal = oriProp[breakpoint];
        if (curVal !== void 0) {
          setProp(curVal);
          return;
        }
      }
    };
    React259.useEffect(() => {
      calcMergedAlignOrJustify();
    }, [JSON.stringify(oriProp), screen]);
    return prop;
  }
  var Row = /* @__PURE__ */ React259.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      justify,
      align,
      className,
      style: style2,
      children,
      gutter = 0,
      wrap
    } = props, others = __rest30(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
    const {
      getPrefixCls,
      direction
    } = React259.useContext(ConfigContext);
    const screens = useBreakpoint_default(true, null);
    const mergedAlign = useMergedPropByScreen(align, screens);
    const mergedJustify = useMergedPropByScreen(justify, screens);
    const prefixCls = getPrefixCls("row", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = useRowStyle(prefixCls);
    const gutters = useGutter(gutter, screens);
    const classes = (0, import_classnames88.default)(prefixCls, {
      [`${prefixCls}-no-wrap`]: wrap === false,
      [`${prefixCls}-${mergedJustify}`]: mergedJustify,
      [`${prefixCls}-${mergedAlign}`]: mergedAlign,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, hashId, cssVarCls);
    const rowStyle = {};
    const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
    if (horizontalGutter) {
      rowStyle.marginLeft = horizontalGutter;
      rowStyle.marginRight = horizontalGutter;
    }
    const [gutterH, gutterV] = gutters;
    rowStyle.rowGap = gutterV;
    const rowContext = React259.useMemo(() => ({
      gutter: [gutterH, gutterV],
      wrap
    }), [gutterH, gutterV, wrap]);
    return wrapCSSVar(/* @__PURE__ */ React259.createElement(RowContext_default.Provider, {
      value: rowContext
    }, /* @__PURE__ */ React259.createElement("div", Object.assign({}, others, {
      className: classes,
      style: Object.assign(Object.assign({}, rowStyle), style2),
      ref
    }), children)));
  });
  if (true) {
    Row.displayName = "Row";
  }
  var row_default = Row;

  // node_modules/antd/es/col/index.js
  var col_default2 = col_default;

  // node_modules/rc-input/es/BaseInput.js
  var import_classnames89 = __toESM(require_classnames());
  var import_react93 = __toESM(require_react());

  // node_modules/rc-input/es/utils/commonUtils.js
  function hasAddon(props) {
    return !!(props.addonBefore || props.addonAfter);
  }
  function hasPrefixSuffix(props) {
    return !!(props.prefix || props.suffix || props.allowClear);
  }
  function cloneEvent(event, target, value) {
    var currentTarget = target.cloneNode(true);
    var newEvent = Object.create(event, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = value;
    if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
      currentTarget.selectionStart = target.selectionStart;
      currentTarget.selectionEnd = target.selectionEnd;
    }
    currentTarget.setSelectionRange = function() {
      target.setSelectionRange.apply(target, arguments);
    };
    return newEvent;
  }
  function resolveOnChange(target, e3, onChange, targetValue) {
    if (!onChange) {
      return;
    }
    var event = e3;
    if (e3.type === "click") {
      event = cloneEvent(e3, target, "");
      onChange(event);
      return;
    }
    if (target.type !== "file" && targetValue !== void 0) {
      event = cloneEvent(e3, target, targetValue);
      onChange(event);
      return;
    }
    onChange(event);
  }
  function triggerFocus(element, option) {
    if (!element) return;
    element.focus(option);
    var _ref = option || {}, cursor = _ref.cursor;
    if (cursor) {
      var len = element.value.length;
      switch (cursor) {
        case "start":
          element.setSelectionRange(0, 0);
          break;
        case "end":
          element.setSelectionRange(len, len);
          break;
        default:
          element.setSelectionRange(0, len);
      }
    }
  }

  // node_modules/rc-input/es/BaseInput.js
  var BaseInput = /* @__PURE__ */ import_react93.default.forwardRef(function(props, ref) {
    var _props, _props2, _props3;
    var inputEl = props.inputElement, children = props.children, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, classes = props.classes, classNames146 = props.classNames, dataAttrs = props.dataAttrs, styles = props.styles, components = props.components, onClear = props.onClear;
    var inputElement = children !== null && children !== void 0 ? children : inputEl;
    var AffixWrapperComponent = (components === null || components === void 0 ? void 0 : components.affixWrapper) || "span";
    var GroupWrapperComponent = (components === null || components === void 0 ? void 0 : components.groupWrapper) || "span";
    var WrapperComponent = (components === null || components === void 0 ? void 0 : components.wrapper) || "span";
    var GroupAddonComponent = (components === null || components === void 0 ? void 0 : components.groupAddon) || "span";
    var containerRef = (0, import_react93.useRef)(null);
    var onInputClick = function onInputClick2(e3) {
      var _containerRef$current;
      if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e3.target)) {
        triggerFocus2 === null || triggerFocus2 === void 0 || triggerFocus2();
      }
    };
    var hasAffix = hasPrefixSuffix(props);
    var element = /* @__PURE__ */ (0, import_react93.cloneElement)(inputElement, {
      value,
      className: (0, import_classnames89.default)((_props = inputElement.props) === null || _props === void 0 ? void 0 : _props.className, !hasAffix && (classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.variant)) || null
    });
    var groupRef = (0, import_react93.useRef)(null);
    import_react93.default.useImperativeHandle(ref, function() {
      return {
        nativeElement: groupRef.current || containerRef.current
      };
    });
    if (hasAffix) {
      var clearIcon = null;
      if (allowClear) {
        var needClear = !disabled && !readOnly && value;
        var clearIconCls = "".concat(prefixCls, "-clear-icon");
        var iconNode = _typeof(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "\u2716";
        clearIcon = /* @__PURE__ */ import_react93.default.createElement("button", {
          type: "button",
          tabIndex: -1,
          onClick: function onClick(event) {
            handleReset === null || handleReset === void 0 || handleReset(event);
            onClear === null || onClear === void 0 || onClear();
          },
          onMouseDown: function onMouseDown(e3) {
            return e3.preventDefault();
          },
          className: (0, import_classnames89.default)(clearIconCls, _defineProperty(_defineProperty({}, "".concat(clearIconCls, "-hidden"), !needClear), "".concat(clearIconCls, "-has-suffix"), !!suffix))
        }, iconNode);
      }
      var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
      var affixWrapperCls = (0, import_classnames89.default)(affixWrapperPrefixCls, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-focused"), focused), "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), classes === null || classes === void 0 ? void 0 : classes.affixWrapper, classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.affixWrapper, classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.variant);
      var suffixNode = (suffix || allowClear) && /* @__PURE__ */ import_react93.default.createElement("span", {
        className: (0, import_classnames89.default)("".concat(prefixCls, "-suffix"), classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.suffix),
        style: styles === null || styles === void 0 ? void 0 : styles.suffix
      }, clearIcon, suffix);
      element = /* @__PURE__ */ import_react93.default.createElement(AffixWrapperComponent, _extends({
        className: affixWrapperCls,
        style: styles === null || styles === void 0 ? void 0 : styles.affixWrapper,
        onClick: onInputClick
      }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
        ref: containerRef
      }), prefix && /* @__PURE__ */ import_react93.default.createElement("span", {
        className: (0, import_classnames89.default)("".concat(prefixCls, "-prefix"), classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.prefix),
        style: styles === null || styles === void 0 ? void 0 : styles.prefix
      }, prefix), element, suffixNode);
    }
    if (hasAddon(props)) {
      var wrapperCls = "".concat(prefixCls, "-group");
      var addonCls = "".concat(wrapperCls, "-addon");
      var groupWrapperCls = "".concat(wrapperCls, "-wrapper");
      var mergedWrapperClassName = (0, import_classnames89.default)("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper, classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.wrapper);
      var mergedGroupClassName = (0, import_classnames89.default)(groupWrapperCls, _defineProperty({}, "".concat(groupWrapperCls, "-disabled"), disabled), classes === null || classes === void 0 ? void 0 : classes.group, classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.groupWrapper);
      element = /* @__PURE__ */ import_react93.default.createElement(GroupWrapperComponent, {
        className: mergedGroupClassName,
        ref: groupRef
      }, /* @__PURE__ */ import_react93.default.createElement(WrapperComponent, {
        className: mergedWrapperClassName
      }, addonBefore && /* @__PURE__ */ import_react93.default.createElement(GroupAddonComponent, {
        className: addonCls
      }, addonBefore), element, addonAfter && /* @__PURE__ */ import_react93.default.createElement(GroupAddonComponent, {
        className: addonCls
      }, addonAfter)));
    }
    return /* @__PURE__ */ import_react93.default.cloneElement(element, {
      className: (0, import_classnames89.default)((_props2 = element.props) === null || _props2 === void 0 ? void 0 : _props2.className, className) || null,
      style: _objectSpread2(_objectSpread2({}, (_props3 = element.props) === null || _props3 === void 0 ? void 0 : _props3.style), style2),
      hidden
    });
  });
  var BaseInput_default = BaseInput;

  // node_modules/rc-input/es/Input.js
  var import_classnames90 = __toESM(require_classnames());
  var import_react94 = __toESM(require_react());

  // node_modules/rc-input/es/hooks/useCount.js
  var React261 = __toESM(require_react());
  var _excluded43 = ["show"];
  function useCount(count, showCount) {
    return React261.useMemo(function() {
      var mergedConfig = {};
      if (showCount) {
        mergedConfig.show = _typeof(showCount) === "object" && showCount.formatter ? showCount.formatter : !!showCount;
      }
      mergedConfig = _objectSpread2(_objectSpread2({}, mergedConfig), count);
      var _ref = mergedConfig, show = _ref.show, rest = _objectWithoutProperties(_ref, _excluded43);
      return _objectSpread2(_objectSpread2({}, rest), {}, {
        show: !!show,
        showFormatter: typeof show === "function" ? show : void 0,
        strategy: rest.strategy || function(value) {
          return value.length;
        }
      });
    }, [count, showCount]);
  }

  // node_modules/rc-input/es/Input.js
  var _excluded44 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "onKeyUp", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"];
  var Input3 = /* @__PURE__ */ (0, import_react94.forwardRef)(function(props, ref) {
    var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown2 = props.onKeyDown, onKeyUp = props.onKeyUp, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, count = props.count, _props$type = props.type, type5 = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames146 = props.classNames, styles = props.styles, _onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, rest = _objectWithoutProperties(props, _excluded44);
    var _useState = (0, import_react94.useState)(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
    var compositionRef = (0, import_react94.useRef)(false);
    var keyLockRef = (0, import_react94.useRef)(false);
    var inputRef = (0, import_react94.useRef)(null);
    var holderRef = (0, import_react94.useRef)(null);
    var focus = function focus2(option) {
      if (inputRef.current) {
        triggerFocus(inputRef.current, option);
      }
    };
    var _useMergedState = useMergedState(props.defaultValue, {
      value: props.value
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
    var formatValue = value === void 0 || value === null ? "" : String(value);
    var _useState3 = (0, import_react94.useState)(null), _useState4 = _slicedToArray(_useState3, 2), selection = _useState4[0], setSelection = _useState4[1];
    var countConfig = useCount(count, showCount);
    var mergedMax = countConfig.max || maxLength;
    var valueLength = countConfig.strategy(formatValue);
    var isOutOfRange = !!mergedMax && valueLength > mergedMax;
    (0, import_react94.useImperativeHandle)(ref, function() {
      var _holderRef$current;
      return {
        focus,
        blur: function blur() {
          var _inputRef$current;
          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
        },
        setSelectionRange: function setSelectionRange(start, end, direction) {
          var _inputRef$current2;
          (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.setSelectionRange(start, end, direction);
        },
        select: function select() {
          var _inputRef$current3;
          (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.select();
        },
        input: inputRef.current,
        nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || inputRef.current
      };
    });
    (0, import_react94.useEffect)(function() {
      if (keyLockRef.current) {
        keyLockRef.current = false;
      }
      setFocused(function(prev2) {
        return prev2 && disabled ? false : prev2;
      });
    }, [disabled]);
    var triggerChange = function triggerChange2(e3, currentValue, info) {
      var cutValue = currentValue;
      if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
        cutValue = countConfig.exceedFormatter(currentValue, {
          max: countConfig.max
        });
        if (currentValue !== cutValue) {
          var _inputRef$current4, _inputRef$current5;
          setSelection([((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.selectionStart) || 0, ((_inputRef$current5 = inputRef.current) === null || _inputRef$current5 === void 0 ? void 0 : _inputRef$current5.selectionEnd) || 0]);
        }
      } else if (info.source === "compositionEnd") {
        return;
      }
      setValue(cutValue);
      if (inputRef.current) {
        resolveOnChange(inputRef.current, e3, onChange, cutValue);
      }
    };
    (0, import_react94.useEffect)(function() {
      if (selection) {
        var _inputRef$current6;
        (_inputRef$current6 = inputRef.current) === null || _inputRef$current6 === void 0 || _inputRef$current6.setSelectionRange.apply(_inputRef$current6, _toConsumableArray(selection));
      }
    }, [selection]);
    var onInternalChange = function onInternalChange2(e3) {
      triggerChange(e3, e3.target.value, {
        source: "change"
      });
    };
    var onInternalCompositionEnd = function onInternalCompositionEnd2(e3) {
      compositionRef.current = false;
      triggerChange(e3, e3.currentTarget.value, {
        source: "compositionEnd"
      });
      onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e3);
    };
    var handleKeyDown = function handleKeyDown2(e3) {
      if (onPressEnter && e3.key === "Enter" && !keyLockRef.current) {
        keyLockRef.current = true;
        onPressEnter(e3);
      }
      onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(e3);
    };
    var handleKeyUp = function handleKeyUp2(e3) {
      if (e3.key === "Enter") {
        keyLockRef.current = false;
      }
      onKeyUp === null || onKeyUp === void 0 || onKeyUp(e3);
    };
    var handleFocus = function handleFocus2(e3) {
      setFocused(true);
      onFocus === null || onFocus === void 0 || onFocus(e3);
    };
    var handleBlur = function handleBlur2(e3) {
      if (keyLockRef.current) {
        keyLockRef.current = false;
      }
      setFocused(false);
      onBlur === null || onBlur === void 0 || onBlur(e3);
    };
    var handleReset = function handleReset2(e3) {
      setValue("");
      focus();
      if (inputRef.current) {
        resolveOnChange(inputRef.current, e3, onChange);
      }
    };
    var outOfRangeCls = isOutOfRange && "".concat(prefixCls, "-out-of-range");
    var getInputElement = function getInputElement2() {
      var otherProps = omit(props, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "showCount",
        "count",
        "classes",
        "htmlSize",
        "styles",
        "classNames",
        "onClear"
      ]);
      return /* @__PURE__ */ import_react94.default.createElement("input", _extends({
        autoComplete
      }, otherProps, {
        onChange: onInternalChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        className: (0, import_classnames90.default)(prefixCls, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.input),
        style: styles === null || styles === void 0 ? void 0 : styles.input,
        ref: inputRef,
        size: htmlSize,
        type: type5,
        onCompositionStart: function onCompositionStart(e3) {
          compositionRef.current = true;
          _onCompositionStart === null || _onCompositionStart === void 0 || _onCompositionStart(e3);
        },
        onCompositionEnd: onInternalCompositionEnd
      }));
    };
    var getSuffix = function getSuffix2() {
      var hasMaxLength = Number(mergedMax) > 0;
      if (suffix || countConfig.show) {
        var dataCount = countConfig.showFormatter ? countConfig.showFormatter({
          value: formatValue,
          count: valueLength,
          maxLength: mergedMax
        }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
        return /* @__PURE__ */ import_react94.default.createElement(import_react94.default.Fragment, null, countConfig.show && /* @__PURE__ */ import_react94.default.createElement("span", {
          className: (0, import_classnames90.default)("".concat(prefixCls, "-show-count-suffix"), _defineProperty({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.count),
          style: _objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.count)
        }, dataCount), suffix);
      }
      return null;
    };
    return /* @__PURE__ */ import_react94.default.createElement(BaseInput_default, _extends({}, rest, {
      prefixCls,
      className: (0, import_classnames90.default)(className, outOfRangeCls),
      handleReset,
      value: formatValue,
      focused,
      triggerFocus: focus,
      suffix: getSuffix(),
      disabled,
      classes,
      classNames: classNames146,
      styles,
      ref: holderRef
    }), getInputElement());
  });
  var Input_default3 = Input3;

  // node_modules/rc-input/es/index.js
  var es_default16 = Input_default3;

  // node_modules/antd/es/input/Input.js
  var import_react97 = __toESM(require_react());
  var import_classnames91 = __toESM(require_classnames());

  // node_modules/antd/es/_util/getAllowClear.js
  var import_react95 = __toESM(require_react());
  var getAllowClear = (allowClear) => {
    let mergedAllowClear;
    if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
      mergedAllowClear = allowClear;
    } else if (allowClear) {
      mergedAllowClear = {
        clearIcon: /* @__PURE__ */ import_react95.default.createElement(CloseCircleFilled_default2, null)
      };
    }
    return mergedAllowClear;
  };
  var getAllowClear_default = getAllowClear;

  // node_modules/antd/es/input/hooks/useRemovePasswordTimeout.js
  var import_react96 = __toESM(require_react());
  function useRemovePasswordTimeout(inputRef, triggerOnMount) {
    const removePasswordTimeoutRef = (0, import_react96.useRef)([]);
    const removePasswordTimeout = () => {
      removePasswordTimeoutRef.current.push(setTimeout(() => {
        var _a, _b, _c, _d;
        if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
          (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
        }
      }));
    };
    (0, import_react96.useEffect)(() => {
      if (triggerOnMount) {
        removePasswordTimeout();
      }
      return () => removePasswordTimeoutRef.current.forEach((timer) => {
        if (timer) {
          clearTimeout(timer);
        }
      });
    }, []);
    return removePasswordTimeout;
  }

  // node_modules/antd/es/input/utils.js
  function hasPrefixSuffix2(props) {
    return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
  }

  // node_modules/antd/es/input/Input.js
  var __rest31 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Input4 = /* @__PURE__ */ (0, import_react97.forwardRef)((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      bordered = true,
      status: customStatus,
      size: customSize,
      disabled: customDisabled,
      onBlur,
      onFocus,
      suffix,
      allowClear,
      addonAfter,
      addonBefore,
      className,
      style: style2,
      styles,
      rootClassName,
      onChange,
      classNames: classNames146,
      variant: customVariant
    } = props, rest = __rest31(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
    if (true) {
      const {
        deprecated
      } = devUseWarning("Input");
      deprecated(!("bordered" in props), "bordered", "variant");
    }
    const {
      getPrefixCls,
      direction,
      allowClear: contextAllowClear,
      autoComplete: contextAutoComplete,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("input");
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    const inputRef = (0, import_react97.useRef)(null);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapSharedCSSVar, hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
    const [wrapCSSVar] = style_default14(prefixCls, rootCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = useSize_default((ctx) => {
      var _a;
      return (_a = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
    });
    const disabled = import_react97.default.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const {
      status: contextStatus,
      hasFeedback,
      feedbackIcon
    } = (0, import_react97.useContext)(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const inputHasPrefixSuffix = hasPrefixSuffix2(props) || !!hasFeedback;
    const prevHasPrefixSuffix = (0, import_react97.useRef)(inputHasPrefixSuffix);
    if (true) {
      const warning6 = devUseWarning("Input");
      (0, import_react97.useEffect)(() => {
        var _a;
        if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) {
          true ? warning6(document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input), "usage", `When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ`) : void 0;
        }
        prevHasPrefixSuffix.current = inputHasPrefixSuffix;
      }, [inputHasPrefixSuffix]);
    }
    const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
    const handleBlur = (e3) => {
      removePasswordTimeout();
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(e3);
    };
    const handleFocus = (e3) => {
      removePasswordTimeout();
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e3);
    };
    const handleChange = (e3) => {
      removePasswordTimeout();
      onChange === null || onChange === void 0 ? void 0 : onChange(e3);
    };
    const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ import_react97.default.createElement(import_react97.default.Fragment, null, suffix, hasFeedback && feedbackIcon);
    const mergedAllowClear = getAllowClear_default(allowClear !== null && allowClear !== void 0 ? allowClear : contextAllowClear);
    const [variant, enableVariantCls] = useVariants_default("input", customVariant, bordered);
    return wrapSharedCSSVar(wrapCSSVar(/* @__PURE__ */ import_react97.default.createElement(es_default16, Object.assign({
      ref: composeRef(ref, inputRef),
      prefixCls,
      autoComplete: contextAutoComplete
    }, rest, {
      disabled: mergedDisabled,
      onBlur: handleBlur,
      onFocus: handleFocus,
      style: Object.assign(Object.assign({}, contextStyle), style2),
      styles: Object.assign(Object.assign({}, contextStyles), styles),
      suffix: suffixNode,
      allowClear: mergedAllowClear,
      className: (0, import_classnames91.default)(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, contextClassName),
      onChange: handleChange,
      addonBefore: addonBefore && /* @__PURE__ */ import_react97.default.createElement(ContextIsolator_default, {
        form: true,
        space: true
      }, addonBefore),
      addonAfter: addonAfter && /* @__PURE__ */ import_react97.default.createElement(ContextIsolator_default, {
        form: true,
        space: true
      }, addonAfter),
      classNames: Object.assign(Object.assign(Object.assign({}, classNames146), contextClassNames), {
        input: (0, import_classnames91.default)({
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-lg`]: mergedSize === "large",
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.input, contextClassNames.input, hashId),
        variant: (0, import_classnames91.default)({
          [`${prefixCls}-${variant}`]: enableVariantCls
        }, getStatusClassNames(prefixCls, mergedStatus)),
        affixWrapper: (0, import_classnames91.default)({
          [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
        }, hashId),
        wrapper: (0, import_classnames91.default)({
          [`${prefixCls}-group-rtl`]: direction === "rtl"
        }, hashId),
        groupWrapper: (0, import_classnames91.default)({
          [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
        }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
      })
    }))));
  });
  if (true) {
    Input4.displayName = "Input";
  }
  var Input_default4 = Input4;

  // node_modules/antd/es/dropdown/dropdown-button.js
  var React268 = __toESM(require_react());
  var import_classnames93 = __toESM(require_classnames());

  // node_modules/antd/es/space/index.js
  var React267 = __toESM(require_react());
  var import_classnames92 = __toESM(require_classnames());

  // node_modules/antd/es/_util/gapSize.js
  function isPresetSize(size) {
    return ["small", "middle", "large"].includes(size);
  }
  function isValidGapNumber(size) {
    if (!size) {
      return false;
    }
    return typeof size === "number" && !Number.isNaN(size);
  }

  // node_modules/antd/es/space/context.js
  var import_react98 = __toESM(require_react());
  var SpaceContext = /* @__PURE__ */ import_react98.default.createContext({
    latestIndex: 0
  });
  var SpaceContextProvider = SpaceContext.Provider;

  // node_modules/antd/es/space/Item.js
  var React266 = __toESM(require_react());
  var Item3 = ({
    className,
    index: index3,
    children,
    split,
    style: style2
  }) => {
    const {
      latestIndex
    } = React266.useContext(SpaceContext);
    if (children === null || children === void 0) {
      return null;
    }
    return /* @__PURE__ */ React266.createElement(React266.Fragment, null, /* @__PURE__ */ React266.createElement("div", {
      className,
      style: style2
    }, children), index3 < latestIndex && split && /* @__PURE__ */ React266.createElement("span", {
      className: `${className}-split`
    }, split));
  };
  var Item_default2 = Item3;

  // node_modules/antd/es/space/index.js
  var __rest32 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var InternalSpace = /* @__PURE__ */ React267.forwardRef((props, ref) => {
    var _a;
    const {
      getPrefixCls,
      direction: directionConfig,
      size: contextSize,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("space");
    const {
      size = contextSize !== null && contextSize !== void 0 ? contextSize : "small",
      align,
      className,
      rootClassName,
      children,
      direction = "horizontal",
      prefixCls: customizePrefixCls,
      split,
      style: style2,
      wrap = false,
      classNames: customClassNames,
      styles
    } = props, otherProps = __rest32(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap", "classNames", "styles"]);
    const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
    const isPresetVerticalSize = isPresetSize(verticalSize);
    const isPresetHorizontalSize = isPresetSize(horizontalSize);
    const isValidVerticalSize = isValidGapNumber(verticalSize);
    const isValidHorizontalSize = isValidGapNumber(horizontalSize);
    const childNodes = toArray(children, {
      keepEmpty: true
    });
    const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
    const prefixCls = getPrefixCls("space", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default3(prefixCls);
    const cls3 = (0, import_classnames92.default)(prefixCls, contextClassName, hashId, `${prefixCls}-${direction}`, {
      [`${prefixCls}-rtl`]: directionConfig === "rtl",
      [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
      [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
      [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
    }, className, rootClassName, cssVarCls);
    const itemClassName = (0, import_classnames92.default)(`${prefixCls}-item`, (_a = customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.item) !== null && _a !== void 0 ? _a : contextClassNames.item);
    let latestIndex = 0;
    const nodes = childNodes.map((child, i) => {
      var _a2;
      if (child !== null && child !== void 0) {
        latestIndex = i;
      }
      const key = (child === null || child === void 0 ? void 0 : child.key) || `${itemClassName}-${i}`;
      return /* @__PURE__ */ React267.createElement(Item_default2, {
        className: itemClassName,
        key,
        index: i,
        split,
        style: (_a2 = styles === null || styles === void 0 ? void 0 : styles.item) !== null && _a2 !== void 0 ? _a2 : contextStyles.item
      }, child);
    });
    const spaceContext = React267.useMemo(() => ({
      latestIndex
    }), [latestIndex]);
    if (childNodes.length === 0) {
      return null;
    }
    const gapStyle = {};
    if (wrap) {
      gapStyle.flexWrap = "wrap";
    }
    if (!isPresetHorizontalSize && isValidHorizontalSize) {
      gapStyle.columnGap = horizontalSize;
    }
    if (!isPresetVerticalSize && isValidVerticalSize) {
      gapStyle.rowGap = verticalSize;
    }
    return wrapCSSVar(/* @__PURE__ */ React267.createElement("div", Object.assign({
      ref,
      className: cls3,
      style: Object.assign(Object.assign(Object.assign({}, gapStyle), contextStyle), style2)
    }, otherProps), /* @__PURE__ */ React267.createElement(SpaceContextProvider, {
      value: spaceContext
    }, nodes)));
  });
  var Space = InternalSpace;
  Space.Compact = Compact_default;
  if (true) {
    Space.displayName = "Space";
  }
  var space_default = Space;

  // node_modules/antd/es/dropdown/dropdown-button.js
  var __rest33 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var DropdownButton = (props) => {
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction
    } = React268.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      type: type5 = "default",
      danger,
      disabled,
      loading,
      onClick,
      htmlType,
      children,
      className,
      menu,
      arrow,
      autoFocus,
      overlay,
      trigger,
      align,
      open: open2,
      onOpenChange,
      placement,
      getPopupContainer,
      href,
      icon = /* @__PURE__ */ React268.createElement(EllipsisOutlined_default2, null),
      title,
      buttonsRender = (buttons) => buttons,
      mouseEnterDelay,
      mouseLeaveDelay,
      overlayClassName,
      overlayStyle,
      destroyOnHidden,
      destroyPopupOnHide,
      dropdownRender,
      popupRender
    } = props, restProps = __rest33(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyOnHidden", "destroyPopupOnHide", "dropdownRender", "popupRender"]);
    const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
    const buttonPrefixCls = `${prefixCls}-button`;
    const mergedPopupRender = popupRender || dropdownRender;
    const dropdownProps = {
      menu,
      arrow,
      autoFocus,
      align,
      disabled,
      trigger: disabled ? [] : trigger,
      onOpenChange,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      mouseEnterDelay,
      mouseLeaveDelay,
      overlayClassName,
      overlayStyle,
      destroyOnHidden,
      popupRender: mergedPopupRender
    };
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const classes = (0, import_classnames93.default)(buttonPrefixCls, compactItemClassnames, className);
    if ("destroyPopupOnHide" in props) {
      dropdownProps.destroyPopupOnHide = destroyPopupOnHide;
    }
    if ("overlay" in props) {
      dropdownProps.overlay = overlay;
    }
    if ("open" in props) {
      dropdownProps.open = open2;
    }
    if ("placement" in props) {
      dropdownProps.placement = placement;
    } else {
      dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
    }
    const leftButton = /* @__PURE__ */ React268.createElement(button_default2, {
      type: type5,
      danger,
      disabled,
      loading,
      onClick,
      htmlType,
      href,
      title
    }, children);
    const rightButton = /* @__PURE__ */ React268.createElement(button_default2, {
      type: type5,
      danger,
      icon
    });
    const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
    return /* @__PURE__ */ React268.createElement(space_default.Compact, Object.assign({
      className: classes,
      size: compactSize,
      block: true
    }, restProps), leftButtonToRender, /* @__PURE__ */ React268.createElement(dropdown_default2, Object.assign({}, dropdownProps), rightButtonToRender));
  };
  DropdownButton.__ANT_BUTTON = true;
  var dropdown_button_default = DropdownButton;

  // node_modules/antd/es/dropdown/index.js
  var Dropdown3 = dropdown_default2;
  Dropdown3.Button = dropdown_button_default;
  var dropdown_default3 = Dropdown3;

  // node_modules/antd/es/_util/convertToTooltipProps.js
  var import_react99 = __toESM(require_react());
  function convertToTooltipProps(tooltip) {
    if (tooltip === void 0 || tooltip === null) {
      return null;
    }
    if (typeof tooltip === "object" && !/* @__PURE__ */ (0, import_react99.isValidElement)(tooltip)) {
      return tooltip;
    }
    return {
      title: tooltip
    };
  }
  var convertToTooltipProps_default = convertToTooltipProps;

  // node_modules/antd/es/form/ErrorList.js
  var React270 = __toESM(require_react());
  var import_classnames94 = __toESM(require_classnames());

  // node_modules/antd/es/form/hooks/useDebounce.js
  var React269 = __toESM(require_react());
  function useDebounce(value) {
    const [cacheValue, setCacheValue] = React269.useState(value);
    React269.useEffect(() => {
      const timeout = setTimeout(() => {
        setCacheValue(value);
      }, value.length ? 0 : 10);
      return () => {
        clearTimeout(timeout);
      };
    }, [value]);
    return cacheValue;
  }

  // node_modules/antd/es/form/style/explain.js
  var genFormValidateMotionStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const helpCls = `${componentCls}-show-help`;
    const helpItemCls = `${componentCls}-show-help-item`;
    return {
      [helpCls]: {
        // Explain holder
        transition: `opacity ${token2.motionDurationFast} ${token2.motionEaseInOut}`,
        "&-appear, &-enter": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        },
        // Explain
        [helpItemCls]: {
          overflow: "hidden",
          transition: `height ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationFast} ${token2.motionEaseInOut} !important`,
          [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
            transform: `translateY(-5px)`,
            opacity: 0,
            "&-active": {
              transform: "translateY(0)",
              opacity: 1
            }
          },
          [`&${helpItemCls}-leave-active`]: {
            transform: `translateY(-5px)`
          }
        }
      }
    };
  };
  var explain_default = genFormValidateMotionStyle;

  // node_modules/antd/es/form/style/index.js
  var resetForm = (token2) => ({
    legend: {
      display: "block",
      width: "100%",
      marginBottom: token2.marginLG,
      padding: 0,
      color: token2.colorTextDescription,
      fontSize: token2.fontSizeLG,
      lineHeight: "inherit",
      border: 0,
      borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
    },
    'input[type="search"]': {
      boxSizing: "border-box"
    },
    // Position radios and checkboxes better
    'input[type="radio"], input[type="checkbox"]': {
      lineHeight: "normal"
    },
    'input[type="file"]': {
      display: "block"
    },
    // Make range inputs behave like textual form controls
    'input[type="range"]': {
      display: "block",
      width: "100%"
    },
    // Make multiple select elements height not fixed
    "select[multiple], select[size]": {
      height: "auto"
    },
    // Focus for file, radio, and checkbox
    [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
      outline: 0,
      boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${token2.controlOutline}`
    },
    // Adjust output element
    output: {
      display: "block",
      paddingTop: 15,
      color: token2.colorText,
      fontSize: token2.fontSize,
      lineHeight: token2.lineHeight
    }
  });
  var genFormSize = (token2, height) => {
    const {
      formItemCls
    } = token2;
    return {
      [formItemCls]: {
        [`${formItemCls}-label > label`]: {
          height
        },
        [`${formItemCls}-control-input`]: {
          minHeight: height
        }
      }
    };
  };
  var genFormStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), resetForm(token2)), {
        [`${componentCls}-text`]: {
          display: "inline-block",
          paddingInlineEnd: token2.paddingSM
        },
        // ================================================================
        // =                             Size                             =
        // ================================================================
        "&-small": Object.assign({}, genFormSize(token2, token2.controlHeightSM)),
        "&-large": Object.assign({}, genFormSize(token2, token2.controlHeightLG))
      })
    };
  };
  var genFormItemStyle = (token2) => {
    const {
      formItemCls,
      iconCls,
      rootPrefixCls,
      antCls,
      labelRequiredMarkColor,
      labelColor,
      labelFontSize,
      labelHeight,
      labelColonMarginInlineStart,
      labelColonMarginInlineEnd,
      itemMarginBottom
    } = token2;
    return {
      [formItemCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        marginBottom: itemMarginBottom,
        verticalAlign: "top",
        "&-with-help": {
          transition: "none"
        },
        [`&-hidden,
        &-hidden${antCls}-row`]: {
          // https://github.com/ant-design/ant-design/issues/26141
          display: "none"
        },
        "&-has-warning": {
          [`${formItemCls}-split`]: {
            color: token2.colorError
          }
        },
        "&-has-error": {
          [`${formItemCls}-split`]: {
            color: token2.colorWarning
          }
        },
        // ==============================================================
        // =                            Label                           =
        // ==============================================================
        [`${formItemCls}-label`]: {
          flexGrow: 0,
          overflow: "hidden",
          whiteSpace: "nowrap",
          textAlign: "end",
          verticalAlign: "middle",
          "&-left": {
            textAlign: "start"
          },
          "&-wrap": {
            overflow: "unset",
            lineHeight: token2.lineHeight,
            whiteSpace: "unset",
            "> label": {
              verticalAlign: "middle",
              textWrap: "balance"
            }
          },
          "> label": {
            position: "relative",
            display: "inline-flex",
            alignItems: "center",
            maxWidth: "100%",
            height: labelHeight,
            color: labelColor,
            fontSize: labelFontSize,
            [`> ${iconCls}`]: {
              fontSize: token2.fontSize,
              verticalAlign: "top"
            },
            [`&${formItemCls}-required`]: {
              "&::before": {
                display: "inline-block",
                marginInlineEnd: token2.marginXXS,
                color: labelRequiredMarkColor,
                fontSize: token2.fontSize,
                fontFamily: "SimSun, sans-serif",
                lineHeight: 1,
                content: '"*"'
              },
              [`&${formItemCls}-required-mark-hidden, &${formItemCls}-required-mark-optional`]: {
                "&::before": {
                  display: "none"
                }
              }
            },
            // Optional mark
            [`${formItemCls}-optional`]: {
              display: "inline-block",
              marginInlineStart: token2.marginXXS,
              color: token2.colorTextDescription,
              [`&${formItemCls}-required-mark-hidden`]: {
                display: "none"
              }
            },
            // Optional mark
            [`${formItemCls}-tooltip`]: {
              color: token2.colorTextDescription,
              cursor: "help",
              writingMode: "horizontal-tb",
              marginInlineStart: token2.marginXXS
            },
            "&::after": {
              content: '":"',
              position: "relative",
              marginBlock: 0,
              marginInlineStart: labelColonMarginInlineStart,
              marginInlineEnd: labelColonMarginInlineEnd
            },
            [`&${formItemCls}-no-colon::after`]: {
              content: '"\\a0"'
            }
          }
        },
        // ==============================================================
        // =                            Input                           =
        // ==============================================================
        [`${formItemCls}-control`]: {
          ["--ant-display"]: "flex",
          flexDirection: "column",
          flexGrow: 1,
          [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
            width: "100%"
          },
          "&-input": {
            position: "relative",
            display: "flex",
            alignItems: "center",
            minHeight: token2.controlHeight,
            "&-content": {
              flex: "auto",
              maxWidth: "100%",
              // Fix https://github.com/ant-design/ant-design/issues/54042
              // Remove impact of whitespaces
              [`&:has(> ${antCls}-switch:only-child, > ${antCls}-rate:only-child)`]: {
                display: "flex",
                alignItems: "center"
              }
            }
          }
        },
        // ==============================================================
        // =                           Explain                          =
        // ==============================================================
        [formItemCls]: {
          "&-additional": {
            display: "flex",
            flexDirection: "column"
          },
          "&-explain, &-extra": {
            clear: "both",
            color: token2.colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight
          },
          "&-explain-connected": {
            width: "100%"
          },
          "&-extra": {
            minHeight: token2.controlHeightSM,
            transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
            // sync input color transition
          },
          "&-explain": {
            "&-error": {
              color: token2.colorError
            },
            "&-warning": {
              color: token2.colorWarning
            }
          }
        },
        [`&-with-help ${formItemCls}-explain`]: {
          height: "auto",
          opacity: 1
        },
        // ==============================================================
        // =                        Feedback Icon                       =
        // ==============================================================
        [`${formItemCls}-feedback-icon`]: {
          fontSize: token2.fontSize,
          textAlign: "center",
          visibility: "visible",
          animationName: zoomIn,
          animationDuration: token2.motionDurationMid,
          animationTimingFunction: token2.motionEaseOutBack,
          pointerEvents: "none",
          "&-success": {
            color: token2.colorSuccess
          },
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          },
          "&-validating": {
            color: token2.colorPrimary
          }
        }
      })
    };
  };
  var genHorizontalStyle = (token2, className) => {
    const {
      formItemCls
    } = token2;
    return {
      [`${className}-horizontal`]: {
        [`${formItemCls}-label`]: {
          flexGrow: 0
        },
        [`${formItemCls}-control`]: {
          flex: "1 1 0",
          // https://github.com/ant-design/ant-design/issues/32777
          // https://github.com/ant-design/ant-design/issues/33773
          minWidth: 0
        },
        // Do not change this to `ant-col-24`! `-24` match all the responsive rules
        // https://github.com/ant-design/ant-design/issues/32980
        // https://github.com/ant-design/ant-design/issues/34903
        // https://github.com/ant-design/ant-design/issues/44538
        [`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: {
          [`& + ${formItemCls}-control`]: {
            minWidth: "unset"
          }
        }
      }
    };
  };
  var genInlineStyle = (token2) => {
    const {
      componentCls,
      formItemCls,
      inlineItemMarginBottom
    } = token2;
    return {
      [`${componentCls}-inline`]: {
        display: "flex",
        flexWrap: "wrap",
        [formItemCls]: {
          flex: "none",
          marginInlineEnd: token2.margin,
          marginBottom: inlineItemMarginBottom,
          "&-row": {
            flexWrap: "nowrap"
          },
          [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
            display: "inline-block",
            verticalAlign: "top"
          },
          [`> ${formItemCls}-label`]: {
            flex: "none"
          },
          [`${componentCls}-text`]: {
            display: "inline-block"
          },
          [`${formItemCls}-has-feedback`]: {
            display: "inline-block"
          }
        }
      }
    };
  };
  var makeVerticalLayoutLabel = (token2) => ({
    padding: token2.verticalLabelPadding,
    margin: token2.verticalLabelMargin,
    whiteSpace: "initial",
    textAlign: "start",
    "> label": {
      margin: 0,
      "&::after": {
        // https://github.com/ant-design/ant-design/issues/43538
        visibility: "hidden"
      }
    }
  });
  var makeVerticalLayout = (token2) => {
    const {
      componentCls,
      formItemCls,
      rootPrefixCls
    } = token2;
    return {
      [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
      // ref: https://github.com/ant-design/ant-design/issues/45122
      [`${componentCls}:not(${componentCls}-inline)`]: {
        [formItemCls]: {
          flexWrap: "wrap",
          [`${formItemCls}-label, ${formItemCls}-control`]: {
            // When developer pass `xs: { span }`,
            // It should follow the `xs` screen config
            // ref: https://github.com/ant-design/ant-design/issues/44386
            [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
              flex: "0 0 100%",
              maxWidth: "100%"
            }
          }
        }
      }
    };
  };
  var genVerticalStyle = (token2) => {
    const {
      componentCls,
      formItemCls,
      antCls
    } = token2;
    return {
      [`${componentCls}-vertical`]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${formItemCls}-row`]: {
            flexDirection: "column"
          },
          [`${formItemCls}-label > label`]: {
            height: "auto"
          },
          [`${formItemCls}-control`]: {
            width: "100%"
          },
          [`${formItemCls}-label,
        ${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      },
      [`@media (max-width: ${unit(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
        [componentCls]: {
          [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
            [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }
      }],
      [`@media (max-width: ${unit(token2.screenSMMax)})`]: {
        [componentCls]: {
          [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
            [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }
      },
      [`@media (max-width: ${unit(token2.screenMDMax)})`]: {
        [componentCls]: {
          [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
            [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }
      },
      [`@media (max-width: ${unit(token2.screenLGMax)})`]: {
        [componentCls]: {
          [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
            [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }
      }
    };
  };
  var genItemVerticalStyle = (token2) => {
    const {
      formItemCls,
      antCls
    } = token2;
    return {
      [`${formItemCls}-vertical`]: {
        [`${formItemCls}-row`]: {
          flexDirection: "column"
        },
        [`${formItemCls}-label > label`]: {
          height: "auto"
        },
        [`${formItemCls}-control`]: {
          width: "100%"
        }
      },
      [`${formItemCls}-vertical ${formItemCls}-label,
      ${antCls}-col-24${formItemCls}-label,
      ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
      [`@media (max-width: ${unit(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
        [formItemCls]: {
          [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }],
      [`@media (max-width: ${unit(token2.screenSMMax)})`]: {
        [formItemCls]: {
          [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      },
      [`@media (max-width: ${unit(token2.screenMDMax)})`]: {
        [formItemCls]: {
          [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      },
      [`@media (max-width: ${unit(token2.screenLGMax)})`]: {
        [formItemCls]: {
          [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    };
  };
  var prepareComponentToken13 = (token2) => ({
    labelRequiredMarkColor: token2.colorError,
    labelColor: token2.colorTextHeading,
    labelFontSize: token2.fontSize,
    labelHeight: token2.controlHeight,
    labelColonMarginInlineStart: token2.marginXXS / 2,
    labelColonMarginInlineEnd: token2.marginXS,
    itemMarginBottom: token2.marginLG,
    verticalLabelPadding: `0 0 ${token2.paddingXS}px`,
    verticalLabelMargin: 0,
    inlineItemMarginBottom: 0
  });
  var prepareToken3 = (token2, rootPrefixCls) => {
    const formToken = merge2(token2, {
      formItemCls: `${token2.componentCls}-item`,
      rootPrefixCls
    });
    return formToken;
  };
  var style_default18 = genStyleHooks("Form", (token2, {
    rootPrefixCls
  }) => {
    const formToken = prepareToken3(token2, rootPrefixCls);
    return [genFormStyle(formToken), genFormItemStyle(formToken), explain_default(formToken), genHorizontalStyle(formToken, formToken.componentCls), genHorizontalStyle(formToken, formToken.formItemCls), genInlineStyle(formToken), genVerticalStyle(formToken), genItemVerticalStyle(formToken), collapse_default(formToken), zoomIn];
  }, prepareComponentToken13, {
    // Let From style before the Grid
    // ref https://github.com/ant-design/ant-design/issues/44386
    order: -1e3
  });

  // node_modules/antd/es/form/ErrorList.js
  var EMPTY_LIST3 = [];
  function toErrorEntity(error, prefix, errorStatus, index3 = 0) {
    return {
      key: typeof error === "string" ? error : `${prefix}-${index3}`,
      error,
      errorStatus
    };
  }
  var ErrorList = ({
    help,
    helpStatus,
    errors = EMPTY_LIST3,
    warnings = EMPTY_LIST3,
    className: rootClassName,
    fieldId,
    onVisibleChanged
  }) => {
    const {
      prefixCls
    } = React270.useContext(FormItemPrefixContext);
    const baseClassName = `${prefixCls}-item-explain`;
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default18(prefixCls, rootCls);
    const collapseMotion = React270.useMemo(() => motion_default(prefixCls), [prefixCls]);
    const debounceErrors = useDebounce(errors);
    const debounceWarnings = useDebounce(warnings);
    const fullKeyList = React270.useMemo(() => {
      if (help !== void 0 && help !== null) {
        return [toErrorEntity(help, "help", helpStatus)];
      }
      return [].concat(_toConsumableArray(debounceErrors.map((error, index3) => toErrorEntity(error, "error", "error", index3))), _toConsumableArray(debounceWarnings.map((warning6, index3) => toErrorEntity(warning6, "warning", "warning", index3))));
    }, [help, helpStatus, debounceErrors, debounceWarnings]);
    const filledKeyFullKeyList = React270.useMemo(() => {
      const keysCount = {};
      fullKeyList.forEach(({
        key
      }) => {
        keysCount[key] = (keysCount[key] || 0) + 1;
      });
      return fullKeyList.map((entity, index3) => Object.assign(Object.assign({}, entity), {
        key: keysCount[entity.key] > 1 ? `${entity.key}-fallback-${index3}` : entity.key
      }));
    }, [fullKeyList]);
    const helpProps = {};
    if (fieldId) {
      helpProps.id = `${fieldId}_help`;
    }
    return wrapCSSVar(/* @__PURE__ */ React270.createElement(es_default2, {
      motionDeadline: collapseMotion.motionDeadline,
      motionName: `${prefixCls}-show-help`,
      visible: !!filledKeyFullKeyList.length,
      onVisibleChanged
    }, (holderProps) => {
      const {
        className: holderClassName,
        style: holderStyle
      } = holderProps;
      return /* @__PURE__ */ React270.createElement("div", Object.assign({}, helpProps, {
        className: (0, import_classnames94.default)(baseClassName, holderClassName, cssVarCls, rootCls, rootClassName, hashId),
        style: holderStyle
      }), /* @__PURE__ */ React270.createElement(CSSMotionList_default, Object.assign({
        keys: filledKeyFullKeyList
      }, motion_default(prefixCls), {
        motionName: `${prefixCls}-show-help-item`,
        component: false
      }), (itemProps) => {
        const {
          key,
          error,
          errorStatus,
          className: itemClassName,
          style: itemStyle
        } = itemProps;
        return /* @__PURE__ */ React270.createElement("div", {
          key,
          className: (0, import_classnames94.default)(itemClassName, {
            [`${baseClassName}-${errorStatus}`]: errorStatus
          }),
          style: itemStyle
        }, error);
      }));
    }));
  };
  var ErrorList_default = ErrorList;

  // node_modules/antd/es/form/Form.js
  var React272 = __toESM(require_react());
  var import_classnames95 = __toESM(require_classnames());

  // node_modules/antd/es/form/hooks/useFormWarning.js
  var React271 = __toESM(require_react());
  var names = {};
  function useFormWarning({
    name
  }) {
    const warning6 = devUseWarning("Form");
    React271.useEffect(() => {
      if (name) {
        names[name] = (names[name] || 0) + 1;
        true ? warning6(names[name] <= 1, "usage", "There exist multiple Form with same `name`.") : void 0;
        return () => {
          names[name] -= 1;
        };
      }
    }, [name]);
  }

  // node_modules/antd/es/form/Form.js
  var __rest34 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var InternalForm2 = (props, ref) => {
    const contextDisabled = React272.useContext(DisabledContext_default);
    const {
      getPrefixCls,
      direction,
      requiredMark: contextRequiredMark,
      colon: contextColon,
      scrollToFirstError: contextScrollToFirstError,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("form");
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      size,
      disabled = contextDisabled,
      form,
      colon,
      labelAlign,
      labelWrap,
      labelCol,
      wrapperCol,
      hideRequiredMark,
      layout = "horizontal",
      scrollToFirstError,
      requiredMark,
      onFinishFailed,
      name,
      style: style2,
      feedbackIcons,
      variant
    } = props, restFormProps = __rest34(props, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name", "style", "feedbackIcons", "variant"]);
    const mergedSize = useSize_default(size);
    const contextValidateMessages = React272.useContext(validateMessagesContext_default);
    if (true) {
      useFormWarning(props);
    }
    const mergedRequiredMark = React272.useMemo(() => {
      if (requiredMark !== void 0) {
        return requiredMark;
      }
      if (hideRequiredMark) {
        return false;
      }
      if (contextRequiredMark !== void 0) {
        return contextRequiredMark;
      }
      return true;
    }, [hideRequiredMark, requiredMark, contextRequiredMark]);
    const mergedColon = colon !== null && colon !== void 0 ? colon : contextColon;
    const prefixCls = getPrefixCls("form", customizePrefixCls);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default18(prefixCls, rootCls);
    const formClassName = (0, import_classnames95.default)(prefixCls, `${prefixCls}-${layout}`, {
      [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
      // todo: remove in next major version
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${mergedSize}`]: mergedSize
    }, cssVarCls, rootCls, hashId, contextClassName, className, rootClassName);
    const [wrapForm] = useForm2(form);
    const {
      __INTERNAL__
    } = wrapForm;
    __INTERNAL__.name = name;
    const formContextValue = React272.useMemo(() => ({
      name,
      labelAlign,
      labelCol,
      labelWrap,
      wrapperCol,
      vertical: layout === "vertical",
      colon: mergedColon,
      requiredMark: mergedRequiredMark,
      itemRef: __INTERNAL__.itemRef,
      form: wrapForm,
      feedbackIcons
    }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm, feedbackIcons]);
    const nativeElementRef = React272.useRef(null);
    React272.useImperativeHandle(ref, () => {
      var _a;
      return Object.assign(Object.assign({}, wrapForm), {
        nativeElement: (_a = nativeElementRef.current) === null || _a === void 0 ? void 0 : _a.nativeElement
      });
    });
    const scrollToField = (options, fieldName) => {
      if (options) {
        let defaultScrollToFirstError = {
          block: "nearest"
        };
        if (typeof options === "object") {
          defaultScrollToFirstError = Object.assign(Object.assign({}, defaultScrollToFirstError), options);
        }
        wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
      }
    };
    const onInternalFinishFailed = (errorInfo) => {
      onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
      if (errorInfo.errorFields.length) {
        const fieldName = errorInfo.errorFields[0].name;
        if (scrollToFirstError !== void 0) {
          scrollToField(scrollToFirstError, fieldName);
          return;
        }
        if (contextScrollToFirstError !== void 0) {
          scrollToField(contextScrollToFirstError, fieldName);
        }
      }
    };
    return wrapCSSVar(/* @__PURE__ */ React272.createElement(VariantContext.Provider, {
      value: variant
    }, /* @__PURE__ */ React272.createElement(DisabledContextProvider, {
      disabled
    }, /* @__PURE__ */ React272.createElement(SizeContext_default.Provider, {
      value: mergedSize
    }, /* @__PURE__ */ React272.createElement(FormProvider3, {
      // This is not list in API, we pass with spread
      validateMessages: contextValidateMessages
    }, /* @__PURE__ */ React272.createElement(FormContext2.Provider, {
      value: formContextValue
    }, /* @__PURE__ */ React272.createElement(es_default6, Object.assign({
      id: name
    }, restFormProps, {
      name,
      onFinishFailed: onInternalFinishFailed,
      form: wrapForm,
      ref: nativeElementRef,
      style: Object.assign(Object.assign({}, contextStyle), style2),
      className: formClassName
    }))))))));
  };
  var Form3 = /* @__PURE__ */ React272.forwardRef(InternalForm2);
  if (true) {
    Form3.displayName = "Form";
  }
  var Form_default2 = Form3;

  // node_modules/antd/es/form/FormItem/index.js
  var React281 = __toESM(require_react());
  var import_classnames100 = __toESM(require_classnames());

  // node_modules/antd/es/form/hooks/useChildren.js
  function useChildren2(children) {
    if (typeof children === "function") {
      return children;
    }
    const childList = toArray(children);
    return childList.length <= 1 ? childList[0] : childList;
  }

  // node_modules/antd/es/form/hooks/useFormItemStatus.js
  var React273 = __toESM(require_react());
  var useFormItemStatus = () => {
    const {
      status,
      errors = [],
      warnings = []
    } = React273.useContext(FormItemInputContext);
    if (true) {
      const warning6 = devUseWarning("Form.Item");
      true ? warning6(status !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus") : void 0;
    }
    return {
      status,
      errors,
      warnings
    };
  };
  useFormItemStatus.Context = FormItemInputContext;
  var useFormItemStatus_default = useFormItemStatus;

  // node_modules/antd/es/form/hooks/useFrameState.js
  var React274 = __toESM(require_react());
  function useFrameState(defaultValue) {
    const [value, setValue] = React274.useState(defaultValue);
    const frameRef = React274.useRef(null);
    const batchRef = React274.useRef([]);
    const destroyRef = React274.useRef(false);
    React274.useEffect(() => {
      destroyRef.current = false;
      return () => {
        destroyRef.current = true;
        raf_default.cancel(frameRef.current);
        frameRef.current = null;
      };
    }, []);
    function setFrameValue(updater) {
      if (destroyRef.current) {
        return;
      }
      if (frameRef.current === null) {
        batchRef.current = [];
        frameRef.current = raf_default(() => {
          frameRef.current = null;
          setValue((prevValue) => {
            let current = prevValue;
            batchRef.current.forEach((func) => {
              current = func(current);
            });
            return current;
          });
        });
      }
      batchRef.current.push(updater);
    }
    return [value, setFrameValue];
  }

  // node_modules/antd/es/form/hooks/useItemRef.js
  var React275 = __toESM(require_react());
  function useItemRef() {
    const {
      itemRef
    } = React275.useContext(FormContext2);
    const cacheRef = React275.useRef({});
    function getRef(name, children) {
      const childrenRef = children && typeof children === "object" && getNodeRef(children);
      const nameStr = name.join("_");
      if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
        cacheRef.current.name = nameStr;
        cacheRef.current.originRef = childrenRef;
        cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
      }
      return cacheRef.current.ref;
    }
    return getRef;
  }

  // node_modules/antd/es/form/FormItem/ItemHolder.js
  var React280 = __toESM(require_react());
  var import_classnames99 = __toESM(require_classnames());

  // node_modules/antd/es/form/FormItemInput.js
  var React276 = __toESM(require_react());
  var import_classnames96 = __toESM(require_classnames());

  // node_modules/antd/es/form/style/fallbackCmp.js
  var genFallbackStyle = (token2) => {
    const {
      formItemCls
    } = token2;
    return {
      "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
        // Fallback for IE, safe to remove we not support it anymore
        [`${formItemCls}-control`]: {
          display: "flex"
        }
      }
    };
  };
  var fallbackCmp_default = genSubStyleComponent(["Form", "item-item"], (token2, {
    rootPrefixCls
  }) => {
    const formToken = prepareToken3(token2, rootPrefixCls);
    return [genFallbackStyle(formToken)];
  });

  // node_modules/antd/es/form/FormItemInput.js
  var __rest35 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var GRID_MAX = 24;
  var FormItemInput = (props) => {
    const {
      prefixCls,
      status,
      labelCol,
      wrapperCol,
      children,
      errors,
      warnings,
      _internalItemRender: formItemRender,
      extra,
      help,
      fieldId,
      marginBottom,
      onErrorVisibleChanged,
      label
    } = props;
    const baseClassName = `${prefixCls}-item`;
    const formContext = React276.useContext(FormContext2);
    const mergedWrapperCol = React276.useMemo(() => {
      let mergedWrapper = Object.assign({}, wrapperCol || formContext.wrapperCol || {});
      if (label === null && !labelCol && !wrapperCol && formContext.labelCol) {
        const list = [void 0, "xs", "sm", "md", "lg", "xl", "xxl"];
        list.forEach((size) => {
          const _size = size ? [size] : [];
          const formLabel = get(formContext.labelCol, _size);
          const formLabelObj = typeof formLabel === "object" ? formLabel : {};
          const wrapper = get(mergedWrapper, _size);
          const wrapperObj = typeof wrapper === "object" ? wrapper : {};
          if ("span" in formLabelObj && !("offset" in wrapperObj) && formLabelObj.span < GRID_MAX) {
            mergedWrapper = set(mergedWrapper, [].concat(_size, ["offset"]), formLabelObj.span);
          }
        });
      }
      return mergedWrapper;
    }, [wrapperCol, formContext]);
    const className = (0, import_classnames96.default)(`${baseClassName}-control`, mergedWrapperCol.className);
    const subFormContext = React276.useMemo(() => {
      const {
        labelCol: labelCol2,
        wrapperCol: wrapperCol2
      } = formContext, rest = __rest35(formContext, ["labelCol", "wrapperCol"]);
      return rest;
    }, [formContext]);
    const extraRef = React276.useRef(null);
    const [extraHeight, setExtraHeight] = React276.useState(0);
    useLayoutEffect_default(() => {
      if (extra && extraRef.current) {
        setExtraHeight(extraRef.current.clientHeight);
      } else {
        setExtraHeight(0);
      }
    }, [extra]);
    const inputDom = /* @__PURE__ */ React276.createElement("div", {
      className: `${baseClassName}-control-input`
    }, /* @__PURE__ */ React276.createElement("div", {
      className: `${baseClassName}-control-input-content`
    }, children));
    const formItemContext = React276.useMemo(() => ({
      prefixCls,
      status
    }), [prefixCls, status]);
    const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ React276.createElement(FormItemPrefixContext.Provider, {
      value: formItemContext
    }, /* @__PURE__ */ React276.createElement(ErrorList_default, {
      fieldId,
      errors,
      warnings,
      help,
      helpStatus: status,
      className: `${baseClassName}-explain-connected`,
      onVisibleChanged: onErrorVisibleChanged
    })) : null;
    const extraProps = {};
    if (fieldId) {
      extraProps.id = `${fieldId}_extra`;
    }
    const extraDom = extra ? /* @__PURE__ */ React276.createElement("div", Object.assign({}, extraProps, {
      className: `${baseClassName}-extra`,
      ref: extraRef
    }), extra) : null;
    const additionalDom = errorListDom || extraDom ? /* @__PURE__ */ React276.createElement("div", {
      className: `${baseClassName}-additional`,
      style: marginBottom ? {
        minHeight: marginBottom + extraHeight
      } : {}
    }, errorListDom, extraDom) : null;
    const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
      input: inputDom,
      errorList: errorListDom,
      extra: extraDom
    }) : /* @__PURE__ */ React276.createElement(React276.Fragment, null, inputDom, additionalDom);
    return /* @__PURE__ */ React276.createElement(FormContext2.Provider, {
      value: subFormContext
    }, /* @__PURE__ */ React276.createElement(col_default, Object.assign({}, mergedWrapperCol, {
      className
    }), dom), /* @__PURE__ */ React276.createElement(fallbackCmp_default, {
      prefixCls
    }));
  };
  var FormItemInput_default = FormItemInput;

  // node_modules/antd/es/form/FormItemLabel.js
  var React278 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/QuestionCircleOutlined.js
  var React277 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/QuestionCircleOutlined.js
  var QuestionCircleOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
  var QuestionCircleOutlined_default = QuestionCircleOutlined;

  // node_modules/@ant-design/icons/es/icons/QuestionCircleOutlined.js
  var QuestionCircleOutlined2 = function QuestionCircleOutlined3(props, ref) {
    return /* @__PURE__ */ React277.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: QuestionCircleOutlined_default
    }));
  };
  var RefIcon15 = /* @__PURE__ */ React277.forwardRef(QuestionCircleOutlined2);
  if (true) {
    RefIcon15.displayName = "QuestionCircleOutlined";
  }
  var QuestionCircleOutlined_default2 = RefIcon15;

  // node_modules/antd/es/form/FormItemLabel.js
  var import_classnames97 = __toESM(require_classnames());
  var __rest36 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var FormItemLabel = ({
    prefixCls,
    label,
    htmlFor,
    labelCol,
    labelAlign,
    colon,
    required: required5,
    requiredMark,
    tooltip,
    vertical
  }) => {
    var _a;
    const [formLocale] = useLocale_default("Form");
    const {
      labelAlign: contextLabelAlign,
      labelCol: contextLabelCol,
      labelWrap,
      colon: contextColon
    } = React278.useContext(FormContext2);
    if (!label) {
      return null;
    }
    const mergedLabelCol = labelCol || contextLabelCol || {};
    const mergedLabelAlign = labelAlign || contextLabelAlign;
    const labelClsBasic = `${prefixCls}-item-label`;
    const labelColClassName = (0, import_classnames97.default)(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
      [`${labelClsBasic}-wrap`]: !!labelWrap
    });
    let labelChildren = label;
    const computedColon = colon === true || contextColon !== false && colon !== false;
    const haveColon = computedColon && !vertical;
    if (haveColon && typeof label === "string" && label.trim()) {
      labelChildren = label.replace(/[:|：]\s*$/, "");
    }
    const tooltipProps = convertToTooltipProps_default(tooltip);
    if (tooltipProps) {
      const {
        icon = /* @__PURE__ */ React278.createElement(QuestionCircleOutlined_default2, null)
      } = tooltipProps, restTooltipProps = __rest36(tooltipProps, ["icon"]);
      const tooltipNode = /* @__PURE__ */ React278.createElement(tooltip_default, Object.assign({}, restTooltipProps), /* @__PURE__ */ React278.cloneElement(icon, {
        className: `${prefixCls}-item-tooltip`,
        title: "",
        onClick: (e3) => {
          e3.preventDefault();
        },
        tabIndex: null
      }));
      labelChildren = /* @__PURE__ */ React278.createElement(React278.Fragment, null, labelChildren, tooltipNode);
    }
    const isOptionalMark = requiredMark === "optional";
    const isRenderMark = typeof requiredMark === "function";
    const hideRequiredMark = requiredMark === false;
    if (isRenderMark) {
      labelChildren = requiredMark(labelChildren, {
        required: !!required5
      });
    } else if (isOptionalMark && !required5) {
      labelChildren = /* @__PURE__ */ React278.createElement(React278.Fragment, null, labelChildren, /* @__PURE__ */ React278.createElement("span", {
        className: `${prefixCls}-item-optional`,
        title: ""
      }, (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = en_US_default6.Form) === null || _a === void 0 ? void 0 : _a.optional)));
    }
    let markType;
    if (hideRequiredMark) {
      markType = "hidden";
    } else if (isOptionalMark || isRenderMark) {
      markType = "optional";
    }
    const labelClassName = (0, import_classnames97.default)({
      [`${prefixCls}-item-required`]: required5,
      [`${prefixCls}-item-required-mark-${markType}`]: markType,
      [`${prefixCls}-item-no-colon`]: !computedColon
    });
    return /* @__PURE__ */ React278.createElement(col_default, Object.assign({}, mergedLabelCol, {
      className: labelColClassName
    }), /* @__PURE__ */ React278.createElement("label", {
      htmlFor,
      className: labelClassName,
      title: typeof label === "string" ? label : ""
    }, labelChildren));
  };
  var FormItemLabel_default = FormItemLabel;

  // node_modules/antd/es/form/FormItem/StatusProvider.js
  var React279 = __toESM(require_react());
  var import_classnames98 = __toESM(require_classnames());
  var iconMap = {
    success: CheckCircleFilled_default2,
    warning: ExclamationCircleFilled_default2,
    error: CloseCircleFilled_default2,
    validating: LoadingOutlined_default2
  };
  function StatusProvider({
    children,
    errors,
    warnings,
    hasFeedback,
    validateStatus: validateStatus2,
    prefixCls,
    meta,
    noStyle,
    name
  }) {
    const itemPrefixCls = `${prefixCls}-item`;
    const {
      feedbackIcons
    } = React279.useContext(FormContext2);
    const mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus2);
    const {
      isFormItemInput: parentIsFormItemInput,
      status: parentStatus,
      hasFeedback: parentHasFeedback,
      feedbackIcon: parentFeedbackIcon,
      name: parentName
    } = React279.useContext(FormItemInputContext);
    const formItemStatusContext = React279.useMemo(() => {
      var _a;
      let feedbackIcon;
      if (hasFeedback) {
        const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
        const customIconNode = mergedValidateStatus && ((_a = customIcons === null || customIcons === void 0 ? void 0 : customIcons({
          status: mergedValidateStatus,
          errors,
          warnings
        })) === null || _a === void 0 ? void 0 : _a[mergedValidateStatus]);
        const IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
        feedbackIcon = customIconNode !== false && IconNode ? /* @__PURE__ */ React279.createElement("span", {
          className: (0, import_classnames98.default)(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
        }, customIconNode || /* @__PURE__ */ React279.createElement(IconNode, null)) : null;
      }
      const context = {
        status: mergedValidateStatus || "",
        errors,
        warnings,
        hasFeedback: !!hasFeedback,
        feedbackIcon,
        isFormItemInput: true,
        name
      };
      if (noStyle) {
        context.status = (mergedValidateStatus !== null && mergedValidateStatus !== void 0 ? mergedValidateStatus : parentStatus) || "";
        context.isFormItemInput = parentIsFormItemInput;
        context.hasFeedback = !!(hasFeedback !== null && hasFeedback !== void 0 ? hasFeedback : parentHasFeedback);
        context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
        context.name = name !== null && name !== void 0 ? name : parentName;
      }
      return context;
    }, [mergedValidateStatus, hasFeedback, noStyle, parentIsFormItemInput, parentStatus]);
    return /* @__PURE__ */ React279.createElement(FormItemInputContext.Provider, {
      value: formItemStatusContext
    }, children);
  }

  // node_modules/antd/es/form/FormItem/ItemHolder.js
  var __rest37 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function ItemHolder(props) {
    const {
      prefixCls,
      className,
      rootClassName,
      style: style2,
      help,
      errors,
      warnings,
      validateStatus: validateStatus2,
      meta,
      hasFeedback,
      hidden,
      children,
      fieldId,
      required: required5,
      isRequired,
      onSubItemMetaChange,
      layout,
      name
    } = props, restProps = __rest37(props, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "required", "isRequired", "onSubItemMetaChange", "layout", "name"]);
    const itemPrefixCls = `${prefixCls}-item`;
    const {
      requiredMark,
      vertical: formVertical
    } = React280.useContext(FormContext2);
    const vertical = formVertical || layout === "vertical";
    const itemRef = React280.useRef(null);
    const debounceErrors = useDebounce(errors);
    const debounceWarnings = useDebounce(warnings);
    const hasHelp = help !== void 0 && help !== null;
    const hasError = !!(hasHelp || errors.length || warnings.length);
    const isOnScreen = !!itemRef.current && isVisible_default(itemRef.current);
    const [marginBottom, setMarginBottom] = React280.useState(null);
    useLayoutEffect_default(() => {
      if (hasError && itemRef.current) {
        const itemStyle = getComputedStyle(itemRef.current);
        setMarginBottom(parseInt(itemStyle.marginBottom, 10));
      }
    }, [hasError, isOnScreen]);
    const onErrorVisibleChanged = (nextVisible) => {
      if (!nextVisible) {
        setMarginBottom(null);
      }
    };
    const getValidateState = (isDebounce = false) => {
      const _errors = isDebounce ? debounceErrors : meta.errors;
      const _warnings = isDebounce ? debounceWarnings : meta.warnings;
      return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus2);
    };
    const mergedValidateStatus = getValidateState();
    const itemClassName = (0, import_classnames99.default)(itemPrefixCls, className, rootClassName, {
      [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
      // Status
      [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
      [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
      [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
      [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
      [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
      [`${itemPrefixCls}-hidden`]: hidden,
      // Layout
      [`${itemPrefixCls}-${layout}`]: layout
    });
    return /* @__PURE__ */ React280.createElement("div", {
      className: itemClassName,
      style: style2,
      ref: itemRef
    }, /* @__PURE__ */ React280.createElement(row_default, Object.assign({
      className: `${itemPrefixCls}-row`
    }, omit(restProps, [
      "_internalItemRender",
      "colon",
      "dependencies",
      "extra",
      "fieldKey",
      "getValueFromEvent",
      "getValueProps",
      "htmlFor",
      "id",
      // It is deprecated because `htmlFor` is its replacement.
      "initialValue",
      "isListField",
      "label",
      "labelAlign",
      "labelCol",
      "labelWrap",
      "messageVariables",
      "name",
      "normalize",
      "noStyle",
      "preserve",
      "requiredMark",
      "rules",
      "shouldUpdate",
      "trigger",
      "tooltip",
      "validateFirst",
      "validateTrigger",
      "valuePropName",
      "wrapperCol",
      "validateDebounce"
    ])), /* @__PURE__ */ React280.createElement(FormItemLabel_default, Object.assign({
      htmlFor: fieldId
    }, props, {
      requiredMark,
      required: required5 !== null && required5 !== void 0 ? required5 : isRequired,
      prefixCls,
      vertical
    })), /* @__PURE__ */ React280.createElement(FormItemInput_default, Object.assign({}, props, meta, {
      errors: debounceErrors,
      warnings: debounceWarnings,
      prefixCls,
      status: mergedValidateStatus,
      help,
      marginBottom,
      onErrorVisibleChanged
    }), /* @__PURE__ */ React280.createElement(NoStyleItemContext.Provider, {
      value: onSubItemMetaChange
    }, /* @__PURE__ */ React280.createElement(StatusProvider, {
      prefixCls,
      meta,
      errors: meta.errors,
      warnings: meta.warnings,
      hasFeedback,
      // Already calculated
      validateStatus: mergedValidateStatus,
      name
    }, children)))), !!marginBottom && /* @__PURE__ */ React280.createElement("div", {
      className: `${itemPrefixCls}-margin-offset`,
      style: {
        marginBottom: -marginBottom
      }
    }));
  }

  // node_modules/antd/es/form/FormItem/index.js
  var NAME_SPLIT = "__SPLIT__";
  function isSimilarControl(a, b) {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    return keysA.length === keysB.length && keysA.every((key) => {
      const propValueA = a[key];
      const propValueB = b[key];
      return propValueA === propValueB || typeof propValueA === "function" || typeof propValueB === "function";
    });
  }
  var MemoInput = /* @__PURE__ */ React281.memo(({
    children
  }) => children, (prev2, next2) => isSimilarControl(prev2.control, next2.control) && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index3) => value === next2.childProps[index3]));
  function genEmptyMeta() {
    return {
      errors: [],
      warnings: [],
      touched: false,
      validating: false,
      name: [],
      validated: false
    };
  }
  function InternalFormItem(props) {
    const {
      name,
      noStyle,
      className,
      dependencies,
      prefixCls: customizePrefixCls,
      shouldUpdate,
      rules,
      children,
      required: required5,
      label,
      messageVariables,
      trigger = "onChange",
      validateTrigger,
      hidden,
      help,
      layout
    } = props;
    const {
      getPrefixCls
    } = React281.useContext(ConfigContext);
    const {
      name: formName
    } = React281.useContext(FormContext2);
    const mergedChildren = useChildren2(children);
    const isRenderProps = typeof mergedChildren === "function";
    const notifyParentMetaChange = React281.useContext(NoStyleItemContext);
    const {
      validateTrigger: contextValidateTrigger
    } = React281.useContext(FieldContext_default);
    const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
    const hasName = !(name === void 0 || name === null);
    const prefixCls = getPrefixCls("form", customizePrefixCls);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default18(prefixCls, rootCls);
    const warning6 = devUseWarning("Form.Item");
    if (true) {
      true ? warning6(name !== null, "usage", "`null` is passed as `name` property") : void 0;
    }
    const listContext = React281.useContext(ListContext_default);
    const fieldKeyPathRef = React281.useRef(null);
    const [subFieldErrors, setSubFieldErrors] = useFrameState({});
    const [meta, setMeta] = useSafeState(() => genEmptyMeta());
    const onMetaChange = (nextMeta) => {
      const keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
      setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
      if (noStyle && help !== false && notifyParentMetaChange) {
        let namePath = nextMeta.name;
        if (!nextMeta.destroy) {
          if (keyInfo !== void 0) {
            const [fieldKey, restPath] = keyInfo;
            namePath = [fieldKey].concat(_toConsumableArray(restPath));
            fieldKeyPathRef.current = namePath;
          }
        } else {
          namePath = fieldKeyPathRef.current || namePath;
        }
        notifyParentMetaChange(nextMeta, namePath);
      }
    };
    const onSubItemMetaChange = (subMeta, uniqueKeys) => {
      setSubFieldErrors((prevSubFieldErrors) => {
        const clone = Object.assign({}, prevSubFieldErrors);
        const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
        const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
        if (subMeta.destroy) {
          delete clone[mergedNameKey];
        } else {
          clone[mergedNameKey] = subMeta;
        }
        return clone;
      });
    };
    const [mergedErrors, mergedWarnings] = React281.useMemo(() => {
      const errorList = _toConsumableArray(meta.errors);
      const warningList = _toConsumableArray(meta.warnings);
      Object.values(subFieldErrors).forEach((subFieldError) => {
        errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
        warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
      });
      return [errorList, warningList];
    }, [subFieldErrors, meta.errors, meta.warnings]);
    const getItemRef = useItemRef();
    function renderLayout(baseChildren, fieldId, isRequired) {
      if (noStyle && !hidden) {
        return /* @__PURE__ */ React281.createElement(StatusProvider, {
          prefixCls,
          hasFeedback: props.hasFeedback,
          validateStatus: props.validateStatus,
          meta,
          errors: mergedErrors,
          warnings: mergedWarnings,
          noStyle: true,
          name
        }, baseChildren);
      }
      return /* @__PURE__ */ React281.createElement(ItemHolder, Object.assign({
        key: "row"
      }, props, {
        className: (0, import_classnames100.default)(className, cssVarCls, rootCls, hashId),
        prefixCls,
        fieldId,
        isRequired,
        errors: mergedErrors,
        warnings: mergedWarnings,
        meta,
        onSubItemMetaChange,
        layout,
        name
      }), baseChildren);
    }
    if (!hasName && !isRenderProps && !dependencies) {
      return wrapCSSVar(renderLayout(mergedChildren));
    }
    let variables = {};
    if (typeof label === "string") {
      variables.label = label;
    } else if (name) {
      variables.label = String(name);
    }
    if (messageVariables) {
      variables = Object.assign(Object.assign({}, variables), messageVariables);
    }
    return wrapCSSVar(/* @__PURE__ */ React281.createElement(Field_default, Object.assign({}, props, {
      messageVariables: variables,
      trigger,
      validateTrigger: mergedValidateTrigger,
      onMetaChange
    }), (control, renderMeta, context) => {
      const mergedName = toArray5(name).length && renderMeta ? renderMeta.name : [];
      const fieldId = getFieldId(mergedName, formName);
      const isRequired = required5 !== void 0 ? required5 : !!(rules === null || rules === void 0 ? void 0 : rules.some((rule) => {
        if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
          return true;
        }
        if (typeof rule === "function") {
          const ruleEntity = rule(context);
          return (ruleEntity === null || ruleEntity === void 0 ? void 0 : ruleEntity.required) && !(ruleEntity === null || ruleEntity === void 0 ? void 0 : ruleEntity.warningOnly);
        }
        return false;
      }));
      const mergedControl = Object.assign({}, control);
      let childNode = null;
      true ? warning6(!(shouldUpdate && dependencies), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps.") : void 0;
      if (Array.isArray(mergedChildren) && hasName) {
        true ? warning6(false, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item.") : void 0;
        childNode = mergedChildren;
      } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) {
        true ? warning6(!!(shouldUpdate || dependencies), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`.") : void 0;
        true ? warning6(!hasName, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.") : void 0;
      } else if (dependencies && !isRenderProps && !hasName) {
        true ? warning6(false, "usage", "Must set `name` or use a render function when `dependencies` is set.") : void 0;
      } else if (/* @__PURE__ */ React281.isValidElement(mergedChildren)) {
        true ? warning6(mergedChildren.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.") : void 0;
        const childProps = Object.assign(Object.assign({}, mergedChildren.props), mergedControl);
        if (!childProps.id) {
          childProps.id = fieldId;
        }
        if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
          const describedbyArr = [];
          if (help || mergedErrors.length > 0) {
            describedbyArr.push(`${fieldId}_help`);
          }
          if (props.extra) {
            describedbyArr.push(`${fieldId}_extra`);
          }
          childProps["aria-describedby"] = describedbyArr.join(" ");
        }
        if (mergedErrors.length > 0) {
          childProps["aria-invalid"] = "true";
        }
        if (isRequired) {
          childProps["aria-required"] = "true";
        }
        if (supportRef(mergedChildren)) {
          childProps.ref = getItemRef(mergedName, mergedChildren);
        }
        const triggers = new Set([].concat(_toConsumableArray(toArray5(trigger)), _toConsumableArray(toArray5(mergedValidateTrigger))));
        triggers.forEach((eventName) => {
          childProps[eventName] = (...args) => {
            var _a2, _c2;
            var _a, _b, _c;
            (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
            (_c = (_b = mergedChildren.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
          };
        });
        const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
        childNode = /* @__PURE__ */ React281.createElement(MemoInput, {
          control: mergedControl,
          update: mergedChildren,
          childProps: watchingChildProps
        }, cloneElement3(mergedChildren, childProps));
      } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
        childNode = mergedChildren(context);
      } else {
        true ? warning6(!mergedName.length || !!noStyle, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead.") : void 0;
        childNode = mergedChildren;
      }
      return renderLayout(childNode, fieldId, isRequired);
    }));
  }
  var FormItem = InternalFormItem;
  FormItem.useStatus = useFormItemStatus_default;
  var FormItem_default = FormItem;

  // node_modules/antd/es/form/FormList.js
  var React282 = __toESM(require_react());
  var __rest38 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var FormList = (_a) => {
    var {
      prefixCls: customizePrefixCls,
      children
    } = _a, props = __rest38(_a, ["prefixCls", "children"]);
    if (true) {
      const warning6 = devUseWarning("Form.List");
      true ? warning6(typeof props.name === "number" || (Array.isArray(props.name) ? !!props.name.length : !!props.name), "usage", "Miss `name` prop.") : void 0;
    }
    const {
      getPrefixCls
    } = React282.useContext(ConfigContext);
    const prefixCls = getPrefixCls("form", customizePrefixCls);
    const contextValue = React282.useMemo(() => ({
      prefixCls,
      status: "error"
    }), [prefixCls]);
    return /* @__PURE__ */ React282.createElement(List_default, Object.assign({}, props), (fields, operation, meta) => /* @__PURE__ */ React282.createElement(FormItemPrefixContext.Provider, {
      value: contextValue
    }, children(fields.map((field) => Object.assign(Object.assign({}, field), {
      fieldKey: field.key
    })), operation, {
      errors: meta.errors,
      warnings: meta.warnings
    })));
  };
  var FormList_default = FormList;

  // node_modules/antd/es/form/hooks/useFormInstance.js
  var React283 = __toESM(require_react());
  function useFormInstance() {
    const {
      form
    } = React283.useContext(FormContext2);
    return form;
  }

  // node_modules/antd/es/form/index.js
  var Form4 = Form_default2;
  Form4.Item = FormItem_default;
  Form4.List = FormList_default;
  Form4.ErrorList = ErrorList_default;
  Form4.useForm = useForm2;
  Form4.useFormInstance = useFormInstance;
  Form4.useWatch = useWatch_default;
  Form4.Provider = FormProvider3;
  Form4.create = () => {
    true ? warning_default2(false, "Form", "antd v4 removed `Form.create`. Please remove or use `@ant-design/compatible` instead.") : void 0;
  };
  var form_default = Form4;

  // node_modules/@ant-design/icons/es/icons/EyeOutlined.js
  var React284 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/EyeOutlined.js
  var EyeOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
  var EyeOutlined_default = EyeOutlined;

  // node_modules/@ant-design/icons/es/icons/EyeOutlined.js
  var EyeOutlined2 = function EyeOutlined3(props, ref) {
    return /* @__PURE__ */ React284.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: EyeOutlined_default
    }));
  };
  var RefIcon16 = /* @__PURE__ */ React284.forwardRef(EyeOutlined2);
  if (true) {
    RefIcon16.displayName = "EyeOutlined";
  }
  var EyeOutlined_default2 = RefIcon16;

  // node_modules/rc-util/es/Dom/addEventListener.js
  var import_react_dom7 = __toESM(require_react_dom());
  function addEventListenerWrap(target, eventType, cb, option) {
    var callback = import_react_dom7.default.unstable_batchedUpdates ? function run(e3) {
      import_react_dom7.default.unstable_batchedUpdates(cb, e3);
    } : cb;
    if (target !== null && target !== void 0 && target.addEventListener) {
      target.addEventListener(eventType, callback, option);
    }
    return {
      remove: function remove() {
        if (target !== null && target !== void 0 && target.removeEventListener) {
          target.removeEventListener(eventType, callback, option);
        }
      }
    };
  }

  // node_modules/antd/es/input/Group.js
  var React285 = __toESM(require_react());
  var import_react100 = __toESM(require_react());
  var import_classnames101 = __toESM(require_classnames());
  var Group = (props) => {
    const {
      getPrefixCls,
      direction
    } = (0, import_react100.useContext)(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      className
    } = props;
    const prefixCls = getPrefixCls("input-group", customizePrefixCls);
    const inputPrefixCls = getPrefixCls("input");
    const [wrapCSSVar, hashId, cssVarCls] = style_default14(inputPrefixCls);
    const cls3 = (0, import_classnames101.default)(prefixCls, cssVarCls, {
      [`${prefixCls}-lg`]: props.size === "large",
      [`${prefixCls}-sm`]: props.size === "small",
      [`${prefixCls}-compact`]: props.compact,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, hashId, className);
    const formItemContext = (0, import_react100.useContext)(FormItemInputContext);
    const groupFormItemContext = (0, import_react100.useMemo)(() => Object.assign(Object.assign({}, formItemContext), {
      isFormItemInput: false
    }), [formItemContext]);
    if (true) {
      const warning6 = devUseWarning("Input.Group");
      warning6.deprecated(false, "Input.Group", "Space.Compact");
    }
    return wrapCSSVar(/* @__PURE__ */ React285.createElement("span", {
      className: cls3,
      style: props.style,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      onFocus: props.onFocus,
      onBlur: props.onBlur
    }, /* @__PURE__ */ React285.createElement(FormItemInputContext.Provider, {
      value: groupFormItemContext
    }, props.children)));
  };
  var Group_default2 = Group;

  // node_modules/antd/es/input/OTP/index.js
  var React287 = __toESM(require_react());
  var import_classnames103 = __toESM(require_classnames());

  // node_modules/antd/es/input/style/otp.js
  var genOTPStyle = (token2) => {
    const {
      componentCls,
      paddingXS
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        alignItems: "center",
        flexWrap: "nowrap",
        columnGap: paddingXS,
        [`${componentCls}-input-wrapper`]: {
          position: "relative",
          [`${componentCls}-mask-icon`]: {
            position: "absolute",
            zIndex: "1",
            top: "50%",
            right: "50%",
            transform: "translate(50%, -50%)",
            pointerEvents: "none"
          },
          [`${componentCls}-mask-input`]: {
            color: "transparent",
            caretColor: "var(--ant-color-text)"
          },
          [`${componentCls}-mask-input[type=number]::-webkit-inner-spin-button`]: {
            "-webkit-appearance": "none",
            margin: 0
          },
          [`${componentCls}-mask-input[type=number]`]: {
            "-moz-appearance": "textfield"
          }
        },
        "&-rtl": {
          direction: "rtl"
        },
        [`${componentCls}-input`]: {
          textAlign: "center",
          paddingInline: token2.paddingXXS
        },
        // ================= Size =================
        [`&${componentCls}-sm ${componentCls}-input`]: {
          paddingInline: token2.calc(token2.paddingXXS).div(2).equal()
        },
        [`&${componentCls}-lg ${componentCls}-input`]: {
          paddingInline: token2.paddingXS
        }
      }
    };
  };
  var otp_default = genStyleHooks(["Input", "OTP"], (token2) => {
    const inputToken = merge2(token2, initInputToken(token2));
    return [genOTPStyle(inputToken)];
  }, initComponentToken);

  // node_modules/antd/es/input/OTP/OTPInput.js
  var React286 = __toESM(require_react());
  var import_classnames102 = __toESM(require_classnames());
  var __rest39 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var OTPInput = /* @__PURE__ */ React286.forwardRef((props, ref) => {
    const {
      className,
      value,
      onChange,
      onActiveChange,
      index: index3,
      mask
    } = props, restProps = __rest39(props, ["className", "value", "onChange", "onActiveChange", "index", "mask"]);
    const {
      getPrefixCls
    } = React286.useContext(ConfigContext);
    const prefixCls = getPrefixCls("otp");
    const maskValue = typeof mask === "string" ? mask : value;
    const inputRef = React286.useRef(null);
    React286.useImperativeHandle(ref, () => inputRef.current);
    const onInternalChange = (e3) => {
      onChange(index3, e3.target.value);
    };
    const syncSelection = () => {
      raf_default(() => {
        var _a;
        const inputEle = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input;
        if (document.activeElement === inputEle && inputEle) {
          inputEle.select();
        }
      });
    };
    const onInternalKeyDown = (event) => {
      const {
        key,
        ctrlKey,
        metaKey
      } = event;
      if (key === "ArrowLeft") {
        onActiveChange(index3 - 1);
      } else if (key === "ArrowRight") {
        onActiveChange(index3 + 1);
      } else if (key === "z" && (ctrlKey || metaKey)) {
        event.preventDefault();
      }
      syncSelection();
    };
    const onInternalKeyUp = (e3) => {
      if (e3.key === "Backspace" && !value) {
        onActiveChange(index3 - 1);
      }
      syncSelection();
    };
    return /* @__PURE__ */ React286.createElement("span", {
      className: `${prefixCls}-input-wrapper`,
      role: "presentation"
    }, mask && value !== "" && value !== void 0 && /* @__PURE__ */ React286.createElement("span", {
      className: `${prefixCls}-mask-icon`,
      "aria-hidden": "true"
    }, maskValue), /* @__PURE__ */ React286.createElement(Input_default4, Object.assign({
      "aria-label": `OTP Input ${index3 + 1}`,
      type: mask === true ? "password" : "text"
    }, restProps, {
      ref: inputRef,
      value,
      onInput: onInternalChange,
      onFocus: syncSelection,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onMouseDown: syncSelection,
      onMouseUp: syncSelection,
      className: (0, import_classnames102.default)(className, {
        [`${prefixCls}-mask-input`]: mask
      })
    })));
  });
  var OTPInput_default = OTPInput;

  // node_modules/antd/es/input/OTP/index.js
  var __rest40 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function strToArr(str) {
    return (str || "").split("");
  }
  var Separator = (props) => {
    const {
      index: index3,
      prefixCls,
      separator
    } = props;
    const separatorNode = typeof separator === "function" ? separator(index3) : separator;
    if (!separatorNode) {
      return null;
    }
    return /* @__PURE__ */ React287.createElement("span", {
      className: `${prefixCls}-separator`
    }, separatorNode);
  };
  var OTP = /* @__PURE__ */ React287.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      length: length2 = 6,
      size: customSize,
      defaultValue,
      value,
      onChange,
      formatter,
      separator,
      variant,
      disabled,
      status: customStatus,
      autoFocus,
      mask,
      type: type5,
      onInput,
      inputMode
    } = props, restProps = __rest40(props, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "separator", "variant", "disabled", "status", "autoFocus", "mask", "type", "onInput", "inputMode"]);
    if (true) {
      const warning6 = devUseWarning("Input.OTP");
      true ? warning6(!(typeof mask === "string" && mask.length > 1), "usage", "`mask` prop should be a single character.") : void 0;
    }
    const {
      getPrefixCls,
      direction
    } = React287.useContext(ConfigContext);
    const prefixCls = getPrefixCls("otp", customizePrefixCls);
    const domAttrs = pickAttrs(restProps, {
      aria: true,
      data: true,
      attr: true
    });
    const [wrapCSSVar, hashId, cssVarCls] = otp_default(prefixCls);
    const mergedSize = useSize_default((ctx) => customSize !== null && customSize !== void 0 ? customSize : ctx);
    const formContext = React287.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(formContext.status, customStatus);
    const proxyFormContext = React287.useMemo(() => Object.assign(Object.assign({}, formContext), {
      status: mergedStatus,
      hasFeedback: false,
      feedbackIcon: null
    }), [formContext, mergedStatus]);
    const containerRef = React287.useRef(null);
    const refs = React287.useRef({});
    React287.useImperativeHandle(ref, () => ({
      focus: () => {
        var _a;
        (_a = refs.current[0]) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur: () => {
        var _a;
        for (let i = 0; i < length2; i += 1) {
          (_a = refs.current[i]) === null || _a === void 0 ? void 0 : _a.blur();
        }
      },
      nativeElement: containerRef.current
    }));
    const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
    const [valueCells, setValueCells] = React287.useState(() => strToArr(internalFormatter(defaultValue || "")));
    React287.useEffect(() => {
      if (value !== void 0) {
        setValueCells(strToArr(value));
      }
    }, [value]);
    const triggerValueCellsChange = useEvent((nextValueCells) => {
      setValueCells(nextValueCells);
      if (onInput) {
        onInput(nextValueCells);
      }
      if (onChange && nextValueCells.length === length2 && nextValueCells.every((c) => c) && nextValueCells.some((c, index3) => valueCells[index3] !== c)) {
        onChange(nextValueCells.join(""));
      }
    });
    const patchValue = useEvent((index3, txt) => {
      let nextCells = _toConsumableArray(valueCells);
      for (let i = 0; i < index3; i += 1) {
        if (!nextCells[i]) {
          nextCells[i] = "";
        }
      }
      if (txt.length <= 1) {
        nextCells[index3] = txt;
      } else {
        nextCells = nextCells.slice(0, index3).concat(strToArr(txt));
      }
      nextCells = nextCells.slice(0, length2);
      for (let i = nextCells.length - 1; i >= 0; i -= 1) {
        if (nextCells[i]) {
          break;
        }
        nextCells.pop();
      }
      const formattedValue = internalFormatter(nextCells.map((c) => c || " ").join(""));
      nextCells = strToArr(formattedValue).map((c, i) => {
        if (c === " " && !nextCells[i]) {
          return nextCells[i];
        }
        return c;
      });
      return nextCells;
    });
    const onInputChange = (index3, txt) => {
      var _a;
      const nextCells = patchValue(index3, txt);
      const nextIndex = Math.min(index3 + txt.length, length2 - 1);
      if (nextIndex !== index3 && nextCells[index3] !== void 0) {
        (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
      }
      triggerValueCellsChange(nextCells);
    };
    const onInputActiveChange = (nextIndex) => {
      var _a;
      (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const inputSharedProps = {
      variant,
      disabled,
      status: mergedStatus,
      mask,
      type: type5,
      inputMode
    };
    return wrapCSSVar(/* @__PURE__ */ React287.createElement("div", Object.assign({}, domAttrs, {
      ref: containerRef,
      className: (0, import_classnames103.default)(prefixCls, {
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, cssVarCls, hashId),
      role: "group"
    }), /* @__PURE__ */ React287.createElement(FormItemInputContext.Provider, {
      value: proxyFormContext
    }, Array.from({
      length: length2
    }).map((_, index3) => {
      const key = `otp-${index3}`;
      const singleValue = valueCells[index3] || "";
      return /* @__PURE__ */ React287.createElement(React287.Fragment, {
        key
      }, /* @__PURE__ */ React287.createElement(OTPInput_default, Object.assign({
        ref: (inputEle) => {
          refs.current[index3] = inputEle;
        },
        index: index3,
        size: mergedSize,
        htmlSize: 1,
        className: `${prefixCls}-input`,
        onChange: onInputChange,
        value: singleValue,
        onActiveChange: onInputActiveChange,
        autoFocus: index3 === 0 && autoFocus
      }, inputSharedProps)), index3 < length2 - 1 && /* @__PURE__ */ React287.createElement(Separator, {
        separator,
        index: index3,
        prefixCls
      }));
    }))));
  });
  var OTP_default = OTP;

  // node_modules/antd/es/input/Password.js
  var React289 = __toESM(require_react());
  var import_react101 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/EyeInvisibleOutlined.js
  var React288 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/EyeInvisibleOutlined.js
  var EyeInvisibleOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
  var EyeInvisibleOutlined_default = EyeInvisibleOutlined;

  // node_modules/@ant-design/icons/es/icons/EyeInvisibleOutlined.js
  var EyeInvisibleOutlined2 = function EyeInvisibleOutlined3(props, ref) {
    return /* @__PURE__ */ React288.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: EyeInvisibleOutlined_default
    }));
  };
  var RefIcon17 = /* @__PURE__ */ React288.forwardRef(EyeInvisibleOutlined2);
  if (true) {
    RefIcon17.displayName = "EyeInvisibleOutlined";
  }
  var EyeInvisibleOutlined_default2 = RefIcon17;

  // node_modules/antd/es/input/Password.js
  var import_classnames104 = __toESM(require_classnames());
  var __rest41 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var defaultIconRender = (visible) => visible ? /* @__PURE__ */ React289.createElement(EyeOutlined_default2, null) : /* @__PURE__ */ React289.createElement(EyeInvisibleOutlined_default2, null);
  var actionMap = {
    click: "onClick",
    hover: "onMouseOver"
  };
  var Password = /* @__PURE__ */ React289.forwardRef((props, ref) => {
    const {
      disabled: customDisabled,
      action = "click",
      visibilityToggle = true,
      iconRender = defaultIconRender
    } = props;
    const disabled = React289.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
    const [visible, setVisible] = (0, import_react101.useState)(() => visibilityControlled ? visibilityToggle.visible : false);
    const inputRef = (0, import_react101.useRef)(null);
    React289.useEffect(() => {
      if (visibilityControlled) {
        setVisible(visibilityToggle.visible);
      }
    }, [visibilityControlled, visibilityToggle]);
    const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
    const onVisibleChange = () => {
      var _a;
      if (mergedDisabled) {
        return;
      }
      if (visible) {
        removePasswordTimeout();
      }
      const nextVisible = !visible;
      setVisible(nextVisible);
      if (typeof visibilityToggle === "object") {
        (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, nextVisible);
      }
    };
    const getIcon2 = (prefixCls2) => {
      const iconTrigger = actionMap[action] || "";
      const icon = iconRender(visible);
      const iconProps = {
        [iconTrigger]: onVisibleChange,
        className: `${prefixCls2}-icon`,
        key: "passwordIcon",
        onMouseDown: (e3) => {
          e3.preventDefault();
        },
        onMouseUp: (e3) => {
          e3.preventDefault();
        }
      };
      return /* @__PURE__ */ React289.cloneElement(/* @__PURE__ */ React289.isValidElement(icon) ? icon : /* @__PURE__ */ React289.createElement("span", null, icon), iconProps);
    };
    const {
      className,
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      size
    } = props, restProps = __rest41(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
    const {
      getPrefixCls
    } = React289.useContext(ConfigContext);
    const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    const prefixCls = getPrefixCls("input-password", customizePrefixCls);
    const suffixIcon = visibilityToggle && getIcon2(prefixCls);
    const inputClassName = (0, import_classnames104.default)(prefixCls, className, {
      [`${prefixCls}-${size}`]: !!size
    });
    const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
      type: visible ? "text" : "password",
      className: inputClassName,
      prefixCls: inputPrefixCls,
      suffix: suffixIcon
    });
    if (size) {
      omittedProps.size = size;
    }
    return /* @__PURE__ */ React289.createElement(Input_default4, Object.assign({
      ref: composeRef(ref, inputRef)
    }, omittedProps));
  });
  if (true) {
    Password.displayName = "Input.Password";
  }
  var Password_default = Password;

  // node_modules/antd/es/input/Search.js
  var React290 = __toESM(require_react());
  var import_classnames105 = __toESM(require_classnames());
  var __rest42 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Search = /* @__PURE__ */ React290.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      className,
      size: customizeSize,
      suffix,
      enterButton = false,
      addonAfter,
      loading,
      disabled,
      onSearch: customOnSearch,
      onChange: customOnChange,
      onCompositionStart,
      onCompositionEnd,
      variant,
      onPressEnter: customOnPressEnter
    } = props, restProps = __rest42(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd", "variant", "onPressEnter"]);
    const {
      getPrefixCls,
      direction
    } = React290.useContext(ConfigContext);
    const composedRef = React290.useRef(false);
    const prefixCls = getPrefixCls("input-search", customizePrefixCls);
    const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    const {
      compactSize
    } = useCompactItemContext(prefixCls, direction);
    const size = useSize_default((ctx) => {
      var _a;
      return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
    });
    const inputRef = React290.useRef(null);
    const onChange = (e3) => {
      if ((e3 === null || e3 === void 0 ? void 0 : e3.target) && e3.type === "click" && customOnSearch) {
        customOnSearch(e3.target.value, e3, {
          source: "clear"
        });
      }
      customOnChange === null || customOnChange === void 0 ? void 0 : customOnChange(e3);
    };
    const onMouseDown = (e3) => {
      var _a;
      if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
        e3.preventDefault();
      }
    };
    const onSearch = (e3) => {
      var _a, _b;
      if (customOnSearch) {
        customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e3, {
          source: "input"
        });
      }
    };
    const onPressEnter = (e3) => {
      if (composedRef.current || loading) {
        return;
      }
      customOnPressEnter === null || customOnPressEnter === void 0 ? void 0 : customOnPressEnter(e3);
      onSearch(e3);
    };
    const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ React290.createElement(SearchOutlined_default2, null) : null;
    const btnClassName = `${prefixCls}-button`;
    let button;
    const enterButtonAsElement = enterButton || {};
    const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
    if (isAntdButton || enterButtonAsElement.type === "button") {
      button = cloneElement3(enterButtonAsElement, Object.assign({
        onMouseDown,
        onClick: (e3) => {
          var _a, _b;
          (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e3);
          onSearch(e3);
        },
        key: "enterButton"
      }, isAntdButton ? {
        className: btnClassName,
        size
      } : {}));
    } else {
      button = /* @__PURE__ */ React290.createElement(button_default2, {
        className: btnClassName,
        color: enterButton ? "primary" : "default",
        size,
        disabled,
        key: "enterButton",
        onMouseDown,
        onClick: onSearch,
        loading,
        icon: searchIcon,
        variant: variant === "borderless" || variant === "filled" || variant === "underlined" ? "text" : enterButton ? "solid" : void 0
      }, enterButton);
    }
    if (addonAfter) {
      button = [button, cloneElement3(addonAfter, {
        key: "addonAfter"
      })];
    }
    const cls3 = (0, import_classnames105.default)(prefixCls, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${size}`]: !!size,
      [`${prefixCls}-with-button`]: !!enterButton
    }, className);
    const handleOnCompositionStart = (e3) => {
      composedRef.current = true;
      onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e3);
    };
    const handleOnCompositionEnd = (e3) => {
      composedRef.current = false;
      onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e3);
    };
    const inputProps = Object.assign(Object.assign({}, restProps), {
      className: cls3,
      prefixCls: inputPrefixCls,
      type: "search",
      size,
      variant,
      onPressEnter,
      onCompositionStart: handleOnCompositionStart,
      onCompositionEnd: handleOnCompositionEnd,
      addonAfter: button,
      suffix,
      onChange,
      disabled
    });
    return /* @__PURE__ */ React290.createElement(Input_default4, Object.assign({
      ref: composeRef(inputRef, ref)
    }, inputProps));
  });
  if (true) {
    Search.displayName = "Search";
  }
  var Search_default = Search;

  // node_modules/antd/es/input/TextArea.js
  var React293 = __toESM(require_react());
  var import_react103 = __toESM(require_react());
  var import_classnames108 = __toESM(require_classnames());

  // node_modules/rc-textarea/es/TextArea.js
  var import_classnames107 = __toESM(require_classnames());
  var import_react102 = __toESM(require_react());

  // node_modules/rc-textarea/es/ResizableTextArea.js
  var import_classnames106 = __toESM(require_classnames());
  var React291 = __toESM(require_react());

  // node_modules/rc-textarea/es/calculateNodeHeight.js
  var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
  var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
  var computedStyleCache = {};
  var hiddenTextarea;
  function calculateNodeStyling(node2) {
    var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
    if (useCache && computedStyleCache[nodeRef]) {
      return computedStyleCache[nodeRef];
    }
    var style2 = window.getComputedStyle(node2);
    var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
    var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
    var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
    var sizingStyle = SIZING_STYLE.map(function(name) {
      return "".concat(name, ":").concat(style2.getPropertyValue(name));
    }).join(";");
    var nodeInfo = {
      sizingStyle,
      paddingSize,
      borderSize,
      boxSizing
    };
    if (useCache && nodeRef) {
      computedStyleCache[nodeRef] = nodeInfo;
    }
    return nodeInfo;
  }
  function calculateAutoSizeStyle(uiTextNode) {
    var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      hiddenTextarea.setAttribute("tab-index", "-1");
      hiddenTextarea.setAttribute("aria-hidden", "true");
      hiddenTextarea.setAttribute("name", "hiddenTextarea");
      document.body.appendChild(hiddenTextarea);
    }
    if (uiTextNode.getAttribute("wrap")) {
      hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
    } else {
      hiddenTextarea.removeAttribute("wrap");
    }
    var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
    hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
    var minHeight = void 0;
    var maxHeight = void 0;
    var overflowY;
    var height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += borderSize;
    } else if (boxSizing === "content-box") {
      height -= paddingSize;
    }
    if (minRows !== null || maxRows !== null) {
      hiddenTextarea.value = " ";
      var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (minRows !== null) {
        minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
      }
      if (maxRows !== null) {
        maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        overflowY = height > maxHeight ? "" : "hidden";
        height = Math.min(maxHeight, height);
      }
    }
    var style2 = {
      height,
      overflowY,
      resize: "none"
    };
    if (minHeight) {
      style2.minHeight = minHeight;
    }
    if (maxHeight) {
      style2.maxHeight = maxHeight;
    }
    return style2;
  }

  // node_modules/rc-textarea/es/ResizableTextArea.js
  var _excluded45 = ["prefixCls", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
  var RESIZE_START = 0;
  var RESIZE_MEASURING = 1;
  var RESIZE_STABLE = 2;
  var ResizableTextArea = /* @__PURE__ */ React291.forwardRef(function(props, ref) {
    var _ref = props, prefixCls = _ref.prefixCls, defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange, onInternalAutoSize = _ref.onInternalAutoSize, restProps = _objectWithoutProperties(_ref, _excluded45);
    var _useMergedState = useMergedState(defaultValue, {
      value,
      postState: function postState(val) {
        return val !== null && val !== void 0 ? val : "";
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
    var onInternalChange = function onInternalChange2(event) {
      setMergedValue(event.target.value);
      onChange === null || onChange === void 0 || onChange(event);
    };
    var textareaRef = React291.useRef();
    React291.useImperativeHandle(ref, function() {
      return {
        textArea: textareaRef.current
      };
    });
    var _React$useMemo = React291.useMemo(function() {
      if (autoSize && _typeof(autoSize) === "object") {
        return [autoSize.minRows, autoSize.maxRows];
      }
      return [];
    }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
    var needAutoSize = !!autoSize;
    var _React$useState = React291.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
    var _React$useState3 = React291.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
    var startResize = function startResize2() {
      setResizeState(RESIZE_START);
      if (false) {
        onInternalAutoSize === null || onInternalAutoSize === void 0 || onInternalAutoSize();
      }
    };
    useLayoutEffect_default(function() {
      if (needAutoSize) {
        startResize();
      }
    }, [value, minRows, maxRows, needAutoSize]);
    useLayoutEffect_default(function() {
      if (resizeState === RESIZE_START) {
        setResizeState(RESIZE_MEASURING);
      } else if (resizeState === RESIZE_MEASURING) {
        var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
        setResizeState(RESIZE_STABLE);
        setAutoSizeStyle(textareaStyles);
      } else {
      }
    }, [resizeState]);
    var resizeRafRef = React291.useRef();
    var cleanRaf = function cleanRaf2() {
      raf_default.cancel(resizeRafRef.current);
    };
    var onInternalResize = function onInternalResize2(size) {
      if (resizeState === RESIZE_STABLE) {
        onResize2 === null || onResize2 === void 0 || onResize2(size);
        if (autoSize) {
          cleanRaf();
          resizeRafRef.current = raf_default(function() {
            startResize();
          });
        }
      }
    };
    React291.useEffect(function() {
      return cleanRaf;
    }, []);
    var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
    var mergedStyle = _objectSpread2(_objectSpread2({}, style2), mergedAutoSizeStyle);
    if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
      mergedStyle.overflowY = "hidden";
      mergedStyle.overflowX = "hidden";
    }
    return /* @__PURE__ */ React291.createElement(es_default, {
      onResize: onInternalResize,
      disabled: !(autoSize || onResize2)
    }, /* @__PURE__ */ React291.createElement("textarea", _extends({}, restProps, {
      ref: textareaRef,
      style: mergedStyle,
      className: (0, import_classnames106.default)(prefixCls, className, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled)),
      disabled,
      value: mergedValue,
      onChange: onInternalChange
    })));
  });
  var ResizableTextArea_default = ResizableTextArea;

  // node_modules/rc-textarea/es/TextArea.js
  var _excluded46 = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "onClear", "onPressEnter", "readOnly", "autoSize", "onKeyDown"];
  var TextArea = /* @__PURE__ */ import_react102.default.forwardRef(function(_ref, ref) {
    var _countConfig$max;
    var defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, showCount = _ref.showCount, count = _ref.count, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, hidden = _ref.hidden, classNames146 = _ref.classNames, styles = _ref.styles, onResize2 = _ref.onResize, onClear = _ref.onClear, onPressEnter = _ref.onPressEnter, readOnly = _ref.readOnly, autoSize = _ref.autoSize, onKeyDown2 = _ref.onKeyDown, rest = _objectWithoutProperties(_ref, _excluded46);
    var _useMergedState = useMergedState(defaultValue, {
      value: customValue,
      defaultValue
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
    var formatValue = value === void 0 || value === null ? "" : String(value);
    var _React$useState = import_react102.default.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
    var compositionRef = import_react102.default.useRef(false);
    var _React$useState3 = import_react102.default.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), textareaResized = _React$useState4[0], setTextareaResized = _React$useState4[1];
    var holderRef = (0, import_react102.useRef)(null);
    var resizableTextAreaRef = (0, import_react102.useRef)(null);
    var getTextArea = function getTextArea2() {
      var _resizableTextAreaRef;
      return (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea;
    };
    var focus = function focus2() {
      getTextArea().focus();
    };
    (0, import_react102.useImperativeHandle)(ref, function() {
      var _holderRef$current;
      return {
        resizableTextArea: resizableTextAreaRef.current,
        focus,
        blur: function blur() {
          getTextArea().blur();
        },
        nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || getTextArea()
      };
    });
    (0, import_react102.useEffect)(function() {
      setFocused(function(prev2) {
        return !disabled && prev2;
      });
    }, [disabled]);
    var _React$useState5 = import_react102.default.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), selection = _React$useState6[0], setSelection = _React$useState6[1];
    import_react102.default.useEffect(function() {
      if (selection) {
        var _getTextArea;
        (_getTextArea = getTextArea()).setSelectionRange.apply(_getTextArea, _toConsumableArray(selection));
      }
    }, [selection]);
    var countConfig = useCount(count, showCount);
    var mergedMax = (_countConfig$max = countConfig.max) !== null && _countConfig$max !== void 0 ? _countConfig$max : maxLength;
    var hasMaxLength = Number(mergedMax) > 0;
    var valueLength = countConfig.strategy(formatValue);
    var isOutOfRange = !!mergedMax && valueLength > mergedMax;
    var triggerChange = function triggerChange2(e3, currentValue) {
      var cutValue = currentValue;
      if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
        cutValue = countConfig.exceedFormatter(currentValue, {
          max: countConfig.max
        });
        if (currentValue !== cutValue) {
          setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
        }
      }
      setValue(cutValue);
      resolveOnChange(e3.currentTarget, e3, onChange, cutValue);
    };
    var onInternalCompositionStart = function onInternalCompositionStart2(e3) {
      compositionRef.current = true;
      onCompositionStart === null || onCompositionStart === void 0 || onCompositionStart(e3);
    };
    var onInternalCompositionEnd = function onInternalCompositionEnd2(e3) {
      compositionRef.current = false;
      triggerChange(e3, e3.currentTarget.value);
      onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e3);
    };
    var onInternalChange = function onInternalChange2(e3) {
      triggerChange(e3, e3.target.value);
    };
    var handleKeyDown = function handleKeyDown2(e3) {
      if (e3.key === "Enter" && onPressEnter) {
        onPressEnter(e3);
      }
      onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(e3);
    };
    var handleFocus = function handleFocus2(e3) {
      setFocused(true);
      onFocus === null || onFocus === void 0 || onFocus(e3);
    };
    var handleBlur = function handleBlur2(e3) {
      setFocused(false);
      onBlur === null || onBlur === void 0 || onBlur(e3);
    };
    var handleReset = function handleReset2(e3) {
      setValue("");
      focus();
      resolveOnChange(getTextArea(), e3, onChange);
    };
    var suffixNode = suffix;
    var dataCount;
    if (countConfig.show) {
      if (countConfig.showFormatter) {
        dataCount = countConfig.showFormatter({
          value: formatValue,
          count: valueLength,
          maxLength: mergedMax
        });
      } else {
        dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
      }
      suffixNode = /* @__PURE__ */ import_react102.default.createElement(import_react102.default.Fragment, null, suffixNode, /* @__PURE__ */ import_react102.default.createElement("span", {
        className: (0, import_classnames107.default)("".concat(prefixCls, "-data-count"), classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.count),
        style: styles === null || styles === void 0 ? void 0 : styles.count
      }, dataCount));
    }
    var handleResize = function handleResize2(size) {
      var _getTextArea2;
      onResize2 === null || onResize2 === void 0 || onResize2(size);
      if ((_getTextArea2 = getTextArea()) !== null && _getTextArea2 !== void 0 && _getTextArea2.style.height) {
        setTextareaResized(true);
      }
    };
    var isPureTextArea = !autoSize && !showCount && !allowClear;
    return /* @__PURE__ */ import_react102.default.createElement(BaseInput_default, {
      ref: holderRef,
      value: formatValue,
      allowClear,
      handleReset,
      suffix: suffixNode,
      prefixCls,
      classNames: _objectSpread2(_objectSpread2({}, classNames146), {}, {
        affixWrapper: (0, import_classnames107.default)(classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.affixWrapper, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-show-count"), showCount), "".concat(prefixCls, "-textarea-allow-clear"), allowClear))
      }),
      disabled,
      focused,
      className: (0, import_classnames107.default)(className, isOutOfRange && "".concat(prefixCls, "-out-of-range")),
      style: _objectSpread2(_objectSpread2({}, style2), textareaResized && !isPureTextArea ? {
        height: "auto"
      } : {}),
      dataAttrs: {
        affixWrapper: {
          "data-count": typeof dataCount === "string" ? dataCount : void 0
        }
      },
      hidden,
      readOnly,
      onClear
    }, /* @__PURE__ */ import_react102.default.createElement(ResizableTextArea_default, _extends({}, rest, {
      autoSize,
      maxLength,
      onKeyDown: handleKeyDown,
      onChange: onInternalChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onCompositionStart: onInternalCompositionStart,
      onCompositionEnd: onInternalCompositionEnd,
      className: (0, import_classnames107.default)(classNames146 === null || classNames146 === void 0 ? void 0 : classNames146.textarea),
      style: _objectSpread2(_objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.textarea), {}, {
        resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
      }),
      disabled,
      prefixCls,
      onResize: handleResize,
      ref: resizableTextAreaRef,
      readOnly
    })));
  });
  var TextArea_default = TextArea;

  // node_modules/rc-textarea/es/index.js
  var es_default17 = TextArea_default;

  // node_modules/antd/es/input/style/textarea.js
  var genTextAreaStyle = (token2) => {
    const {
      componentCls,
      paddingLG
    } = token2;
    const textareaPrefixCls = `${componentCls}-textarea`;
    return {
      // Raw Textarea
      [`textarea${componentCls}`]: {
        maxWidth: "100%",
        // prevent textarea resize from coming out of its container
        height: "auto",
        minHeight: token2.controlHeight,
        lineHeight: token2.lineHeight,
        verticalAlign: "bottom",
        transition: `all ${token2.motionDurationSlow}`,
        resize: "vertical",
        [`&${componentCls}-mouse-active`]: {
          transition: `all ${token2.motionDurationSlow}, height 0s, width 0s`
        }
      },
      // Wrapper for resize
      [`${componentCls}-textarea-affix-wrapper-resize-dirty`]: {
        width: "auto"
      },
      [textareaPrefixCls]: {
        position: "relative",
        "&-show-count": {
          [`${componentCls}-data-count`]: {
            position: "absolute",
            bottom: token2.calc(token2.fontSize).mul(token2.lineHeight).mul(-1).equal(),
            insetInlineEnd: 0,
            color: token2.colorTextDescription,
            whiteSpace: "nowrap",
            pointerEvents: "none"
          }
        },
        [`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: {
          paddingInlineEnd: paddingLG
        },
        [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
          padding: 0,
          [`> textarea${componentCls}`]: {
            fontSize: "inherit",
            border: "none",
            outline: "none",
            background: "transparent",
            minHeight: token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal(),
            "&:focus": {
              boxShadow: "none !important"
            }
          },
          [`${componentCls}-suffix`]: {
            margin: 0,
            "> *:not(:last-child)": {
              marginInline: 0
            },
            // Clear Icon
            [`${componentCls}-clear-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingInline,
              insetBlockStart: token2.paddingXS
            },
            // Feedback Icon
            [`${textareaPrefixCls}-suffix`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: token2.paddingInline,
              bottom: 0,
              zIndex: 1,
              display: "inline-flex",
              alignItems: "center",
              margin: "auto",
              pointerEvents: "none"
            }
          }
        },
        [`&-affix-wrapper${componentCls}-affix-wrapper-rtl`]: {
          [`${componentCls}-suffix`]: {
            [`${componentCls}-data-count`]: {
              direction: "ltr",
              insetInlineStart: 0
            }
          }
        },
        [`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: {
          [`${componentCls}-suffix`]: {
            [`${componentCls}-clear-icon`]: {
              insetInlineEnd: token2.paddingInlineSM
            }
          }
        }
      }
    };
  };
  var textarea_default = genStyleHooks(["Input", "TextArea"], (token2) => {
    const inputToken = merge2(token2, initInputToken(token2));
    return [genTextAreaStyle(inputToken)];
  }, initComponentToken, {
    resetFont: false
  });

  // node_modules/antd/es/input/TextArea.js
  var __rest43 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var TextArea2 = /* @__PURE__ */ (0, import_react103.forwardRef)((props, ref) => {
    var _a;
    const {
      prefixCls: customizePrefixCls,
      bordered = true,
      size: customizeSize,
      disabled: customDisabled,
      status: customStatus,
      allowClear,
      classNames: classes,
      rootClassName,
      className,
      style: style2,
      styles,
      variant: customVariant,
      showCount,
      onMouseDown,
      onResize: onResize2
    } = props, rest = __rest43(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant", "showCount", "onMouseDown", "onResize"]);
    if (true) {
      const {
        deprecated
      } = devUseWarning("TextArea");
      deprecated(!("bordered" in props), "bordered", "variant");
    }
    const {
      getPrefixCls,
      direction,
      allowClear: contextAllowClear,
      autoComplete: contextAutoComplete,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("textArea");
    const disabled = React293.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const {
      status: contextStatus,
      hasFeedback,
      feedbackIcon
    } = React293.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const innerRef = React293.useRef(null);
    React293.useImperativeHandle(ref, () => {
      var _a2;
      return {
        resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
        focus: (option) => {
          var _a3, _b;
          triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
        },
        blur: () => {
          var _a3;
          return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
        }
      };
    });
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapSharedCSSVar, hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
    const [wrapCSSVar] = textarea_default(prefixCls, rootCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = useSize_default((ctx) => {
      var _a2;
      return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
    });
    const [variant, enableVariantCls] = useVariants_default("textArea", customVariant, bordered);
    const mergedAllowClear = getAllowClear_default(allowClear !== null && allowClear !== void 0 ? allowClear : contextAllowClear);
    const [isMouseDown, setIsMouseDown] = React293.useState(false);
    const [resizeDirty, setResizeDirty] = React293.useState(false);
    const onInternalMouseDown = (e3) => {
      setIsMouseDown(true);
      onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(e3);
      const onMouseUp = () => {
        setIsMouseDown(false);
        document.removeEventListener("mouseup", onMouseUp);
      };
      document.addEventListener("mouseup", onMouseUp);
    };
    const onInternalResize = (size) => {
      var _a2, _b;
      onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
      if (isMouseDown && typeof getComputedStyle === "function") {
        const ele = (_b = (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.nativeElement) === null || _b === void 0 ? void 0 : _b.querySelector("textarea");
        if (ele && getComputedStyle(ele).resize === "both") {
          setResizeDirty(true);
        }
      }
    };
    return wrapSharedCSSVar(wrapCSSVar(/* @__PURE__ */ React293.createElement(es_default17, Object.assign({
      autoComplete: contextAutoComplete
    }, rest, {
      style: Object.assign(Object.assign({}, contextStyle), style2),
      styles: Object.assign(Object.assign({}, contextStyles), styles),
      disabled: mergedDisabled,
      allowClear: mergedAllowClear,
      className: (0, import_classnames108.default)(
        cssVarCls,
        rootCls,
        className,
        rootClassName,
        compactItemClassnames,
        contextClassName,
        // Only for wrapper
        resizeDirty && `${prefixCls}-textarea-affix-wrapper-resize-dirty`
      ),
      classNames: Object.assign(Object.assign(Object.assign({}, classes), contextClassNames), {
        textarea: (0, import_classnames108.default)({
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-lg`]: mergedSize === "large"
        }, hashId, classes === null || classes === void 0 ? void 0 : classes.textarea, contextClassNames.textarea, isMouseDown && `${prefixCls}-mouse-active`),
        variant: (0, import_classnames108.default)({
          [`${prefixCls}-${variant}`]: enableVariantCls
        }, getStatusClassNames(prefixCls, mergedStatus)),
        affixWrapper: (0, import_classnames108.default)(`${prefixCls}-textarea-affix-wrapper`, {
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-textarea-show-count`]: showCount || ((_a = props.count) === null || _a === void 0 ? void 0 : _a.show)
        }, hashId)
      }),
      prefixCls,
      suffix: hasFeedback && /* @__PURE__ */ React293.createElement("span", {
        className: `${prefixCls}-textarea-suffix`
      }, feedbackIcon),
      showCount,
      ref: innerRef,
      onResize: onInternalResize,
      onMouseDown: onInternalMouseDown
    }))));
  });
  var TextArea_default2 = TextArea2;

  // node_modules/antd/es/input/index.js
  var Input5 = Input_default4;
  Input5.Group = Group_default2;
  Input5.Search = Search_default;
  Input5.TextArea = TextArea_default2;
  Input5.Password = Password_default;
  Input5.OTP = OTP_default;
  var input_default = Input5;

  // node_modules/antd/es/layout/layout.js
  var React294 = __toESM(require_react());
  var import_classnames109 = __toESM(require_classnames());

  // node_modules/antd/es/layout/hooks/useHasSider.js
  function useHasSider(siders, children, hasSider) {
    if (typeof hasSider === "boolean") {
      return hasSider;
    }
    if (siders.length) {
      return true;
    }
    const childNodes = toArray(children);
    return childNodes.some((node2) => node2.type === Sider_default);
  }

  // node_modules/antd/es/layout/layout.js
  var __rest44 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function generator({
    suffixCls,
    tagName,
    displayName
  }) {
    return (BasicComponent) => {
      const Adapter = /* @__PURE__ */ React294.forwardRef((props, ref) => /* @__PURE__ */ React294.createElement(BasicComponent, Object.assign({
        ref,
        suffixCls,
        tagName
      }, props)));
      if (true) {
        Adapter.displayName = displayName;
      }
      return Adapter;
    };
  }
  var Basic = /* @__PURE__ */ React294.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      suffixCls,
      className,
      tagName: TagName
    } = props, others = __rest44(props, ["prefixCls", "suffixCls", "className", "tagName"]);
    const {
      getPrefixCls
    } = React294.useContext(ConfigContext);
    const prefixCls = getPrefixCls("layout", customizePrefixCls);
    const [wrapSSR, hashId, cssVarCls] = style_default10(prefixCls);
    const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
    return wrapSSR(/* @__PURE__ */ React294.createElement(TagName, Object.assign({
      className: (0, import_classnames109.default)(customizePrefixCls || prefixWithSuffixCls, className, hashId, cssVarCls),
      ref
    }, others)));
  });
  var BasicLayout = /* @__PURE__ */ React294.forwardRef((props, ref) => {
    const {
      direction
    } = React294.useContext(ConfigContext);
    const [siders, setSiders] = React294.useState([]);
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      children,
      hasSider,
      tagName: Tag2,
      style: style2
    } = props, others = __rest44(props, ["prefixCls", "className", "rootClassName", "children", "hasSider", "tagName", "style"]);
    const passedProps = omit(others, ["suffixCls"]);
    const {
      getPrefixCls,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("layout");
    const prefixCls = getPrefixCls("layout", customizePrefixCls);
    const mergedHasSider = useHasSider(siders, children, hasSider);
    const [wrapCSSVar, hashId, cssVarCls] = style_default10(prefixCls);
    const classString = (0, import_classnames109.default)(prefixCls, {
      [`${prefixCls}-has-sider`]: mergedHasSider,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, contextClassName, className, rootClassName, hashId, cssVarCls);
    const contextValue = React294.useMemo(() => ({
      siderHook: {
        addSider: (id) => {
          setSiders((prev2) => [].concat(_toConsumableArray(prev2), [id]));
        },
        removeSider: (id) => {
          setSiders((prev2) => prev2.filter((currentId) => currentId !== id));
        }
      }
    }), []);
    return wrapCSSVar(/* @__PURE__ */ React294.createElement(LayoutContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React294.createElement(Tag2, Object.assign({
      ref,
      className: classString,
      style: Object.assign(Object.assign({}, contextStyle), style2)
    }, passedProps), children)));
  });
  var Layout = generator({
    tagName: "div",
    displayName: "Layout"
  })(BasicLayout);
  var Header = generator({
    suffixCls: "header",
    tagName: "header",
    displayName: "Header"
  })(Basic);
  var Footer2 = generator({
    suffixCls: "footer",
    tagName: "footer",
    displayName: "Footer"
  })(Basic);
  var Content2 = generator({
    suffixCls: "content",
    tagName: "main",
    displayName: "Content"
  })(Basic);
  var layout_default = Layout;

  // node_modules/antd/es/layout/index.js
  var Layout2 = layout_default;
  Layout2.Header = Header;
  Layout2.Footer = Footer2;
  Layout2.Content = Content2;
  Layout2.Sider = Sider_default;
  Layout2._InternalSiderContext = SiderContext;
  var layout_default2 = Layout2;

  // node_modules/antd/es/pagination/Pagination.js
  var React300 = __toESM(require_react());

  // node_modules/@ant-design/icons/es/icons/DoubleLeftOutlined.js
  var React295 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/DoubleLeftOutlined.js
  var DoubleLeftOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
  var DoubleLeftOutlined_default = DoubleLeftOutlined;

  // node_modules/@ant-design/icons/es/icons/DoubleLeftOutlined.js
  var DoubleLeftOutlined2 = function DoubleLeftOutlined3(props, ref) {
    return /* @__PURE__ */ React295.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: DoubleLeftOutlined_default
    }));
  };
  var RefIcon18 = /* @__PURE__ */ React295.forwardRef(DoubleLeftOutlined2);
  if (true) {
    RefIcon18.displayName = "DoubleLeftOutlined";
  }
  var DoubleLeftOutlined_default2 = RefIcon18;

  // node_modules/@ant-design/icons/es/icons/DoubleRightOutlined.js
  var React296 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/DoubleRightOutlined.js
  var DoubleRightOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
  var DoubleRightOutlined_default = DoubleRightOutlined;

  // node_modules/@ant-design/icons/es/icons/DoubleRightOutlined.js
  var DoubleRightOutlined2 = function DoubleRightOutlined3(props, ref) {
    return /* @__PURE__ */ React296.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: DoubleRightOutlined_default
    }));
  };
  var RefIcon19 = /* @__PURE__ */ React296.forwardRef(DoubleRightOutlined2);
  if (true) {
    RefIcon19.displayName = "DoubleRightOutlined";
  }
  var DoubleRightOutlined_default2 = RefIcon19;

  // node_modules/antd/es/pagination/Pagination.js
  var import_classnames112 = __toESM(require_classnames());

  // node_modules/rc-pagination/es/Pagination.js
  var import_classnames111 = __toESM(require_classnames());
  var import_react106 = __toESM(require_react());

  // node_modules/rc-pagination/es/locale/zh_CN.js
  var locale5 = {
    // Options
    items_per_page: "\u6761/\u9875",
    jump_to: "\u8DF3\u81F3",
    jump_to_confirm: "\u786E\u5B9A",
    page: "\u9875",
    // Pagination
    prev_page: "\u4E0A\u4E00\u9875",
    next_page: "\u4E0B\u4E00\u9875",
    prev_5: "\u5411\u524D 5 \u9875",
    next_5: "\u5411\u540E 5 \u9875",
    prev_3: "\u5411\u524D 3 \u9875",
    next_3: "\u5411\u540E 3 \u9875",
    page_size: "\u9875\u7801"
  };
  var zh_CN_default = locale5;

  // node_modules/rc-pagination/es/Options.js
  var import_react104 = __toESM(require_react());
  var defaultPageSizeOptions = [10, 20, 50, 100];
  var Options = function Options2(props) {
    var _props$pageSizeOption = props.pageSizeOptions, pageSizeOptions = _props$pageSizeOption === void 0 ? defaultPageSizeOptions : _props$pageSizeOption, locale6 = props.locale, changeSize = props.changeSize, pageSize = props.pageSize, goButton = props.goButton, quickGo = props.quickGo, rootPrefixCls = props.rootPrefixCls, disabled = props.disabled, buildOptionText = props.buildOptionText, showSizeChanger = props.showSizeChanger, sizeChangerRender = props.sizeChangerRender;
    var _React$useState = import_react104.default.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), goInputText = _React$useState2[0], setGoInputText = _React$useState2[1];
    var getValidValue = function getValidValue2() {
      return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
    };
    var mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : function(value) {
      return "".concat(value, " ").concat(locale6.items_per_page);
    };
    var handleChange = function handleChange2(e3) {
      setGoInputText(e3.target.value);
    };
    var handleBlur = function handleBlur2(e3) {
      if (goButton || goInputText === "") {
        return;
      }
      setGoInputText("");
      if (e3.relatedTarget && (e3.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e3.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
        return;
      }
      quickGo === null || quickGo === void 0 || quickGo(getValidValue());
    };
    var go = function go2(e3) {
      if (goInputText === "") {
        return;
      }
      if (e3.keyCode === KeyCode_default.ENTER || e3.type === "click") {
        setGoInputText("");
        quickGo === null || quickGo === void 0 || quickGo(getValidValue());
      }
    };
    var getPageSizeOptions = function getPageSizeOptions2() {
      if (pageSizeOptions.some(function(option) {
        return option.toString() === pageSize.toString();
      })) {
        return pageSizeOptions;
      }
      return pageSizeOptions.concat([pageSize]).sort(function(a, b) {
        var numberA = Number.isNaN(Number(a)) ? 0 : Number(a);
        var numberB = Number.isNaN(Number(b)) ? 0 : Number(b);
        return numberA - numberB;
      });
    };
    var prefixCls = "".concat(rootPrefixCls, "-options");
    if (!showSizeChanger && !quickGo) {
      return null;
    }
    var changeSelect = null;
    var goInput = null;
    var gotoButton = null;
    if (showSizeChanger && sizeChangerRender) {
      changeSelect = sizeChangerRender({
        disabled,
        size: pageSize,
        onSizeChange: function onSizeChange(nextValue) {
          changeSize === null || changeSize === void 0 || changeSize(Number(nextValue));
        },
        "aria-label": locale6.page_size,
        className: "".concat(prefixCls, "-size-changer"),
        options: getPageSizeOptions().map(function(opt) {
          return {
            label: mergeBuildOptionText(opt),
            value: opt
          };
        })
      });
    }
    if (quickGo) {
      if (goButton) {
        gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ import_react104.default.createElement("button", {
          type: "button",
          onClick: go,
          onKeyUp: go,
          disabled,
          className: "".concat(prefixCls, "-quick-jumper-button")
        }, locale6.jump_to_confirm) : /* @__PURE__ */ import_react104.default.createElement("span", {
          onClick: go,
          onKeyUp: go
        }, goButton);
      }
      goInput = /* @__PURE__ */ import_react104.default.createElement("div", {
        className: "".concat(prefixCls, "-quick-jumper")
      }, locale6.jump_to, /* @__PURE__ */ import_react104.default.createElement("input", {
        disabled,
        type: "text",
        value: goInputText,
        onChange: handleChange,
        onKeyUp: go,
        onBlur: handleBlur,
        "aria-label": locale6.page
      }), locale6.page, gotoButton);
    }
    return /* @__PURE__ */ import_react104.default.createElement("li", {
      className: prefixCls
    }, changeSelect, goInput);
  };
  if (true) {
    Options.displayName = "Options";
  }
  var Options_default = Options;

  // node_modules/rc-pagination/es/Pager.js
  var import_classnames110 = __toESM(require_classnames());
  var import_react105 = __toESM(require_react());
  var Pager = function Pager2(props) {
    var rootPrefixCls = props.rootPrefixCls, page = props.page, active = props.active, className = props.className, showTitle = props.showTitle, onClick = props.onClick, onKeyPress = props.onKeyPress, itemRender = props.itemRender;
    var prefixCls = "".concat(rootPrefixCls, "-item");
    var cls3 = (0, import_classnames110.default)(prefixCls, "".concat(prefixCls, "-").concat(page), _defineProperty(_defineProperty({}, "".concat(prefixCls, "-active"), active), "".concat(prefixCls, "-disabled"), !page), className);
    var handleClick = function handleClick2() {
      onClick(page);
    };
    var handleKeyPress = function handleKeyPress2(e3) {
      onKeyPress(e3, onClick, page);
    };
    var pager = itemRender(page, "page", /* @__PURE__ */ import_react105.default.createElement("a", {
      rel: "nofollow"
    }, page));
    return pager ? /* @__PURE__ */ import_react105.default.createElement("li", {
      title: showTitle ? String(page) : null,
      className: cls3,
      onClick: handleClick,
      onKeyDown: handleKeyPress,
      tabIndex: 0
    }, pager) : null;
  };
  if (true) {
    Pager.displayName = "Pager";
  }
  var Pager_default = Pager;

  // node_modules/rc-pagination/es/Pagination.js
  var defaultItemRender = function defaultItemRender2(page, type5, element) {
    return element;
  };
  function noop3() {
  }
  function isInteger(v) {
    var value = Number(v);
    return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
  }
  function calculatePage(p, pageSize, total) {
    var _pageSize = typeof p === "undefined" ? pageSize : p;
    return Math.floor((total - 1) / _pageSize) + 1;
  }
  var Pagination = function Pagination2(props) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-pagination" : _props$prefixCls, _props$selectPrefixCl = props.selectPrefixCls, selectPrefixCls = _props$selectPrefixCl === void 0 ? "rc-select" : _props$selectPrefixCl, className = props.className, currentProp = props.current, _props$defaultCurrent = props.defaultCurrent, defaultCurrent = _props$defaultCurrent === void 0 ? 1 : _props$defaultCurrent, _props$total = props.total, total = _props$total === void 0 ? 0 : _props$total, pageSizeProp = props.pageSize, _props$defaultPageSiz = props.defaultPageSize, defaultPageSize = _props$defaultPageSiz === void 0 ? 10 : _props$defaultPageSiz, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? noop3 : _props$onChange, hideOnSinglePage = props.hideOnSinglePage, align = props.align, _props$showPrevNextJu = props.showPrevNextJumpers, showPrevNextJumpers = _props$showPrevNextJu === void 0 ? true : _props$showPrevNextJu, showQuickJumper = props.showQuickJumper, showLessItems = props.showLessItems, _props$showTitle = props.showTitle, showTitle = _props$showTitle === void 0 ? true : _props$showTitle, _props$onShowSizeChan = props.onShowSizeChange, onShowSizeChange = _props$onShowSizeChan === void 0 ? noop3 : _props$onShowSizeChan, _props$locale = props.locale, locale6 = _props$locale === void 0 ? zh_CN_default : _props$locale, style2 = props.style, _props$totalBoundaryS = props.totalBoundaryShowSizeChanger, totalBoundaryShowSizeChanger = _props$totalBoundaryS === void 0 ? 50 : _props$totalBoundaryS, disabled = props.disabled, simple = props.simple, showTotal = props.showTotal, _props$showSizeChange = props.showSizeChanger, showSizeChanger = _props$showSizeChange === void 0 ? total > totalBoundaryShowSizeChanger : _props$showSizeChange, sizeChangerRender = props.sizeChangerRender, pageSizeOptions = props.pageSizeOptions, _props$itemRender = props.itemRender, itemRender = _props$itemRender === void 0 ? defaultItemRender : _props$itemRender, jumpPrevIcon = props.jumpPrevIcon, jumpNextIcon = props.jumpNextIcon, prevIcon = props.prevIcon, nextIcon = props.nextIcon;
    var paginationRef = import_react106.default.useRef(null);
    var _useMergedState = useMergedState(10, {
      value: pageSizeProp,
      defaultValue: defaultPageSize
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), pageSize = _useMergedState2[0], setPageSize = _useMergedState2[1];
    var _useMergedState3 = useMergedState(1, {
      value: currentProp,
      defaultValue: defaultCurrent,
      postState: function postState(c) {
        return Math.max(1, Math.min(c, calculatePage(void 0, pageSize, total)));
      }
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), current = _useMergedState4[0], setCurrent = _useMergedState4[1];
    var _React$useState = import_react106.default.useState(current), _React$useState2 = _slicedToArray(_React$useState, 2), internalInputVal = _React$useState2[0], setInternalInputVal = _React$useState2[1];
    (0, import_react106.useEffect)(function() {
      setInternalInputVal(current);
    }, [current]);
    var hasOnChange = onChange !== noop3;
    var hasCurrent = "current" in props;
    if (true) {
      warning_default(hasCurrent ? hasOnChange : true, "You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
    }
    var jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
    var jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
    function getItemIcon(icon, label) {
      var iconNode = icon || /* @__PURE__ */ import_react106.default.createElement("button", {
        type: "button",
        "aria-label": label,
        className: "".concat(prefixCls, "-item-link")
      });
      if (typeof icon === "function") {
        iconNode = /* @__PURE__ */ import_react106.default.createElement(icon, _objectSpread2({}, props));
      }
      return iconNode;
    }
    function getValidValue(e3) {
      var inputValue = e3.target.value;
      var allPages2 = calculatePage(void 0, pageSize, total);
      var value;
      if (inputValue === "") {
        value = inputValue;
      } else if (Number.isNaN(Number(inputValue))) {
        value = internalInputVal;
      } else if (inputValue >= allPages2) {
        value = allPages2;
      } else {
        value = Number(inputValue);
      }
      return value;
    }
    function isValid(page) {
      return isInteger(page) && page !== current && isInteger(total) && total > 0;
    }
    var shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
    function handleKeyDown(event) {
      if (event.keyCode === KeyCode_default.UP || event.keyCode === KeyCode_default.DOWN) {
        event.preventDefault();
      }
    }
    function handleKeyUp(event) {
      var value = getValidValue(event);
      if (value !== internalInputVal) {
        setInternalInputVal(value);
      }
      switch (event.keyCode) {
        case KeyCode_default.ENTER:
          handleChange(value);
          break;
        case KeyCode_default.UP:
          handleChange(value - 1);
          break;
        case KeyCode_default.DOWN:
          handleChange(value + 1);
          break;
        default:
          break;
      }
    }
    function handleBlur(event) {
      handleChange(getValidValue(event));
    }
    function changePageSize(size) {
      var newCurrent = calculatePage(size, pageSize, total);
      var nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
      setPageSize(size);
      setInternalInputVal(nextCurrent);
      onShowSizeChange === null || onShowSizeChange === void 0 || onShowSizeChange(current, size);
      setCurrent(nextCurrent);
      onChange === null || onChange === void 0 || onChange(nextCurrent, size);
    }
    function handleChange(page) {
      if (isValid(page) && !disabled) {
        var currentPage = calculatePage(void 0, pageSize, total);
        var newPage = page;
        if (page > currentPage) {
          newPage = currentPage;
        } else if (page < 1) {
          newPage = 1;
        }
        if (newPage !== internalInputVal) {
          setInternalInputVal(newPage);
        }
        setCurrent(newPage);
        onChange === null || onChange === void 0 || onChange(newPage, pageSize);
        return newPage;
      }
      return current;
    }
    var hasPrev = current > 1;
    var hasNext = current < calculatePage(void 0, pageSize, total);
    function prevHandle() {
      if (hasPrev) handleChange(current - 1);
    }
    function nextHandle() {
      if (hasNext) handleChange(current + 1);
    }
    function jumpPrevHandle() {
      handleChange(jumpPrevPage);
    }
    function jumpNextHandle() {
      handleChange(jumpNextPage);
    }
    function runIfEnter(event, callback) {
      if (event.key === "Enter" || event.charCode === KeyCode_default.ENTER || event.keyCode === KeyCode_default.ENTER) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback.apply(void 0, restParams);
      }
    }
    function runIfEnterPrev(event) {
      runIfEnter(event, prevHandle);
    }
    function runIfEnterNext(event) {
      runIfEnter(event, nextHandle);
    }
    function runIfEnterJumpPrev(event) {
      runIfEnter(event, jumpPrevHandle);
    }
    function runIfEnterJumpNext(event) {
      runIfEnter(event, jumpNextHandle);
    }
    function renderPrev(prevPage2) {
      var prevButton = itemRender(prevPage2, "prev", getItemIcon(prevIcon, "prev page"));
      return /* @__PURE__ */ import_react106.default.isValidElement(prevButton) ? /* @__PURE__ */ import_react106.default.cloneElement(prevButton, {
        disabled: !hasPrev
      }) : prevButton;
    }
    function renderNext(nextPage2) {
      var nextButton = itemRender(nextPage2, "next", getItemIcon(nextIcon, "next page"));
      return /* @__PURE__ */ import_react106.default.isValidElement(nextButton) ? /* @__PURE__ */ import_react106.default.cloneElement(nextButton, {
        disabled: !hasNext
      }) : nextButton;
    }
    function handleGoTO(event) {
      if (event.type === "click" || event.keyCode === KeyCode_default.ENTER) {
        handleChange(internalInputVal);
      }
    }
    var jumpPrev = null;
    var dataOrAriaAttributeProps = pickAttrs(props, {
      aria: true,
      data: true
    });
    var totalText = showTotal && /* @__PURE__ */ import_react106.default.createElement("li", {
      className: "".concat(prefixCls, "-total-text")
    }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
    var jumpNext = null;
    var allPages = calculatePage(void 0, pageSize, total);
    if (hideOnSinglePage && total <= pageSize) {
      return null;
    }
    var pagerList = [];
    var pagerProps = {
      rootPrefixCls: prefixCls,
      onClick: handleChange,
      onKeyPress: runIfEnter,
      showTitle,
      itemRender,
      page: -1
    };
    var prevPage = current - 1 > 0 ? current - 1 : 0;
    var nextPage = current + 1 < allPages ? current + 1 : allPages;
    var goButton = showQuickJumper && showQuickJumper.goButton;
    var isReadOnly = _typeof(simple) === "object" ? simple.readOnly : !simple;
    var gotoButton = goButton;
    var simplePager = null;
    if (simple) {
      if (goButton) {
        if (typeof goButton === "boolean") {
          gotoButton = /* @__PURE__ */ import_react106.default.createElement("button", {
            type: "button",
            onClick: handleGoTO,
            onKeyUp: handleGoTO
          }, locale6.jump_to_confirm);
        } else {
          gotoButton = /* @__PURE__ */ import_react106.default.createElement("span", {
            onClick: handleGoTO,
            onKeyUp: handleGoTO
          }, goButton);
        }
        gotoButton = /* @__PURE__ */ import_react106.default.createElement("li", {
          title: showTitle ? "".concat(locale6.jump_to).concat(current, "/").concat(allPages) : null,
          className: "".concat(prefixCls, "-simple-pager")
        }, gotoButton);
      }
      simplePager = /* @__PURE__ */ import_react106.default.createElement("li", {
        title: showTitle ? "".concat(current, "/").concat(allPages) : null,
        className: "".concat(prefixCls, "-simple-pager")
      }, isReadOnly ? internalInputVal : /* @__PURE__ */ import_react106.default.createElement("input", {
        type: "text",
        "aria-label": locale6.jump_to,
        value: internalInputVal,
        disabled,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onChange: handleKeyUp,
        onBlur: handleBlur,
        size: 3
      }), /* @__PURE__ */ import_react106.default.createElement("span", {
        className: "".concat(prefixCls, "-slash")
      }, "/"), allPages);
    }
    var pageBufferSize = showLessItems ? 1 : 2;
    if (allPages <= 3 + pageBufferSize * 2) {
      if (!allPages) {
        pagerList.push(/* @__PURE__ */ import_react106.default.createElement(Pager_default, _extends({}, pagerProps, {
          key: "noPager",
          page: 1,
          className: "".concat(prefixCls, "-item-disabled")
        })));
      }
      for (var i = 1; i <= allPages; i += 1) {
        pagerList.push(/* @__PURE__ */ import_react106.default.createElement(Pager_default, _extends({}, pagerProps, {
          key: i,
          page: i,
          active: current === i
        })));
      }
    } else {
      var prevItemTitle = showLessItems ? locale6.prev_3 : locale6.prev_5;
      var nextItemTitle = showLessItems ? locale6.next_3 : locale6.next_5;
      var jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
      var jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
      if (showPrevNextJumpers) {
        jumpPrev = jumpPrevContent ? /* @__PURE__ */ import_react106.default.createElement("li", {
          title: showTitle ? prevItemTitle : null,
          key: "prev",
          onClick: jumpPrevHandle,
          tabIndex: 0,
          onKeyDown: runIfEnterJumpPrev,
          className: (0, import_classnames111.default)("".concat(prefixCls, "-jump-prev"), _defineProperty({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
        }, jumpPrevContent) : null;
        jumpNext = jumpNextContent ? /* @__PURE__ */ import_react106.default.createElement("li", {
          title: showTitle ? nextItemTitle : null,
          key: "next",
          onClick: jumpNextHandle,
          tabIndex: 0,
          onKeyDown: runIfEnterJumpNext,
          className: (0, import_classnames111.default)("".concat(prefixCls, "-jump-next"), _defineProperty({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
        }, jumpNextContent) : null;
      }
      var left = Math.max(1, current - pageBufferSize);
      var right = Math.min(current + pageBufferSize, allPages);
      if (current - 1 <= pageBufferSize) {
        right = 1 + pageBufferSize * 2;
      }
      if (allPages - current <= pageBufferSize) {
        left = allPages - pageBufferSize * 2;
      }
      for (var _i = left; _i <= right; _i += 1) {
        pagerList.push(/* @__PURE__ */ import_react106.default.createElement(Pager_default, _extends({}, pagerProps, {
          key: _i,
          page: _i,
          active: current === _i
        })));
      }
      if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
        pagerList[0] = /* @__PURE__ */ import_react106.default.cloneElement(pagerList[0], {
          className: (0, import_classnames111.default)("".concat(prefixCls, "-item-after-jump-prev"), pagerList[0].props.className)
        });
        pagerList.unshift(jumpPrev);
      }
      if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
        var lastOne = pagerList[pagerList.length - 1];
        pagerList[pagerList.length - 1] = /* @__PURE__ */ import_react106.default.cloneElement(lastOne, {
          className: (0, import_classnames111.default)("".concat(prefixCls, "-item-before-jump-next"), lastOne.props.className)
        });
        pagerList.push(jumpNext);
      }
      if (left !== 1) {
        pagerList.unshift(/* @__PURE__ */ import_react106.default.createElement(Pager_default, _extends({}, pagerProps, {
          key: 1,
          page: 1
        })));
      }
      if (right !== allPages) {
        pagerList.push(/* @__PURE__ */ import_react106.default.createElement(Pager_default, _extends({}, pagerProps, {
          key: allPages,
          page: allPages
        })));
      }
    }
    var prev2 = renderPrev(prevPage);
    if (prev2) {
      var prevDisabled = !hasPrev || !allPages;
      prev2 = /* @__PURE__ */ import_react106.default.createElement("li", {
        title: showTitle ? locale6.prev_page : null,
        onClick: prevHandle,
        tabIndex: prevDisabled ? null : 0,
        onKeyDown: runIfEnterPrev,
        className: (0, import_classnames111.default)("".concat(prefixCls, "-prev"), _defineProperty({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
        "aria-disabled": prevDisabled
      }, prev2);
    }
    var next2 = renderNext(nextPage);
    if (next2) {
      var nextDisabled, nextTabIndex;
      if (simple) {
        nextDisabled = !hasNext;
        nextTabIndex = hasPrev ? 0 : null;
      } else {
        nextDisabled = !hasNext || !allPages;
        nextTabIndex = nextDisabled ? null : 0;
      }
      next2 = /* @__PURE__ */ import_react106.default.createElement("li", {
        title: showTitle ? locale6.next_page : null,
        onClick: nextHandle,
        tabIndex: nextTabIndex,
        onKeyDown: runIfEnterNext,
        className: (0, import_classnames111.default)("".concat(prefixCls, "-next"), _defineProperty({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
        "aria-disabled": nextDisabled
      }, next2);
    }
    var cls3 = (0, import_classnames111.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-start"), align === "start"), "".concat(prefixCls, "-center"), align === "center"), "".concat(prefixCls, "-end"), align === "end"), "".concat(prefixCls, "-simple"), simple), "".concat(prefixCls, "-disabled"), disabled));
    return /* @__PURE__ */ import_react106.default.createElement("ul", _extends({
      className: cls3,
      style: style2,
      ref: paginationRef
    }, dataOrAriaAttributeProps), totalText, prev2, simple ? simplePager : pagerList, next2, /* @__PURE__ */ import_react106.default.createElement(Options_default, {
      locale: locale6,
      rootPrefixCls: prefixCls,
      disabled,
      selectPrefixCls,
      changeSize: changePageSize,
      pageSize,
      pageSizeOptions,
      quickGo: shouldDisplayQuickJumper ? handleChange : null,
      goButton: gotoButton,
      showSizeChanger,
      sizeChangerRender
    }));
  };
  if (true) {
    Pagination.displayName = "Pagination";
  }
  var Pagination_default = Pagination;

  // node_modules/antd/es/pagination/style/index.js
  var genPaginationDisabledStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-disabled`]: {
        "&, &:hover": {
          cursor: "not-allowed",
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        },
        "&:focus-visible": {
          cursor: "not-allowed",
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`${componentCls}-item`]: {
          cursor: "not-allowed",
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          },
          a: {
            color: token2.colorTextDisabled,
            backgroundColor: "transparent",
            border: "none",
            cursor: "not-allowed"
          },
          "&-active": {
            borderColor: token2.colorBorder,
            backgroundColor: token2.itemActiveBgDisabled,
            "&:hover, &:active": {
              backgroundColor: token2.itemActiveBgDisabled
            },
            a: {
              color: token2.itemActiveColorDisabled
            }
          }
        },
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          },
          [`${componentCls}-simple&`]: {
            backgroundColor: "transparent",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            }
          }
        },
        [`${componentCls}-simple-pager`]: {
          color: token2.colorTextDisabled
        },
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          [`${componentCls}-item-link-icon`]: {
            opacity: 0
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 1
          }
        }
      },
      [`&${componentCls}-simple`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          [`&${componentCls}-disabled ${componentCls}-item-link`]: {
            "&:hover, &:active": {
              backgroundColor: "transparent"
            }
          }
        }
      }
    };
  };
  var genPaginationMiniStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
        height: token2.itemSizeSM,
        lineHeight: unit(token2.itemSizeSM)
      },
      [`&${componentCls}-mini ${componentCls}-item`]: {
        minWidth: token2.itemSizeSM,
        height: token2.itemSizeSM,
        margin: 0,
        lineHeight: unit(token2.calc(token2.itemSizeSM).sub(2).equal())
      },
      [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
        minWidth: token2.itemSizeSM,
        height: token2.itemSizeSM,
        margin: 0,
        lineHeight: unit(token2.itemSizeSM)
      },
      [`&${componentCls}-mini:not(${componentCls}-disabled)`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          [`&:hover ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextHover
          },
          [`&:active ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextActive
          },
          [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
            backgroundColor: "transparent"
          }
        }
      },
      [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
        backgroundColor: "transparent",
        borderColor: "transparent",
        "&::after": {
          height: token2.itemSizeSM,
          lineHeight: unit(token2.itemSizeSM)
        }
      },
      [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
        height: token2.itemSizeSM,
        marginInlineEnd: 0,
        lineHeight: unit(token2.itemSizeSM)
      },
      [`&${componentCls}-mini ${componentCls}-options`]: {
        marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
        "&-size-changer": {
          top: token2.miniOptionsSizeChangerTop
        },
        "&-quick-jumper": {
          height: token2.itemSizeSM,
          lineHeight: unit(token2.itemSizeSM),
          input: Object.assign(Object.assign({}, genInputSmallStyle(token2)), {
            width: token2.paginationMiniQuickJumperInputWidth,
            height: token2.controlHeightSM
          })
        }
      }
    };
  };
  var genPaginationSimpleStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
        height: token2.itemSizeSM,
        lineHeight: unit(token2.itemSizeSM),
        verticalAlign: "top",
        [`${componentCls}-item-link`]: {
          height: token2.itemSizeSM,
          backgroundColor: "transparent",
          border: 0,
          "&:hover": {
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          },
          "&::after": {
            height: token2.itemSizeSM,
            lineHeight: unit(token2.itemSizeSM)
          }
        }
      },
      [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
        display: "inline-block",
        height: token2.itemSizeSM,
        marginInlineEnd: token2.marginXS,
        input: {
          boxSizing: "border-box",
          height: "100%",
          padding: `0 ${unit(token2.paginationItemPaddingInline)}`,
          textAlign: "center",
          backgroundColor: token2.itemInputBg,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadius,
          outline: "none",
          transition: `border-color ${token2.motionDurationMid}`,
          color: "inherit",
          "&:hover": {
            borderColor: token2.colorPrimary
          },
          "&:focus": {
            borderColor: token2.colorPrimaryHover,
            boxShadow: `${unit(token2.inputOutlineOffset)} 0 ${unit(token2.controlOutlineWidth)} ${token2.controlOutline}`
          },
          "&[disabled]": {
            color: token2.colorTextDisabled,
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            cursor: "not-allowed"
          }
        }
      }
    };
  };
  var genPaginationJumpStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        outline: 0,
        [`${componentCls}-item-container`]: {
          position: "relative",
          [`${componentCls}-item-link-icon`]: {
            color: token2.colorPrimary,
            fontSize: token2.fontSizeSM,
            opacity: 0,
            transition: `all ${token2.motionDurationMid}`,
            "&-svg": {
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              margin: "auto"
            }
          },
          [`${componentCls}-item-ellipsis`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            display: "block",
            margin: "auto",
            color: token2.colorTextDisabled,
            letterSpacing: token2.paginationEllipsisLetterSpacing,
            textAlign: "center",
            textIndent: token2.paginationEllipsisTextIndent,
            opacity: 1,
            transition: `all ${token2.motionDurationMid}`
          }
        },
        "&:hover": {
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          }
        }
      },
      [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
        marginInlineEnd: token2.marginXS
      },
      [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
        display: "inline-block",
        minWidth: token2.itemSize,
        height: token2.itemSize,
        color: token2.colorText,
        fontFamily: token2.fontFamily,
        lineHeight: unit(token2.itemSize),
        textAlign: "center",
        verticalAlign: "middle",
        listStyle: "none",
        borderRadius: token2.borderRadius,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}`
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        outline: 0,
        button: {
          color: token2.colorText,
          cursor: "pointer",
          userSelect: "none"
        },
        [`${componentCls}-item-link`]: {
          display: "block",
          width: "100%",
          height: "100%",
          padding: 0,
          fontSize: token2.fontSizeSM,
          textAlign: "center",
          backgroundColor: "transparent",
          border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
          borderRadius: token2.borderRadius,
          outline: "none",
          transition: `all ${token2.motionDurationMid}`
        },
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover`]: {
          [`${componentCls}-item-link`]: {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-slash`]: {
        marginInlineEnd: token2.paginationSlashMarginInlineEnd,
        marginInlineStart: token2.paginationSlashMarginInlineStart
      },
      [`${componentCls}-options`]: {
        display: "inline-block",
        marginInlineStart: token2.margin,
        verticalAlign: "middle",
        "&-size-changer": {
          display: "inline-block",
          width: "auto"
        },
        "&-quick-jumper": {
          display: "inline-block",
          height: token2.controlHeight,
          marginInlineStart: token2.marginXS,
          lineHeight: unit(token2.controlHeight),
          verticalAlign: "top",
          input: Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), genBaseOutlinedStyle2(token2, {
            borderColor: token2.colorBorder,
            hoverBorderColor: token2.colorPrimaryHover,
            activeBorderColor: token2.colorPrimary,
            activeShadow: token2.activeShadow
          })), {
            "&[disabled]": Object.assign({}, genDisabledStyle2(token2)),
            width: token2.calc(token2.controlHeightLG).mul(1.25).equal(),
            height: token2.controlHeight,
            boxSizing: "border-box",
            margin: 0,
            marginInlineStart: token2.marginXS,
            marginInlineEnd: token2.marginXS
          })
        }
      }
    };
  };
  var genPaginationItemStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-item`]: {
        display: "inline-block",
        minWidth: token2.itemSize,
        height: token2.itemSize,
        marginInlineEnd: token2.marginXS,
        fontFamily: token2.fontFamily,
        lineHeight: unit(token2.calc(token2.itemSize).sub(2).equal()),
        textAlign: "center",
        verticalAlign: "middle",
        listStyle: "none",
        backgroundColor: token2.itemBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: 0,
        cursor: "pointer",
        userSelect: "none",
        a: {
          display: "block",
          padding: `0 ${unit(token2.paginationItemPaddingInline)}`,
          color: token2.colorText,
          "&:hover": {
            textDecoration: "none"
          }
        },
        [`&:not(${componentCls}-item-active)`]: {
          "&:hover": {
            transition: `all ${token2.motionDurationMid}`,
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          }
        },
        "&-active": {
          fontWeight: token2.fontWeightStrong,
          backgroundColor: token2.itemActiveBg,
          borderColor: token2.colorPrimary,
          a: {
            color: token2.colorPrimary
          },
          "&:hover": {
            borderColor: token2.colorPrimaryHover
          },
          "&:hover a": {
            color: token2.colorPrimaryHover
          }
        }
      }
    };
  };
  var genPaginationStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "flex",
        "&-start": {
          justifyContent: "start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-end": {
          justifyContent: "end"
        },
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        "&::after": {
          display: "block",
          clear: "both",
          height: 0,
          overflow: "hidden",
          visibility: "hidden",
          content: '""'
        },
        [`${componentCls}-total-text`]: {
          display: "inline-block",
          height: token2.itemSize,
          marginInlineEnd: token2.marginXS,
          lineHeight: unit(token2.calc(token2.itemSize).sub(2).equal()),
          verticalAlign: "middle"
        }
      }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
        // media query style
        [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
          [`${componentCls}-item`]: {
            "&-after-jump-prev, &-before-jump-next": {
              display: "none"
            }
          }
        },
        [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
          [`${componentCls}-options`]: {
            display: "none"
          }
        }
      }),
      // rtl style
      [`&${token2.componentCls}-rtl`]: {
        direction: "rtl"
      }
    };
  };
  var genPaginationFocusStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}:not(${componentCls}-disabled)`]: {
        [`${componentCls}-item`]: Object.assign({}, genFocusStyle(token2)),
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          "&:focus-visible": Object.assign({
            [`${componentCls}-item-link-icon`]: {
              opacity: 1
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 0
            }
          }, genFocusOutline(token2))
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          [`&:focus-visible ${componentCls}-item-link`]: Object.assign({}, genFocusOutline(token2))
        }
      }
    };
  };
  var prepareComponentToken14 = (token2) => Object.assign({
    itemBg: token2.colorBgContainer,
    itemSize: token2.controlHeight,
    itemSizeSM: token2.controlHeightSM,
    itemActiveBg: token2.colorBgContainer,
    itemLinkBg: token2.colorBgContainer,
    itemActiveColorDisabled: token2.colorTextDisabled,
    itemActiveBgDisabled: token2.controlItemBgActiveDisabled,
    itemInputBg: token2.colorBgContainer,
    miniOptionsSizeChangerTop: 0
  }, initComponentToken(token2));
  var prepareToken4 = (token2) => merge2(token2, {
    inputOutlineOffset: 0,
    paginationMiniOptionsMarginInlineStart: token2.calc(token2.marginXXS).div(2).equal(),
    paginationMiniQuickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.1).equal(),
    paginationItemPaddingInline: token2.calc(token2.marginXXS).mul(1.5).equal(),
    paginationEllipsisLetterSpacing: token2.calc(token2.marginXXS).div(2).equal(),
    paginationSlashMarginInlineStart: token2.marginSM,
    paginationSlashMarginInlineEnd: token2.marginSM,
    paginationEllipsisTextIndent: "0.13em"
    // magic for ui experience
  }, initInputToken(token2));
  var style_default19 = genStyleHooks("Pagination", (token2) => {
    const paginationToken = prepareToken4(token2);
    return [genPaginationStyle(paginationToken), genPaginationFocusStyle(paginationToken)];
  }, prepareComponentToken14);

  // node_modules/antd/es/pagination/style/bordered.js
  var genBorderedStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
        "&, &:hover": {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder
          }
        },
        "&:focus-visible": {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder
          }
        },
        [`${componentCls}-item, ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          [`&:hover:not(${componentCls}-item-active)`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            a: {
              color: token2.colorTextDisabled
            }
          },
          [`&${componentCls}-item-active`]: {
            backgroundColor: token2.itemActiveBgDisabled
          }
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          "&:hover button": {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          },
          [`${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder
          }
        }
      },
      [`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          "&:hover button": {
            borderColor: token2.colorPrimaryHover,
            backgroundColor: token2.itemBg
          },
          [`${componentCls}-item-link`]: {
            backgroundColor: token2.itemLinkBg,
            borderColor: token2.colorBorder
          },
          [`&:hover ${componentCls}-item-link`]: {
            borderColor: token2.colorPrimary,
            backgroundColor: token2.itemBg,
            color: token2.colorPrimary
          },
          [`&${componentCls}-disabled`]: {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder,
              color: token2.colorTextDisabled
            }
          }
        },
        [`${componentCls}-item`]: {
          backgroundColor: token2.itemBg,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          [`&:hover:not(${componentCls}-item-active)`]: {
            borderColor: token2.colorPrimary,
            backgroundColor: token2.itemBg,
            a: {
              color: token2.colorPrimary
            }
          },
          "&-active": {
            borderColor: token2.colorPrimary
          }
        }
      }
    };
  };
  var bordered_default = genSubStyleComponent(["Pagination", "bordered"], (token2) => {
    const paginationToken = prepareToken4(token2);
    return [genBorderedStyle(paginationToken)];
  }, prepareComponentToken14);

  // node_modules/antd/es/pagination/useShowSizeChanger.js
  var import_react107 = __toESM(require_react());
  function useShowSizeChanger(showSizeChanger) {
    return (0, import_react107.useMemo)(() => {
      if (typeof showSizeChanger === "boolean") {
        return [showSizeChanger, {}];
      }
      if (showSizeChanger && typeof showSizeChanger === "object") {
        return [true, showSizeChanger];
      }
      return [void 0, void 0];
    }, [showSizeChanger]);
  }

  // node_modules/antd/es/pagination/Pagination.js
  var __rest45 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Pagination3 = (props) => {
    const {
      align,
      prefixCls: customizePrefixCls,
      selectPrefixCls: customizeSelectPrefixCls,
      className,
      rootClassName,
      style: style2,
      size: customizeSize,
      locale: customLocale,
      responsive,
      showSizeChanger,
      selectComponentClass,
      pageSizeOptions
    } = props, restProps = __rest45(props, ["align", "prefixCls", "selectPrefixCls", "className", "rootClassName", "style", "size", "locale", "responsive", "showSizeChanger", "selectComponentClass", "pageSizeOptions"]);
    const {
      xs
    } = useBreakpoint_default(responsive);
    const [, token2] = useToken();
    const {
      getPrefixCls,
      direction,
      showSizeChanger: contextShowSizeChangerConfig,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("pagination");
    const prefixCls = getPrefixCls("pagination", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default19(prefixCls);
    const mergedSize = useSize_default(customizeSize);
    const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
    const [contextLocale] = useLocale_default("Pagination", en_US_default);
    const locale6 = Object.assign(Object.assign({}, contextLocale), customLocale);
    const [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger);
    const [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(contextShowSizeChangerConfig);
    const mergedShowSizeChanger = propShowSizeChanger !== null && propShowSizeChanger !== void 0 ? propShowSizeChanger : contextShowSizeChanger;
    const mergedShowSizeChangerSelectProps = propSizeChangerSelectProps !== null && propSizeChangerSelectProps !== void 0 ? propSizeChangerSelectProps : contextSizeChangerSelectProps;
    const SizeChanger = selectComponentClass || select_default;
    const mergedPageSizeOptions = React300.useMemo(() => {
      return pageSizeOptions ? pageSizeOptions.map((option) => Number(option)) : void 0;
    }, [pageSizeOptions]);
    const sizeChangerRender = (info) => {
      var _a;
      const {
        disabled,
        size: pageSize,
        onSizeChange,
        "aria-label": ariaLabel,
        className: sizeChangerClassName,
        options
      } = info;
      const {
        className: propSizeChangerClassName,
        onChange: propSizeChangerOnChange
      } = mergedShowSizeChangerSelectProps || {};
      const selectedValue = (_a = options.find((option) => String(option.value) === String(pageSize))) === null || _a === void 0 ? void 0 : _a.value;
      return /* @__PURE__ */ React300.createElement(SizeChanger, Object.assign({
        disabled,
        showSearch: true,
        popupMatchSelectWidth: false,
        getPopupContainer: (triggerNode) => triggerNode.parentNode,
        "aria-label": ariaLabel,
        options
      }, mergedShowSizeChangerSelectProps, {
        value: selectedValue,
        onChange: (nextSize, option) => {
          onSizeChange === null || onSizeChange === void 0 ? void 0 : onSizeChange(nextSize);
          propSizeChangerOnChange === null || propSizeChangerOnChange === void 0 ? void 0 : propSizeChangerOnChange(nextSize, option);
        },
        size: isSmall ? "small" : "middle",
        className: (0, import_classnames112.default)(sizeChangerClassName, propSizeChangerClassName)
      }));
    };
    if (true) {
      const warning6 = devUseWarning("Pagination");
      true ? warning6(!selectComponentClass, "usage", "`selectComponentClass` is not official api which will be removed.") : void 0;
    }
    const iconsProps = React300.useMemo(() => {
      const ellipsis = /* @__PURE__ */ React300.createElement("span", {
        className: `${prefixCls}-item-ellipsis`
      }, "\u2022\u2022\u2022");
      const prevIcon = /* @__PURE__ */ React300.createElement("button", {
        className: `${prefixCls}-item-link`,
        type: "button",
        tabIndex: -1
      }, direction === "rtl" ? /* @__PURE__ */ React300.createElement(RightOutlined_default2, null) : /* @__PURE__ */ React300.createElement(LeftOutlined_default2, null));
      const nextIcon = /* @__PURE__ */ React300.createElement("button", {
        className: `${prefixCls}-item-link`,
        type: "button",
        tabIndex: -1
      }, direction === "rtl" ? /* @__PURE__ */ React300.createElement(LeftOutlined_default2, null) : /* @__PURE__ */ React300.createElement(RightOutlined_default2, null));
      const jumpPrevIcon = (
        // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
        /* @__PURE__ */ React300.createElement("a", {
          className: `${prefixCls}-item-link`
        }, /* @__PURE__ */ React300.createElement("div", {
          className: `${prefixCls}-item-container`
        }, direction === "rtl" ? /* @__PURE__ */ React300.createElement(DoubleRightOutlined_default2, {
          className: `${prefixCls}-item-link-icon`
        }) : /* @__PURE__ */ React300.createElement(DoubleLeftOutlined_default2, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis))
      );
      const jumpNextIcon = (
        // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
        /* @__PURE__ */ React300.createElement("a", {
          className: `${prefixCls}-item-link`
        }, /* @__PURE__ */ React300.createElement("div", {
          className: `${prefixCls}-item-container`
        }, direction === "rtl" ? /* @__PURE__ */ React300.createElement(DoubleLeftOutlined_default2, {
          className: `${prefixCls}-item-link-icon`
        }) : /* @__PURE__ */ React300.createElement(DoubleRightOutlined_default2, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis))
      );
      return {
        prevIcon,
        nextIcon,
        jumpPrevIcon,
        jumpNextIcon
      };
    }, [direction, prefixCls]);
    const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
    const extendedClassName = (0, import_classnames112.default)({
      [`${prefixCls}-${align}`]: !!align,
      [`${prefixCls}-mini`]: isSmall,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-bordered`]: token2.wireframe
    }, contextClassName, className, rootClassName, hashId, cssVarCls);
    const mergedStyle = Object.assign(Object.assign({}, contextStyle), style2);
    return wrapCSSVar(/* @__PURE__ */ React300.createElement(React300.Fragment, null, token2.wireframe && /* @__PURE__ */ React300.createElement(bordered_default, {
      prefixCls
    }), /* @__PURE__ */ React300.createElement(Pagination_default, Object.assign({}, iconsProps, restProps, {
      style: mergedStyle,
      prefixCls,
      selectPrefixCls,
      className: extendedClassName,
      locale: locale6,
      pageSizeOptions: mergedPageSizeOptions,
      showSizeChanger: mergedShowSizeChanger,
      sizeChangerRender
    }))));
  };
  if (true) {
    Pagination3.displayName = "Pagination";
  }
  var Pagination_default2 = Pagination3;

  // node_modules/antd/es/pagination/index.js
  var pagination_default = Pagination_default2;

  // node_modules/antd/es/spin/index.js
  var React305 = __toESM(require_react());
  var import_classnames116 = __toESM(require_classnames());

  // node_modules/antd/es/spin/Indicator/index.js
  var React303 = __toESM(require_react());
  var import_classnames115 = __toESM(require_classnames());

  // node_modules/antd/es/spin/Indicator/Looper.js
  var React302 = __toESM(require_react());
  var import_classnames114 = __toESM(require_classnames());

  // node_modules/antd/es/spin/Indicator/Progress.js
  var React301 = __toESM(require_react());
  var import_classnames113 = __toESM(require_classnames());
  var viewSize = 100;
  var borderWidth = viewSize / 5;
  var radius = viewSize / 2 - borderWidth / 2;
  var circumference = radius * 2 * Math.PI;
  var position2 = 50;
  var CustomCircle = (props) => {
    const {
      dotClassName,
      style: style2,
      hasCircleCls
    } = props;
    return /* @__PURE__ */ React301.createElement("circle", {
      className: (0, import_classnames113.default)(`${dotClassName}-circle`, {
        [`${dotClassName}-circle-bg`]: hasCircleCls
      }),
      r: radius,
      cx: position2,
      cy: position2,
      strokeWidth: borderWidth,
      style: style2
    });
  };
  var Progress = ({
    percent,
    prefixCls
  }) => {
    const dotClassName = `${prefixCls}-dot`;
    const holderClassName = `${dotClassName}-holder`;
    const hideClassName = `${holderClassName}-hidden`;
    const [render4, setRender] = React301.useState(false);
    useLayoutEffect_default(() => {
      if (percent !== 0) {
        setRender(true);
      }
    }, [percent !== 0]);
    const safePtg = Math.max(Math.min(percent, 100), 0);
    if (!render4) {
      return null;
    }
    const circleStyle = {
      strokeDashoffset: `${circumference / 4}`,
      strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
    };
    return /* @__PURE__ */ React301.createElement("span", {
      className: (0, import_classnames113.default)(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName)
    }, /* @__PURE__ */ React301.createElement("svg", {
      viewBox: `0 0 ${viewSize} ${viewSize}`,
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": safePtg
    }, /* @__PURE__ */ React301.createElement(CustomCircle, {
      dotClassName,
      hasCircleCls: true
    }), /* @__PURE__ */ React301.createElement(CustomCircle, {
      dotClassName,
      style: circleStyle
    })));
  };
  var Progress_default = Progress;

  // node_modules/antd/es/spin/Indicator/Looper.js
  function Looper(props) {
    const {
      prefixCls,
      percent = 0
    } = props;
    const dotClassName = `${prefixCls}-dot`;
    const holderClassName = `${dotClassName}-holder`;
    const hideClassName = `${holderClassName}-hidden`;
    return /* @__PURE__ */ React302.createElement(React302.Fragment, null, /* @__PURE__ */ React302.createElement("span", {
      className: (0, import_classnames114.default)(holderClassName, percent > 0 && hideClassName)
    }, /* @__PURE__ */ React302.createElement("span", {
      className: (0, import_classnames114.default)(dotClassName, `${prefixCls}-dot-spin`)
    }, [1, 2, 3, 4].map((i) => /* @__PURE__ */ React302.createElement("i", {
      className: `${prefixCls}-dot-item`,
      key: i
    })))), /* @__PURE__ */ React302.createElement(Progress_default, {
      prefixCls,
      percent
    }));
  }

  // node_modules/antd/es/spin/Indicator/index.js
  function Indicator(props) {
    var _a;
    const {
      prefixCls,
      indicator,
      percent
    } = props;
    const dotClassName = `${prefixCls}-dot`;
    if (indicator && /* @__PURE__ */ React303.isValidElement(indicator)) {
      return cloneElement3(indicator, {
        className: (0, import_classnames115.default)((_a = indicator.props) === null || _a === void 0 ? void 0 : _a.className, dotClassName),
        percent
      });
    }
    return /* @__PURE__ */ React303.createElement(Looper, {
      prefixCls,
      percent
    });
  }

  // node_modules/antd/es/spin/style/index.js
  var antSpinMove = new Keyframes_default("antSpinMove", {
    to: {
      opacity: 1
    }
  });
  var antRotate = new Keyframes_default("antRotate", {
    to: {
      transform: "rotate(405deg)"
    }
  });
  var genSpinStyle = (token2) => {
    const {
      componentCls,
      calc
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        display: "none",
        color: token2.colorPrimary,
        fontSize: 0,
        textAlign: "center",
        verticalAlign: "middle",
        opacity: 0,
        transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
        "&-spinning": {
          position: "relative",
          display: "inline-block",
          opacity: 1
        },
        [`${componentCls}-text`]: {
          fontSize: token2.fontSize,
          paddingTop: calc(calc(token2.dotSize).sub(token2.fontSize)).div(2).add(2).equal()
        },
        "&-fullscreen": {
          position: "fixed",
          width: "100vw",
          height: "100vh",
          backgroundColor: token2.colorBgMask,
          zIndex: token2.zIndexPopupBase,
          inset: 0,
          display: "flex",
          alignItems: "center",
          flexDirection: "column",
          justifyContent: "center",
          opacity: 0,
          visibility: "hidden",
          transition: `all ${token2.motionDurationMid}`,
          "&-show": {
            opacity: 1,
            visibility: "visible"
          },
          [componentCls]: {
            [`${componentCls}-dot-holder`]: {
              color: token2.colorWhite
            },
            [`${componentCls}-text`]: {
              color: token2.colorTextLightSolid
            }
          }
        },
        "&-nested-loading": {
          position: "relative",
          [`> div > ${componentCls}`]: {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            zIndex: 4,
            display: "block",
            width: "100%",
            height: "100%",
            maxHeight: token2.contentHeight,
            [`${componentCls}-dot`]: {
              position: "absolute",
              top: "50%",
              insetInlineStart: "50%",
              margin: calc(token2.dotSize).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              position: "absolute",
              top: "50%",
              width: "100%",
              textShadow: `0 1px 2px ${token2.colorBgContainer}`
              // FIXME: shadow
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token2.dotSize).div(2).mul(-1).sub(10).equal()
            },
            "&-sm": {
              [`${componentCls}-dot`]: {
                margin: calc(token2.dotSizeSM).mul(-1).div(2).equal()
              },
              [`${componentCls}-text`]: {
                paddingTop: calc(calc(token2.dotSizeSM).sub(token2.fontSize)).div(2).add(2).equal()
              },
              [`&${componentCls}-show-text ${componentCls}-dot`]: {
                marginTop: calc(token2.dotSizeSM).div(2).mul(-1).sub(10).equal()
              }
            },
            "&-lg": {
              [`${componentCls}-dot`]: {
                margin: calc(token2.dotSizeLG).mul(-1).div(2).equal()
              },
              [`${componentCls}-text`]: {
                paddingTop: calc(calc(token2.dotSizeLG).sub(token2.fontSize)).div(2).add(2).equal()
              },
              [`&${componentCls}-show-text ${componentCls}-dot`]: {
                marginTop: calc(token2.dotSizeLG).div(2).mul(-1).sub(10).equal()
              }
            }
          },
          [`${componentCls}-container`]: {
            position: "relative",
            transition: `opacity ${token2.motionDurationSlow}`,
            "&::after": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              zIndex: 10,
              width: "100%",
              height: "100%",
              background: token2.colorBgContainer,
              opacity: 0,
              transition: `all ${token2.motionDurationSlow}`,
              content: '""',
              pointerEvents: "none"
            }
          },
          [`${componentCls}-blur`]: {
            clear: "both",
            opacity: 0.5,
            userSelect: "none",
            pointerEvents: "none",
            "&::after": {
              opacity: 0.4,
              pointerEvents: "auto"
            }
          }
        },
        // tip
        // ------------------------------
        "&-tip": {
          color: token2.spinDotDefault
        },
        // holder
        // ------------------------------
        [`${componentCls}-dot-holder`]: {
          width: "1em",
          height: "1em",
          fontSize: token2.dotSize,
          display: "inline-block",
          transition: `transform ${token2.motionDurationSlow} ease, opacity ${token2.motionDurationSlow} ease`,
          transformOrigin: "50% 50%",
          lineHeight: 1,
          color: token2.colorPrimary,
          "&-hidden": {
            transform: "scale(0.3)",
            opacity: 0
          }
        },
        // progress
        // ------------------------------
        [`${componentCls}-dot-progress`]: {
          position: "absolute",
          inset: 0
        },
        // dots
        // ------------------------------
        [`${componentCls}-dot`]: {
          position: "relative",
          display: "inline-block",
          fontSize: token2.dotSize,
          width: "1em",
          height: "1em",
          "&-item": {
            position: "absolute",
            display: "block",
            width: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
            height: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
            background: "currentColor",
            borderRadius: "100%",
            transform: "scale(0.75)",
            transformOrigin: "50% 50%",
            opacity: 0.3,
            animationName: antSpinMove,
            animationDuration: "1s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear",
            animationDirection: "alternate",
            "&:nth-child(1)": {
              top: 0,
              insetInlineStart: 0,
              animationDelay: "0s"
            },
            "&:nth-child(2)": {
              top: 0,
              insetInlineEnd: 0,
              animationDelay: "0.4s"
            },
            "&:nth-child(3)": {
              insetInlineEnd: 0,
              bottom: 0,
              animationDelay: "0.8s"
            },
            "&:nth-child(4)": {
              bottom: 0,
              insetInlineStart: 0,
              animationDelay: "1.2s"
            }
          },
          "&-spin": {
            transform: "rotate(45deg)",
            animationName: antRotate,
            animationDuration: "1.2s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear"
          },
          "&-circle": {
            strokeLinecap: "round",
            transition: ["stroke-dashoffset", "stroke-dasharray", "stroke", "stroke-width", "opacity"].map((item) => `${item} ${token2.motionDurationSlow} ease`).join(","),
            fillOpacity: 0,
            stroke: "currentcolor"
          },
          "&-circle-bg": {
            stroke: token2.colorFillSecondary
          }
        },
        // small
        [`&-sm ${componentCls}-dot`]: {
          "&, &-holder": {
            fontSize: token2.dotSizeSM
          }
        },
        [`&-sm ${componentCls}-dot-holder`]: {
          i: {
            width: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal(),
            height: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal()
          }
        },
        // large
        [`&-lg ${componentCls}-dot`]: {
          "&, &-holder": {
            fontSize: token2.dotSizeLG
          }
        },
        [`&-lg ${componentCls}-dot-holder`]: {
          i: {
            width: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal(),
            height: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal()
          }
        },
        [`&${componentCls}-show-text ${componentCls}-text`]: {
          display: "block"
        }
      })
    };
  };
  var prepareComponentToken15 = (token2) => {
    const {
      controlHeightLG,
      controlHeight
    } = token2;
    return {
      contentHeight: 400,
      dotSize: controlHeightLG / 2,
      dotSizeSM: controlHeightLG * 0.35,
      dotSizeLG: controlHeight
    };
  };
  var style_default20 = genStyleHooks("Spin", (token2) => {
    const spinToken = merge2(token2, {
      spinDotDefault: token2.colorTextDescription
    });
    return [genSpinStyle(spinToken)];
  }, prepareComponentToken15);

  // node_modules/antd/es/spin/usePercent.js
  var React304 = __toESM(require_react());
  var AUTO_INTERVAL = 200;
  var STEP_BUCKETS = [[30, 0.05], [70, 0.03], [96, 0.01]];
  function usePercent(spinning, percent) {
    const [mockPercent, setMockPercent] = React304.useState(0);
    const mockIntervalRef = React304.useRef(null);
    const isAuto = percent === "auto";
    React304.useEffect(() => {
      if (isAuto && spinning) {
        setMockPercent(0);
        mockIntervalRef.current = setInterval(() => {
          setMockPercent((prev2) => {
            const restPTG = 100 - prev2;
            for (let i = 0; i < STEP_BUCKETS.length; i += 1) {
              const [limit, stepPtg] = STEP_BUCKETS[i];
              if (prev2 <= limit) {
                return prev2 + restPTG * stepPtg;
              }
            }
            return prev2;
          });
        }, AUTO_INTERVAL);
      }
      return () => {
        clearInterval(mockIntervalRef.current);
      };
    }, [isAuto, spinning]);
    return isAuto ? mockPercent : percent;
  }

  // node_modules/antd/es/spin/index.js
  var __rest46 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var defaultIndicator;
  function shouldDelay(spinning, delay) {
    return !!spinning && !!delay && !Number.isNaN(Number(delay));
  }
  var Spin = (props) => {
    var _a;
    const {
      prefixCls: customizePrefixCls,
      spinning: customSpinning = true,
      delay = 0,
      className,
      rootClassName,
      size = "default",
      tip,
      wrapperClassName,
      style: style2,
      children,
      fullscreen = false,
      indicator,
      percent
    } = props, restProps = __rest46(props, ["prefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "fullscreen", "indicator", "percent"]);
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      indicator: contextIndicator
    } = useComponentConfig("spin");
    const prefixCls = getPrefixCls("spin", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default20(prefixCls);
    const [spinning, setSpinning] = React305.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
    const mergedPercent = usePercent(spinning, percent);
    React305.useEffect(() => {
      if (customSpinning) {
        const showSpinning = debounce(delay, () => {
          setSpinning(true);
        });
        showSpinning();
        return () => {
          var _a2;
          (_a2 = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a2 === void 0 ? void 0 : _a2.call(showSpinning);
        };
      }
      setSpinning(false);
    }, [delay, customSpinning]);
    const isNestedPattern = React305.useMemo(() => typeof children !== "undefined" && !fullscreen, [children, fullscreen]);
    if (true) {
      const warning6 = devUseWarning("Spin");
      true ? warning6(!tip || isNestedPattern || fullscreen, "usage", "`tip` only work in nest or fullscreen pattern.") : void 0;
    }
    const spinClassName = (0, import_classnames116.default)(prefixCls, contextClassName, {
      [`${prefixCls}-sm`]: size === "small",
      [`${prefixCls}-lg`]: size === "large",
      [`${prefixCls}-spinning`]: spinning,
      [`${prefixCls}-show-text`]: !!tip,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, !fullscreen && rootClassName, hashId, cssVarCls);
    const containerClassName = (0, import_classnames116.default)(`${prefixCls}-container`, {
      [`${prefixCls}-blur`]: spinning
    });
    const mergedIndicator = (_a = indicator !== null && indicator !== void 0 ? indicator : contextIndicator) !== null && _a !== void 0 ? _a : defaultIndicator;
    const mergedStyle = Object.assign(Object.assign({}, contextStyle), style2);
    const spinElement = /* @__PURE__ */ React305.createElement("div", Object.assign({}, restProps, {
      style: mergedStyle,
      className: spinClassName,
      "aria-live": "polite",
      "aria-busy": spinning
    }), /* @__PURE__ */ React305.createElement(Indicator, {
      prefixCls,
      indicator: mergedIndicator,
      percent: mergedPercent
    }), tip && (isNestedPattern || fullscreen) ? /* @__PURE__ */ React305.createElement("div", {
      className: `${prefixCls}-text`
    }, tip) : null);
    if (isNestedPattern) {
      return wrapCSSVar(/* @__PURE__ */ React305.createElement("div", Object.assign({}, restProps, {
        className: (0, import_classnames116.default)(`${prefixCls}-nested-loading`, wrapperClassName, hashId, cssVarCls)
      }), spinning && /* @__PURE__ */ React305.createElement("div", {
        key: "loading"
      }, spinElement), /* @__PURE__ */ React305.createElement("div", {
        className: containerClassName,
        key: "container"
      }, children)));
    }
    if (fullscreen) {
      return wrapCSSVar(/* @__PURE__ */ React305.createElement("div", {
        className: (0, import_classnames116.default)(`${prefixCls}-fullscreen`, {
          [`${prefixCls}-fullscreen-show`]: spinning
        }, rootClassName, hashId, cssVarCls)
      }, spinElement));
    }
    return wrapCSSVar(spinElement);
  };
  Spin.setDefaultIndicator = (indicator) => {
    defaultIndicator = indicator;
  };
  if (true) {
    Spin.displayName = "Spin";
  }
  var spin_default = Spin;

  // node_modules/antd/es/message/index.js
  var import_react108 = __toESM(require_react());
  var message = null;
  var act = (callback) => callback();
  var taskQueue = [];
  var defaultGlobalConfig = {};
  function getGlobalContext() {
    const {
      getContainer: getContainer2,
      duration,
      rtl,
      maxCount,
      top
    } = defaultGlobalConfig;
    const mergedContainer = (getContainer2 === null || getContainer2 === void 0 ? void 0 : getContainer2()) || document.body;
    return {
      getContainer: () => mergedContainer,
      duration,
      rtl,
      maxCount,
      top
    };
  }
  var GlobalHolder = /* @__PURE__ */ import_react108.default.forwardRef((props, ref) => {
    const {
      messageConfig,
      sync
    } = props;
    const {
      getPrefixCls
    } = (0, import_react108.useContext)(ConfigContext);
    const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("message");
    const appConfig = (0, import_react108.useContext)(AppConfigContext);
    const [api, holder] = useInternalMessage(Object.assign(Object.assign(Object.assign({}, messageConfig), {
      prefixCls
    }), appConfig.message));
    import_react108.default.useImperativeHandle(ref, () => {
      const instance = Object.assign({}, api);
      Object.keys(instance).forEach((method4) => {
        instance[method4] = (...args) => {
          sync();
          return api[method4].apply(api, args);
        };
      });
      return {
        instance,
        sync
      };
    });
    return holder;
  });
  var GlobalHolderWrapper = /* @__PURE__ */ import_react108.default.forwardRef((_, ref) => {
    const [messageConfig, setMessageConfig] = import_react108.default.useState(getGlobalContext);
    const sync = () => {
      setMessageConfig(getGlobalContext);
    };
    import_react108.default.useEffect(sync, []);
    const global2 = globalConfig();
    const rootPrefixCls = global2.getRootPrefixCls();
    const rootIconPrefixCls = global2.getIconPrefixCls();
    const theme = global2.getTheme();
    const dom = /* @__PURE__ */ import_react108.default.createElement(GlobalHolder, {
      ref,
      sync,
      messageConfig
    });
    return /* @__PURE__ */ import_react108.default.createElement(config_provider_default, {
      prefixCls: rootPrefixCls,
      iconPrefixCls: rootIconPrefixCls,
      theme
    }, global2.holderRender ? global2.holderRender(dom) : dom);
  });
  function flushNotice() {
    if (!message) {
      const holderFragment = document.createDocumentFragment();
      const newMessage = {
        fragment: holderFragment
      };
      message = newMessage;
      act(() => {
        const reactRender2 = unstableSetRender();
        reactRender2(/* @__PURE__ */ import_react108.default.createElement(GlobalHolderWrapper, {
          ref: (node2) => {
            const {
              instance,
              sync
            } = node2 || {};
            Promise.resolve().then(() => {
              if (!newMessage.instance && instance) {
                newMessage.instance = instance;
                newMessage.sync = sync;
                flushNotice();
              }
            });
          }
        }), holderFragment);
      });
      return;
    }
    if (!message.instance) {
      return;
    }
    taskQueue.forEach((task) => {
      const {
        type: type5,
        skipped
      } = task;
      if (!skipped) {
        switch (type5) {
          case "open": {
            act(() => {
              const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
              closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
              task.setCloseFn(closeFn);
            });
            break;
          }
          case "destroy":
            act(() => {
              message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);
            });
            break;
          // Other type open
          default: {
            act(() => {
              var _message$instance;
              const closeFn = (_message$instance = message.instance)[type5].apply(_message$instance, _toConsumableArray(task.args));
              closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
              task.setCloseFn(closeFn);
            });
          }
        }
      }
    });
    taskQueue = [];
  }
  function setMessageGlobalConfig(config) {
    defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);
    act(() => {
      var _a;
      (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);
    });
  }
  function open(config) {
    const result = wrapPromiseFn((resolve) => {
      let closeFn;
      const task = {
        type: "open",
        config,
        resolve,
        setCloseFn: (fn) => {
          closeFn = fn;
        }
      };
      taskQueue.push(task);
      return () => {
        if (closeFn) {
          act(() => {
            closeFn();
          });
        } else {
          task.skipped = true;
        }
      };
    });
    flushNotice();
    return result;
  }
  function typeOpen(type5, args) {
    const global2 = globalConfig();
    if (!global2.holderRender) {
      warnContext("message");
    }
    const result = wrapPromiseFn((resolve) => {
      let closeFn;
      const task = {
        type: type5,
        args,
        resolve,
        setCloseFn: (fn) => {
          closeFn = fn;
        }
      };
      taskQueue.push(task);
      return () => {
        if (closeFn) {
          act(() => {
            closeFn();
          });
        } else {
          task.skipped = true;
        }
      };
    });
    flushNotice();
    return result;
  }
  var destroy = (key) => {
    taskQueue.push({
      type: "destroy",
      key
    });
    flushNotice();
  };
  var methods = ["success", "info", "warning", "error", "loading"];
  var baseStaticMethods = {
    open,
    destroy,
    config: setMessageGlobalConfig,
    useMessage,
    _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default
  };
  var staticMethods = baseStaticMethods;
  methods.forEach((type5) => {
    staticMethods[type5] = (...args) => typeOpen(type5, args);
  });
  if (false) {
    _actWrapper = (wrapper) => {
      act = wrapper;
    };
  }
  if (false) {
    _actDestroy = () => {
      message = null;
    };
  }
  var message_default = staticMethods;

  // node_modules/antd/es/modal/PurePanel.js
  var React307 = __toESM(require_react());
  var import_classnames117 = __toESM(require_classnames());
  var __rest47 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var PurePanel5 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      closeIcon,
      closable,
      type: type5,
      title,
      children,
      footer
    } = props, restProps = __rest47(props, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children", "footer"]);
    const {
      getPrefixCls
    } = React307.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const prefixCls = customizePrefixCls || getPrefixCls("modal");
    const rootCls = useCSSVarCls_default(rootPrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default6(prefixCls, rootCls);
    const confirmPrefixCls = `${prefixCls}-confirm`;
    let additionalProps = {};
    if (type5) {
      additionalProps = {
        closable: closable !== null && closable !== void 0 ? closable : false,
        title: "",
        footer: "",
        children: /* @__PURE__ */ React307.createElement(ConfirmContent, Object.assign({}, props, {
          prefixCls,
          confirmPrefixCls,
          rootPrefixCls,
          content: children
        }))
      };
    } else {
      additionalProps = {
        closable: closable !== null && closable !== void 0 ? closable : true,
        title,
        footer: footer !== null && /* @__PURE__ */ React307.createElement(Footer, Object.assign({}, props)),
        children
      };
    }
    return wrapCSSVar(/* @__PURE__ */ React307.createElement(Panel_default, Object.assign({
      prefixCls,
      className: (0, import_classnames117.default)(hashId, `${prefixCls}-pure-panel`, type5 && confirmPrefixCls, type5 && `${confirmPrefixCls}-${type5}`, className, cssVarCls, rootCls)
    }, restProps, {
      closeIcon: renderCloseIcon(prefixCls, closeIcon),
      closable
    }, additionalProps)));
  };
  var PurePanel_default4 = withPureRenderTheme(PurePanel5);

  // node_modules/antd/es/modal/index.js
  function modalWarn(props) {
    return confirm(withWarn(props));
  }
  var Modal2 = Modal_default;
  Modal2.useModal = useModal_default;
  Modal2.info = function infoFn(props) {
    return confirm(withInfo(props));
  };
  Modal2.success = function successFn(props) {
    return confirm(withSuccess(props));
  };
  Modal2.error = function errorFn(props) {
    return confirm(withError(props));
  };
  Modal2.warning = modalWarn;
  Modal2.warn = modalWarn;
  Modal2.confirm = function confirmFn(props) {
    return confirm(withConfirm(props));
  };
  Modal2.destroyAll = function destroyAllFn() {
    while (destroyFns_default.length) {
      const close = destroyFns_default.pop();
      if (close) {
        close();
      }
    }
  };
  Modal2.config = modalGlobalConfig;
  Modal2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default4;
  if (true) {
    Modal2.displayName = "Modal";
  }
  var modal_default = Modal2;

  // node_modules/antd/es/progress/progress.js
  var React315 = __toESM(require_react());
  var import_classnames123 = __toESM(require_classnames());

  // node_modules/antd/es/progress/Circle.js
  var React312 = __toESM(require_react());
  var import_classnames120 = __toESM(require_classnames());

  // node_modules/rc-progress/es/Line.js
  var React308 = __toESM(require_react());
  var import_classnames118 = __toESM(require_classnames());

  // node_modules/rc-progress/es/common.js
  var import_react109 = __toESM(require_react());
  var defaultProps = {
    percent: 0,
    prefixCls: "rc-progress",
    strokeColor: "#2db7f5",
    strokeLinecap: "round",
    strokeWidth: 1,
    trailColor: "#D9D9D9",
    trailWidth: 1,
    gapPosition: "bottom"
  };
  var useTransitionDuration = function useTransitionDuration2() {
    var pathsRef = (0, import_react109.useRef)([]);
    var prevTimeStamp = (0, import_react109.useRef)(null);
    (0, import_react109.useEffect)(function() {
      var now2 = Date.now();
      var updated = false;
      pathsRef.current.forEach(function(path2) {
        if (!path2) {
          return;
        }
        updated = true;
        var pathStyle = path2.style;
        pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
        if (prevTimeStamp.current && now2 - prevTimeStamp.current < 100) {
          pathStyle.transitionDuration = "0s, 0s";
        }
      });
      if (updated) {
        prevTimeStamp.current = Date.now();
      }
    });
    return pathsRef.current;
  };

  // node_modules/rc-progress/es/Line.js
  var _excluded47 = ["className", "percent", "prefixCls", "strokeColor", "strokeLinecap", "strokeWidth", "style", "trailColor", "trailWidth", "transition"];
  var Line = function Line2(props) {
    var _defaultProps$props = _objectSpread2(_objectSpread2({}, defaultProps), props), className = _defaultProps$props.className, percent = _defaultProps$props.percent, prefixCls = _defaultProps$props.prefixCls, strokeColor = _defaultProps$props.strokeColor, strokeLinecap = _defaultProps$props.strokeLinecap, strokeWidth = _defaultProps$props.strokeWidth, style2 = _defaultProps$props.style, trailColor = _defaultProps$props.trailColor, trailWidth = _defaultProps$props.trailWidth, transition = _defaultProps$props.transition, restProps = _objectWithoutProperties(_defaultProps$props, _excluded47);
    delete restProps.gapPosition;
    var percentList = Array.isArray(percent) ? percent : [percent];
    var strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
    var paths = useTransitionDuration();
    var center = strokeWidth / 2;
    var right = 100 - strokeWidth / 2;
    var pathString = "M ".concat(strokeLinecap === "round" ? center : 0, ",").concat(center, "\n         L ").concat(strokeLinecap === "round" ? right : 100, ",").concat(center);
    var viewBoxString = "0 0 100 ".concat(strokeWidth);
    var stackPtg = 0;
    return /* @__PURE__ */ React308.createElement("svg", _extends({
      className: (0, import_classnames118.default)("".concat(prefixCls, "-line"), className),
      viewBox: viewBoxString,
      preserveAspectRatio: "none",
      style: style2
    }, restProps), /* @__PURE__ */ React308.createElement("path", {
      className: "".concat(prefixCls, "-line-trail"),
      d: pathString,
      strokeLinecap,
      stroke: trailColor,
      strokeWidth: trailWidth || strokeWidth,
      fillOpacity: "0"
    }), percentList.map(function(ptg, index3) {
      var dashPercent = 1;
      switch (strokeLinecap) {
        case "round":
          dashPercent = 1 - strokeWidth / 100;
          break;
        case "square":
          dashPercent = 1 - strokeWidth / 2 / 100;
          break;
        default:
          dashPercent = 1;
          break;
      }
      var pathStyle = {
        strokeDasharray: "".concat(ptg * dashPercent, "px, 100px"),
        strokeDashoffset: "-".concat(stackPtg, "px"),
        transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear"
      };
      var color = strokeColorList[index3] || strokeColorList[strokeColorList.length - 1];
      stackPtg += ptg;
      return /* @__PURE__ */ React308.createElement("path", {
        key: index3,
        className: "".concat(prefixCls, "-line-path"),
        d: pathString,
        strokeLinecap,
        stroke: color,
        strokeWidth,
        fillOpacity: "0",
        ref: function ref(elem) {
          paths[index3] = elem;
        },
        style: pathStyle
      });
    }));
  };
  if (true) {
    Line.displayName = "Line";
  }

  // node_modules/rc-progress/es/Circle/index.js
  var React311 = __toESM(require_react());
  var import_classnames119 = __toESM(require_classnames());

  // node_modules/rc-progress/es/hooks/useId.js
  var React309 = __toESM(require_react());
  var uuid7 = 0;
  var isBrowserClient3 = canUseDom();
  function getUUID2() {
    var retId;
    if (isBrowserClient3) {
      retId = uuid7;
      uuid7 += 1;
    } else {
      retId = "TEST_OR_SSR";
    }
    return retId;
  }
  var useId_default2 = function(id) {
    var _React$useState = React309.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
    React309.useEffect(function() {
      setInnerId("rc_progress_".concat(getUUID2()));
    }, []);
    return id || innerId;
  };

  // node_modules/rc-progress/es/Circle/PtgCircle.js
  var React310 = __toESM(require_react());
  var Block = function Block2(_ref) {
    var bg = _ref.bg, children = _ref.children;
    return /* @__PURE__ */ React310.createElement("div", {
      style: {
        width: "100%",
        height: "100%",
        background: bg
      }
    }, children);
  };
  function getPtgColors(color, scale) {
    return Object.keys(color).map(function(key) {
      var parsedKey = parseFloat(key);
      var ptgKey = "".concat(Math.floor(parsedKey * scale), "%");
      return "".concat(color[key], " ").concat(ptgKey);
    });
  }
  var PtgCircle = /* @__PURE__ */ React310.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, color = props.color, gradientId = props.gradientId, radius2 = props.radius, circleStyleForStack = props.style, ptg = props.ptg, strokeLinecap = props.strokeLinecap, strokeWidth = props.strokeWidth, size = props.size, gapDegree = props.gapDegree;
    var isGradient = color && _typeof(color) === "object";
    var stroke = isGradient ? "#FFF" : void 0;
    var halfSize = size / 2;
    var circleNode = /* @__PURE__ */ React310.createElement("circle", {
      className: "".concat(prefixCls, "-circle-path"),
      r: radius2,
      cx: halfSize,
      cy: halfSize,
      stroke,
      strokeLinecap,
      strokeWidth,
      opacity: ptg === 0 ? 0 : 1,
      style: circleStyleForStack,
      ref
    });
    if (!isGradient) {
      return circleNode;
    }
    var maskId = "".concat(gradientId, "-conic");
    var fromDeg = gapDegree ? "".concat(180 + gapDegree / 2, "deg") : "0deg";
    var conicColors = getPtgColors(color, (360 - gapDegree) / 360);
    var linearColors = getPtgColors(color, 1);
    var conicColorBg = "conic-gradient(from ".concat(fromDeg, ", ").concat(conicColors.join(", "), ")");
    var linearColorBg = "linear-gradient(to ".concat(gapDegree ? "bottom" : "top", ", ").concat(linearColors.join(", "), ")");
    return /* @__PURE__ */ React310.createElement(React310.Fragment, null, /* @__PURE__ */ React310.createElement("mask", {
      id: maskId
    }, circleNode), /* @__PURE__ */ React310.createElement("foreignObject", {
      x: 0,
      y: 0,
      width: size,
      height: size,
      mask: "url(#".concat(maskId, ")")
    }, /* @__PURE__ */ React310.createElement(Block, {
      bg: linearColorBg
    }, /* @__PURE__ */ React310.createElement(Block, {
      bg: conicColorBg
    }))));
  });
  if (true) {
    PtgCircle.displayName = "PtgCircle";
  }
  var PtgCircle_default = PtgCircle;

  // node_modules/rc-progress/es/Circle/util.js
  var VIEW_BOX_SIZE = 100;
  var getCircleStyle = function getCircleStyle2(perimeter, perimeterWithoutGap, offset3, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth) {
    var stepSpace = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0;
    var offsetDeg = offset3 / 100 * 360 * ((360 - gapDegree) / 360);
    var positionDeg = gapDegree === 0 ? 0 : {
      bottom: 0,
      top: 180,
      left: 90,
      right: -90
    }[gapPosition];
    var strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
    if (strokeLinecap === "round" && percent !== 100) {
      strokeDashoffset += strokeWidth / 2;
      if (strokeDashoffset >= perimeterWithoutGap) {
        strokeDashoffset = perimeterWithoutGap - 0.01;
      }
    }
    var halfSize = VIEW_BOX_SIZE / 2;
    return {
      stroke: typeof strokeColor === "string" ? strokeColor : void 0,
      strokeDasharray: "".concat(perimeterWithoutGap, "px ").concat(perimeter),
      strokeDashoffset: strokeDashoffset + stepSpace,
      transform: "rotate(".concat(rotateDeg + offsetDeg + positionDeg, "deg)"),
      transformOrigin: "".concat(halfSize, "px ").concat(halfSize, "px"),
      transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
      fillOpacity: 0
    };
  };

  // node_modules/rc-progress/es/Circle/index.js
  var _excluded48 = ["id", "prefixCls", "steps", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor", "percent"];
  function toArray6(value) {
    var mergedValue = value !== null && value !== void 0 ? value : [];
    return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
  }
  var Circle = function Circle2(props) {
    var _defaultProps$props = _objectSpread2(_objectSpread2({}, defaultProps), props), id = _defaultProps$props.id, prefixCls = _defaultProps$props.prefixCls, steps = _defaultProps$props.steps, strokeWidth = _defaultProps$props.strokeWidth, trailWidth = _defaultProps$props.trailWidth, _defaultProps$props$g = _defaultProps$props.gapDegree, gapDegree = _defaultProps$props$g === void 0 ? 0 : _defaultProps$props$g, gapPosition = _defaultProps$props.gapPosition, trailColor = _defaultProps$props.trailColor, strokeLinecap = _defaultProps$props.strokeLinecap, style2 = _defaultProps$props.style, className = _defaultProps$props.className, strokeColor = _defaultProps$props.strokeColor, percent = _defaultProps$props.percent, restProps = _objectWithoutProperties(_defaultProps$props, _excluded48);
    var halfSize = VIEW_BOX_SIZE / 2;
    var mergedId = useId_default2(id);
    var gradientId = "".concat(mergedId, "-gradient");
    var radius2 = halfSize - strokeWidth / 2;
    var perimeter = Math.PI * 2 * radius2;
    var rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
    var perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
    var _ref = _typeof(steps) === "object" ? steps : {
      count: steps,
      gap: 2
    }, stepCount = _ref.count, stepGap = _ref.gap;
    var percentList = toArray6(percent);
    var strokeColorList = toArray6(strokeColor);
    var gradient = strokeColorList.find(function(color) {
      return color && _typeof(color) === "object";
    });
    var isConicGradient = gradient && _typeof(gradient) === "object";
    var mergedStrokeLinecap = isConicGradient ? "butt" : strokeLinecap;
    var circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, trailColor, mergedStrokeLinecap, strokeWidth);
    var paths = useTransitionDuration();
    var getStokeList = function getStokeList2() {
      var stackPtg = 0;
      return percentList.map(function(ptg, index3) {
        var color = strokeColorList[index3] || strokeColorList[strokeColorList.length - 1];
        var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, mergedStrokeLinecap, strokeWidth);
        stackPtg += ptg;
        return /* @__PURE__ */ React311.createElement(PtgCircle_default, {
          key: index3,
          color,
          ptg,
          radius: radius2,
          prefixCls,
          gradientId,
          style: circleStyleForStack,
          strokeLinecap: mergedStrokeLinecap,
          strokeWidth,
          gapDegree,
          ref: function ref(elem) {
            paths[index3] = elem;
          },
          size: VIEW_BOX_SIZE
        });
      }).reverse();
    };
    var getStepStokeList = function getStepStokeList2() {
      var current = Math.round(stepCount * (percentList[0] / 100));
      var stepPtg = 100 / stepCount;
      var stackPtg = 0;
      return new Array(stepCount).fill(null).map(function(_, index3) {
        var color = index3 <= current - 1 ? strokeColorList[0] : trailColor;
        var stroke = color && _typeof(color) === "object" ? "url(#".concat(gradientId, ")") : void 0;
        var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, "butt", strokeWidth, stepGap);
        stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepGap) * 100 / perimeterWithoutGap;
        return /* @__PURE__ */ React311.createElement("circle", {
          key: index3,
          className: "".concat(prefixCls, "-circle-path"),
          r: radius2,
          cx: halfSize,
          cy: halfSize,
          stroke,
          strokeWidth,
          opacity: 1,
          style: circleStyleForStack,
          ref: function ref(elem) {
            paths[index3] = elem;
          }
        });
      });
    };
    return /* @__PURE__ */ React311.createElement("svg", _extends({
      className: (0, import_classnames119.default)("".concat(prefixCls, "-circle"), className),
      viewBox: "0 0 ".concat(VIEW_BOX_SIZE, " ").concat(VIEW_BOX_SIZE),
      style: style2,
      id,
      role: "presentation"
    }, restProps), !stepCount && /* @__PURE__ */ React311.createElement("circle", {
      className: "".concat(prefixCls, "-circle-trail"),
      r: radius2,
      cx: halfSize,
      cy: halfSize,
      stroke: trailColor,
      strokeLinecap: mergedStrokeLinecap,
      strokeWidth: trailWidth || strokeWidth,
      style: circleStyle
    }), stepCount ? getStepStokeList() : getStokeList());
  };
  if (true) {
    Circle.displayName = "Circle";
  }
  var Circle_default = Circle;

  // node_modules/antd/es/progress/utils.js
  function validProgress(progress) {
    if (!progress || progress < 0) {
      return 0;
    }
    if (progress > 100) {
      return 100;
    }
    return progress;
  }
  function getSuccessPercent({
    success,
    successPercent
  }) {
    let percent = successPercent;
    if (success && "progress" in success) {
      percent = success.progress;
    }
    if (success && "percent" in success) {
      percent = success.percent;
    }
    return percent;
  }
  var getPercentage = ({
    percent,
    success,
    successPercent
  }) => {
    const realSuccessPercent = validProgress(getSuccessPercent({
      success,
      successPercent
    }));
    return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
  };
  var getStrokeColor = ({
    success = {},
    strokeColor
  }) => {
    const {
      strokeColor: successColor
    } = success;
    return [successColor || presetPrimaryColors.green, strokeColor || null];
  };
  var getSize3 = (size, type5, extra) => {
    var _a, _b, _c, _d;
    let width = -1;
    let height = -1;
    if (type5 === "step") {
      const steps = extra.steps;
      const strokeWidth = extra.strokeWidth;
      if (typeof size === "string" || typeof size === "undefined") {
        width = size === "small" ? 2 : 14;
        height = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 8;
      } else if (typeof size === "number") {
        [width, height] = [size, size];
      } else {
        [width = 14, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
      }
      width *= steps;
    } else if (type5 === "line") {
      const strokeWidth = extra === null || extra === void 0 ? void 0 : extra.strokeWidth;
      if (typeof size === "string" || typeof size === "undefined") {
        height = strokeWidth || (size === "small" ? 6 : 8);
      } else if (typeof size === "number") {
        [width, height] = [size, size];
      } else {
        [width = -1, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
      }
    } else if (type5 === "circle" || type5 === "dashboard") {
      if (typeof size === "string" || typeof size === "undefined") {
        [width, height] = size === "small" ? [60, 60] : [120, 120];
      } else if (typeof size === "number") {
        [width, height] = [size, size];
      } else if (Array.isArray(size)) {
        width = (_b = (_a = size[0]) !== null && _a !== void 0 ? _a : size[1]) !== null && _b !== void 0 ? _b : 120;
        height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120;
      }
    }
    return [width, height];
  };

  // node_modules/antd/es/progress/Circle.js
  var CIRCLE_MIN_STROKE_WIDTH = 3;
  var getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
  var Circle3 = (props) => {
    const {
      prefixCls,
      trailColor = null,
      strokeLinecap = "round",
      gapPosition,
      gapDegree,
      width: originWidth = 120,
      type: type5,
      children,
      success,
      size = originWidth,
      steps
    } = props;
    const [width, height] = getSize3(size, "circle");
    let {
      strokeWidth
    } = props;
    if (strokeWidth === void 0) {
      strokeWidth = Math.max(getMinPercent(width), 6);
    }
    const circleStyle = {
      width,
      height,
      fontSize: width * 0.15 + 6
    };
    const realGapDegree = React312.useMemo(() => {
      if (gapDegree || gapDegree === 0) {
        return gapDegree;
      }
      if (type5 === "dashboard") {
        return 75;
      }
      return void 0;
    }, [gapDegree, type5]);
    const percentArray = getPercentage(props);
    const gapPos = gapPosition || type5 === "dashboard" && "bottom" || void 0;
    const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
    const strokeColor = getStrokeColor({
      success,
      strokeColor: props.strokeColor
    });
    const wrapperClassName = (0, import_classnames120.default)(`${prefixCls}-inner`, {
      [`${prefixCls}-circle-gradient`]: isGradient
    });
    const circleContent = /* @__PURE__ */ React312.createElement(Circle_default, {
      steps,
      percent: steps ? percentArray[1] : percentArray,
      strokeWidth,
      trailWidth: strokeWidth,
      strokeColor: steps ? strokeColor[1] : strokeColor,
      strokeLinecap,
      trailColor,
      prefixCls,
      gapDegree: realGapDegree,
      gapPosition: gapPos
    });
    const smallCircle = width <= 20;
    const node2 = /* @__PURE__ */ React312.createElement("div", {
      className: wrapperClassName,
      style: circleStyle
    }, circleContent, !smallCircle && children);
    if (smallCircle) {
      return /* @__PURE__ */ React312.createElement(tooltip_default, {
        title: children
      }, node2);
    }
    return node2;
  };
  var Circle_default2 = Circle3;

  // node_modules/antd/es/progress/Line.js
  var React313 = __toESM(require_react());
  var import_classnames121 = __toESM(require_classnames());

  // node_modules/antd/es/progress/style/index.js
  var LineStrokeColorVar = "--progress-line-stroke-color";
  var Percent = "--progress-percent";
  var genAntProgressActive = (isRtl) => {
    const direction = isRtl ? "100%" : "-100%";
    return new Keyframes_default(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
      "0%": {
        transform: `translateX(${direction}) scaleX(0)`,
        opacity: 0.1
      },
      "20%": {
        transform: `translateX(${direction}) scaleX(0)`,
        opacity: 0.5
      },
      to: {
        transform: "translateX(0) scaleX(1)",
        opacity: 0
      }
    });
  };
  var genBaseStyle4 = (token2) => {
    const {
      componentCls: progressCls,
      iconCls: iconPrefixCls
    } = token2;
    return {
      [progressCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-block",
        "&-rtl": {
          direction: "rtl"
        },
        "&-line": {
          position: "relative",
          width: "100%",
          fontSize: token2.fontSize
        },
        [`${progressCls}-outer`]: {
          display: "inline-flex",
          alignItems: "center",
          width: "100%"
        },
        [`${progressCls}-inner`]: {
          position: "relative",
          display: "inline-block",
          width: "100%",
          flex: 1,
          overflow: "hidden",
          verticalAlign: "middle",
          backgroundColor: token2.remainingColor,
          borderRadius: token2.lineBorderRadius
        },
        [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
          [`${progressCls}-circle-path`]: {
            stroke: token2.defaultColor
          }
        },
        [`${progressCls}-success-bg, ${progressCls}-bg`]: {
          position: "relative",
          background: token2.defaultColor,
          borderRadius: token2.lineBorderRadius,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`
        },
        [`${progressCls}-layout-bottom`]: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          [`${progressCls}-text`]: {
            width: "max-content",
            marginInlineStart: 0,
            marginTop: token2.marginXXS
          }
        },
        [`${progressCls}-bg`]: {
          overflow: "hidden",
          "&::after": {
            content: '""',
            background: {
              _multi_value_: true,
              value: ["inherit", `var(${LineStrokeColorVar})`]
            },
            height: "100%",
            width: `calc(1 / var(${Percent}) * 100%)`,
            display: "block"
          },
          [`&${progressCls}-bg-inner`]: {
            minWidth: "max-content",
            "&::after": {
              content: "none"
            },
            [`${progressCls}-text-inner`]: {
              color: token2.colorWhite,
              [`&${progressCls}-text-bright`]: {
                color: "rgba(0, 0, 0, 0.45)"
              }
            }
          }
        },
        [`${progressCls}-success-bg`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          backgroundColor: token2.colorSuccess
        },
        [`${progressCls}-text`]: {
          display: "inline-block",
          marginInlineStart: token2.marginXS,
          color: token2.colorText,
          lineHeight: 1,
          width: "2em",
          whiteSpace: "nowrap",
          textAlign: "start",
          verticalAlign: "middle",
          wordBreak: "normal",
          [iconPrefixCls]: {
            fontSize: token2.fontSize
          },
          [`&${progressCls}-text-outer`]: {
            width: "max-content"
          },
          [`&${progressCls}-text-outer${progressCls}-text-start`]: {
            width: "max-content",
            marginInlineStart: 0,
            marginInlineEnd: token2.marginXS
          }
        },
        [`${progressCls}-text-inner`]: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          width: "100%",
          height: "100%",
          marginInlineStart: 0,
          padding: `0 ${unit(token2.paddingXXS)}`,
          [`&${progressCls}-text-start`]: {
            justifyContent: "start"
          },
          [`&${progressCls}-text-end`]: {
            justifyContent: "end"
          }
        },
        [`&${progressCls}-status-active`]: {
          [`${progressCls}-bg::before`]: {
            position: "absolute",
            inset: 0,
            backgroundColor: token2.colorBgContainer,
            borderRadius: token2.lineBorderRadius,
            opacity: 0,
            animationName: genAntProgressActive(),
            animationDuration: token2.progressActiveMotionDuration,
            animationTimingFunction: token2.motionEaseOutQuint,
            animationIterationCount: "infinite",
            content: '""'
          }
        },
        [`&${progressCls}-rtl${progressCls}-status-active`]: {
          [`${progressCls}-bg::before`]: {
            animationName: genAntProgressActive(true)
          }
        },
        [`&${progressCls}-status-exception`]: {
          [`${progressCls}-bg`]: {
            backgroundColor: token2.colorError
          },
          [`${progressCls}-text`]: {
            color: token2.colorError
          }
        },
        [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
          [`${progressCls}-circle-path`]: {
            stroke: token2.colorError
          }
        },
        [`&${progressCls}-status-success`]: {
          [`${progressCls}-bg`]: {
            backgroundColor: token2.colorSuccess
          },
          [`${progressCls}-text`]: {
            color: token2.colorSuccess
          }
        },
        [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
          [`${progressCls}-circle-path`]: {
            stroke: token2.colorSuccess
          }
        }
      })
    };
  };
  var genCircleStyle = (token2) => {
    const {
      componentCls: progressCls,
      iconCls: iconPrefixCls
    } = token2;
    return {
      [progressCls]: {
        [`${progressCls}-circle-trail`]: {
          stroke: token2.remainingColor
        },
        [`&${progressCls}-circle ${progressCls}-inner`]: {
          position: "relative",
          lineHeight: 1,
          backgroundColor: "transparent"
        },
        [`&${progressCls}-circle ${progressCls}-text`]: {
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: 0,
          width: "100%",
          margin: 0,
          padding: 0,
          color: token2.circleTextColor,
          fontSize: token2.circleTextFontSize,
          lineHeight: 1,
          whiteSpace: "normal",
          textAlign: "center",
          transform: "translateY(-50%)",
          [iconPrefixCls]: {
            fontSize: token2.circleIconFontSize
          }
        },
        [`${progressCls}-circle&-status-exception`]: {
          [`${progressCls}-text`]: {
            color: token2.colorError
          }
        },
        [`${progressCls}-circle&-status-success`]: {
          [`${progressCls}-text`]: {
            color: token2.colorSuccess
          }
        }
      },
      [`${progressCls}-inline-circle`]: {
        lineHeight: 1,
        [`${progressCls}-inner`]: {
          verticalAlign: "bottom"
        }
      }
    };
  };
  var genStepStyle = (token2) => {
    const {
      componentCls: progressCls
    } = token2;
    return {
      [progressCls]: {
        [`${progressCls}-steps`]: {
          display: "inline-block",
          "&-outer": {
            display: "flex",
            flexDirection: "row",
            alignItems: "center"
          },
          "&-item": {
            flexShrink: 0,
            minWidth: token2.progressStepMinWidth,
            marginInlineEnd: token2.progressStepMarginInlineEnd,
            backgroundColor: token2.remainingColor,
            transition: `all ${token2.motionDurationSlow}`,
            "&-active": {
              backgroundColor: token2.defaultColor
            }
          }
        }
      }
    };
  };
  var genSmallLine = (token2) => {
    const {
      componentCls: progressCls,
      iconCls: iconPrefixCls
    } = token2;
    return {
      [progressCls]: {
        [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {
          fontSize: token2.fontSizeSM
        }
      }
    };
  };
  var prepareComponentToken16 = (token2) => ({
    circleTextColor: token2.colorText,
    defaultColor: token2.colorInfo,
    remainingColor: token2.colorFillSecondary,
    lineBorderRadius: 100,
    // magic for capsule shape, should be a very large number
    circleTextFontSize: "1em",
    circleIconFontSize: `${token2.fontSize / token2.fontSizeSM}em`
  });
  var style_default21 = genStyleHooks("Progress", (token2) => {
    const progressStepMarginInlineEnd = token2.calc(token2.marginXXS).div(2).equal();
    const progressToken = merge2(token2, {
      progressStepMarginInlineEnd,
      progressStepMinWidth: progressStepMarginInlineEnd,
      progressActiveMotionDuration: "2.4s"
    });
    return [genBaseStyle4(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
  }, prepareComponentToken16);

  // node_modules/antd/es/progress/Line.js
  var __rest48 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var sortGradient = (gradients) => {
    let tempArr = [];
    Object.keys(gradients).forEach((key) => {
      const formattedKey = parseFloat(key.replace(/%/g, ""));
      if (!Number.isNaN(formattedKey)) {
        tempArr.push({
          key: formattedKey,
          value: gradients[key]
        });
      }
    });
    tempArr = tempArr.sort((a, b) => a.key - b.key);
    return tempArr.map(({
      key,
      value
    }) => `${value} ${key}%`).join(", ");
  };
  var handleGradient = (strokeColor, directionConfig) => {
    const {
      from: from2 = presetPrimaryColors.blue,
      to = presetPrimaryColors.blue,
      direction = directionConfig === "rtl" ? "to left" : "to right"
    } = strokeColor, rest = __rest48(strokeColor, ["from", "to", "direction"]);
    if (Object.keys(rest).length !== 0) {
      const sortedGradients = sortGradient(rest);
      const background2 = `linear-gradient(${direction}, ${sortedGradients})`;
      return {
        background: background2,
        [LineStrokeColorVar]: background2
      };
    }
    const background = `linear-gradient(${direction}, ${from2}, ${to})`;
    return {
      background,
      [LineStrokeColorVar]: background
    };
  };
  var Line3 = (props) => {
    const {
      prefixCls,
      direction: directionConfig,
      percent,
      size,
      strokeWidth,
      strokeColor,
      strokeLinecap = "round",
      children,
      trailColor = null,
      percentPosition,
      success
    } = props;
    const {
      align: infoAlign,
      type: infoPosition
    } = percentPosition;
    const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : {
      [LineStrokeColorVar]: strokeColor,
      background: strokeColor
    };
    const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
    const mergedSize = size !== null && size !== void 0 ? size : [-1, strokeWidth || (size === "small" ? 6 : 8)];
    const [width, height] = getSize3(mergedSize, "line", {
      strokeWidth
    });
    if (true) {
      const warning6 = devUseWarning("Progress");
      warning6.deprecated(!("strokeWidth" in props), "strokeWidth", "size");
    }
    const trailStyle = {
      backgroundColor: trailColor || void 0,
      borderRadius
    };
    const percentStyle = Object.assign(Object.assign({
      width: `${validProgress(percent)}%`,
      height,
      borderRadius
    }, backgroundProps), {
      [Percent]: validProgress(percent) / 100
    });
    const successPercent = getSuccessPercent(props);
    const successPercentStyle = {
      width: `${validProgress(successPercent)}%`,
      height,
      borderRadius,
      backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
    };
    const outerStyle = {
      width: width < 0 ? "100%" : width
    };
    const lineInner = /* @__PURE__ */ React313.createElement("div", {
      className: `${prefixCls}-inner`,
      style: trailStyle
    }, /* @__PURE__ */ React313.createElement("div", {
      className: (0, import_classnames121.default)(`${prefixCls}-bg`, `${prefixCls}-bg-${infoPosition}`),
      style: percentStyle
    }, infoPosition === "inner" && children), successPercent !== void 0 && /* @__PURE__ */ React313.createElement("div", {
      className: `${prefixCls}-success-bg`,
      style: successPercentStyle
    }));
    const isOuterStart = infoPosition === "outer" && infoAlign === "start";
    const isOuterEnd = infoPosition === "outer" && infoAlign === "end";
    return infoPosition === "outer" && infoAlign === "center" ? /* @__PURE__ */ React313.createElement("div", {
      className: `${prefixCls}-layout-bottom`
    }, lineInner, children) : /* @__PURE__ */ React313.createElement("div", {
      className: `${prefixCls}-outer`,
      style: outerStyle
    }, isOuterStart && children, lineInner, isOuterEnd && children);
  };
  var Line_default2 = Line3;

  // node_modules/antd/es/progress/Steps.js
  var React314 = __toESM(require_react());
  var import_classnames122 = __toESM(require_classnames());
  var Steps = (props) => {
    const {
      size,
      steps,
      rounding: customRounding = Math.round,
      percent = 0,
      strokeWidth = 8,
      strokeColor,
      trailColor = null,
      prefixCls,
      children
    } = props;
    const current = customRounding(steps * (percent / 100));
    const stepWidth = size === "small" ? 2 : 14;
    const mergedSize = size !== null && size !== void 0 ? size : [stepWidth, strokeWidth];
    const [width, height] = getSize3(mergedSize, "step", {
      steps,
      strokeWidth
    });
    const unitWidth = width / steps;
    const styledSteps = Array.from({
      length: steps
    });
    for (let i = 0; i < steps; i++) {
      const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
      styledSteps[i] = /* @__PURE__ */ React314.createElement("div", {
        key: i,
        className: (0, import_classnames122.default)(`${prefixCls}-steps-item`, {
          [`${prefixCls}-steps-item-active`]: i <= current - 1
        }),
        style: {
          backgroundColor: i <= current - 1 ? color : trailColor,
          width: unitWidth,
          height
        }
      });
    }
    return /* @__PURE__ */ React314.createElement("div", {
      className: `${prefixCls}-steps-outer`
    }, styledSteps, children);
  };
  var Steps_default = Steps;

  // node_modules/antd/es/progress/progress.js
  var __rest49 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var ProgressStatuses = ["normal", "exception", "active", "success"];
  var Progress2 = /* @__PURE__ */ React315.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      steps,
      strokeColor,
      percent = 0,
      size = "default",
      showInfo = true,
      type: type5 = "line",
      status,
      format: format2,
      style: style2,
      percentPosition = {}
    } = props, restProps = __rest49(props, ["prefixCls", "className", "rootClassName", "steps", "strokeColor", "percent", "size", "showInfo", "type", "status", "format", "style", "percentPosition"]);
    const {
      align: infoAlign = "end",
      type: infoPosition = "outer"
    } = percentPosition;
    const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
    const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
    const strokeColorIsBright = React315.useMemo(() => {
      if (strokeColorNotArray) {
        const color = typeof strokeColorNotArray === "string" ? strokeColorNotArray : Object.values(strokeColorNotArray)[0];
        return new FastColor(color).isLight();
      }
      return false;
    }, [strokeColor]);
    const percentNumber = React315.useMemo(() => {
      var _a, _b;
      const successPercent = getSuccessPercent(props);
      return parseInt(successPercent !== void 0 ? (_a = successPercent !== null && successPercent !== void 0 ? successPercent : 0) === null || _a === void 0 ? void 0 : _a.toString() : (_b = percent !== null && percent !== void 0 ? percent : 0) === null || _b === void 0 ? void 0 : _b.toString(), 10);
    }, [percent, props.success, props.successPercent]);
    const progressStatus = React315.useMemo(() => {
      if (!ProgressStatuses.includes(status) && percentNumber >= 100) {
        return "success";
      }
      return status || "normal";
    }, [status, percentNumber]);
    const {
      getPrefixCls,
      direction,
      progress: progressStyle
    } = React315.useContext(ConfigContext);
    const prefixCls = getPrefixCls("progress", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default21(prefixCls);
    const isLineType = type5 === "line";
    const isPureLineType = isLineType && !steps;
    const progressInfo = React315.useMemo(() => {
      if (!showInfo) {
        return null;
      }
      const successPercent = getSuccessPercent(props);
      let text;
      const textFormatter = format2 || ((number4) => `${number4}%`);
      const isBrightInnerColor = isLineType && strokeColorIsBright && infoPosition === "inner";
      if (infoPosition === "inner" || format2 || progressStatus !== "exception" && progressStatus !== "success") {
        text = textFormatter(validProgress(percent), validProgress(successPercent));
      } else if (progressStatus === "exception") {
        text = isLineType ? /* @__PURE__ */ React315.createElement(CloseCircleFilled_default2, null) : /* @__PURE__ */ React315.createElement(CloseOutlined_default2, null);
      } else if (progressStatus === "success") {
        text = isLineType ? /* @__PURE__ */ React315.createElement(CheckCircleFilled_default2, null) : /* @__PURE__ */ React315.createElement(CheckOutlined_default2, null);
      }
      return /* @__PURE__ */ React315.createElement("span", {
        className: (0, import_classnames123.default)(`${prefixCls}-text`, {
          [`${prefixCls}-text-bright`]: isBrightInnerColor,
          [`${prefixCls}-text-${infoAlign}`]: isPureLineType,
          [`${prefixCls}-text-${infoPosition}`]: isPureLineType
        }),
        title: typeof text === "string" ? text : void 0
      }, text);
    }, [showInfo, percent, percentNumber, progressStatus, type5, prefixCls, format2]);
    if (true) {
      const warning6 = devUseWarning("Progress");
      warning6.deprecated(!("successPercent" in props), "successPercent", "success.percent");
      warning6.deprecated(!("width" in props), "width", "size");
      if (type5 === "circle" || type5 === "dashboard") {
        if (Array.isArray(size)) {
          true ? warning6(false, "usage", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.') : void 0;
        } else if (typeof size === "object") {
          true ? warning6(false, "usage", 'Type "circle" and "dashboard" do not accept object as `size`, please use number or preset size instead.') : void 0;
        }
      }
      if (props.success && "progress" in props.success) {
        warning6.deprecated(false, "success.progress", "success.percent");
      }
    }
    let progress;
    if (type5 === "line") {
      progress = steps ? /* @__PURE__ */ React315.createElement(Steps_default, Object.assign({}, props, {
        strokeColor: strokeColorNotGradient,
        prefixCls,
        steps: typeof steps === "object" ? steps.count : steps
      }), progressInfo) : /* @__PURE__ */ React315.createElement(Line_default2, Object.assign({}, props, {
        strokeColor: strokeColorNotArray,
        prefixCls,
        direction,
        percentPosition: {
          align: infoAlign,
          type: infoPosition
        }
      }), progressInfo);
    } else if (type5 === "circle" || type5 === "dashboard") {
      progress = /* @__PURE__ */ React315.createElement(Circle_default2, Object.assign({}, props, {
        strokeColor: strokeColorNotArray,
        prefixCls,
        progressStatus
      }), progressInfo);
    }
    const classString = (0, import_classnames123.default)(prefixCls, `${prefixCls}-status-${progressStatus}`, {
      [`${prefixCls}-${type5 === "dashboard" && "circle" || type5}`]: type5 !== "line",
      [`${prefixCls}-inline-circle`]: type5 === "circle" && getSize3(size, "circle")[0] <= 20,
      [`${prefixCls}-line`]: isPureLineType,
      [`${prefixCls}-line-align-${infoAlign}`]: isPureLineType,
      [`${prefixCls}-line-position-${infoPosition}`]: isPureLineType,
      [`${prefixCls}-steps`]: steps,
      [`${prefixCls}-show-info`]: showInfo,
      [`${prefixCls}-${size}`]: typeof size === "string",
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.className, className, rootClassName, hashId, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React315.createElement("div", Object.assign({
      ref,
      style: Object.assign(Object.assign({}, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.style), style2),
      className: classString,
      role: "progressbar",
      "aria-valuenow": percentNumber,
      "aria-valuemin": 0,
      "aria-valuemax": 100
    }, omit(restProps, ["trailColor", "strokeWidth", "width", "gapDegree", "gapPosition", "strokeLinecap", "success", "successPercent"])), progress));
  });
  if (true) {
    Progress2.displayName = "Progress";
  }
  var progress_default = Progress2;

  // node_modules/antd/es/progress/index.js
  var progress_default2 = progress_default;

  // node_modules/@ant-design/icons/es/icons/CaretDownFilled.js
  var React316 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/CaretDownFilled.js
  var CaretDownFilled = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
  var CaretDownFilled_default = CaretDownFilled;

  // node_modules/@ant-design/icons/es/icons/CaretDownFilled.js
  var CaretDownFilled2 = function CaretDownFilled3(props, ref) {
    return /* @__PURE__ */ React316.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: CaretDownFilled_default
    }));
  };
  var RefIcon20 = /* @__PURE__ */ React316.forwardRef(CaretDownFilled2);
  if (true) {
    RefIcon20.displayName = "CaretDownFilled";
  }
  var CaretDownFilled_default2 = RefIcon20;

  // node_modules/@ant-design/icons/es/icons/CaretDownOutlined.js
  var React317 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/CaretDownOutlined.js
  var CaretDownOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
  var CaretDownOutlined_default = CaretDownOutlined;

  // node_modules/@ant-design/icons/es/icons/CaretDownOutlined.js
  var CaretDownOutlined2 = function CaretDownOutlined3(props, ref) {
    return /* @__PURE__ */ React317.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: CaretDownOutlined_default
    }));
  };
  var RefIcon21 = /* @__PURE__ */ React317.forwardRef(CaretDownOutlined2);
  if (true) {
    RefIcon21.displayName = "CaretDownOutlined";
  }
  var CaretDownOutlined_default2 = RefIcon21;

  // node_modules/@ant-design/icons/es/icons/CaretUpOutlined.js
  var React318 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/CaretUpOutlined.js
  var CaretUpOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
  var CaretUpOutlined_default = CaretUpOutlined;

  // node_modules/@ant-design/icons/es/icons/CaretUpOutlined.js
  var CaretUpOutlined2 = function CaretUpOutlined3(props, ref) {
    return /* @__PURE__ */ React318.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: CaretUpOutlined_default
    }));
  };
  var RefIcon22 = /* @__PURE__ */ React318.forwardRef(CaretUpOutlined2);
  if (true) {
    RefIcon22.displayName = "CaretUpOutlined";
  }
  var CaretUpOutlined_default2 = RefIcon22;

  // node_modules/@ant-design/icons/es/icons/DeleteOutlined.js
  var React319 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/DeleteOutlined.js
  var DeleteOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
  var DeleteOutlined_default = DeleteOutlined;

  // node_modules/@ant-design/icons/es/icons/DeleteOutlined.js
  var DeleteOutlined2 = function DeleteOutlined3(props, ref) {
    return /* @__PURE__ */ React319.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: DeleteOutlined_default
    }));
  };
  var RefIcon23 = /* @__PURE__ */ React319.forwardRef(DeleteOutlined2);
  if (true) {
    RefIcon23.displayName = "DeleteOutlined";
  }
  var DeleteOutlined_default2 = RefIcon23;

  // node_modules/@ant-design/icons/es/icons/DownloadOutlined.js
  var React320 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/DownloadOutlined.js
  var DownloadOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
  var DownloadOutlined_default = DownloadOutlined;

  // node_modules/@ant-design/icons/es/icons/DownloadOutlined.js
  var DownloadOutlined2 = function DownloadOutlined3(props, ref) {
    return /* @__PURE__ */ React320.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: DownloadOutlined_default
    }));
  };
  var RefIcon24 = /* @__PURE__ */ React320.forwardRef(DownloadOutlined2);
  if (true) {
    RefIcon24.displayName = "DownloadOutlined";
  }
  var DownloadOutlined_default2 = RefIcon24;

  // node_modules/@ant-design/icons/es/icons/FileOutlined.js
  var React321 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/FileOutlined.js
  var FileOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
  var FileOutlined_default = FileOutlined;

  // node_modules/@ant-design/icons/es/icons/FileOutlined.js
  var FileOutlined2 = function FileOutlined3(props, ref) {
    return /* @__PURE__ */ React321.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: FileOutlined_default
    }));
  };
  var RefIcon25 = /* @__PURE__ */ React321.forwardRef(FileOutlined2);
  if (true) {
    RefIcon25.displayName = "FileOutlined";
  }
  var FileOutlined_default2 = RefIcon25;

  // node_modules/@ant-design/icons/es/icons/FileTwoTone.js
  var React322 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/FileTwoTone.js
  var FileTwoTone = { "icon": function render2(primaryColor, secondaryColor) {
    return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", "fill": primaryColor } }] };
  }, "name": "file", "theme": "twotone" };
  var FileTwoTone_default = FileTwoTone;

  // node_modules/@ant-design/icons/es/icons/FileTwoTone.js
  var FileTwoTone2 = function FileTwoTone3(props, ref) {
    return /* @__PURE__ */ React322.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: FileTwoTone_default
    }));
  };
  var RefIcon26 = /* @__PURE__ */ React322.forwardRef(FileTwoTone2);
  if (true) {
    RefIcon26.displayName = "FileTwoTone";
  }
  var FileTwoTone_default2 = RefIcon26;

  // node_modules/@ant-design/icons/es/icons/FilterFilled.js
  var React323 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/FilterFilled.js
  var FilterFilled = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
  var FilterFilled_default = FilterFilled;

  // node_modules/@ant-design/icons/es/icons/FilterFilled.js
  var FilterFilled2 = function FilterFilled3(props, ref) {
    return /* @__PURE__ */ React323.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: FilterFilled_default
    }));
  };
  var RefIcon27 = /* @__PURE__ */ React323.forwardRef(FilterFilled2);
  if (true) {
    RefIcon27.displayName = "FilterFilled";
  }
  var FilterFilled_default2 = RefIcon27;

  // node_modules/@ant-design/icons/es/icons/FolderOpenOutlined.js
  var React324 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/FolderOpenOutlined.js
  var FolderOpenOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
  var FolderOpenOutlined_default = FolderOpenOutlined;

  // node_modules/@ant-design/icons/es/icons/FolderOpenOutlined.js
  var FolderOpenOutlined2 = function FolderOpenOutlined3(props, ref) {
    return /* @__PURE__ */ React324.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: FolderOpenOutlined_default
    }));
  };
  var RefIcon28 = /* @__PURE__ */ React324.forwardRef(FolderOpenOutlined2);
  if (true) {
    RefIcon28.displayName = "FolderOpenOutlined";
  }
  var FolderOpenOutlined_default2 = RefIcon28;

  // node_modules/@ant-design/icons/es/icons/FolderOutlined.js
  var React325 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/FolderOutlined.js
  var FolderOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
  var FolderOutlined_default = FolderOutlined;

  // node_modules/@ant-design/icons/es/icons/FolderOutlined.js
  var FolderOutlined2 = function FolderOutlined3(props, ref) {
    return /* @__PURE__ */ React325.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: FolderOutlined_default
    }));
  };
  var RefIcon29 = /* @__PURE__ */ React325.forwardRef(FolderOutlined2);
  if (true) {
    RefIcon29.displayName = "FolderOutlined";
  }
  var FolderOutlined_default2 = RefIcon29;

  // node_modules/@ant-design/icons/es/icons/HolderOutlined.js
  var React326 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/HolderOutlined.js
  var HolderOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, "name": "holder", "theme": "outlined" };
  var HolderOutlined_default = HolderOutlined;

  // node_modules/@ant-design/icons/es/icons/HolderOutlined.js
  var HolderOutlined2 = function HolderOutlined3(props, ref) {
    return /* @__PURE__ */ React326.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: HolderOutlined_default
    }));
  };
  var RefIcon30 = /* @__PURE__ */ React326.forwardRef(HolderOutlined2);
  if (true) {
    RefIcon30.displayName = "HolderOutlined";
  }
  var HolderOutlined_default2 = RefIcon30;

  // node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js
  var React327 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/MinusSquareOutlined.js
  var MinusSquareOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
  var MinusSquareOutlined_default = MinusSquareOutlined;

  // node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js
  var MinusSquareOutlined2 = function MinusSquareOutlined3(props, ref) {
    return /* @__PURE__ */ React327.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: MinusSquareOutlined_default
    }));
  };
  var RefIcon31 = /* @__PURE__ */ React327.forwardRef(MinusSquareOutlined2);
  if (true) {
    RefIcon31.displayName = "MinusSquareOutlined";
  }
  var MinusSquareOutlined_default2 = RefIcon31;

  // node_modules/@ant-design/icons/es/icons/PaperClipOutlined.js
  var React328 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/PaperClipOutlined.js
  var PaperClipOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
  var PaperClipOutlined_default = PaperClipOutlined;

  // node_modules/@ant-design/icons/es/icons/PaperClipOutlined.js
  var PaperClipOutlined2 = function PaperClipOutlined3(props, ref) {
    return /* @__PURE__ */ React328.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: PaperClipOutlined_default
    }));
  };
  var RefIcon32 = /* @__PURE__ */ React328.forwardRef(PaperClipOutlined2);
  if (true) {
    RefIcon32.displayName = "PaperClipOutlined";
  }
  var PaperClipOutlined_default2 = RefIcon32;

  // node_modules/@ant-design/icons/es/icons/PictureTwoTone.js
  var React329 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/PictureTwoTone.js
  var PictureTwoTone = { "icon": function render3(primaryColor, secondaryColor) {
    return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", "fill": primaryColor } }] };
  }, "name": "picture", "theme": "twotone" };
  var PictureTwoTone_default = PictureTwoTone;

  // node_modules/@ant-design/icons/es/icons/PictureTwoTone.js
  var PictureTwoTone2 = function PictureTwoTone3(props, ref) {
    return /* @__PURE__ */ React329.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: PictureTwoTone_default
    }));
  };
  var RefIcon33 = /* @__PURE__ */ React329.forwardRef(PictureTwoTone2);
  if (true) {
    RefIcon33.displayName = "PictureTwoTone";
  }
  var PictureTwoTone_default2 = RefIcon33;

  // node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js
  var React330 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/PlusSquareOutlined.js
  var PlusSquareOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
  var PlusSquareOutlined_default = PlusSquareOutlined;

  // node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js
  var PlusSquareOutlined2 = function PlusSquareOutlined3(props, ref) {
    return /* @__PURE__ */ React330.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: PlusSquareOutlined_default
    }));
  };
  var RefIcon34 = /* @__PURE__ */ React330.forwardRef(PlusSquareOutlined2);
  if (true) {
    RefIcon34.displayName = "PlusSquareOutlined";
  }
  var PlusSquareOutlined_default2 = RefIcon34;

  // node_modules/@ant-design/icons/es/icons/UploadOutlined.js
  var React331 = __toESM(require_react());

  // node_modules/@ant-design/icons-svg/es/asn/UploadOutlined.js
  var UploadOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M400 317.7h73.9V656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V317.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 163a8 8 0 00-12.6 0l-112 141.7c-4.1 5.3-.4 13 6.3 13zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "upload", "theme": "outlined" };
  var UploadOutlined_default = UploadOutlined;

  // node_modules/@ant-design/icons/es/icons/UploadOutlined.js
  var UploadOutlined2 = function UploadOutlined3(props, ref) {
    return /* @__PURE__ */ React331.createElement(AntdIcon_default, _extends({}, props, {
      ref,
      icon: UploadOutlined_default
    }));
  };
  var RefIcon35 = /* @__PURE__ */ React331.forwardRef(UploadOutlined2);
  if (true) {
    RefIcon35.displayName = "UploadOutlined";
  }
  var UploadOutlined_default2 = RefIcon35;

  // node_modules/antd/es/row/index.js
  var row_default2 = row_default;

  // node_modules/antd/es/statistic/Countdown.js
  var React335 = __toESM(require_react());

  // node_modules/antd/es/statistic/Timer.js
  var React334 = __toESM(require_react());

  // node_modules/antd/es/statistic/Statistic.js
  var React333 = __toESM(require_react());
  var import_classnames124 = __toESM(require_classnames());

  // node_modules/antd/es/statistic/Number.js
  var React332 = __toESM(require_react());
  var StatisticNumber = (props) => {
    const {
      value,
      formatter,
      precision,
      decimalSeparator,
      groupSeparator = "",
      prefixCls
    } = props;
    let valueNode;
    if (typeof formatter === "function") {
      valueNode = formatter(value);
    } else {
      const val = String(value);
      const cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
      if (!cells || val === "-") {
        valueNode = val;
      } else {
        const negative = cells[1];
        let int = cells[2] || "0";
        let decimal = cells[4] || "";
        int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
        if (typeof precision === "number") {
          decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
        }
        if (decimal) {
          decimal = `${decimalSeparator}${decimal}`;
        }
        valueNode = [/* @__PURE__ */ React332.createElement("span", {
          key: "int",
          className: `${prefixCls}-content-value-int`
        }, negative, int), decimal && /* @__PURE__ */ React332.createElement("span", {
          key: "decimal",
          className: `${prefixCls}-content-value-decimal`
        }, decimal)];
      }
    }
    return /* @__PURE__ */ React332.createElement("span", {
      className: `${prefixCls}-content-value`
    }, valueNode);
  };
  var Number_default = StatisticNumber;

  // node_modules/antd/es/statistic/style/index.js
  var genStatisticStyle = (token2) => {
    const {
      componentCls,
      marginXXS,
      padding,
      colorTextDescription,
      titleFontSize,
      colorTextHeading,
      contentFontSize,
      fontFamily
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        [`${componentCls}-title`]: {
          marginBottom: marginXXS,
          color: colorTextDescription,
          fontSize: titleFontSize
        },
        [`${componentCls}-skeleton`]: {
          paddingTop: padding
        },
        [`${componentCls}-content`]: {
          color: colorTextHeading,
          fontSize: contentFontSize,
          fontFamily,
          [`${componentCls}-content-value`]: {
            display: "inline-block",
            direction: "ltr"
          },
          [`${componentCls}-content-prefix, ${componentCls}-content-suffix`]: {
            display: "inline-block"
          },
          [`${componentCls}-content-prefix`]: {
            marginInlineEnd: marginXXS
          },
          [`${componentCls}-content-suffix`]: {
            marginInlineStart: marginXXS
          }
        }
      })
    };
  };
  var prepareComponentToken17 = (token2) => {
    const {
      fontSizeHeading3,
      fontSize
    } = token2;
    return {
      titleFontSize: fontSize,
      contentFontSize: fontSizeHeading3
    };
  };
  var style_default22 = genStyleHooks("Statistic", (token2) => {
    const statisticToken3 = merge2(token2, {});
    return [genStatisticStyle(statisticToken3)];
  }, prepareComponentToken17);

  // node_modules/antd/es/statistic/Statistic.js
  var __rest50 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Statistic = /* @__PURE__ */ React333.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      valueStyle,
      value = 0,
      title,
      valueRender,
      prefix,
      suffix,
      loading = false,
      /* --- FormatConfig starts --- */
      formatter,
      precision,
      decimalSeparator = ".",
      groupSeparator = ",",
      /* --- FormatConfig starts --- */
      onMouseEnter,
      onMouseLeave
    } = props, rest = __rest50(props, ["prefixCls", "className", "rootClassName", "style", "valueStyle", "value", "title", "valueRender", "prefix", "suffix", "loading", "formatter", "precision", "decimalSeparator", "groupSeparator", "onMouseEnter", "onMouseLeave"]);
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("statistic");
    const prefixCls = getPrefixCls("statistic", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default22(prefixCls);
    const valueNode = /* @__PURE__ */ React333.createElement(Number_default, {
      decimalSeparator,
      groupSeparator,
      prefixCls,
      formatter,
      precision,
      value
    });
    const cls3 = (0, import_classnames124.default)(prefixCls, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, contextClassName, className, rootClassName, hashId, cssVarCls);
    const internalRef = React333.useRef(null);
    React333.useImperativeHandle(ref, () => ({
      nativeElement: internalRef.current
    }));
    const restProps = pickAttrs(rest, {
      aria: true,
      data: true
    });
    return wrapCSSVar(/* @__PURE__ */ React333.createElement("div", Object.assign({}, restProps, {
      ref: internalRef,
      className: cls3,
      style: Object.assign(Object.assign({}, contextStyle), style2),
      onMouseEnter,
      onMouseLeave
    }), title && /* @__PURE__ */ React333.createElement("div", {
      className: `${prefixCls}-title`
    }, title), /* @__PURE__ */ React333.createElement(skeleton_default, {
      paragraph: false,
      loading,
      className: `${prefixCls}-skeleton`
    }, /* @__PURE__ */ React333.createElement("div", {
      style: valueStyle,
      className: `${prefixCls}-content`
    }, prefix && /* @__PURE__ */ React333.createElement("span", {
      className: `${prefixCls}-content-prefix`
    }, prefix), valueRender ? valueRender(valueNode) : valueNode, suffix && /* @__PURE__ */ React333.createElement("span", {
      className: `${prefixCls}-content-suffix`
    }, suffix)))));
  });
  if (true) {
    Statistic.displayName = "Statistic";
  }
  var Statistic_default = Statistic;

  // node_modules/antd/es/statistic/utils.js
  var timeUnits = [
    ["Y", 1e3 * 60 * 60 * 24 * 365],
    // years
    ["M", 1e3 * 60 * 60 * 24 * 30],
    // months
    ["D", 1e3 * 60 * 60 * 24],
    // days
    ["H", 1e3 * 60 * 60],
    // hours
    ["m", 1e3 * 60],
    // minutes
    ["s", 1e3],
    // seconds
    ["S", 1]
    // million seconds
  ];
  function formatTimeStr(duration, format2) {
    let leftDuration = duration;
    const escapeRegex = /\[[^\]]*]/g;
    const keepList = (format2.match(escapeRegex) || []).map((str) => str.slice(1, -1));
    const templateText = format2.replace(escapeRegex, "[]");
    const replacedText = timeUnits.reduce((current, [name, unit3]) => {
      if (current.includes(name)) {
        const value = Math.floor(leftDuration / unit3);
        leftDuration -= value * unit3;
        return current.replace(new RegExp(`${name}+`, "g"), (match2) => {
          const len = match2.length;
          return value.toString().padStart(len, "0");
        });
      }
      return current;
    }, templateText);
    let index3 = 0;
    return replacedText.replace(escapeRegex, () => {
      const match2 = keepList[index3];
      index3 += 1;
      return match2;
    });
  }
  function formatCounter(value, config, down) {
    const {
      format: format2 = ""
    } = config;
    const target = new Date(value).getTime();
    const current = Date.now();
    const diff = down ? Math.max(target - current, 0) : Math.max(current - target, 0);
    return formatTimeStr(diff, format2);
  }

  // node_modules/antd/es/statistic/Timer.js
  var __rest51 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function getTime(value) {
    return new Date(value).getTime();
  }
  var StatisticTimer = (props) => {
    const {
      value,
      format: format2 = "HH:mm:ss",
      onChange,
      onFinish,
      type: type5
    } = props, rest = __rest51(props, ["value", "format", "onChange", "onFinish", "type"]);
    const down = type5 === "countdown";
    const [showTime, setShowTime] = React334.useState(null);
    const update = useEvent(() => {
      const now2 = Date.now();
      const timestamp = getTime(value);
      setShowTime({});
      const timeDiff = !down ? now2 - timestamp : timestamp - now2;
      onChange === null || onChange === void 0 ? void 0 : onChange(timeDiff);
      if (down && timestamp < now2) {
        onFinish === null || onFinish === void 0 ? void 0 : onFinish();
        return false;
      }
      return true;
    });
    React334.useEffect(() => {
      let rafId;
      const clear = () => raf_default.cancel(rafId);
      const rafUpdate = () => {
        rafId = raf_default(() => {
          if (update()) {
            rafUpdate();
          }
        });
      };
      rafUpdate();
      return clear;
    }, [value, down]);
    React334.useEffect(() => {
      setShowTime({});
    }, []);
    const formatter = (formatValue, config) => showTime ? formatCounter(formatValue, Object.assign(Object.assign({}, config), {
      format: format2
    }), down) : "-";
    const valueRender = (node2) => cloneElement3(node2, {
      title: void 0
    });
    return /* @__PURE__ */ React334.createElement(Statistic_default, Object.assign({}, rest, {
      value,
      valueRender,
      formatter
    }));
  };
  var Timer_default = StatisticTimer;

  // node_modules/antd/es/statistic/Countdown.js
  var Countdown = (props) => {
    if (true) {
      const warning6 = devUseWarning("Countdown");
      warning6.deprecated(false, "<Statistic.Countdown />", '<Statistic.Timer type="countdown" />');
    }
    return /* @__PURE__ */ React335.createElement(Timer_default, Object.assign({}, props, {
      type: "countdown"
    }));
  };
  var Countdown_default = /* @__PURE__ */ React335.memo(Countdown);

  // node_modules/antd/es/statistic/index.js
  Statistic_default.Timer = Timer_default;
  Statistic_default.Countdown = Countdown_default;
  var statistic_default2 = Statistic_default;

  // node_modules/antd/es/table/Table.js
  var React393 = __toESM(require_react());

  // node_modules/rc-table/es/constant.js
  var EXPAND_COLUMN = {};
  var INTERNAL_HOOKS = "rc-table-internal-hook";

  // node_modules/@rc-component/context/es/context.js
  var React336 = __toESM(require_react());
  var import_react_dom8 = __toESM(require_react_dom());
  function createContext36(defaultValue) {
    var Context3 = /* @__PURE__ */ React336.createContext(void 0);
    var Provider = function Provider2(_ref) {
      var value = _ref.value, children = _ref.children;
      var valueRef = React336.useRef(value);
      valueRef.current = value;
      var _React$useState = React336.useState(function() {
        return {
          getValue: function getValue3() {
            return valueRef.current;
          },
          listeners: /* @__PURE__ */ new Set()
        };
      }), _React$useState2 = _slicedToArray(_React$useState, 1), context = _React$useState2[0];
      useLayoutEffect_default(function() {
        (0, import_react_dom8.unstable_batchedUpdates)(function() {
          context.listeners.forEach(function(listener) {
            listener(value);
          });
        });
      }, [value]);
      return /* @__PURE__ */ React336.createElement(Context3.Provider, {
        value: context
      }, children);
    };
    return {
      Context: Context3,
      Provider,
      defaultValue
    };
  }
  function useContext117(holder, selector) {
    var eventSelector = useEvent(typeof selector === "function" ? selector : function(ctx) {
      if (selector === void 0) {
        return ctx;
      }
      if (!Array.isArray(selector)) {
        return ctx[selector];
      }
      var obj = {};
      selector.forEach(function(key) {
        obj[key] = ctx[key];
      });
      return obj;
    });
    var context = React336.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
    var _ref2 = context || {}, listeners = _ref2.listeners, getValue3 = _ref2.getValue;
    var valueRef = React336.useRef();
    valueRef.current = eventSelector(context ? getValue3() : holder === null || holder === void 0 ? void 0 : holder.defaultValue);
    var _React$useState3 = React336.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), forceUpdate = _React$useState4[1];
    useLayoutEffect_default(function() {
      if (!context) {
        return;
      }
      function trigger(nextValue) {
        var nextSelectorValue = eventSelector(nextValue);
        if (!isEqual_default(valueRef.current, nextSelectorValue, true)) {
          forceUpdate({});
        }
      }
      listeners.add(trigger);
      return function() {
        listeners.delete(trigger);
      };
    }, [context]);
    return valueRef.current;
  }

  // node_modules/@rc-component/context/es/Immutable.js
  var React337 = __toESM(require_react());
  function createImmutable() {
    var ImmutableContext = /* @__PURE__ */ React337.createContext(null);
    function useImmutableMark3() {
      return React337.useContext(ImmutableContext);
    }
    function makeImmutable3(Component9, shouldTriggerRender) {
      var refAble = supportRef(Component9);
      var ImmutableComponent = function ImmutableComponent2(props, ref) {
        var refProps = refAble ? {
          ref
        } : {};
        var renderTimesRef = React337.useRef(0);
        var prevProps = React337.useRef(props);
        var mark = useImmutableMark3();
        if (mark !== null) {
          return /* @__PURE__ */ React337.createElement(Component9, _extends({}, props, refProps));
        }
        if (
          // Always trigger re-render if not provide `notTriggerRender`
          !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)
        ) {
          renderTimesRef.current += 1;
        }
        prevProps.current = props;
        return /* @__PURE__ */ React337.createElement(ImmutableContext.Provider, {
          value: renderTimesRef.current
        }, /* @__PURE__ */ React337.createElement(Component9, _extends({}, props, refProps)));
      };
      if (true) {
        ImmutableComponent.displayName = "ImmutableRoot(".concat(Component9.displayName || Component9.name, ")");
      }
      return refAble ? /* @__PURE__ */ React337.forwardRef(ImmutableComponent) : ImmutableComponent;
    }
    function responseImmutable3(Component9, propsAreEqual) {
      var refAble = supportRef(Component9);
      var ImmutableComponent = function ImmutableComponent2(props, ref) {
        var refProps = refAble ? {
          ref
        } : {};
        useImmutableMark3();
        return /* @__PURE__ */ React337.createElement(Component9, _extends({}, props, refProps));
      };
      if (true) {
        ImmutableComponent.displayName = "ImmutableResponse(".concat(Component9.displayName || Component9.name, ")");
      }
      return refAble ? /* @__PURE__ */ React337.memo(/* @__PURE__ */ React337.forwardRef(ImmutableComponent), propsAreEqual) : /* @__PURE__ */ React337.memo(ImmutableComponent, propsAreEqual);
    }
    return {
      makeImmutable: makeImmutable3,
      responseImmutable: responseImmutable3,
      useImmutableMark: useImmutableMark3
    };
  }

  // node_modules/@rc-component/context/es/index.js
  var _createImmutable = createImmutable();
  var makeImmutable = _createImmutable.makeImmutable;
  var responseImmutable = _createImmutable.responseImmutable;
  var useImmutableMark = _createImmutable.useImmutableMark;

  // node_modules/rc-table/es/Footer/index.js
  var React345 = __toESM(require_react());

  // node_modules/rc-table/es/context/TableContext.js
  var _createImmutable2 = createImmutable();
  var makeImmutable2 = _createImmutable2.makeImmutable;
  var responseImmutable2 = _createImmutable2.responseImmutable;
  var useImmutableMark2 = _createImmutable2.useImmutableMark;
  var TableContext = createContext36();
  var TableContext_default = TableContext;

  // node_modules/rc-table/es/hooks/useRenderTimes.js
  var React338 = __toESM(require_react());
  function useRenderTimes(props, debug) {
    var timesRef = React338.useRef(0);
    timesRef.current += 1;
    var propsRef = React338.useRef(props);
    var keys2 = [];
    Object.keys(props || {}).map(function(key) {
      var _propsRef$current;
      if ((props === null || props === void 0 ? void 0 : props[key]) !== ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current[key])) {
        keys2.push(key);
      }
    });
    propsRef.current = props;
    var keysRef = React338.useRef([]);
    if (keys2.length) {
      keysRef.current = keys2;
    }
    React338.useDebugValue(timesRef.current);
    React338.useDebugValue(keysRef.current.join(", "));
    if (debug) {
      console.log("".concat(debug, ":"), timesRef.current, keysRef.current);
    }
    return timesRef.current;
  }
  var useRenderTimes_default = true ? useRenderTimes : function() {
  };
  var RenderBlock = /* @__PURE__ */ React338.memo(function() {
    var times = useRenderTimes();
    return /* @__PURE__ */ React338.createElement("h1", null, "Render Times: ", times);
  });
  if (true) {
    RenderBlock.displayName = "RenderBlock";
  }

  // node_modules/rc-table/es/Footer/Cell.js
  var React343 = __toESM(require_react());

  // node_modules/rc-table/es/Cell/index.js
  var import_classnames125 = __toESM(require_classnames());
  var React341 = __toESM(require_react());

  // node_modules/rc-table/es/Cell/useCellRender.js
  var React340 = __toESM(require_react());

  // node_modules/rc-table/es/context/PerfContext.js
  var React339 = __toESM(require_react());
  var PerfContext = /* @__PURE__ */ React339.createContext({
    renderWithProps: false
  });
  var PerfContext_default = PerfContext;

  // node_modules/rc-table/es/utils/valueUtil.js
  var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
  function toArray7(arr) {
    if (arr === void 0 || arr === null) {
      return [];
    }
    return Array.isArray(arr) ? arr : [arr];
  }
  function getColumnsKey(columns) {
    var columnKeys = [];
    var keys2 = {};
    columns.forEach(function(column2) {
      var _ref = column2 || {}, key = _ref.key, dataIndex = _ref.dataIndex;
      var mergedKey = key || toArray7(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
      while (keys2[mergedKey]) {
        mergedKey = "".concat(mergedKey, "_next");
      }
      keys2[mergedKey] = true;
      columnKeys.push(mergedKey);
    });
    return columnKeys;
  }
  function validateValue(val) {
    return val !== null && val !== void 0;
  }
  function validNumberValue(value) {
    return typeof value === "number" && !Number.isNaN(value);
  }

  // node_modules/rc-table/es/Cell/useCellRender.js
  function isRenderCell(data) {
    return data && _typeof(data) === "object" && !Array.isArray(data) && !/* @__PURE__ */ React340.isValidElement(data);
  }
  function useCellRender(record, dataIndex, renderIndex, children, render4, shouldCellUpdate) {
    var perfRecord = React340.useContext(PerfContext_default);
    var mark = useImmutableMark2();
    var retData = useMemo(function() {
      if (validateValue(children)) {
        return [children];
      }
      var path2 = dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex];
      var value = get(record, path2);
      var returnChildNode = value;
      var returnCellProps = void 0;
      if (render4) {
        var renderData = render4(value, record, renderIndex);
        if (isRenderCell(renderData)) {
          if (true) {
            warning_default(false, "`columns.render` return cell props is deprecated with perf issue, please use `onCell` instead.");
          }
          returnChildNode = renderData.children;
          returnCellProps = renderData.props;
          perfRecord.renderWithProps = true;
        } else {
          returnChildNode = renderData;
        }
      }
      return [returnChildNode, returnCellProps];
    }, [
      // Force update deps
      mark,
      // Normal deps
      record,
      children,
      dataIndex,
      render4,
      renderIndex
    ], function(prev2, next2) {
      if (shouldCellUpdate) {
        var _prev = _slicedToArray(prev2, 2), prevRecord = _prev[1];
        var _next = _slicedToArray(next2, 2), nextRecord = _next[1];
        return shouldCellUpdate(nextRecord, prevRecord);
      }
      if (perfRecord.renderWithProps) {
        return true;
      }
      return !isEqual_default(prev2, next2, true);
    });
    return retData;
  }

  // node_modules/rc-table/es/Cell/useHoverState.js
  function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
    var cellEndRow = cellStartRow + cellRowSpan - 1;
    return cellStartRow <= endRow && cellEndRow >= startRow;
  }
  function useHoverState(rowIndex, rowSpan) {
    return useContext117(TableContext_default, function(ctx) {
      var hovering = inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow);
      return [hovering, ctx.onHover];
    });
  }

  // node_modules/rc-table/es/Cell/index.js
  var getTitleFromCellRenderChildren = function getTitleFromCellRenderChildren2(_ref) {
    var ellipsis = _ref.ellipsis, rowType = _ref.rowType, children = _ref.children;
    var title;
    var ellipsisConfig = ellipsis === true ? {
      showTitle: true
    } : ellipsis;
    if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
      if (typeof children === "string" || typeof children === "number") {
        title = children.toString();
      } else if (/* @__PURE__ */ React341.isValidElement(children) && typeof children.props.children === "string") {
        title = children.props.children;
      }
    }
    return title;
  };
  function Cell(props) {
    var _ref2, _ref3, _legacyCellProps$colS, _ref4, _ref5, _legacyCellProps$rowS, _additionalProps$titl, _classNames;
    if (true) {
      useRenderTimes_default(props);
    }
    var Component9 = props.component, children = props.children, ellipsis = props.ellipsis, scope = props.scope, prefixCls = props.prefixCls, className = props.className, align = props.align, record = props.record, render4 = props.render, dataIndex = props.dataIndex, renderIndex = props.renderIndex, shouldCellUpdate = props.shouldCellUpdate, index3 = props.index, rowType = props.rowType, colSpan = props.colSpan, rowSpan = props.rowSpan, fixLeft = props.fixLeft, fixRight = props.fixRight, firstFixLeft = props.firstFixLeft, lastFixLeft = props.lastFixLeft, firstFixRight = props.firstFixRight, lastFixRight = props.lastFixRight, appendNode = props.appendNode, _props$additionalProp = props.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, isSticky = props.isSticky;
    var cellPrefixCls = "".concat(prefixCls, "-cell");
    var _useContext = useContext117(TableContext_default, ["supportSticky", "allColumnsFixedLeft", "rowHoverable"]), supportSticky = _useContext.supportSticky, allColumnsFixedLeft = _useContext.allColumnsFixedLeft, rowHoverable = _useContext.rowHoverable;
    var _useCellRender = useCellRender(record, dataIndex, renderIndex, children, render4, shouldCellUpdate), _useCellRender2 = _slicedToArray(_useCellRender, 2), childNode = _useCellRender2[0], legacyCellProps = _useCellRender2[1];
    var fixedStyle = {};
    var isFixLeft = typeof fixLeft === "number" && supportSticky;
    var isFixRight = typeof fixRight === "number" && supportSticky;
    if (isFixLeft) {
      fixedStyle.position = "sticky";
      fixedStyle.left = fixLeft;
    }
    if (isFixRight) {
      fixedStyle.position = "sticky";
      fixedStyle.right = fixRight;
    }
    var mergedColSpan = (_ref2 = (_ref3 = (_legacyCellProps$colS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.colSpan) !== null && _legacyCellProps$colS !== void 0 ? _legacyCellProps$colS : additionalProps.colSpan) !== null && _ref3 !== void 0 ? _ref3 : colSpan) !== null && _ref2 !== void 0 ? _ref2 : 1;
    var mergedRowSpan = (_ref4 = (_ref5 = (_legacyCellProps$rowS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.rowSpan) !== null && _legacyCellProps$rowS !== void 0 ? _legacyCellProps$rowS : additionalProps.rowSpan) !== null && _ref5 !== void 0 ? _ref5 : rowSpan) !== null && _ref4 !== void 0 ? _ref4 : 1;
    var _useHoverState = useHoverState(index3, mergedRowSpan), _useHoverState2 = _slicedToArray(_useHoverState, 2), hovering = _useHoverState2[0], onHover = _useHoverState2[1];
    var onMouseEnter = useEvent(function(event) {
      var _additionalProps$onMo;
      if (record) {
        onHover(index3, index3 + mergedRowSpan - 1);
      }
      additionalProps === null || additionalProps === void 0 || (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 || _additionalProps$onMo.call(additionalProps, event);
    });
    var onMouseLeave = useEvent(function(event) {
      var _additionalProps$onMo2;
      if (record) {
        onHover(-1, -1);
      }
      additionalProps === null || additionalProps === void 0 || (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 || _additionalProps$onMo2.call(additionalProps, event);
    });
    if (mergedColSpan === 0 || mergedRowSpan === 0) {
      return null;
    }
    var title = (_additionalProps$titl = additionalProps.title) !== null && _additionalProps$titl !== void 0 ? _additionalProps$titl : getTitleFromCellRenderChildren({
      rowType,
      ellipsis,
      children: childNode
    });
    var mergedClassName = (0, import_classnames125.default)(cellPrefixCls, className, (_classNames = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), "".concat(cellPrefixCls, "-ellipsis"), ellipsis), "".concat(cellPrefixCls, "-with-append"), appendNode), "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering)), additionalProps.className, legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.className);
    var alignStyle = {};
    if (align) {
      alignStyle.textAlign = align;
    }
    var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.style), fixedStyle), alignStyle), additionalProps.style);
    var mergedChildNode = childNode;
    if (_typeof(mergedChildNode) === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ React341.isValidElement(mergedChildNode)) {
      mergedChildNode = null;
    }
    if (ellipsis && (lastFixLeft || firstFixRight)) {
      mergedChildNode = /* @__PURE__ */ React341.createElement("span", {
        className: "".concat(cellPrefixCls, "-content")
      }, mergedChildNode);
    }
    return /* @__PURE__ */ React341.createElement(Component9, _extends({}, legacyCellProps, additionalProps, {
      className: mergedClassName,
      style: mergedStyle,
      title,
      scope,
      onMouseEnter: rowHoverable ? onMouseEnter : void 0,
      onMouseLeave: rowHoverable ? onMouseLeave : void 0,
      colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
      rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
    }), appendNode, mergedChildNode);
  }
  var Cell_default = /* @__PURE__ */ React341.memo(Cell);

  // node_modules/rc-table/es/utils/fixUtil.js
  function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
    var startColumn = columns[colStart] || {};
    var endColumn = columns[colEnd] || {};
    var fixLeft;
    var fixRight;
    if (startColumn.fixed === "left") {
      fixLeft = stickyOffsets.left[direction === "rtl" ? colEnd : colStart];
    } else if (endColumn.fixed === "right") {
      fixRight = stickyOffsets.right[direction === "rtl" ? colStart : colEnd];
    }
    var lastFixLeft = false;
    var firstFixRight = false;
    var lastFixRight = false;
    var firstFixLeft = false;
    var nextColumn = columns[colEnd + 1];
    var prevColumn = columns[colStart - 1];
    var canLastFix = nextColumn && !nextColumn.fixed || prevColumn && !prevColumn.fixed || columns.every(function(col) {
      return col.fixed === "left";
    });
    if (direction === "rtl") {
      if (fixLeft !== void 0) {
        var prevFixLeft = prevColumn && prevColumn.fixed === "left";
        firstFixLeft = !prevFixLeft && canLastFix;
      } else if (fixRight !== void 0) {
        var nextFixRight = nextColumn && nextColumn.fixed === "right";
        lastFixRight = !nextFixRight && canLastFix;
      }
    } else if (fixLeft !== void 0) {
      var nextFixLeft = nextColumn && nextColumn.fixed === "left";
      lastFixLeft = !nextFixLeft && canLastFix;
    } else if (fixRight !== void 0) {
      var prevFixRight = prevColumn && prevColumn.fixed === "right";
      firstFixRight = !prevFixRight && canLastFix;
    }
    return {
      fixLeft,
      fixRight,
      lastFixLeft,
      firstFixRight,
      lastFixRight,
      firstFixLeft,
      isSticky: stickyOffsets.isSticky
    };
  }

  // node_modules/rc-table/es/Footer/SummaryContext.js
  var React342 = __toESM(require_react());
  var SummaryContext = /* @__PURE__ */ React342.createContext({});
  var SummaryContext_default = SummaryContext;

  // node_modules/rc-table/es/Footer/Cell.js
  function SummaryCell(_ref) {
    var className = _ref.className, index3 = _ref.index, children = _ref.children, _ref$colSpan = _ref.colSpan, colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan, rowSpan = _ref.rowSpan, align = _ref.align;
    var _useContext = useContext117(TableContext_default, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
    var _React$useContext = React343.useContext(SummaryContext_default), scrollColumnIndex = _React$useContext.scrollColumnIndex, stickyOffsets = _React$useContext.stickyOffsets, flattenColumns = _React$useContext.flattenColumns;
    var lastIndex = index3 + colSpan - 1;
    var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
    var fixedInfo = getCellFixedInfo(index3, index3 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
    return /* @__PURE__ */ React343.createElement(Cell_default, _extends({
      className,
      index: index3,
      component: "td",
      prefixCls,
      record: null,
      dataIndex: null,
      align,
      colSpan: mergedColSpan,
      rowSpan,
      render: function render4() {
        return children;
      }
    }, fixedInfo));
  }

  // node_modules/rc-table/es/Footer/Row.js
  var React344 = __toESM(require_react());
  var _excluded49 = ["children"];
  function FooterRow(_ref) {
    var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded49);
    return /* @__PURE__ */ React344.createElement("tr", props, children);
  }

  // node_modules/rc-table/es/Footer/Summary.js
  function Summary(_ref) {
    var children = _ref.children;
    return children;
  }
  Summary.Row = FooterRow;
  Summary.Cell = SummaryCell;
  var Summary_default = Summary;

  // node_modules/rc-table/es/Footer/index.js
  function Footer3(props) {
    if (true) {
      useRenderTimes_default(props);
    }
    var children = props.children, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns;
    var prefixCls = useContext117(TableContext_default, "prefixCls");
    var lastColumnIndex = flattenColumns.length - 1;
    var scrollColumn = flattenColumns[lastColumnIndex];
    var summaryContext = React345.useMemo(function() {
      return {
        stickyOffsets,
        flattenColumns,
        scrollColumnIndex: scrollColumn !== null && scrollColumn !== void 0 && scrollColumn.scrollbar ? lastColumnIndex : null
      };
    }, [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]);
    return /* @__PURE__ */ React345.createElement(SummaryContext_default.Provider, {
      value: summaryContext
    }, /* @__PURE__ */ React345.createElement("tfoot", {
      className: "".concat(prefixCls, "-summary")
    }, children));
  }
  var Footer_default = responseImmutable2(Footer3);
  var FooterComponents = Summary_default;

  // node_modules/rc-table/es/sugar/Column.js
  function Column(_) {
    return null;
  }
  var Column_default = Column;

  // node_modules/rc-table/es/sugar/ColumnGroup.js
  function ColumnGroup(_) {
    return null;
  }
  var ColumnGroup_default = ColumnGroup;

  // node_modules/rc-table/es/Table.js
  var import_classnames131 = __toESM(require_classnames());
  var React364 = __toESM(require_react());

  // node_modules/rc-table/es/Body/index.js
  var React352 = __toESM(require_react());

  // node_modules/rc-table/es/hooks/useFlattenRecords.js
  var React346 = __toESM(require_react());
  function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index3) {
    var key = getRowKey(record, index3);
    list.push({
      record,
      indent,
      index: index3,
      rowKey: key
    });
    var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key);
    if (record && Array.isArray(record[childrenColumnName]) && expanded) {
      for (var i = 0; i < record[childrenColumnName].length; i += 1) {
        fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
      }
    }
  }
  function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
    var arr = React346.useMemo(function() {
      if (expandedKeys !== null && expandedKeys !== void 0 && expandedKeys.size) {
        var list = [];
        for (var i = 0; i < (data === null || data === void 0 ? void 0 : data.length); i += 1) {
          var record = data[i];
          fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
        }
        return list;
      }
      return data === null || data === void 0 ? void 0 : data.map(function(item, index3) {
        return {
          record: item,
          indent: 0,
          index: index3,
          rowKey: getRowKey(item, index3)
        };
      });
    }, [data, childrenColumnName, expandedKeys, getRowKey]);
    return arr;
  }

  // node_modules/rc-table/es/Body/BodyRow.js
  var import_classnames128 = __toESM(require_classnames());
  var React349 = __toESM(require_react());

  // node_modules/rc-table/es/hooks/useRowInfo.js
  var import_classnames126 = __toESM(require_classnames());
  function useRowInfo(record, rowKey, recordIndex, indent) {
    var context = useContext117(TableContext_default, ["prefixCls", "fixedInfoList", "flattenColumns", "expandableType", "expandRowByClick", "onTriggerExpand", "rowClassName", "expandedRowClassName", "indentSize", "expandIcon", "expandedRowRender", "expandIconColumnIndex", "expandedKeys", "childrenColumnName", "rowExpandable", "onRow"]);
    var flattenColumns = context.flattenColumns, expandableType = context.expandableType, expandedKeys = context.expandedKeys, childrenColumnName = context.childrenColumnName, onTriggerExpand = context.onTriggerExpand, rowExpandable = context.rowExpandable, onRow = context.onRow, expandRowByClick = context.expandRowByClick, rowClassName = context.rowClassName;
    var nestExpandable = expandableType === "nest";
    var rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
    var mergedExpandable = rowSupportExpand || nestExpandable;
    var expanded = expandedKeys && expandedKeys.has(rowKey);
    var hasNestChildren = childrenColumnName && record && record[childrenColumnName];
    var onInternalTriggerExpand = useEvent(onTriggerExpand);
    var rowProps = onRow === null || onRow === void 0 ? void 0 : onRow(record, recordIndex);
    var onRowClick = rowProps === null || rowProps === void 0 ? void 0 : rowProps.onClick;
    var onClick = function onClick2(event) {
      if (expandRowByClick && mergedExpandable) {
        onTriggerExpand(record, event);
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      onRowClick === null || onRowClick === void 0 || onRowClick.apply(void 0, [event].concat(args));
    };
    var computeRowClassName;
    if (typeof rowClassName === "string") {
      computeRowClassName = rowClassName;
    } else if (typeof rowClassName === "function") {
      computeRowClassName = rowClassName(record, recordIndex, indent);
    }
    var columnsKey = getColumnsKey(flattenColumns);
    return _objectSpread2(_objectSpread2({}, context), {}, {
      columnsKey,
      nestExpandable,
      expanded,
      hasNestChildren,
      record,
      onTriggerExpand: onInternalTriggerExpand,
      rowSupportExpand,
      expandable: mergedExpandable,
      rowProps: _objectSpread2(_objectSpread2({}, rowProps), {}, {
        className: (0, import_classnames126.default)(computeRowClassName, rowProps === null || rowProps === void 0 ? void 0 : rowProps.className),
        onClick
      })
    });
  }

  // node_modules/rc-table/es/Body/ExpandedRow.js
  var React347 = __toESM(require_react());
  function ExpandedRow(props) {
    if (true) {
      useRenderTimes_default(props);
    }
    var prefixCls = props.prefixCls, children = props.children, Component9 = props.component, cellComponent = props.cellComponent, className = props.className, expanded = props.expanded, colSpan = props.colSpan, isEmpty = props.isEmpty, _props$stickyOffset = props.stickyOffset, stickyOffset = _props$stickyOffset === void 0 ? 0 : _props$stickyOffset;
    var _useContext = useContext117(TableContext_default, ["scrollbarSize", "fixHeader", "fixColumn", "componentWidth", "horizonScroll"]), scrollbarSize = _useContext.scrollbarSize, fixHeader = _useContext.fixHeader, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth, horizonScroll = _useContext.horizonScroll;
    var contentNode = children;
    if (isEmpty ? horizonScroll && componentWidth : fixColumn) {
      contentNode = /* @__PURE__ */ React347.createElement("div", {
        style: {
          width: componentWidth - stickyOffset - (fixHeader && !isEmpty ? scrollbarSize : 0),
          position: "sticky",
          left: stickyOffset,
          overflow: "hidden"
        },
        className: "".concat(prefixCls, "-expanded-row-fixed")
      }, contentNode);
    }
    return /* @__PURE__ */ React347.createElement(Component9, {
      className,
      style: {
        display: expanded ? null : "none"
      }
    }, /* @__PURE__ */ React347.createElement(Cell_default, {
      component: cellComponent,
      prefixCls,
      colSpan
    }, contentNode));
  }
  var ExpandedRow_default = ExpandedRow;

  // node_modules/rc-table/es/utils/expandUtil.js
  var React348 = __toESM(require_react());
  var import_classnames127 = __toESM(require_classnames());
  function renderExpandIcon(_ref) {
    var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
    var expandClassName = "".concat(prefixCls, "-row-expand-icon");
    if (!expandable) {
      return /* @__PURE__ */ React348.createElement("span", {
        className: (0, import_classnames127.default)(expandClassName, "".concat(prefixCls, "-row-spaced"))
      });
    }
    var onClick = function onClick2(event) {
      onExpand(record, event);
      event.stopPropagation();
    };
    return /* @__PURE__ */ React348.createElement("span", {
      className: (0, import_classnames127.default)(expandClassName, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-row-expanded"), expanded), "".concat(prefixCls, "-row-collapsed"), !expanded)),
      onClick
    });
  }
  function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
    var keys2 = [];
    function dig(list) {
      (list || []).forEach(function(item, index3) {
        keys2.push(getRowKey(item, index3));
        dig(item[childrenColumnName]);
      });
    }
    dig(data);
    return keys2;
  }
  function computedExpandedClassName(cls3, record, index3, indent) {
    if (typeof cls3 === "string") {
      return cls3;
    }
    if (typeof cls3 === "function") {
      return cls3(record, index3, indent);
    }
    return "";
  }

  // node_modules/rc-table/es/Body/BodyRow.js
  function getCellProps(rowInfo, column2, colIndex, indent, index3) {
    var _column$onCell;
    var rowKeys = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
    var expandedRowOffset = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
    var record = rowInfo.record, prefixCls = rowInfo.prefixCls, columnsKey = rowInfo.columnsKey, fixedInfoList = rowInfo.fixedInfoList, expandIconColumnIndex = rowInfo.expandIconColumnIndex, nestExpandable = rowInfo.nestExpandable, indentSize = rowInfo.indentSize, expandIcon = rowInfo.expandIcon, expanded = rowInfo.expanded, hasNestChildren = rowInfo.hasNestChildren, onTriggerExpand = rowInfo.onTriggerExpand, expandable = rowInfo.expandable, expandedKeys = rowInfo.expandedKeys;
    var key = columnsKey[colIndex];
    var fixedInfo = fixedInfoList[colIndex];
    var appendCellNode;
    if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
      appendCellNode = /* @__PURE__ */ React349.createElement(React349.Fragment, null, /* @__PURE__ */ React349.createElement("span", {
        style: {
          paddingLeft: "".concat(indentSize * indent, "px")
        },
        className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
      }), expandIcon({
        prefixCls,
        expanded,
        expandable: hasNestChildren,
        record,
        onExpand: onTriggerExpand
      }));
    }
    var additionalCellProps = ((_column$onCell = column2.onCell) === null || _column$onCell === void 0 ? void 0 : _column$onCell.call(column2, record, index3)) || {};
    if (expandedRowOffset) {
      var _additionalCellProps$ = additionalCellProps.rowSpan, rowSpan = _additionalCellProps$ === void 0 ? 1 : _additionalCellProps$;
      if (expandable && rowSpan && colIndex < expandedRowOffset) {
        var currentRowSpan = rowSpan;
        for (var i = index3; i < index3 + rowSpan; i += 1) {
          var rowKey = rowKeys[i];
          if (expandedKeys.has(rowKey)) {
            currentRowSpan += 1;
          }
        }
        additionalCellProps.rowSpan = currentRowSpan;
      }
    }
    return {
      key,
      fixedInfo,
      appendCellNode,
      additionalCellProps
    };
  }
  function BodyRow(props) {
    if (true) {
      useRenderTimes_default(props);
    }
    var className = props.className, style2 = props.style, record = props.record, index3 = props.index, renderIndex = props.renderIndex, rowKey = props.rowKey, rowKeys = props.rowKeys, _props$indent = props.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props.rowComponent, cellComponent = props.cellComponent, scopeCellComponent = props.scopeCellComponent, expandedRowInfo = props.expandedRowInfo;
    var rowInfo = useRowInfo(record, rowKey, index3, indent);
    var prefixCls = rowInfo.prefixCls, flattenColumns = rowInfo.flattenColumns, expandedRowClassName = rowInfo.expandedRowClassName, expandedRowRender = rowInfo.expandedRowRender, rowProps = rowInfo.rowProps, expanded = rowInfo.expanded, rowSupportExpand = rowInfo.rowSupportExpand;
    var expandedRef = React349.useRef(false);
    expandedRef.current || (expandedRef.current = expanded);
    if (true) {
      useRenderTimes_default(props);
    }
    var expandedClsName = computedExpandedClassName(expandedRowClassName, record, index3, indent);
    var baseRowNode = /* @__PURE__ */ React349.createElement(RowComponent, _extends({}, rowProps, {
      "data-row-key": rowKey,
      className: (0, import_classnames128.default)(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), rowProps === null || rowProps === void 0 ? void 0 : rowProps.className, _defineProperty({}, expandedClsName, indent >= 1)),
      style: _objectSpread2(_objectSpread2({}, style2), rowProps === null || rowProps === void 0 ? void 0 : rowProps.style)
    }), flattenColumns.map(function(column2, colIndex) {
      var render4 = column2.render, dataIndex = column2.dataIndex, columnClassName = column2.className;
      var _getCellProps = getCellProps(rowInfo, column2, colIndex, indent, index3, rowKeys, expandedRowInfo === null || expandedRowInfo === void 0 ? void 0 : expandedRowInfo.offset), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps;
      return /* @__PURE__ */ React349.createElement(Cell_default, _extends({
        className: columnClassName,
        ellipsis: column2.ellipsis,
        align: column2.align,
        scope: column2.rowScope,
        component: column2.rowScope ? scopeCellComponent : cellComponent,
        prefixCls,
        key,
        record,
        index: index3,
        renderIndex,
        dataIndex,
        render: render4,
        shouldCellUpdate: column2.shouldCellUpdate
      }, fixedInfo, {
        appendNode: appendCellNode,
        additionalProps: additionalCellProps
      }));
    }));
    var expandRowNode;
    if (rowSupportExpand && (expandedRef.current || expanded)) {
      var expandContent = expandedRowRender(record, index3, indent + 1, expanded);
      expandRowNode = /* @__PURE__ */ React349.createElement(ExpandedRow_default, {
        expanded,
        className: (0, import_classnames128.default)("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), expandedClsName),
        prefixCls,
        component: RowComponent,
        cellComponent,
        colSpan: expandedRowInfo ? expandedRowInfo.colSpan : flattenColumns.length,
        stickyOffset: expandedRowInfo === null || expandedRowInfo === void 0 ? void 0 : expandedRowInfo.sticky,
        isEmpty: false
      }, expandContent);
    }
    return /* @__PURE__ */ React349.createElement(React349.Fragment, null, baseRowNode, expandRowNode);
  }
  if (true) {
    BodyRow.displayName = "BodyRow";
  }
  var BodyRow_default = responseImmutable2(BodyRow);

  // node_modules/rc-table/es/Body/MeasureRow.js
  var React351 = __toESM(require_react());

  // node_modules/rc-table/es/Body/MeasureCell.js
  var React350 = __toESM(require_react());
  function MeasureCell(_ref) {
    var columnKey = _ref.columnKey, onColumnResize = _ref.onColumnResize;
    var cellRef = React350.useRef();
    useLayoutEffect_default(function() {
      if (cellRef.current) {
        onColumnResize(columnKey, cellRef.current.offsetWidth);
      }
    }, []);
    return /* @__PURE__ */ React350.createElement(es_default, {
      data: columnKey
    }, /* @__PURE__ */ React350.createElement("td", {
      ref: cellRef,
      style: {
        padding: 0,
        border: 0,
        height: 0
      }
    }, /* @__PURE__ */ React350.createElement("div", {
      style: {
        height: 0,
        overflow: "hidden"
      }
    }, "\xA0")));
  }

  // node_modules/rc-table/es/Body/MeasureRow.js
  function MeasureRow(_ref) {
    var prefixCls = _ref.prefixCls, columnsKey = _ref.columnsKey, onColumnResize = _ref.onColumnResize;
    var ref = React351.useRef(null);
    return /* @__PURE__ */ React351.createElement("tr", {
      "aria-hidden": "true",
      className: "".concat(prefixCls, "-measure-row"),
      style: {
        height: 0,
        fontSize: 0
      },
      ref
    }, /* @__PURE__ */ React351.createElement(es_default.Collection, {
      onBatchResize: function onBatchResize(infoList) {
        if (isVisible_default(ref.current)) {
          infoList.forEach(function(_ref2) {
            var columnKey = _ref2.data, size = _ref2.size;
            onColumnResize(columnKey, size.offsetWidth);
          });
        }
      }
    }, columnsKey.map(function(columnKey) {
      return /* @__PURE__ */ React351.createElement(MeasureCell, {
        key: columnKey,
        columnKey,
        onColumnResize
      });
    })));
  }

  // node_modules/rc-table/es/Body/index.js
  function Body(props) {
    if (true) {
      useRenderTimes_default(props);
    }
    var data = props.data, measureColumnWidth = props.measureColumnWidth;
    var _useContext = useContext117(TableContext_default, ["prefixCls", "getComponent", "onColumnResize", "flattenColumns", "getRowKey", "expandedKeys", "childrenColumnName", "emptyNode", "expandedRowOffset", "fixedInfoList", "colWidths"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent, onColumnResize = _useContext.onColumnResize, flattenColumns = _useContext.flattenColumns, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, childrenColumnName = _useContext.childrenColumnName, emptyNode = _useContext.emptyNode, _useContext$expandedR = _useContext.expandedRowOffset, expandedRowOffset = _useContext$expandedR === void 0 ? 0 : _useContext$expandedR, colWidths = _useContext.colWidths;
    var flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
    var rowKeys = React352.useMemo(function() {
      return flattenData2.map(function(item) {
        return item.rowKey;
      });
    }, [flattenData2]);
    var perfRef = React352.useRef({
      renderWithProps: false
    });
    var expandedRowInfo = React352.useMemo(function() {
      var expandedColSpan = flattenColumns.length - expandedRowOffset;
      var expandedStickyStart = 0;
      for (var i = 0; i < expandedRowOffset; i += 1) {
        expandedStickyStart += colWidths[i] || 0;
      }
      return {
        offset: expandedRowOffset,
        colSpan: expandedColSpan,
        sticky: expandedStickyStart
      };
    }, [flattenColumns.length, expandedRowOffset, colWidths]);
    var WrapperComponent = getComponent(["body", "wrapper"], "tbody");
    var trComponent = getComponent(["body", "row"], "tr");
    var tdComponent = getComponent(["body", "cell"], "td");
    var thComponent = getComponent(["body", "cell"], "th");
    var rows;
    if (data.length) {
      rows = flattenData2.map(function(item, idx) {
        var record = item.record, indent = item.indent, renderIndex = item.index, rowKey = item.rowKey;
        return /* @__PURE__ */ React352.createElement(BodyRow_default, {
          key: rowKey,
          rowKey,
          rowKeys,
          record,
          index: idx,
          renderIndex,
          rowComponent: trComponent,
          cellComponent: tdComponent,
          scopeCellComponent: thComponent,
          indent,
          expandedRowInfo
        });
      });
    } else {
      rows = /* @__PURE__ */ React352.createElement(ExpandedRow_default, {
        expanded: true,
        className: "".concat(prefixCls, "-placeholder"),
        prefixCls,
        component: trComponent,
        cellComponent: tdComponent,
        colSpan: flattenColumns.length,
        isEmpty: true
      }, emptyNode);
    }
    var columnsKey = getColumnsKey(flattenColumns);
    return /* @__PURE__ */ React352.createElement(PerfContext_default.Provider, {
      value: perfRef.current
    }, /* @__PURE__ */ React352.createElement(WrapperComponent, {
      className: "".concat(prefixCls, "-tbody")
    }, measureColumnWidth && /* @__PURE__ */ React352.createElement(MeasureRow, {
      prefixCls,
      columnsKey,
      onColumnResize
    }), rows));
  }
  if (true) {
    Body.displayName = "Body";
  }
  var Body_default = responseImmutable2(Body);

  // node_modules/rc-table/es/ColGroup.js
  var React353 = __toESM(require_react());

  // node_modules/rc-table/es/utils/legacyUtil.js
  var _excluded50 = ["expandable"];
  var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
  function getExpandableProps(props) {
    var expandable = props.expandable, legacyExpandableConfig = _objectWithoutProperties(props, _excluded50);
    var config;
    if ("expandable" in props) {
      config = _objectSpread2(_objectSpread2({}, legacyExpandableConfig), expandable);
    } else {
      if (["indentSize", "expandedRowKeys", "defaultExpandedRowKeys", "defaultExpandAllRows", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "expandedRowClassName", "expandIconColumnIndex", "showExpandColumn", "title"].some(function(prop) {
        return prop in props;
      })) {
        warning_default(false, "expanded related props have been moved into `expandable`.");
      }
      config = legacyExpandableConfig;
    }
    if (config.showExpandColumn === false) {
      config.expandIconColumnIndex = -1;
    }
    return config;
  }

  // node_modules/rc-table/es/ColGroup.js
  var _excluded51 = ["columnType"];
  function ColGroup(_ref) {
    var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount;
    var _useContext = useContext117(TableContext_default, ["tableLayout"]), tableLayout = _useContext.tableLayout;
    var cols = [];
    var len = columCount || columns.length;
    var mustInsert = false;
    for (var i = len - 1; i >= 0; i -= 1) {
      var width = colWidths[i];
      var column2 = columns && columns[i];
      var additionalProps = void 0;
      var minWidth = void 0;
      if (column2) {
        additionalProps = column2[INTERNAL_COL_DEFINE];
        if (tableLayout === "auto") {
          minWidth = column2.minWidth;
        }
      }
      if (width || minWidth || additionalProps || mustInsert) {
        var _ref2 = additionalProps || {}, columnType = _ref2.columnType, restAdditionalProps = _objectWithoutProperties(_ref2, _excluded51);
        cols.unshift(/* @__PURE__ */ React353.createElement("col", _extends({
          key: i,
          style: {
            width,
            minWidth
          }
        }, restAdditionalProps)));
        mustInsert = true;
      }
    }
    return /* @__PURE__ */ React353.createElement("colgroup", null, cols);
  }
  var ColGroup_default = ColGroup;

  // node_modules/rc-table/es/FixedHolder/index.js
  var import_classnames129 = __toESM(require_classnames());
  var React354 = __toESM(require_react());
  var import_react110 = __toESM(require_react());
  var _excluded52 = ["className", "noData", "columns", "flattenColumns", "colWidths", "columCount", "stickyOffsets", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName", "onScroll", "maxContentScroll", "children"];
  function useColumnWidth(colWidths, columCount) {
    return (0, import_react110.useMemo)(function() {
      var cloneColumns = [];
      for (var i = 0; i < columCount; i += 1) {
        var val = colWidths[i];
        if (val !== void 0) {
          cloneColumns[i] = val;
        } else {
          return null;
        }
      }
      return cloneColumns;
    }, [colWidths.join("_"), columCount]);
  }
  var FixedHolder = /* @__PURE__ */ React354.forwardRef(function(props, ref) {
    if (true) {
      useRenderTimes_default(props);
    }
    var className = props.className, noData = props.noData, columns = props.columns, flattenColumns = props.flattenColumns, colWidths = props.colWidths, columCount = props.columCount, stickyOffsets = props.stickyOffsets, direction = props.direction, fixHeader = props.fixHeader, stickyTopOffset = props.stickyTopOffset, stickyBottomOffset = props.stickyBottomOffset, stickyClassName = props.stickyClassName, onScroll = props.onScroll, maxContentScroll = props.maxContentScroll, children = props.children, restProps = _objectWithoutProperties(props, _excluded52);
    var _useContext = useContext117(TableContext_default, ["prefixCls", "scrollbarSize", "isSticky", "getComponent"]), prefixCls = _useContext.prefixCls, scrollbarSize = _useContext.scrollbarSize, isSticky = _useContext.isSticky, getComponent = _useContext.getComponent;
    var TableComponent = getComponent(["header", "table"], "table");
    var combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
    var scrollRef = React354.useRef(null);
    var setScrollRef = React354.useCallback(function(element) {
      fillRef(ref, element);
      fillRef(scrollRef, element);
    }, []);
    React354.useEffect(function() {
      function onWheel(e3) {
        var _ref = e3, currentTarget = _ref.currentTarget, deltaX = _ref.deltaX;
        if (deltaX) {
          onScroll({
            currentTarget,
            scrollLeft: currentTarget.scrollLeft + deltaX
          });
          e3.preventDefault();
        }
      }
      var scrollEle = scrollRef.current;
      scrollEle === null || scrollEle === void 0 || scrollEle.addEventListener("wheel", onWheel, {
        passive: false
      });
      return function() {
        scrollEle === null || scrollEle === void 0 || scrollEle.removeEventListener("wheel", onWheel);
      };
    }, []);
    var allFlattenColumnsWithWidth = React354.useMemo(function() {
      return flattenColumns.every(function(column2) {
        return column2.width;
      });
    }, [flattenColumns]);
    var lastColumn = flattenColumns[flattenColumns.length - 1];
    var ScrollBarColumn = {
      fixed: lastColumn ? lastColumn.fixed : null,
      scrollbar: true,
      onHeaderCell: function onHeaderCell() {
        return {
          className: "".concat(prefixCls, "-cell-scrollbar")
        };
      }
    };
    var columnsWithScrollbar = (0, import_react110.useMemo)(function() {
      return combinationScrollBarSize ? [].concat(_toConsumableArray(columns), [ScrollBarColumn]) : columns;
    }, [combinationScrollBarSize, columns]);
    var flattenColumnsWithScrollbar = (0, import_react110.useMemo)(function() {
      return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
    }, [combinationScrollBarSize, flattenColumns]);
    var headerStickyOffsets = (0, import_react110.useMemo)(function() {
      var right = stickyOffsets.right, left = stickyOffsets.left;
      return _objectSpread2(_objectSpread2({}, stickyOffsets), {}, {
        left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
          return width + combinationScrollBarSize;
        })), [0]) : left,
        right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
          return width + combinationScrollBarSize;
        })), [0]),
        isSticky
      });
    }, [combinationScrollBarSize, stickyOffsets, isSticky]);
    var mergedColumnWidth = useColumnWidth(colWidths, columCount);
    return /* @__PURE__ */ React354.createElement("div", {
      style: _objectSpread2({
        overflow: "hidden"
      }, isSticky ? {
        top: stickyTopOffset,
        bottom: stickyBottomOffset
      } : {}),
      ref: setScrollRef,
      className: (0, import_classnames129.default)(className, _defineProperty({}, stickyClassName, !!stickyClassName))
    }, /* @__PURE__ */ React354.createElement(TableComponent, {
      style: {
        tableLayout: "fixed",
        visibility: noData || mergedColumnWidth ? null : "hidden"
      }
    }, (!noData || !maxContentScroll || allFlattenColumnsWithWidth) && /* @__PURE__ */ React354.createElement(ColGroup_default, {
      colWidths: mergedColumnWidth ? [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]) : [],
      columCount: columCount + 1,
      columns: flattenColumnsWithScrollbar
    }), children(_objectSpread2(_objectSpread2({}, restProps), {}, {
      stickyOffsets: headerStickyOffsets,
      columns: columnsWithScrollbar,
      flattenColumns: flattenColumnsWithScrollbar
    }))));
  });
  if (true) {
    FixedHolder.displayName = "FixedHolder";
  }
  var FixedHolder_default = /* @__PURE__ */ React354.memo(FixedHolder);

  // node_modules/rc-table/es/Header/Header.js
  var React356 = __toESM(require_react());

  // node_modules/rc-table/es/Header/HeaderRow.js
  var React355 = __toESM(require_react());
  var HeaderRow = function HeaderRow2(props) {
    var cells = props.cells, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns, RowComponent = props.rowComponent, CellComponent = props.cellComponent, onHeaderRow = props.onHeaderRow, index3 = props.index;
    var _useContext = useContext117(TableContext_default, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
    var rowProps;
    if (onHeaderRow) {
      rowProps = onHeaderRow(cells.map(function(cell) {
        return cell.column;
      }), index3);
    }
    var columnsKey = getColumnsKey(cells.map(function(cell) {
      return cell.column;
    }));
    return /* @__PURE__ */ React355.createElement(RowComponent, rowProps, cells.map(function(cell, cellIndex) {
      var column2 = cell.column;
      var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
      var additionalProps;
      if (column2 && column2.onHeaderCell) {
        additionalProps = cell.column.onHeaderCell(column2);
      }
      return /* @__PURE__ */ React355.createElement(Cell_default, _extends({}, cell, {
        scope: column2.title ? cell.colSpan > 1 ? "colgroup" : "col" : null,
        ellipsis: column2.ellipsis,
        align: column2.align,
        component: CellComponent,
        prefixCls,
        key: columnsKey[cellIndex]
      }, fixedInfo, {
        additionalProps,
        rowType: "header"
      }));
    }));
  };
  if (true) {
    HeaderRow.displayName = "HeaderRow";
  }
  var HeaderRow_default = HeaderRow;

  // node_modules/rc-table/es/Header/Header.js
  function parseHeaderRows(rootColumns) {
    var rows = [];
    function fillRowCells(columns, colIndex) {
      var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      rows[rowIndex2] = rows[rowIndex2] || [];
      var currentColIndex = colIndex;
      var colSpans = columns.filter(Boolean).map(function(column2) {
        var cell = {
          key: column2.key,
          className: column2.className || "",
          children: column2.title,
          column: column2,
          colStart: currentColIndex
        };
        var colSpan = 1;
        var subColumns = column2.children;
        if (subColumns && subColumns.length > 0) {
          colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total, count) {
            return total + count;
          }, 0);
          cell.hasSubColumns = true;
        }
        if ("colSpan" in column2) {
          colSpan = column2.colSpan;
        }
        if ("rowSpan" in column2) {
          cell.rowSpan = column2.rowSpan;
        }
        cell.colSpan = colSpan;
        cell.colEnd = cell.colStart + colSpan - 1;
        rows[rowIndex2].push(cell);
        currentColIndex += colSpan;
        return colSpan;
      });
      return colSpans;
    }
    fillRowCells(rootColumns, 0);
    var rowCount = rows.length;
    var _loop = function _loop2(rowIndex2) {
      rows[rowIndex2].forEach(function(cell) {
        if (!("rowSpan" in cell) && !cell.hasSubColumns) {
          cell.rowSpan = rowCount - rowIndex2;
        }
      });
    };
    for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      _loop(rowIndex);
    }
    return rows;
  }
  var Header2 = function Header3(props) {
    if (true) {
      useRenderTimes_default(props);
    }
    var stickyOffsets = props.stickyOffsets, columns = props.columns, flattenColumns = props.flattenColumns, onHeaderRow = props.onHeaderRow;
    var _useContext = useContext117(TableContext_default, ["prefixCls", "getComponent"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent;
    var rows = React356.useMemo(function() {
      return parseHeaderRows(columns);
    }, [columns]);
    var WrapperComponent = getComponent(["header", "wrapper"], "thead");
    var trComponent = getComponent(["header", "row"], "tr");
    var thComponent = getComponent(["header", "cell"], "th");
    return /* @__PURE__ */ React356.createElement(WrapperComponent, {
      className: "".concat(prefixCls, "-thead")
    }, rows.map(function(row, rowIndex) {
      var rowNode = /* @__PURE__ */ React356.createElement(HeaderRow_default, {
        key: rowIndex,
        flattenColumns,
        cells: row,
        stickyOffsets,
        rowComponent: trComponent,
        cellComponent: thComponent,
        onHeaderRow,
        index: rowIndex
      });
      return rowNode;
    }));
  };
  var Header_default = responseImmutable2(Header2);

  // node_modules/rc-table/es/hooks/useColumns/index.js
  var React358 = __toESM(require_react());

  // node_modules/rc-table/es/hooks/useColumns/useWidthColumns.js
  var React357 = __toESM(require_react());
  function parseColWidth(totalWidth) {
    var width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (typeof width === "number") {
      return width;
    }
    if (width.endsWith("%")) {
      return totalWidth * parseFloat(width) / 100;
    }
    return null;
  }
  function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
    return React357.useMemo(function() {
      if (scrollWidth && scrollWidth > 0) {
        var totalWidth = 0;
        var missWidthCount = 0;
        flattenColumns.forEach(function(col) {
          var colWidth = parseColWidth(scrollWidth, col.width);
          if (colWidth) {
            totalWidth += colWidth;
          } else {
            missWidthCount += 1;
          }
        });
        var maxFitWidth = Math.max(scrollWidth, clientWidth);
        var restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);
        var restCount = missWidthCount;
        var avgWidth = restWidth / missWidthCount;
        var realTotal = 0;
        var filledColumns = flattenColumns.map(function(col) {
          var clone = _objectSpread2({}, col);
          var colWidth = parseColWidth(scrollWidth, clone.width);
          if (colWidth) {
            clone.width = colWidth;
          } else {
            var colAvgWidth = Math.floor(avgWidth);
            clone.width = restCount === 1 ? restWidth : colAvgWidth;
            restWidth -= colAvgWidth;
            restCount -= 1;
          }
          realTotal += clone.width;
          return clone;
        });
        if (realTotal < maxFitWidth) {
          var scale = maxFitWidth / realTotal;
          restWidth = maxFitWidth;
          filledColumns.forEach(function(col, index3) {
            var colWidth = Math.floor(col.width * scale);
            col.width = index3 === filledColumns.length - 1 ? restWidth : colWidth;
            restWidth -= colWidth;
          });
        }
        return [filledColumns, Math.max(realTotal, maxFitWidth)];
      }
      return [flattenColumns, scrollWidth];
    }, [flattenColumns, scrollWidth, clientWidth]);
  }

  // node_modules/rc-table/es/hooks/useColumns/index.js
  var _excluded53 = ["children"];
  var _excluded213 = ["fixed"];
  function convertChildrenToColumns(children) {
    return toArray(children).filter(function(node2) {
      return /* @__PURE__ */ React358.isValidElement(node2);
    }).map(function(_ref) {
      var key = _ref.key, props = _ref.props;
      var nodeChildren = props.children, restProps = _objectWithoutProperties(props, _excluded53);
      var column2 = _objectSpread2({
        key
      }, restProps);
      if (nodeChildren) {
        column2.children = convertChildrenToColumns(nodeChildren);
      }
      return column2;
    });
  }
  function filterHiddenColumns(columns) {
    return columns.filter(function(column2) {
      return column2 && _typeof(column2) === "object" && !column2.hidden;
    }).map(function(column2) {
      var subColumns = column2.children;
      if (subColumns && subColumns.length > 0) {
        return _objectSpread2(_objectSpread2({}, column2), {}, {
          children: filterHiddenColumns(subColumns)
        });
      }
      return column2;
    });
  }
  function flatColumns(columns) {
    var parentKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key";
    return columns.filter(function(column2) {
      return column2 && _typeof(column2) === "object";
    }).reduce(function(list, column2, index3) {
      var fixed = column2.fixed;
      var parsedFixed = fixed === true ? "left" : fixed;
      var mergedKey = "".concat(parentKey, "-").concat(index3);
      var subColumns = column2.children;
      if (subColumns && subColumns.length > 0) {
        return [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns, mergedKey).map(function(subColum) {
          return _objectSpread2({
            fixed: parsedFixed
          }, subColum);
        })));
      }
      return [].concat(_toConsumableArray(list), [_objectSpread2(_objectSpread2({
        key: mergedKey
      }, column2), {}, {
        fixed: parsedFixed
      })]);
    }, []);
  }
  function revertForRtl(columns) {
    return columns.map(function(column2) {
      var fixed = column2.fixed, restProps = _objectWithoutProperties(column2, _excluded213);
      var parsedFixed = fixed;
      if (fixed === "left") {
        parsedFixed = "right";
      } else if (fixed === "right") {
        parsedFixed = "left";
      }
      return _objectSpread2({
        fixed: parsedFixed
      }, restProps);
    });
  }
  function useColumns(_ref2, transformColumns) {
    var prefixCls = _ref2.prefixCls, columns = _ref2.columns, children = _ref2.children, expandable = _ref2.expandable, expandedKeys = _ref2.expandedKeys, columnTitle = _ref2.columnTitle, getRowKey = _ref2.getRowKey, onTriggerExpand = _ref2.onTriggerExpand, expandIcon = _ref2.expandIcon, rowExpandable = _ref2.rowExpandable, expandIconColumnIndex = _ref2.expandIconColumnIndex, _ref2$expandedRowOffs = _ref2.expandedRowOffset, expandedRowOffset = _ref2$expandedRowOffs === void 0 ? 0 : _ref2$expandedRowOffs, direction = _ref2.direction, expandRowByClick = _ref2.expandRowByClick, columnWidth = _ref2.columnWidth, fixed = _ref2.fixed, scrollWidth = _ref2.scrollWidth, clientWidth = _ref2.clientWidth;
    var baseColumns = React358.useMemo(function() {
      var newColumns = columns || convertChildrenToColumns(children) || [];
      return filterHiddenColumns(newColumns.slice());
    }, [columns, children]);
    var withExpandColumns = React358.useMemo(function() {
      if (expandable) {
        var cloneColumns = baseColumns.slice();
        if (expandIconColumnIndex >= 0) {
          warning_default(false, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead.");
        }
        if (!cloneColumns.includes(EXPAND_COLUMN)) {
          var expandColIndex = expandIconColumnIndex || 0;
          if (expandColIndex >= 0 && (expandColIndex || fixed === "left" || !fixed)) {
            cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
          }
          if (fixed === "right") {
            cloneColumns.splice(baseColumns.length, 0, EXPAND_COLUMN);
          }
        }
        if (cloneColumns.filter(function(c) {
          return c === EXPAND_COLUMN;
        }).length > 1) {
          warning_default(false, "There exist more than one `EXPAND_COLUMN` in `columns`.");
        }
        var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
        cloneColumns = cloneColumns.filter(function(column2, index3) {
          return column2 !== EXPAND_COLUMN || index3 === expandColumnIndex;
        });
        var prevColumn = baseColumns[expandColumnIndex];
        var fixedColumn;
        if (fixed) {
          fixedColumn = fixed;
        } else {
          fixedColumn = prevColumn ? prevColumn.fixed : null;
        }
        var expandColumn = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, INTERNAL_COL_DEFINE, {
          className: "".concat(prefixCls, "-expand-icon-col"),
          columnType: "EXPAND_COLUMN"
        }), "title", columnTitle), "fixed", fixedColumn), "className", "".concat(prefixCls, "-row-expand-icon-cell")), "width", columnWidth), "render", function render4(_, record, index3) {
          var rowKey = getRowKey(record, index3);
          var expanded = expandedKeys.has(rowKey);
          var recordExpandable = rowExpandable ? rowExpandable(record) : true;
          var icon = expandIcon({
            prefixCls,
            expanded,
            expandable: recordExpandable,
            record,
            onExpand: onTriggerExpand
          });
          if (expandRowByClick) {
            return /* @__PURE__ */ React358.createElement("span", {
              onClick: function onClick(e3) {
                return e3.stopPropagation();
              }
            }, icon);
          }
          return icon;
        });
        return cloneColumns.map(function(col, index3) {
          var column2 = col === EXPAND_COLUMN ? expandColumn : col;
          if (index3 < expandedRowOffset) {
            return _objectSpread2(_objectSpread2({}, column2), {}, {
              fixed: column2.fixed || "left"
            });
          }
          return column2;
        });
      }
      if (baseColumns.includes(EXPAND_COLUMN)) {
        warning_default(false, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`.");
      }
      return baseColumns.filter(function(col) {
        return col !== EXPAND_COLUMN;
      });
    }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction, expandedRowOffset]);
    var mergedColumns = React358.useMemo(function() {
      var finalColumns = withExpandColumns;
      if (transformColumns) {
        finalColumns = transformColumns(finalColumns);
      }
      if (!finalColumns.length) {
        finalColumns = [{
          render: function render4() {
            return null;
          }
        }];
      }
      return finalColumns;
    }, [transformColumns, withExpandColumns, direction]);
    var flattenColumns = React358.useMemo(function() {
      if (direction === "rtl") {
        return revertForRtl(flatColumns(mergedColumns));
      }
      return flatColumns(mergedColumns);
    }, [mergedColumns, direction, scrollWidth]);
    var hasGapFixed = React358.useMemo(function() {
      var lastLeftIndex = -1;
      for (var i = flattenColumns.length - 1; i >= 0; i -= 1) {
        var colFixed = flattenColumns[i].fixed;
        if (colFixed === "left" || colFixed === true) {
          lastLeftIndex = i;
          break;
        }
      }
      if (lastLeftIndex >= 0) {
        for (var _i = 0; _i <= lastLeftIndex; _i += 1) {
          var _colFixed = flattenColumns[_i].fixed;
          if (_colFixed !== "left" && _colFixed !== true) {
            return true;
          }
        }
      }
      var firstRightIndex = flattenColumns.findIndex(function(_ref3) {
        var colFixed2 = _ref3.fixed;
        return colFixed2 === "right";
      });
      if (firstRightIndex >= 0) {
        for (var _i2 = firstRightIndex; _i2 < flattenColumns.length; _i2 += 1) {
          var _colFixed2 = flattenColumns[_i2].fixed;
          if (_colFixed2 !== "right") {
            return true;
          }
        }
      }
      return false;
    }, [flattenColumns]);
    var _useWidthColumns = useWidthColumns(flattenColumns, scrollWidth, clientWidth), _useWidthColumns2 = _slicedToArray(_useWidthColumns, 2), filledColumns = _useWidthColumns2[0], realScrollWidth = _useWidthColumns2[1];
    return [mergedColumns, filledColumns, realScrollWidth, hasGapFixed];
  }
  var useColumns_default = useColumns;

  // node_modules/rc-table/es/hooks/useExpand.js
  var React359 = __toESM(require_react());
  function useExpand(props, mergedData, getRowKey) {
    var expandableConfig = getExpandableProps(props);
    var expandIcon = expandableConfig.expandIcon, expandedRowKeys = expandableConfig.expandedRowKeys, defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys, defaultExpandAllRows = expandableConfig.defaultExpandAllRows, expandedRowRender = expandableConfig.expandedRowRender, onExpand = expandableConfig.onExpand, onExpandedRowsChange = expandableConfig.onExpandedRowsChange, childrenColumnName = expandableConfig.childrenColumnName;
    var mergedExpandIcon = expandIcon || renderExpandIcon;
    var mergedChildrenColumnName = childrenColumnName || "children";
    var expandableType = React359.useMemo(function() {
      if (expandedRowRender) {
        return "row";
      }
      if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function(record) {
        return record && _typeof(record) === "object" && record[mergedChildrenColumnName];
      })) {
        return "nest";
      }
      return false;
    }, [!!expandedRowRender, mergedData]);
    var _React$useState = React359.useState(function() {
      if (defaultExpandedRowKeys) {
        return defaultExpandedRowKeys;
      }
      if (defaultExpandAllRows) {
        return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
      }
      return [];
    }), _React$useState2 = _slicedToArray(_React$useState, 2), innerExpandedKeys = _React$useState2[0], setInnerExpandedKeys = _React$useState2[1];
    var mergedExpandedKeys = React359.useMemo(function() {
      return new Set(expandedRowKeys || innerExpandedKeys || []);
    }, [expandedRowKeys, innerExpandedKeys]);
    var onTriggerExpand = React359.useCallback(function(record) {
      var key = getRowKey(record, mergedData.indexOf(record));
      var newExpandedKeys;
      var hasKey = mergedExpandedKeys.has(key);
      if (hasKey) {
        mergedExpandedKeys.delete(key);
        newExpandedKeys = _toConsumableArray(mergedExpandedKeys);
      } else {
        newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key]);
      }
      setInnerExpandedKeys(newExpandedKeys);
      if (onExpand) {
        onExpand(!hasKey, record);
      }
      if (onExpandedRowsChange) {
        onExpandedRowsChange(newExpandedKeys);
      }
    }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
    if (expandedRowRender && mergedData.some(function(record) {
      return Array.isArray(record === null || record === void 0 ? void 0 : record[mergedChildrenColumnName]);
    })) {
      warning_default(false, "`expandedRowRender` should not use with nested Table");
    }
    return [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand];
  }

  // node_modules/rc-table/es/hooks/useFixedInfo.js
  function useFixedInfo(flattenColumns, stickyOffsets, direction) {
    var fixedInfoList = flattenColumns.map(function(_, colIndex) {
      return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction);
    });
    return useMemo(function() {
      return fixedInfoList;
    }, [fixedInfoList], function(prev2, next2) {
      return !isEqual_default(prev2, next2);
    });
  }

  // node_modules/rc-table/es/hooks/useFrame.js
  var import_react111 = __toESM(require_react());
  function useLayoutState(defaultState) {
    var stateRef = (0, import_react111.useRef)(defaultState);
    var _useState = (0, import_react111.useState)({}), _useState2 = _slicedToArray(_useState, 2), forceUpdate = _useState2[1];
    var lastPromiseRef = (0, import_react111.useRef)(null);
    var updateBatchRef = (0, import_react111.useRef)([]);
    function setFrameState(updater) {
      updateBatchRef.current.push(updater);
      var promise = Promise.resolve();
      lastPromiseRef.current = promise;
      promise.then(function() {
        if (lastPromiseRef.current === promise) {
          var prevBatch = updateBatchRef.current;
          var prevState = stateRef.current;
          updateBatchRef.current = [];
          prevBatch.forEach(function(batchUpdater) {
            stateRef.current = batchUpdater(stateRef.current);
          });
          lastPromiseRef.current = null;
          if (prevState !== stateRef.current) {
            forceUpdate({});
          }
        }
      });
    }
    (0, import_react111.useEffect)(function() {
      return function() {
        lastPromiseRef.current = null;
      };
    }, []);
    return [stateRef.current, setFrameState];
  }
  function useTimeoutLock(defaultState) {
    var frameRef = (0, import_react111.useRef)(defaultState || null);
    var timeoutRef = (0, import_react111.useRef)();
    function cleanUp() {
      window.clearTimeout(timeoutRef.current);
    }
    function setState(newState) {
      frameRef.current = newState;
      cleanUp();
      timeoutRef.current = window.setTimeout(function() {
        frameRef.current = null;
        timeoutRef.current = void 0;
      }, 100);
    }
    function getState() {
      return frameRef.current;
    }
    (0, import_react111.useEffect)(function() {
      return cleanUp;
    }, []);
    return [setState, getState];
  }

  // node_modules/rc-table/es/hooks/useHover.js
  var React360 = __toESM(require_react());
  function useHover() {
    var _React$useState = React360.useState(-1), _React$useState2 = _slicedToArray(_React$useState, 2), startRow = _React$useState2[0], setStartRow = _React$useState2[1];
    var _React$useState3 = React360.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), endRow = _React$useState4[0], setEndRow = _React$useState4[1];
    var onHover = React360.useCallback(function(start, end) {
      setStartRow(start);
      setEndRow(end);
    }, []);
    return [startRow, endRow, onHover];
  }

  // node_modules/rc-table/es/hooks/useSticky.js
  var React361 = __toESM(require_react());
  var defaultContainer = canUseDom() ? window : null;
  function useSticky(sticky, prefixCls) {
    var _ref = _typeof(sticky) === "object" ? sticky : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer2 = _ref$getContainer === void 0 ? function() {
      return defaultContainer;
    } : _ref$getContainer;
    var container = getContainer2() || defaultContainer;
    var isSticky = !!sticky;
    return React361.useMemo(function() {
      return {
        isSticky,
        stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : "",
        offsetHeader,
        offsetSummary,
        offsetScroll,
        container
      };
    }, [isSticky, offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
  }

  // node_modules/rc-table/es/hooks/useStickyOffsets.js
  var import_react112 = __toESM(require_react());
  function useStickyOffsets(colWidths, flattenColumns, direction) {
    var stickyOffsets = (0, import_react112.useMemo)(function() {
      var columnCount = flattenColumns.length;
      var getOffsets = function getOffsets2(startIndex, endIndex, offset3) {
        var offsets = [];
        var total = 0;
        for (var i = startIndex; i !== endIndex; i += offset3) {
          offsets.push(total);
          if (flattenColumns[i].fixed) {
            total += colWidths[i] || 0;
          }
        }
        return offsets;
      };
      var startOffsets = getOffsets(0, columnCount, 1);
      var endOffsets = getOffsets(columnCount - 1, -1, -1).reverse();
      return direction === "rtl" ? {
        left: endOffsets,
        right: startOffsets
      } : {
        left: startOffsets,
        right: endOffsets
      };
    }, [colWidths, flattenColumns, direction]);
    return stickyOffsets;
  }
  var useStickyOffsets_default = useStickyOffsets;

  // node_modules/rc-table/es/Panel/index.js
  var React362 = __toESM(require_react());
  function Panel2(_ref) {
    var className = _ref.className, children = _ref.children;
    return /* @__PURE__ */ React362.createElement("div", {
      className
    }, children);
  }
  var Panel_default2 = Panel2;

  // node_modules/rc-table/es/stickyScrollBar.js
  var import_classnames130 = __toESM(require_classnames());
  var React363 = __toESM(require_react());

  // node_modules/rc-table/es/utils/offsetUtil.js
  function getOffset2(node2) {
    var element = getDOM(node2);
    var box2 = element.getBoundingClientRect();
    var docElem = document.documentElement;
    return {
      left: box2.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
      top: box2.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
    };
  }

  // node_modules/rc-table/es/stickyScrollBar.js
  var StickyScrollBar = function StickyScrollBar2(_ref, ref) {
    var _scrollBodyRef$curren, _scrollBodyRef$curren2;
    var scrollBodyRef = _ref.scrollBodyRef, onScroll = _ref.onScroll, offsetScroll = _ref.offsetScroll, container = _ref.container, direction = _ref.direction;
    var prefixCls = useContext117(TableContext_default, "prefixCls");
    var bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0;
    var bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0;
    var scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
    var scrollBarRef = React363.useRef();
    var _useLayoutState = useLayoutState({
      scrollLeft: 0,
      isHiddenScrollBar: true
    }), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
    var refState = React363.useRef({
      delta: 0,
      x: 0
    });
    var _React$useState = React363.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), isActive2 = _React$useState2[0], setActive = _React$useState2[1];
    var rafRef = React363.useRef(null);
    React363.useEffect(function() {
      return function() {
        raf_default.cancel(rafRef.current);
      };
    }, []);
    var onMouseUp = function onMouseUp2() {
      setActive(false);
    };
    var onMouseDown = function onMouseDown2(event) {
      event.persist();
      refState.current.delta = event.pageX - scrollState.scrollLeft;
      refState.current.x = 0;
      setActive(true);
      event.preventDefault();
    };
    var onMouseMove = function onMouseMove2(event) {
      var _window;
      var _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event), buttons = _ref2.buttons;
      if (!isActive2 || buttons === 0) {
        if (isActive2) {
          setActive(false);
        }
        return;
      }
      var left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
      var isRTL = direction === "rtl";
      left = Math.max(isRTL ? scrollBarWidth - bodyWidth : 0, Math.min(isRTL ? 0 : bodyWidth - scrollBarWidth, left));
      var shouldScroll = !isRTL || Math.abs(left) + Math.abs(scrollBarWidth) < bodyWidth;
      if (shouldScroll) {
        onScroll({
          scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
        });
        refState.current.x = event.pageX;
      }
    };
    var checkScrollBarVisible = function checkScrollBarVisible2() {
      raf_default.cancel(rafRef.current);
      rafRef.current = raf_default(function() {
        if (!scrollBodyRef.current) {
          return;
        }
        var tableOffsetTop = getOffset2(scrollBodyRef.current).top;
        var tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
        var currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset2(container).top + container.clientHeight;
        if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
          setScrollState(function(state) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              isHiddenScrollBar: true
            });
          });
        } else {
          setScrollState(function(state) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              isHiddenScrollBar: false
            });
          });
        }
      });
    };
    var setScrollLeft = function setScrollLeft2(left) {
      setScrollState(function(state) {
        return _objectSpread2(_objectSpread2({}, state), {}, {
          scrollLeft: left / bodyScrollWidth * bodyWidth || 0
        });
      });
    };
    React363.useImperativeHandle(ref, function() {
      return {
        setScrollLeft,
        checkScrollBarVisible
      };
    });
    React363.useEffect(function() {
      var onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
      var onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
      checkScrollBarVisible();
      return function() {
        onMouseUpListener.remove();
        onMouseMoveListener.remove();
      };
    }, [scrollBarWidth, isActive2]);
    React363.useEffect(function() {
      if (!scrollBodyRef.current) return;
      var scrollParents = [];
      var parent = getDOM(scrollBodyRef.current);
      while (parent) {
        scrollParents.push(parent);
        parent = parent.parentElement;
      }
      scrollParents.forEach(function(p) {
        return p.addEventListener("scroll", checkScrollBarVisible, false);
      });
      window.addEventListener("resize", checkScrollBarVisible, false);
      window.addEventListener("scroll", checkScrollBarVisible, false);
      container.addEventListener("scroll", checkScrollBarVisible, false);
      return function() {
        scrollParents.forEach(function(p) {
          return p.removeEventListener("scroll", checkScrollBarVisible);
        });
        window.removeEventListener("resize", checkScrollBarVisible);
        window.removeEventListener("scroll", checkScrollBarVisible);
        container.removeEventListener("scroll", checkScrollBarVisible);
      };
    }, [container]);
    React363.useEffect(function() {
      if (!scrollState.isHiddenScrollBar) {
        setScrollState(function(state) {
          var bodyNode = scrollBodyRef.current;
          if (!bodyNode) {
            return state;
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
          });
        });
      }
    }, [scrollState.isHiddenScrollBar]);
    if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
      return null;
    }
    return /* @__PURE__ */ React363.createElement("div", {
      style: {
        height: getScrollBarSize(),
        width: bodyWidth,
        bottom: offsetScroll
      },
      className: "".concat(prefixCls, "-sticky-scroll")
    }, /* @__PURE__ */ React363.createElement("div", {
      onMouseDown,
      ref: scrollBarRef,
      className: (0, import_classnames130.default)("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive2)),
      style: {
        width: "".concat(scrollBarWidth, "px"),
        transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
      }
    }));
  };
  var stickyScrollBar_default = /* @__PURE__ */ React363.forwardRef(StickyScrollBar);

  // node_modules/rc-table/es/Table.js
  var DEFAULT_PREFIX = "rc-table";
  var EMPTY_DATA2 = [];
  var EMPTY_SCROLL_TARGET = {};
  function defaultEmpty() {
    return "No Data";
  }
  function Table(tableProps, ref) {
    var props = _objectSpread2({
      rowKey: "key",
      prefixCls: DEFAULT_PREFIX,
      emptyText: defaultEmpty
    }, tableProps);
    var prefixCls = props.prefixCls, className = props.className, rowClassName = props.rowClassName, style2 = props.style, data = props.data, rowKey = props.rowKey, scroll = props.scroll, tableLayout = props.tableLayout, direction = props.direction, title = props.title, footer = props.footer, summary = props.summary, caption = props.caption, id = props.id, showHeader = props.showHeader, components = props.components, emptyText = props.emptyText, onRow = props.onRow, onHeaderRow = props.onHeaderRow, onScroll = props.onScroll, internalHooks = props.internalHooks, transformColumns = props.transformColumns, internalRefs = props.internalRefs, tailor = props.tailor, getContainerWidth = props.getContainerWidth, sticky = props.sticky, _props$rowHoverable = props.rowHoverable, rowHoverable = _props$rowHoverable === void 0 ? true : _props$rowHoverable;
    var mergedData = data || EMPTY_DATA2;
    var hasData = !!mergedData.length;
    var useInternalHooks = internalHooks === INTERNAL_HOOKS;
    if (true) {
      ["onRowClick", "onRowDoubleClick", "onRowContextMenu", "onRowMouseEnter", "onRowMouseLeave"].forEach(function(name) {
        warning_default(props[name] === void 0, "`".concat(name, "` is removed, please use `onRow` instead."));
      });
      warning_default(!("getBodyWrapper" in props), "`getBodyWrapper` is deprecated, please use custom `components` instead.");
    }
    var getComponent = React364.useCallback(function(path2, defaultComponent) {
      return get(components, path2) || defaultComponent;
    }, [components]);
    var getRowKey = React364.useMemo(function() {
      if (typeof rowKey === "function") {
        return rowKey;
      }
      return function(record) {
        var key = record && record[rowKey];
        if (true) {
          warning_default(key !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key.");
        }
        return key;
      };
    }, [rowKey]);
    var customizeScrollBody = getComponent(["body"]);
    var _useHover = useHover(), _useHover2 = _slicedToArray(_useHover, 3), startRow = _useHover2[0], endRow = _useHover2[1], onHover = _useHover2[2];
    var _useExpand = useExpand(props, mergedData, getRowKey), _useExpand2 = _slicedToArray(_useExpand, 6), expandableConfig = _useExpand2[0], expandableType = _useExpand2[1], mergedExpandedKeys = _useExpand2[2], mergedExpandIcon = _useExpand2[3], mergedChildrenColumnName = _useExpand2[4], onTriggerExpand = _useExpand2[5];
    var scrollX = scroll === null || scroll === void 0 ? void 0 : scroll.x;
    var _React$useState = React364.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), componentWidth = _React$useState2[0], setComponentWidth = _React$useState2[1];
    var _useColumns = useColumns_default(_objectSpread2(_objectSpread2(_objectSpread2({}, props), expandableConfig), {}, {
      expandable: !!expandableConfig.expandedRowRender,
      columnTitle: expandableConfig.columnTitle,
      expandedKeys: mergedExpandedKeys,
      getRowKey,
      // https://github.com/ant-design/ant-design/issues/23894
      onTriggerExpand,
      expandIcon: mergedExpandIcon,
      expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
      direction,
      scrollWidth: useInternalHooks && tailor && typeof scrollX === "number" ? scrollX : null,
      clientWidth: componentWidth
    }), useInternalHooks ? transformColumns : null), _useColumns2 = _slicedToArray(_useColumns, 4), columns = _useColumns2[0], flattenColumns = _useColumns2[1], flattenScrollX = _useColumns2[2], hasGapFixed = _useColumns2[3];
    var mergedScrollX = flattenScrollX !== null && flattenScrollX !== void 0 ? flattenScrollX : scrollX;
    var columnContext = React364.useMemo(function() {
      return {
        columns,
        flattenColumns
      };
    }, [columns, flattenColumns]);
    var fullTableRef = React364.useRef();
    var scrollHeaderRef = React364.useRef();
    var scrollBodyRef = React364.useRef();
    var scrollBodyContainerRef = React364.useRef();
    React364.useImperativeHandle(ref, function() {
      return {
        nativeElement: fullTableRef.current,
        scrollTo: function scrollTo2(config) {
          var _scrollBodyRef$curren3;
          if (scrollBodyRef.current instanceof HTMLElement) {
            var index3 = config.index, top = config.top, key = config.key;
            if (validNumberValue(top)) {
              var _scrollBodyRef$curren;
              (_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 || _scrollBodyRef$curren.scrollTo({
                top
              });
            } else {
              var _scrollBodyRef$curren2;
              var mergedKey = key !== null && key !== void 0 ? key : getRowKey(mergedData[index3]);
              (_scrollBodyRef$curren2 = scrollBodyRef.current.querySelector('[data-row-key="'.concat(mergedKey, '"]'))) === null || _scrollBodyRef$curren2 === void 0 || _scrollBodyRef$curren2.scrollIntoView();
            }
          } else if ((_scrollBodyRef$curren3 = scrollBodyRef.current) !== null && _scrollBodyRef$curren3 !== void 0 && _scrollBodyRef$curren3.scrollTo) {
            scrollBodyRef.current.scrollTo(config);
          }
        }
      };
    });
    var scrollSummaryRef = React364.useRef();
    var _React$useState3 = React364.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), pingedLeft = _React$useState4[0], setPingedLeft = _React$useState4[1];
    var _React$useState5 = React364.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), pingedRight = _React$useState6[0], setPingedRight = _React$useState6[1];
    var _React$useState7 = React364.useState(/* @__PURE__ */ new Map()), _React$useState8 = _slicedToArray(_React$useState7, 2), colsWidths = _React$useState8[0], updateColsWidths = _React$useState8[1];
    var colsKeys = getColumnsKey(flattenColumns);
    var pureColWidths = colsKeys.map(function(columnKey) {
      return colsWidths.get(columnKey);
    });
    var colWidths = React364.useMemo(function() {
      return pureColWidths;
    }, [pureColWidths.join("_")]);
    var stickyOffsets = useStickyOffsets_default(colWidths, flattenColumns, direction);
    var fixHeader = scroll && validateValue(scroll.y);
    var horizonScroll = scroll && validateValue(mergedScrollX) || Boolean(expandableConfig.fixed);
    var fixColumn = horizonScroll && flattenColumns.some(function(_ref) {
      var fixed = _ref.fixed;
      return fixed;
    });
    var stickyRef = React364.useRef();
    var _useSticky = useSticky(sticky, prefixCls), isSticky = _useSticky.isSticky, offsetHeader = _useSticky.offsetHeader, offsetSummary = _useSticky.offsetSummary, offsetScroll = _useSticky.offsetScroll, stickyClassName = _useSticky.stickyClassName, container = _useSticky.container;
    var summaryNode = React364.useMemo(function() {
      return summary === null || summary === void 0 ? void 0 : summary(mergedData);
    }, [summary, mergedData]);
    var fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ React364.isValidElement(summaryNode) && summaryNode.type === Summary_default && summaryNode.props.fixed;
    var scrollXStyle;
    var scrollYStyle;
    var scrollTableStyle;
    if (fixHeader) {
      scrollYStyle = {
        overflowY: hasData ? "scroll" : "auto",
        maxHeight: scroll.y
      };
    }
    if (horizonScroll) {
      scrollXStyle = {
        overflowX: "auto"
      };
      if (!fixHeader) {
        scrollYStyle = {
          overflowY: "hidden"
        };
      }
      scrollTableStyle = {
        width: mergedScrollX === true ? "auto" : mergedScrollX,
        minWidth: "100%"
      };
    }
    var onColumnResize = React364.useCallback(function(columnKey, width) {
      updateColsWidths(function(widths) {
        if (widths.get(columnKey) !== width) {
          var newWidths = new Map(widths);
          newWidths.set(columnKey, width);
          return newWidths;
        }
        return widths;
      });
    }, []);
    var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
    function forceScroll(scrollLeft, target) {
      if (!target) {
        return;
      }
      if (typeof target === "function") {
        target(scrollLeft);
      } else if (target.scrollLeft !== scrollLeft) {
        target.scrollLeft = scrollLeft;
        if (target.scrollLeft !== scrollLeft) {
          setTimeout(function() {
            target.scrollLeft = scrollLeft;
          }, 0);
        }
      }
    }
    var onInternalScroll = useEvent(function(_ref2) {
      var currentTarget = _ref2.currentTarget, scrollLeft = _ref2.scrollLeft;
      var isRTL = direction === "rtl";
      var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
      var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
      if (!getScrollTarget() || getScrollTarget() === compareTarget) {
        var _stickyRef$current;
        setScrollTarget(compareTarget);
        forceScroll(mergedScrollLeft, scrollHeaderRef.current);
        forceScroll(mergedScrollLeft, scrollBodyRef.current);
        forceScroll(mergedScrollLeft, scrollSummaryRef.current);
        forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
      }
      var measureTarget = currentTarget || scrollHeaderRef.current;
      if (measureTarget) {
        var scrollWidth = (
          // Should use mergedScrollX in virtual table(useInternalHooks && tailor === true)
          useInternalHooks && tailor && typeof mergedScrollX === "number" ? mergedScrollX : measureTarget.scrollWidth
        );
        var clientWidth = measureTarget.clientWidth;
        if (scrollWidth === clientWidth) {
          setPingedLeft(false);
          setPingedRight(false);
          return;
        }
        if (isRTL) {
          setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
          setPingedRight(-mergedScrollLeft > 0);
        } else {
          setPingedLeft(mergedScrollLeft > 0);
          setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
        }
      }
    });
    var onBodyScroll = useEvent(function(e3) {
      onInternalScroll(e3);
      onScroll === null || onScroll === void 0 || onScroll(e3);
    });
    var triggerOnScroll = function triggerOnScroll2() {
      if (horizonScroll && scrollBodyRef.current) {
        var _scrollBodyRef$curren4;
        onInternalScroll({
          currentTarget: getDOM(scrollBodyRef.current),
          scrollLeft: (_scrollBodyRef$curren4 = scrollBodyRef.current) === null || _scrollBodyRef$curren4 === void 0 ? void 0 : _scrollBodyRef$curren4.scrollLeft
        });
      } else {
        setPingedLeft(false);
        setPingedRight(false);
      }
    };
    var onFullTableResize = function onFullTableResize2(_ref3) {
      var _stickyRef$current2;
      var width = _ref3.width;
      (_stickyRef$current2 = stickyRef.current) === null || _stickyRef$current2 === void 0 || _stickyRef$current2.checkScrollBarVisible();
      var mergedWidth = fullTableRef.current ? fullTableRef.current.offsetWidth : width;
      if (useInternalHooks && getContainerWidth && fullTableRef.current) {
        mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth;
      }
      if (mergedWidth !== componentWidth) {
        triggerOnScroll();
        setComponentWidth(mergedWidth);
      }
    };
    var mounted = React364.useRef(false);
    React364.useEffect(function() {
      if (mounted.current) {
        triggerOnScroll();
      }
    }, [horizonScroll, data, columns.length]);
    React364.useEffect(function() {
      mounted.current = true;
    }, []);
    var _React$useState9 = React364.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), scrollbarSize = _React$useState10[0], setScrollbarSize = _React$useState10[1];
    var _React$useState11 = React364.useState(true), _React$useState12 = _slicedToArray(_React$useState11, 2), supportSticky = _React$useState12[0], setSupportSticky = _React$useState12[1];
    useLayoutEffect_default(function() {
      if (!tailor || !useInternalHooks) {
        if (scrollBodyRef.current instanceof Element) {
          setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
        } else {
          setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
        }
      }
      setSupportSticky(isStyleSupport("position", "sticky"));
    }, []);
    React364.useEffect(function() {
      if (useInternalHooks && internalRefs) {
        internalRefs.body.current = scrollBodyRef.current;
      }
    });
    var renderFixedHeaderTable = React364.useCallback(function(fixedHolderPassProps) {
      return /* @__PURE__ */ React364.createElement(React364.Fragment, null, /* @__PURE__ */ React364.createElement(Header_default, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ React364.createElement(Footer_default, fixedHolderPassProps, summaryNode));
    }, [fixFooter, summaryNode]);
    var renderFixedFooterTable = React364.useCallback(function(fixedHolderPassProps) {
      return /* @__PURE__ */ React364.createElement(Footer_default, fixedHolderPassProps, summaryNode);
    }, [summaryNode]);
    var TableComponent = getComponent(["table"], "table");
    var mergedTableLayout = React364.useMemo(function() {
      if (tableLayout) {
        return tableLayout;
      }
      if (fixColumn) {
        return mergedScrollX === "max-content" ? "auto" : "fixed";
      }
      if (fixHeader || isSticky || flattenColumns.some(function(_ref4) {
        var ellipsis = _ref4.ellipsis;
        return ellipsis;
      })) {
        return "fixed";
      }
      return "auto";
    }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
    var groupTableNode;
    var headerProps = {
      colWidths,
      columCount: flattenColumns.length,
      stickyOffsets,
      onHeaderRow,
      fixHeader,
      scroll
    };
    var emptyNode = React364.useMemo(function() {
      if (hasData) {
        return null;
      }
      if (typeof emptyText === "function") {
        return emptyText();
      }
      return emptyText;
    }, [hasData, emptyText]);
    var bodyTable = /* @__PURE__ */ React364.createElement(Body_default, {
      data: mergedData,
      measureColumnWidth: fixHeader || horizonScroll || isSticky
    });
    var bodyColGroup = /* @__PURE__ */ React364.createElement(ColGroup_default, {
      colWidths: flattenColumns.map(function(_ref5) {
        var width = _ref5.width;
        return width;
      }),
      columns: flattenColumns
    });
    var captionElement = caption !== null && caption !== void 0 ? /* @__PURE__ */ React364.createElement("caption", {
      className: "".concat(prefixCls, "-caption")
    }, caption) : void 0;
    var dataProps = pickAttrs(props, {
      data: true
    });
    var ariaProps = pickAttrs(props, {
      aria: true
    });
    if (fixHeader || isSticky) {
      var bodyContent;
      if (typeof customizeScrollBody === "function") {
        bodyContent = customizeScrollBody(mergedData, {
          scrollbarSize,
          ref: scrollBodyRef,
          onScroll: onInternalScroll
        });
        headerProps.colWidths = flattenColumns.map(function(_ref6, index3) {
          var width = _ref6.width;
          var colWidth = index3 === flattenColumns.length - 1 ? width - scrollbarSize : width;
          if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
            return colWidth;
          }
          if (true) {
            warning_default(props.columns.length === 0, "When use `components.body` with render props. Each column should have a fixed `width` value.");
          }
          return 0;
        });
      } else {
        bodyContent = /* @__PURE__ */ React364.createElement("div", {
          style: _objectSpread2(_objectSpread2({}, scrollXStyle), scrollYStyle),
          onScroll: onBodyScroll,
          ref: scrollBodyRef,
          className: (0, import_classnames131.default)("".concat(prefixCls, "-body"))
        }, /* @__PURE__ */ React364.createElement(TableComponent, _extends({
          style: _objectSpread2(_objectSpread2({}, scrollTableStyle), {}, {
            tableLayout: mergedTableLayout
          })
        }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ React364.createElement(Footer_default, {
          stickyOffsets,
          flattenColumns
        }, summaryNode)));
      }
      var fixedHolderProps = _objectSpread2(_objectSpread2(_objectSpread2({
        noData: !mergedData.length,
        maxContentScroll: horizonScroll && mergedScrollX === "max-content"
      }, headerProps), columnContext), {}, {
        direction,
        stickyClassName,
        onScroll: onInternalScroll
      });
      groupTableNode = /* @__PURE__ */ React364.createElement(React364.Fragment, null, showHeader !== false && /* @__PURE__ */ React364.createElement(FixedHolder_default, _extends({}, fixedHolderProps, {
        stickyTopOffset: offsetHeader,
        className: "".concat(prefixCls, "-header"),
        ref: scrollHeaderRef
      }), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ React364.createElement(FixedHolder_default, _extends({}, fixedHolderProps, {
        stickyBottomOffset: offsetSummary,
        className: "".concat(prefixCls, "-summary"),
        ref: scrollSummaryRef
      }), renderFixedFooterTable), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && /* @__PURE__ */ React364.createElement(stickyScrollBar_default, {
        ref: stickyRef,
        offsetScroll,
        scrollBodyRef,
        onScroll: onInternalScroll,
        container,
        direction
      }));
    } else {
      groupTableNode = /* @__PURE__ */ React364.createElement("div", {
        style: _objectSpread2(_objectSpread2({}, scrollXStyle), scrollYStyle),
        className: (0, import_classnames131.default)("".concat(prefixCls, "-content")),
        onScroll: onInternalScroll,
        ref: scrollBodyRef
      }, /* @__PURE__ */ React364.createElement(TableComponent, _extends({
        style: _objectSpread2(_objectSpread2({}, scrollTableStyle), {}, {
          tableLayout: mergedTableLayout
        })
      }, ariaProps), captionElement, bodyColGroup, showHeader !== false && /* @__PURE__ */ React364.createElement(Header_default, _extends({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ React364.createElement(Footer_default, {
        stickyOffsets,
        flattenColumns
      }, summaryNode)));
    }
    var fullTable = /* @__PURE__ */ React364.createElement("div", _extends({
      className: (0, import_classnames131.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-rtl"), direction === "rtl"), "".concat(prefixCls, "-ping-left"), pingedLeft), "".concat(prefixCls, "-ping-right"), pingedRight), "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), "".concat(prefixCls, "-fixed-header"), fixHeader), "".concat(prefixCls, "-fixed-column"), fixColumn), "".concat(prefixCls, "-fixed-column-gapped"), fixColumn && hasGapFixed), "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right")),
      style: style2,
      id,
      ref: fullTableRef
    }, dataProps), title && /* @__PURE__ */ React364.createElement(Panel_default2, {
      className: "".concat(prefixCls, "-title")
    }, title(mergedData)), /* @__PURE__ */ React364.createElement("div", {
      ref: scrollBodyContainerRef,
      className: "".concat(prefixCls, "-container")
    }, groupTableNode), footer && /* @__PURE__ */ React364.createElement(Panel_default2, {
      className: "".concat(prefixCls, "-footer")
    }, footer(mergedData)));
    if (horizonScroll) {
      fullTable = /* @__PURE__ */ React364.createElement(es_default, {
        onResize: onFullTableResize
      }, fullTable);
    }
    var fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets, direction);
    var TableContextValue = React364.useMemo(function() {
      return {
        // Scroll
        scrollX: mergedScrollX,
        // Table
        prefixCls,
        getComponent,
        scrollbarSize,
        direction,
        fixedInfoList,
        isSticky,
        supportSticky,
        componentWidth,
        fixHeader,
        fixColumn,
        horizonScroll,
        // Body
        tableLayout: mergedTableLayout,
        rowClassName,
        expandedRowClassName: expandableConfig.expandedRowClassName,
        expandIcon: mergedExpandIcon,
        expandableType,
        expandRowByClick: expandableConfig.expandRowByClick,
        expandedRowRender: expandableConfig.expandedRowRender,
        expandedRowOffset: expandableConfig.expandedRowOffset,
        onTriggerExpand,
        expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
        indentSize: expandableConfig.indentSize,
        allColumnsFixedLeft: flattenColumns.every(function(col) {
          return col.fixed === "left";
        }),
        emptyNode,
        // Column
        columns,
        flattenColumns,
        onColumnResize,
        colWidths,
        // Row
        hoverStartRow: startRow,
        hoverEndRow: endRow,
        onHover,
        rowExpandable: expandableConfig.rowExpandable,
        onRow,
        getRowKey,
        expandedKeys: mergedExpandedKeys,
        childrenColumnName: mergedChildrenColumnName,
        rowHoverable
      };
    }, [
      // Scroll
      mergedScrollX,
      // Table
      prefixCls,
      getComponent,
      scrollbarSize,
      direction,
      fixedInfoList,
      isSticky,
      supportSticky,
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll,
      // Body
      mergedTableLayout,
      rowClassName,
      expandableConfig.expandedRowClassName,
      mergedExpandIcon,
      expandableType,
      expandableConfig.expandRowByClick,
      expandableConfig.expandedRowRender,
      expandableConfig.expandedRowOffset,
      onTriggerExpand,
      expandableConfig.expandIconColumnIndex,
      expandableConfig.indentSize,
      emptyNode,
      // Column
      columns,
      flattenColumns,
      onColumnResize,
      colWidths,
      // Row
      startRow,
      endRow,
      onHover,
      expandableConfig.rowExpandable,
      onRow,
      getRowKey,
      mergedExpandedKeys,
      mergedChildrenColumnName,
      rowHoverable
    ]);
    return /* @__PURE__ */ React364.createElement(TableContext_default.Provider, {
      value: TableContextValue
    }, fullTable);
  }
  var RefTable = /* @__PURE__ */ React364.forwardRef(Table);
  if (true) {
    RefTable.displayName = "Table";
  }
  function genTable(shouldTriggerRender) {
    return makeImmutable2(RefTable, shouldTriggerRender);
  }
  var ImmutableTable = genTable();
  ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
  ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
  ImmutableTable.Column = Column_default;
  ImmutableTable.ColumnGroup = ColumnGroup_default;
  ImmutableTable.Summary = FooterComponents;
  var Table_default = ImmutableTable;

  // node_modules/rc-table/es/VirtualTable/index.js
  var import_classnames134 = __toESM(require_classnames());
  var React368 = __toESM(require_react());

  // node_modules/rc-table/es/VirtualTable/BodyGrid.js
  var React367 = __toESM(require_react());

  // node_modules/rc-table/es/VirtualTable/BodyLine.js
  var import_classnames133 = __toESM(require_classnames());
  var React366 = __toESM(require_react());

  // node_modules/rc-table/es/VirtualTable/VirtualCell.js
  var import_classnames132 = __toESM(require_classnames());
  var React365 = __toESM(require_react());

  // node_modules/rc-table/es/VirtualTable/context.js
  var StaticContext = createContext36(null);
  var GridContext = createContext36(null);

  // node_modules/rc-table/es/VirtualTable/VirtualCell.js
  function getColumnWidth(colIndex, colSpan, columnsOffset) {
    var mergedColSpan = colSpan || 1;
    return columnsOffset[colIndex + mergedColSpan] - (columnsOffset[colIndex] || 0);
  }
  function VirtualCell(props) {
    var rowInfo = props.rowInfo, column2 = props.column, colIndex = props.colIndex, indent = props.indent, index3 = props.index, component = props.component, renderIndex = props.renderIndex, record = props.record, style2 = props.style, className = props.className, inverse = props.inverse, getHeight = props.getHeight;
    var render4 = column2.render, dataIndex = column2.dataIndex, columnClassName = column2.className, colWidth = column2.width;
    var _useContext = useContext117(GridContext, ["columnsOffset"]), columnsOffset = _useContext.columnsOffset;
    var _getCellProps = getCellProps(rowInfo, column2, colIndex, indent, index3), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps;
    var cellStyle = additionalCellProps.style, _additionalCellProps$ = additionalCellProps.colSpan, colSpan = _additionalCellProps$ === void 0 ? 1 : _additionalCellProps$, _additionalCellProps$2 = additionalCellProps.rowSpan, rowSpan = _additionalCellProps$2 === void 0 ? 1 : _additionalCellProps$2;
    var startColIndex = colIndex - 1;
    var concatColWidth = getColumnWidth(startColIndex, colSpan, columnsOffset);
    var marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0;
    var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2({}, cellStyle), style2), {}, {
      flex: "0 0 ".concat(concatColWidth, "px"),
      width: "".concat(concatColWidth, "px"),
      marginRight: marginOffset,
      pointerEvents: "auto"
    });
    var needHide = React365.useMemo(function() {
      if (inverse) {
        return rowSpan <= 1;
      } else {
        return colSpan === 0 || rowSpan === 0 || rowSpan > 1;
      }
    }, [rowSpan, colSpan, inverse]);
    if (needHide) {
      mergedStyle.visibility = "hidden";
    } else if (inverse) {
      mergedStyle.height = getHeight === null || getHeight === void 0 ? void 0 : getHeight(rowSpan);
    }
    var mergedRender = needHide ? function() {
      return null;
    } : render4;
    var cellSpan = {};
    if (rowSpan === 0 || colSpan === 0) {
      cellSpan.rowSpan = 1;
      cellSpan.colSpan = 1;
    }
    return /* @__PURE__ */ React365.createElement(Cell_default, _extends({
      className: (0, import_classnames132.default)(columnClassName, className),
      ellipsis: column2.ellipsis,
      align: column2.align,
      scope: column2.rowScope,
      component,
      prefixCls: rowInfo.prefixCls,
      key,
      record,
      index: index3,
      renderIndex,
      dataIndex,
      render: mergedRender,
      shouldCellUpdate: column2.shouldCellUpdate
    }, fixedInfo, {
      appendNode: appendCellNode,
      additionalProps: _objectSpread2(_objectSpread2({}, additionalCellProps), {}, {
        style: mergedStyle
      }, cellSpan)
    }));
  }
  var VirtualCell_default = VirtualCell;

  // node_modules/rc-table/es/VirtualTable/BodyLine.js
  var _excluded54 = ["data", "index", "className", "rowKey", "style", "extra", "getHeight"];
  var BodyLine = /* @__PURE__ */ React366.forwardRef(function(props, ref) {
    var data = props.data, index3 = props.index, className = props.className, rowKey = props.rowKey, style2 = props.style, extra = props.extra, getHeight = props.getHeight, restProps = _objectWithoutProperties(props, _excluded54);
    var record = data.record, indent = data.indent, renderIndex = data.index;
    var _useContext = useContext117(TableContext_default, ["prefixCls", "flattenColumns", "fixColumn", "componentWidth", "scrollX"]), scrollX = _useContext.scrollX, flattenColumns = _useContext.flattenColumns, prefixCls = _useContext.prefixCls, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth;
    var _useContext2 = useContext117(StaticContext, ["getComponent"]), getComponent = _useContext2.getComponent;
    var rowInfo = useRowInfo(record, rowKey, index3, indent);
    var RowComponent = getComponent(["body", "row"], "div");
    var cellComponent = getComponent(["body", "cell"], "div");
    var rowSupportExpand = rowInfo.rowSupportExpand, expanded = rowInfo.expanded, rowProps = rowInfo.rowProps, expandedRowRender = rowInfo.expandedRowRender, expandedRowClassName = rowInfo.expandedRowClassName;
    var expandRowNode;
    if (rowSupportExpand && expanded) {
      var expandContent = expandedRowRender(record, index3, indent + 1, expanded);
      var expandedClsName = computedExpandedClassName(expandedRowClassName, record, index3, indent);
      var additionalProps = {};
      if (fixColumn) {
        additionalProps = {
          style: _defineProperty({}, "--virtual-width", "".concat(componentWidth, "px"))
        };
      }
      var rowCellCls = "".concat(prefixCls, "-expanded-row-cell");
      expandRowNode = /* @__PURE__ */ React366.createElement(RowComponent, {
        className: (0, import_classnames133.default)("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), expandedClsName)
      }, /* @__PURE__ */ React366.createElement(Cell_default, {
        component: cellComponent,
        prefixCls,
        className: (0, import_classnames133.default)(rowCellCls, _defineProperty({}, "".concat(rowCellCls, "-fixed"), fixColumn)),
        additionalProps
      }, expandContent));
    }
    var rowStyle = _objectSpread2(_objectSpread2({}, style2), {}, {
      width: scrollX
    });
    if (extra) {
      rowStyle.position = "absolute";
      rowStyle.pointerEvents = "none";
    }
    var rowNode = /* @__PURE__ */ React366.createElement(RowComponent, _extends({}, rowProps, restProps, {
      "data-row-key": rowKey,
      ref: rowSupportExpand ? null : ref,
      className: (0, import_classnames133.default)(className, "".concat(prefixCls, "-row"), rowProps === null || rowProps === void 0 ? void 0 : rowProps.className, _defineProperty({}, "".concat(prefixCls, "-row-extra"), extra)),
      style: _objectSpread2(_objectSpread2({}, rowStyle), rowProps === null || rowProps === void 0 ? void 0 : rowProps.style)
    }), flattenColumns.map(function(column2, colIndex) {
      return /* @__PURE__ */ React366.createElement(VirtualCell_default, {
        key: colIndex,
        component: cellComponent,
        rowInfo,
        column: column2,
        colIndex,
        indent,
        index: index3,
        renderIndex,
        record,
        inverse: extra,
        getHeight
      });
    }));
    if (rowSupportExpand) {
      return /* @__PURE__ */ React366.createElement("div", {
        ref
      }, rowNode, expandRowNode);
    }
    return rowNode;
  });
  var ResponseBodyLine = responseImmutable2(BodyLine);
  if (true) {
    ResponseBodyLine.displayName = "BodyLine";
  }
  var BodyLine_default = ResponseBodyLine;

  // node_modules/rc-table/es/VirtualTable/BodyGrid.js
  var Grid2 = /* @__PURE__ */ React367.forwardRef(function(props, ref) {
    var data = props.data, onScroll = props.onScroll;
    var _useContext = useContext117(TableContext_default, ["flattenColumns", "onColumnResize", "getRowKey", "prefixCls", "expandedKeys", "childrenColumnName", "scrollX", "direction"]), flattenColumns = _useContext.flattenColumns, onColumnResize = _useContext.onColumnResize, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, prefixCls = _useContext.prefixCls, childrenColumnName = _useContext.childrenColumnName, scrollX = _useContext.scrollX, direction = _useContext.direction;
    var _useContext2 = useContext117(StaticContext), sticky = _useContext2.sticky, scrollY = _useContext2.scrollY, listItemHeight = _useContext2.listItemHeight, getComponent = _useContext2.getComponent, onTablePropScroll = _useContext2.onScroll;
    var listRef = React367.useRef();
    var flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
    var columnsWidth = React367.useMemo(function() {
      var total = 0;
      return flattenColumns.map(function(_ref) {
        var width = _ref.width, key = _ref.key;
        total += width;
        return [key, width, total];
      });
    }, [flattenColumns]);
    var columnsOffset = React367.useMemo(function() {
      return columnsWidth.map(function(colWidth) {
        return colWidth[2];
      });
    }, [columnsWidth]);
    React367.useEffect(function() {
      columnsWidth.forEach(function(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], width = _ref3[1];
        onColumnResize(key, width);
      });
    }, [columnsWidth]);
    React367.useImperativeHandle(ref, function() {
      var _listRef$current2;
      var obj = {
        scrollTo: function scrollTo2(config) {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(config);
        },
        nativeElement: (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 ? void 0 : _listRef$current2.nativeElement
      };
      Object.defineProperty(obj, "scrollLeft", {
        get: function get2() {
          var _listRef$current3;
          return ((_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 ? void 0 : _listRef$current3.getScrollInfo().x) || 0;
        },
        set: function set2(value) {
          var _listRef$current4;
          (_listRef$current4 = listRef.current) === null || _listRef$current4 === void 0 || _listRef$current4.scrollTo({
            left: value
          });
        }
      });
      return obj;
    });
    var getRowSpan = function getRowSpan2(column2, index3) {
      var _flattenData$index;
      var record = (_flattenData$index = flattenData2[index3]) === null || _flattenData$index === void 0 ? void 0 : _flattenData$index.record;
      var onCell = column2.onCell;
      if (onCell) {
        var _cellProps$rowSpan;
        var cellProps = onCell(record, index3);
        return (_cellProps$rowSpan = cellProps === null || cellProps === void 0 ? void 0 : cellProps.rowSpan) !== null && _cellProps$rowSpan !== void 0 ? _cellProps$rowSpan : 1;
      }
      return 1;
    };
    var extraRender = function extraRender2(info) {
      var start = info.start, end = info.end, getSize4 = info.getSize, offsetY = info.offsetY;
      if (end < 0) {
        return null;
      }
      var firstRowSpanColumns = flattenColumns.filter(
        // rowSpan is 0
        function(column2) {
          return getRowSpan(column2, start) === 0;
        }
      );
      var startIndex = start;
      var _loop = function _loop4(i2) {
        firstRowSpanColumns = firstRowSpanColumns.filter(function(column2) {
          return getRowSpan(column2, i2) === 0;
        });
        if (!firstRowSpanColumns.length) {
          startIndex = i2;
          return 1;
        }
      };
      for (var i = start; i >= 0; i -= 1) {
        if (_loop(i)) break;
      }
      var lastRowSpanColumns = flattenColumns.filter(
        // rowSpan is not 1
        function(column2) {
          return getRowSpan(column2, end) !== 1;
        }
      );
      var endIndex = end;
      var _loop2 = function _loop22(_i3) {
        lastRowSpanColumns = lastRowSpanColumns.filter(function(column2) {
          return getRowSpan(column2, _i3) !== 1;
        });
        if (!lastRowSpanColumns.length) {
          endIndex = Math.max(_i3 - 1, end);
          return 1;
        }
      };
      for (var _i = end; _i < flattenData2.length; _i += 1) {
        if (_loop2(_i)) break;
      }
      var spanLines = [];
      var _loop3 = function _loop32(_i22) {
        var item = flattenData2[_i22];
        if (!item) {
          return 1;
        }
        if (flattenColumns.some(function(column2) {
          return getRowSpan(column2, _i22) > 1;
        })) {
          spanLines.push(_i22);
        }
      };
      for (var _i2 = startIndex; _i2 <= endIndex; _i2 += 1) {
        if (_loop3(_i2)) continue;
      }
      var nodes = spanLines.map(function(index3) {
        var item = flattenData2[index3];
        var rowKey = getRowKey(item.record, index3);
        var getHeight = function getHeight2(rowSpan) {
          var endItemIndex = index3 + rowSpan - 1;
          var endItemKey = getRowKey(flattenData2[endItemIndex].record, endItemIndex);
          var sizeInfo2 = getSize4(rowKey, endItemKey);
          return sizeInfo2.bottom - sizeInfo2.top;
        };
        var sizeInfo = getSize4(rowKey);
        return /* @__PURE__ */ React367.createElement(BodyLine_default, {
          key: index3,
          data: item,
          rowKey,
          index: index3,
          style: {
            top: -offsetY + sizeInfo.top
          },
          extra: true,
          getHeight
        });
      });
      return nodes;
    };
    var gridContext = React367.useMemo(function() {
      return {
        columnsOffset
      };
    }, [columnsOffset]);
    var tblPrefixCls = "".concat(prefixCls, "-tbody");
    var wrapperComponent = getComponent(["body", "wrapper"]);
    var horizontalScrollBarStyle = {};
    if (sticky) {
      horizontalScrollBarStyle.position = "sticky";
      horizontalScrollBarStyle.bottom = 0;
      if (_typeof(sticky) === "object" && sticky.offsetScroll) {
        horizontalScrollBarStyle.bottom = sticky.offsetScroll;
      }
    }
    return /* @__PURE__ */ React367.createElement(GridContext.Provider, {
      value: gridContext
    }, /* @__PURE__ */ React367.createElement(es_default9, {
      fullHeight: false,
      ref: listRef,
      prefixCls: "".concat(tblPrefixCls, "-virtual"),
      styles: {
        horizontalScrollBar: horizontalScrollBarStyle
      },
      className: tblPrefixCls,
      height: scrollY,
      itemHeight: listItemHeight || 24,
      data: flattenData2,
      itemKey: function itemKey3(item) {
        return getRowKey(item.record);
      },
      component: wrapperComponent,
      scrollWidth: scrollX,
      direction,
      onVirtualScroll: function onVirtualScroll(_ref4) {
        var _listRef$current5;
        var x = _ref4.x;
        onScroll({
          currentTarget: (_listRef$current5 = listRef.current) === null || _listRef$current5 === void 0 ? void 0 : _listRef$current5.nativeElement,
          scrollLeft: x
        });
      },
      onScroll: onTablePropScroll,
      extraRender
    }, function(item, index3, itemProps) {
      var rowKey = getRowKey(item.record, index3);
      return /* @__PURE__ */ React367.createElement(BodyLine_default, {
        data: item,
        rowKey,
        index: index3,
        style: itemProps.style
      });
    }));
  });
  var ResponseGrid = responseImmutable2(Grid2);
  if (true) {
    ResponseGrid.displayName = "ResponseGrid";
  }
  var BodyGrid_default = ResponseGrid;

  // node_modules/rc-table/es/VirtualTable/index.js
  var renderBody = function renderBody2(rawData, props) {
    var ref = props.ref, onScroll = props.onScroll;
    return /* @__PURE__ */ React368.createElement(BodyGrid_default, {
      ref,
      data: rawData,
      onScroll
    });
  };
  function VirtualTable(props, ref) {
    var data = props.data, columns = props.columns, scroll = props.scroll, sticky = props.sticky, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? DEFAULT_PREFIX : _props$prefixCls, className = props.className, listItemHeight = props.listItemHeight, components = props.components, onScroll = props.onScroll;
    var _ref = scroll || {}, scrollX = _ref.x, scrollY = _ref.y;
    if (typeof scrollX !== "number") {
      if (true) {
        warning_default(!scrollX, "`scroll.x` in virtual table must be number.");
      }
      scrollX = 1;
    }
    if (typeof scrollY !== "number") {
      scrollY = 500;
      if (true) {
        warning_default(false, "`scroll.y` in virtual table must be number.");
      }
    }
    var getComponent = useEvent(function(path2, defaultComponent) {
      return get(components, path2) || defaultComponent;
    });
    var onInternalScroll = useEvent(onScroll);
    var context = React368.useMemo(function() {
      return {
        sticky,
        scrollY,
        listItemHeight,
        getComponent,
        onScroll: onInternalScroll
      };
    }, [sticky, scrollY, listItemHeight, getComponent, onInternalScroll]);
    return /* @__PURE__ */ React368.createElement(StaticContext.Provider, {
      value: context
    }, /* @__PURE__ */ React368.createElement(Table_default, _extends({}, props, {
      className: (0, import_classnames134.default)(className, "".concat(prefixCls, "-virtual")),
      scroll: _objectSpread2(_objectSpread2({}, scroll), {}, {
        x: scrollX
      }),
      components: _objectSpread2(_objectSpread2({}, components), {}, {
        // fix https://github.com/ant-design/ant-design/issues/48991
        body: data !== null && data !== void 0 && data.length ? renderBody : void 0
      }),
      columns,
      internalHooks: INTERNAL_HOOKS,
      tailor: true,
      ref
    })));
  }
  var RefVirtualTable = /* @__PURE__ */ React368.forwardRef(VirtualTable);
  if (true) {
    RefVirtualTable.displayName = "VirtualTable";
  }
  function genVirtualTable(shouldTriggerRender) {
    return makeImmutable2(RefVirtualTable, shouldTriggerRender);
  }
  var VirtualTable_default = genVirtualTable();

  // node_modules/antd/es/table/Column.js
  var Column2 = (_) => null;
  var Column_default2 = Column2;

  // node_modules/antd/es/table/ColumnGroup.js
  var ColumnGroup2 = (_) => null;
  var ColumnGroup_default2 = ColumnGroup2;

  // node_modules/antd/es/table/hooks/useSelection.js
  var React373 = __toESM(require_react());
  var import_react116 = __toESM(require_react());
  var import_classnames137 = __toESM(require_classnames());

  // node_modules/rc-tree/es/util.js
  var import_react114 = __toESM(require_react());

  // node_modules/rc-tree/es/TreeNode.js
  var import_react113 = __toESM(require_react());
  var import_classnames136 = __toESM(require_classnames());

  // node_modules/rc-tree/es/contextTypes.js
  var React369 = __toESM(require_react());
  var TreeContext = /* @__PURE__ */ React369.createContext(null);
  var UnstableContext = /* @__PURE__ */ React369.createContext({});

  // node_modules/rc-tree/es/Indent.js
  var import_classnames135 = __toESM(require_classnames());
  var React370 = __toESM(require_react());
  var Indent = function Indent2(_ref) {
    var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
    var baseClassName = "".concat(prefixCls, "-indent-unit");
    var list = [];
    for (var i = 0; i < level; i += 1) {
      list.push(/* @__PURE__ */ React370.createElement("span", {
        key: i,
        className: (0, import_classnames135.default)(baseClassName, _defineProperty(_defineProperty({}, "".concat(baseClassName, "-start"), isStart[i]), "".concat(baseClassName, "-end"), isEnd[i]))
      }));
    }
    return /* @__PURE__ */ React370.createElement("span", {
      "aria-hidden": "true",
      className: "".concat(prefixCls, "-indent")
    }, list);
  };
  var Indent_default = /* @__PURE__ */ React370.memo(Indent);

  // node_modules/rc-tree/es/TreeNode.js
  var _excluded55 = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];
  var ICON_OPEN = "open";
  var ICON_CLOSE = "close";
  var defaultTitle = "---";
  var TreeNode = function TreeNode2(props) {
    var _unstableContext$node, _context$filterTreeNo, _classNames4;
    var eventKey = props.eventKey, className = props.className, style2 = props.style, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, isLeaf = props.isLeaf, isStart = props.isStart, isEnd = props.isEnd, expanded = props.expanded, selected = props.selected, checked = props.checked, halfChecked = props.halfChecked, loading = props.loading, domRef = props.domRef, active = props.active, data = props.data, onMouseMove = props.onMouseMove, selectable = props.selectable, otherProps = _objectWithoutProperties(props, _excluded55);
    var context = import_react113.default.useContext(TreeContext);
    var unstableContext = import_react113.default.useContext(UnstableContext);
    var selectHandleRef = import_react113.default.useRef(null);
    var _React$useState = import_react113.default.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragNodeHighlight = _React$useState2[0], setDragNodeHighlight = _React$useState2[1];
    var isDisabled = !!(context.disabled || props.disabled || (_unstableContext$node = unstableContext.nodeDisabled) !== null && _unstableContext$node !== void 0 && _unstableContext$node.call(unstableContext, data));
    var isCheckable = import_react113.default.useMemo(function() {
      if (!context.checkable || props.checkable === false) {
        return false;
      }
      return context.checkable;
    }, [context.checkable, props.checkable]);
    var onSelect = function onSelect2(e3) {
      if (isDisabled) {
        return;
      }
      context.onNodeSelect(e3, convertNodePropsToEventData(props));
    };
    var onCheck = function onCheck2(e3) {
      if (isDisabled) {
        return;
      }
      if (!isCheckable || props.disableCheckbox) {
        return;
      }
      context.onNodeCheck(e3, convertNodePropsToEventData(props), !checked);
    };
    var isSelectable = import_react113.default.useMemo(function() {
      if (typeof selectable === "boolean") {
        return selectable;
      }
      return context.selectable;
    }, [selectable, context.selectable]);
    var onSelectorClick = function onSelectorClick2(e3) {
      context.onNodeClick(e3, convertNodePropsToEventData(props));
      if (isSelectable) {
        onSelect(e3);
      } else {
        onCheck(e3);
      }
    };
    var onSelectorDoubleClick = function onSelectorDoubleClick2(e3) {
      context.onNodeDoubleClick(e3, convertNodePropsToEventData(props));
    };
    var onMouseEnter = function onMouseEnter2(e3) {
      context.onNodeMouseEnter(e3, convertNodePropsToEventData(props));
    };
    var onMouseLeave = function onMouseLeave2(e3) {
      context.onNodeMouseLeave(e3, convertNodePropsToEventData(props));
    };
    var onContextMenu = function onContextMenu2(e3) {
      context.onNodeContextMenu(e3, convertNodePropsToEventData(props));
    };
    var isDraggable = import_react113.default.useMemo(function() {
      return !!(context.draggable && (!context.draggable.nodeDraggable || context.draggable.nodeDraggable(data)));
    }, [context.draggable, data]);
    var onDragStart = function onDragStart2(e3) {
      e3.stopPropagation();
      setDragNodeHighlight(true);
      context.onNodeDragStart(e3, props);
      try {
        e3.dataTransfer.setData("text/plain", "");
      } catch (_unused) {
      }
    };
    var onDragEnter = function onDragEnter2(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      context.onNodeDragEnter(e3, props);
    };
    var onDragOver = function onDragOver2(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      context.onNodeDragOver(e3, props);
    };
    var onDragLeave = function onDragLeave2(e3) {
      e3.stopPropagation();
      context.onNodeDragLeave(e3, props);
    };
    var onDragEnd = function onDragEnd2(e3) {
      e3.stopPropagation();
      setDragNodeHighlight(false);
      context.onNodeDragEnd(e3, props);
    };
    var onDrop = function onDrop2(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      setDragNodeHighlight(false);
      context.onNodeDrop(e3, props);
    };
    var onExpand = function onExpand2(e3) {
      if (loading) {
        return;
      }
      context.onNodeExpand(e3, convertNodePropsToEventData(props));
    };
    var hasChildren = import_react113.default.useMemo(function() {
      var _ref = getEntity(context.keyEntities, eventKey) || {}, children = _ref.children;
      return Boolean((children || []).length);
    }, [context.keyEntities, eventKey]);
    var memoizedIsLeaf = import_react113.default.useMemo(function() {
      if (isLeaf === false) {
        return false;
      }
      return isLeaf || !context.loadData && !hasChildren || context.loadData && props.loaded && !hasChildren;
    }, [isLeaf, context.loadData, hasChildren, props.loaded]);
    import_react113.default.useEffect(function() {
      if (loading) {
        return;
      }
      if (typeof context.loadData === "function" && expanded && !memoizedIsLeaf && !props.loaded) {
        context.onNodeLoad(convertNodePropsToEventData(props));
      }
    }, [loading, context.loadData, context.onNodeLoad, expanded, memoizedIsLeaf, props]);
    var dragHandlerNode = import_react113.default.useMemo(function() {
      var _context$draggable;
      if (!((_context$draggable = context.draggable) !== null && _context$draggable !== void 0 && _context$draggable.icon)) {
        return null;
      }
      return /* @__PURE__ */ import_react113.default.createElement("span", {
        className: "".concat(context.prefixCls, "-draggable-icon")
      }, context.draggable.icon);
    }, [context.draggable]);
    var renderSwitcherIconDom = function renderSwitcherIconDom2(isInternalLeaf) {
      var switcherIcon = props.switcherIcon || context.switcherIcon;
      if (typeof switcherIcon === "function") {
        return switcherIcon(_objectSpread2(_objectSpread2({}, props), {}, {
          isLeaf: isInternalLeaf
        }));
      }
      return switcherIcon;
    };
    var renderSwitcher = function renderSwitcher2() {
      if (memoizedIsLeaf) {
        var _switcherIconDom = renderSwitcherIconDom(true);
        return _switcherIconDom !== false ? /* @__PURE__ */ import_react113.default.createElement("span", {
          className: (0, import_classnames136.default)("".concat(context.prefixCls, "-switcher"), "".concat(context.prefixCls, "-switcher-noop"))
        }, _switcherIconDom) : null;
      }
      var switcherIconDom = renderSwitcherIconDom(false);
      return switcherIconDom !== false ? /* @__PURE__ */ import_react113.default.createElement("span", {
        onClick: onExpand,
        className: (0, import_classnames136.default)("".concat(context.prefixCls, "-switcher"), "".concat(context.prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE))
      }, switcherIconDom) : null;
    };
    var checkboxNode = import_react113.default.useMemo(function() {
      if (!isCheckable) {
        return null;
      }
      var $custom = typeof isCheckable !== "boolean" ? isCheckable : null;
      return /* @__PURE__ */ import_react113.default.createElement("span", {
        className: (0, import_classnames136.default)("".concat(context.prefixCls, "-checkbox"), _defineProperty(_defineProperty(_defineProperty({}, "".concat(context.prefixCls, "-checkbox-checked"), checked), "".concat(context.prefixCls, "-checkbox-indeterminate"), !checked && halfChecked), "".concat(context.prefixCls, "-checkbox-disabled"), isDisabled || props.disableCheckbox)),
        onClick: onCheck,
        role: "checkbox",
        "aria-checked": halfChecked ? "mixed" : checked,
        "aria-disabled": isDisabled || props.disableCheckbox,
        "aria-label": "Select ".concat(typeof props.title === "string" ? props.title : "tree node")
      }, $custom);
    }, [isCheckable, checked, halfChecked, isDisabled, props.disableCheckbox, props.title]);
    var nodeState = import_react113.default.useMemo(function() {
      if (memoizedIsLeaf) {
        return null;
      }
      return expanded ? ICON_OPEN : ICON_CLOSE;
    }, [memoizedIsLeaf, expanded]);
    var iconNode = import_react113.default.useMemo(function() {
      return /* @__PURE__ */ import_react113.default.createElement("span", {
        className: (0, import_classnames136.default)("".concat(context.prefixCls, "-iconEle"), "".concat(context.prefixCls, "-icon__").concat(nodeState || "docu"), _defineProperty({}, "".concat(context.prefixCls, "-icon_loading"), loading))
      });
    }, [context.prefixCls, nodeState, loading]);
    var dropIndicatorNode = import_react113.default.useMemo(function() {
      var rootDraggable = Boolean(context.draggable);
      var showIndicator = !props.disabled && rootDraggable && context.dragOverNodeKey === eventKey;
      if (!showIndicator) {
        return null;
      }
      return context.dropIndicatorRender({
        dropPosition: context.dropPosition,
        dropLevelOffset: context.dropLevelOffset,
        indent: context.indent,
        prefixCls: context.prefixCls,
        direction: context.direction
      });
    }, [context.dropPosition, context.dropLevelOffset, context.indent, context.prefixCls, context.direction, context.draggable, context.dragOverNodeKey, context.dropIndicatorRender]);
    var selectorNode = import_react113.default.useMemo(function() {
      var _props$title = props.title, title = _props$title === void 0 ? defaultTitle : _props$title;
      var wrapClass = "".concat(context.prefixCls, "-node-content-wrapper");
      var $icon;
      if (context.showIcon) {
        var currentIcon = props.icon || context.icon;
        $icon = currentIcon ? /* @__PURE__ */ import_react113.default.createElement("span", {
          className: (0, import_classnames136.default)("".concat(context.prefixCls, "-iconEle"), "".concat(context.prefixCls, "-icon__customize"))
        }, typeof currentIcon === "function" ? currentIcon(props) : currentIcon) : iconNode;
      } else if (context.loadData && loading) {
        $icon = iconNode;
      }
      var titleNode;
      if (typeof title === "function") {
        titleNode = title(data);
      } else if (context.titleRender) {
        titleNode = context.titleRender(data);
      } else {
        titleNode = title;
      }
      return /* @__PURE__ */ import_react113.default.createElement("span", {
        ref: selectHandleRef,
        title: typeof title === "string" ? title : "",
        className: (0, import_classnames136.default)(wrapClass, "".concat(wrapClass, "-").concat(nodeState || "normal"), _defineProperty({}, "".concat(context.prefixCls, "-node-selected"), !isDisabled && (selected || dragNodeHighlight))),
        onMouseEnter,
        onMouseLeave,
        onContextMenu,
        onClick: onSelectorClick,
        onDoubleClick: onSelectorDoubleClick
      }, $icon, /* @__PURE__ */ import_react113.default.createElement("span", {
        className: "".concat(context.prefixCls, "-title")
      }, titleNode), dropIndicatorNode);
    }, [context.prefixCls, context.showIcon, props, context.icon, iconNode, context.titleRender, data, nodeState, onMouseEnter, onMouseLeave, onContextMenu, onSelectorClick, onSelectorDoubleClick]);
    var dataOrAriaAttributeProps = pickAttrs(otherProps, {
      aria: true,
      data: true
    });
    var _ref2 = getEntity(context.keyEntities, eventKey) || {}, level = _ref2.level;
    var isEndNode = isEnd[isEnd.length - 1];
    var draggableWithoutDisabled = !isDisabled && isDraggable;
    var dragging = context.draggingNodeKey === eventKey;
    var ariaSelected = selectable !== void 0 ? {
      "aria-selected": !!selectable
    } : void 0;
    return /* @__PURE__ */ import_react113.default.createElement("div", _extends({
      ref: domRef,
      role: "treeitem",
      "aria-expanded": isLeaf ? void 0 : expanded,
      className: (0, import_classnames136.default)(className, "".concat(context.prefixCls, "-treenode"), (_classNames4 = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classNames4, "".concat(context.prefixCls, "-treenode-disabled"), isDisabled), "".concat(context.prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf), "".concat(context.prefixCls, "-treenode-checkbox-checked"), checked), "".concat(context.prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), "".concat(context.prefixCls, "-treenode-selected"), selected), "".concat(context.prefixCls, "-treenode-loading"), loading), "".concat(context.prefixCls, "-treenode-active"), active), "".concat(context.prefixCls, "-treenode-leaf-last"), isEndNode), "".concat(context.prefixCls, "-treenode-draggable"), isDraggable), "dragging", dragging), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classNames4, "drop-target", context.dropTargetKey === eventKey), "drop-container", context.dropContainerKey === eventKey), "drag-over", !isDisabled && dragOver), "drag-over-gap-top", !isDisabled && dragOverGapTop), "drag-over-gap-bottom", !isDisabled && dragOverGapBottom), "filter-node", (_context$filterTreeNo = context.filterTreeNode) === null || _context$filterTreeNo === void 0 ? void 0 : _context$filterTreeNo.call(context, convertNodePropsToEventData(props))), "".concat(context.prefixCls, "-treenode-leaf"), memoizedIsLeaf))),
      style: style2,
      draggable: draggableWithoutDisabled,
      onDragStart: draggableWithoutDisabled ? onDragStart : void 0,
      onDragEnter: isDraggable ? onDragEnter : void 0,
      onDragOver: isDraggable ? onDragOver : void 0,
      onDragLeave: isDraggable ? onDragLeave : void 0,
      onDrop: isDraggable ? onDrop : void 0,
      onDragEnd: isDraggable ? onDragEnd : void 0,
      onMouseMove
    }, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ import_react113.default.createElement(Indent_default, {
      prefixCls: context.prefixCls,
      level,
      isStart,
      isEnd
    }), dragHandlerNode, renderSwitcher(), checkboxNode, selectorNode);
  };
  TreeNode.isTreeNode = 1;
  if (true) {
    TreeNode.displayName = "TreeNode";
  }
  var TreeNode_default = TreeNode;

  // node_modules/rc-tree/es/util.js
  function arrDel(list, value) {
    if (!list) return [];
    var clone = list.slice();
    var index3 = clone.indexOf(value);
    if (index3 >= 0) {
      clone.splice(index3, 1);
    }
    return clone;
  }
  function arrAdd(list, value) {
    var clone = (list || []).slice();
    if (clone.indexOf(value) === -1) {
      clone.push(value);
    }
    return clone;
  }
  function posToArr(pos) {
    return pos.split("-");
  }
  function getDragChildrenKeys(dragNodeKey, keyEntities) {
    var dragChildrenKeys = [];
    var entity = getEntity(keyEntities, dragNodeKey);
    function dig() {
      var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      list.forEach(function(_ref) {
        var key = _ref.key, children = _ref.children;
        dragChildrenKeys.push(key);
        dig(children);
      });
    }
    dig(entity.children);
    return dragChildrenKeys;
  }
  function isLastChild(treeNodeEntity) {
    if (treeNodeEntity.parent) {
      var posArr = posToArr(treeNodeEntity.pos);
      return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
    }
    return false;
  }
  function isFirstChild(treeNodeEntity) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === 0;
  }
  function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop2, flattenedNodes, keyEntities, expandKeys, direction) {
    var _abstractDropNodeEnti;
    var clientX = event.clientX, clientY = event.clientY;
    var _getBoundingClientRec = event.target.getBoundingClientRect(), top = _getBoundingClientRec.top, height = _getBoundingClientRec.height;
    var horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
    var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
    var filteredExpandKeys = expandKeys.filter(function(key) {
      var _keyEntities$key;
      return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;
    });
    var abstractDropNodeEntity = getEntity(keyEntities, targetNodeProps.eventKey);
    if (clientY < top + height / 2) {
      var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
        return flattenedNode.key === abstractDropNodeEntity.key;
      });
      var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
      var prevNodeKey = flattenedNodes[prevNodeIndex].key;
      abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
    }
    var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
    var abstractDragOverEntity = abstractDropNodeEntity;
    var dragOverNodeKey = abstractDropNodeEntity.key;
    var dropPosition = 0;
    var dropLevelOffset = 0;
    if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {
      for (var i = 0; i < rawDropLevelOffset; i += 1) {
        if (isLastChild(abstractDropNodeEntity)) {
          abstractDropNodeEntity = abstractDropNodeEntity.parent;
          dropLevelOffset += 1;
        } else {
          break;
        }
      }
    }
    var abstractDragDataNode = dragNodeProps.data;
    var abstractDropDataNode = abstractDropNodeEntity.node;
    var dropAllowed = true;
    if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: -1
    }) && abstractDropNodeEntity.key === targetNodeProps.eventKey) {
      dropPosition = -1;
    } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else {
        dropAllowed = false;
      }
    } else if (dropLevelOffset === 0) {
      if (rawDropLevelOffset > -1.5) {
        if (allowDrop2({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 1
        })) {
          dropPosition = 1;
        } else {
          dropAllowed = false;
        }
      } else {
        if (allowDrop2({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 0
        })) {
          dropPosition = 0;
        } else if (allowDrop2({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 1
        })) {
          dropPosition = 1;
        } else {
          dropAllowed = false;
        }
      }
    } else {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
    return {
      dropPosition,
      dropLevelOffset,
      dropTargetKey: abstractDropNodeEntity.key,
      dropTargetPos: abstractDropNodeEntity.pos,
      dragOverNodeKey,
      dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
      dropAllowed
    };
  }
  function calcSelectedKeys(selectedKeys, props) {
    if (!selectedKeys) return void 0;
    var multiple = props.multiple;
    if (multiple) {
      return selectedKeys.slice();
    }
    if (selectedKeys.length) {
      return [selectedKeys[0]];
    }
    return selectedKeys;
  }
  function parseCheckedKeys(keys2) {
    if (!keys2) {
      return null;
    }
    var keyProps;
    if (Array.isArray(keys2)) {
      keyProps = {
        checkedKeys: keys2,
        halfCheckedKeys: void 0
      };
    } else if (_typeof(keys2) === "object") {
      keyProps = {
        checkedKeys: keys2.checked || void 0,
        halfCheckedKeys: keys2.halfChecked || void 0
      };
    } else {
      warning_default(false, "`checkedKeys` is not an array or an object");
      return null;
    }
    return keyProps;
  }
  function conductExpandParent(keyList, keyEntities) {
    var expandedKeys = /* @__PURE__ */ new Set();
    function conductUp(key) {
      if (expandedKeys.has(key)) return;
      var entity = getEntity(keyEntities, key);
      if (!entity) return;
      expandedKeys.add(key);
      var parent = entity.parent, node2 = entity.node;
      if (node2.disabled) return;
      if (parent) {
        conductUp(parent.key);
      }
    }
    (keyList || []).forEach(function(key) {
      conductUp(key);
    });
    return _toConsumableArray(expandedKeys);
  }

  // node_modules/antd/es/_util/hooks/useMultipleSelect.js
  var import_react115 = __toESM(require_react());
  function useMultipleSelect(getKey3) {
    const [prevSelectedIndex, setPrevSelectedIndex] = (0, import_react115.useState)(null);
    const multipleSelect = (0, import_react115.useCallback)((currentSelectedIndex, data, selectedKeys) => {
      const configPrevSelectedIndex = prevSelectedIndex !== null && prevSelectedIndex !== void 0 ? prevSelectedIndex : currentSelectedIndex;
      const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
      const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
      const rangeKeys = data.slice(startIndex, endIndex + 1).map((item) => getKey3(item));
      const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
      const changedKeys = [];
      rangeKeys.forEach((item) => {
        if (shouldSelected) {
          if (!selectedKeys.has(item)) {
            changedKeys.push(item);
          }
          selectedKeys.add(item);
        } else {
          selectedKeys.delete(item);
          changedKeys.push(item);
        }
      });
      setPrevSelectedIndex(shouldSelected ? endIndex : null);
      return changedKeys;
    }, [prevSelectedIndex]);
    const updatePrevSelectedIndex = (val) => {
      setPrevSelectedIndex(val);
    };
    return [multipleSelect, updatePrevSelectedIndex];
  }

  // node_modules/antd/es/table/hooks/useSelection.js
  var SELECTION_COLUMN = {};
  var SELECTION_ALL = "SELECT_ALL";
  var SELECTION_INVERT = "SELECT_INVERT";
  var SELECTION_NONE = "SELECT_NONE";
  var EMPTY_LIST4 = [];
  var flattenData = (childrenColumnName, data, list = []) => {
    (data || []).forEach((record) => {
      list.push(record);
      if (record && typeof record === "object" && childrenColumnName in record) {
        flattenData(childrenColumnName, record[childrenColumnName], list);
      }
    });
    return list;
  };
  var useSelection = (config, rowSelection) => {
    const {
      preserveSelectedRowKeys,
      selectedRowKeys,
      defaultSelectedRowKeys,
      getCheckboxProps,
      onChange: onSelectionChange,
      onSelect,
      onSelectAll,
      onSelectInvert,
      onSelectNone,
      onSelectMultiple,
      columnWidth: selectionColWidth,
      type: selectionType,
      selections,
      fixed,
      renderCell: customizeRenderCell,
      hideSelectAll,
      checkStrictly = true
    } = rowSelection || {};
    const {
      prefixCls,
      data,
      pageData,
      getRecordByKey,
      getRowKey,
      expandType,
      childrenColumnName,
      locale: tableLocale,
      getPopupContainer
    } = config;
    const warning6 = devUseWarning("Table");
    const [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect((item) => item);
    const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST4, {
      value: selectedRowKeys
    });
    const preserveRecordsRef = React373.useRef(/* @__PURE__ */ new Map());
    const updatePreserveRecordsCache = (0, import_react116.useCallback)((keys2) => {
      if (preserveSelectedRowKeys) {
        const newCache = /* @__PURE__ */ new Map();
        keys2.forEach((key) => {
          let record = getRecordByKey(key);
          if (!record && preserveRecordsRef.current.has(key)) {
            record = preserveRecordsRef.current.get(key);
          }
          newCache.set(key, record);
        });
        preserveRecordsRef.current = newCache;
      }
    }, [getRecordByKey, preserveSelectedRowKeys]);
    React373.useEffect(() => {
      updatePreserveRecordsCache(mergedSelectedKeys);
    }, [mergedSelectedKeys]);
    const flattedData = (0, import_react116.useMemo)(() => flattenData(childrenColumnName, pageData), [childrenColumnName, pageData]);
    const {
      keyEntities
    } = (0, import_react116.useMemo)(() => {
      if (checkStrictly) {
        return {
          keyEntities: null
        };
      }
      let convertData = data;
      if (preserveSelectedRowKeys) {
        const keysSet = new Set(flattedData.map((record, index3) => getRowKey(record, index3)));
        const preserveRecords = Array.from(preserveRecordsRef.current).reduce((total, [key, value]) => keysSet.has(key) ? total : total.concat(value), []);
        convertData = [].concat(_toConsumableArray(convertData), _toConsumableArray(preserveRecords));
      }
      return convertDataToEntities(convertData, {
        externalGetKey: getRowKey,
        childrenPropName: childrenColumnName
      });
    }, [data, getRowKey, checkStrictly, childrenColumnName, preserveSelectedRowKeys, flattedData]);
    const checkboxPropsMap = (0, import_react116.useMemo)(() => {
      const map = /* @__PURE__ */ new Map();
      flattedData.forEach((record, index3) => {
        const key = getRowKey(record, index3);
        const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
        map.set(key, checkboxProps);
        true ? warning6(!("checked" in checkboxProps || "defaultChecked" in checkboxProps), "usage", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.") : void 0;
      });
      return map;
    }, [flattedData, getRowKey, getCheckboxProps]);
    const isCheckboxDisabled = (0, import_react116.useCallback)((r2) => {
      const rowKey = getRowKey(r2);
      let checkboxProps;
      if (checkboxPropsMap.has(rowKey)) {
        checkboxProps = checkboxPropsMap.get(getRowKey(r2));
      } else {
        checkboxProps = getCheckboxProps ? getCheckboxProps(r2) : void 0;
      }
      return !!(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.disabled);
    }, [checkboxPropsMap, getRowKey]);
    const [derivedSelectedKeys, derivedHalfSelectedKeys] = (0, import_react116.useMemo)(() => {
      if (checkStrictly) {
        return [mergedSelectedKeys || [], []];
      }
      const {
        checkedKeys,
        halfCheckedKeys
      } = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled);
      return [checkedKeys || [], halfCheckedKeys];
    }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]);
    const derivedSelectedKeySet = (0, import_react116.useMemo)(() => {
      const keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
      return new Set(keys2);
    }, [derivedSelectedKeys, selectionType]);
    const derivedHalfSelectedKeySet = (0, import_react116.useMemo)(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
    React373.useEffect(() => {
      if (!rowSelection) {
        setMergedSelectedKeys(EMPTY_LIST4);
      }
    }, [!!rowSelection]);
    const setSelectedKeys = (0, import_react116.useCallback)((keys2, method4) => {
      let availableKeys;
      let records;
      updatePreserveRecordsCache(keys2);
      if (preserveSelectedRowKeys) {
        availableKeys = keys2;
        records = keys2.map((key) => preserveRecordsRef.current.get(key));
      } else {
        availableKeys = [];
        records = [];
        keys2.forEach((key) => {
          const record = getRecordByKey(key);
          if (record !== void 0) {
            availableKeys.push(key);
            records.push(record);
          }
        });
      }
      setMergedSelectedKeys(availableKeys);
      onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records, {
        type: method4
      });
    }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
    const triggerSingleSelection = (0, import_react116.useCallback)((key, selected, keys2, event) => {
      if (onSelect) {
        const rows = keys2.map((k) => getRecordByKey(k));
        onSelect(getRecordByKey(key), selected, rows, event);
      }
      setSelectedKeys(keys2, "single");
    }, [onSelect, getRecordByKey, setSelectedKeys]);
    const mergedSelections = (0, import_react116.useMemo)(() => {
      if (!selections || hideSelectAll) {
        return null;
      }
      const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
      return selectionList.map((selection) => {
        if (selection === SELECTION_ALL) {
          return {
            key: "all",
            text: tableLocale.selectionAll,
            onSelect() {
              setSelectedKeys(data.map((record, index3) => getRowKey(record, index3)).filter((key) => {
                const checkProps = checkboxPropsMap.get(key);
                return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key);
              }), "all");
            }
          };
        }
        if (selection === SELECTION_INVERT) {
          return {
            key: "invert",
            text: tableLocale.selectInvert,
            onSelect() {
              const keySet = new Set(derivedSelectedKeySet);
              pageData.forEach((record, index3) => {
                const key = getRowKey(record, index3);
                const checkProps = checkboxPropsMap.get(key);
                if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                  if (keySet.has(key)) {
                    keySet.delete(key);
                  } else {
                    keySet.add(key);
                  }
                }
              });
              const keys2 = Array.from(keySet);
              if (onSelectInvert) {
                warning6.deprecated(false, "onSelectInvert", "onChange");
                onSelectInvert(keys2);
              }
              setSelectedKeys(keys2, "invert");
            }
          };
        }
        if (selection === SELECTION_NONE) {
          return {
            key: "none",
            text: tableLocale.selectNone,
            onSelect() {
              onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
              setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
                const checkProps = checkboxPropsMap.get(key);
                return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
              }), "none");
            }
          };
        }
        return selection;
      }).map((selection) => Object.assign(Object.assign({}, selection), {
        onSelect: (...rest) => {
          var _a2;
          var _a;
          (_a = selection.onSelect) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [selection].concat(rest));
          updatePrevSelectedIndex(null);
        }
      }));
    }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
    const transformColumns = (0, import_react116.useCallback)((columns) => {
      var _a;
      if (!rowSelection) {
        true ? warning6(!columns.includes(SELECTION_COLUMN), "usage", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`.") : void 0;
        return columns.filter((col) => col !== SELECTION_COLUMN);
      }
      let cloneColumns = _toConsumableArray(columns);
      const keySet = new Set(derivedSelectedKeySet);
      const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
      const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
      const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
      const onSelectAllChange = () => {
        const changeKeys = [];
        if (checkedCurrentAll) {
          recordKeys.forEach((key) => {
            keySet.delete(key);
            changeKeys.push(key);
          });
        } else {
          recordKeys.forEach((key) => {
            if (!keySet.has(key)) {
              keySet.add(key);
              changeKeys.push(key);
            }
          });
        }
        const keys2 = Array.from(keySet);
        onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map((k) => getRecordByKey(k)), changeKeys.map((k) => getRecordByKey(k)));
        setSelectedKeys(keys2, "all");
        updatePrevSelectedIndex(null);
      };
      let title;
      let columnTitleCheckbox;
      if (selectionType !== "radio") {
        let customizeSelections;
        if (mergedSelections) {
          const menu = {
            getPopupContainer,
            items: mergedSelections.map((selection, index3) => {
              const {
                key,
                text,
                onSelect: onSelectionClick
              } = selection;
              return {
                key: key !== null && key !== void 0 ? key : index3,
                onClick: () => {
                  onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
                },
                label: text
              };
            })
          };
          customizeSelections = /* @__PURE__ */ React373.createElement("div", {
            className: `${prefixCls}-selection-extra`
          }, /* @__PURE__ */ React373.createElement(dropdown_default3, {
            menu,
            getPopupContainer
          }, /* @__PURE__ */ React373.createElement("span", null, /* @__PURE__ */ React373.createElement(DownOutlined_default2, null))));
        }
        const allDisabledData = flattedData.map((record, index3) => {
          const key = getRowKey(record, index3);
          const checkboxProps = checkboxPropsMap.get(key) || {};
          return Object.assign({
            checked: keySet.has(key)
          }, checkboxProps);
        }).filter(({
          disabled
        }) => disabled);
        const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
        const allDisabledAndChecked = allDisabled && allDisabledData.every(({
          checked
        }) => checked);
        const allDisabledSomeChecked = allDisabled && allDisabledData.some(({
          checked
        }) => checked);
        columnTitleCheckbox = /* @__PURE__ */ React373.createElement(checkbox_default, {
          checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
          indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
          onChange: onSelectAllChange,
          disabled: flattedData.length === 0 || allDisabled,
          "aria-label": customizeSelections ? "Custom selection" : "Select all",
          skipGroup: true
        });
        title = !hideSelectAll && /* @__PURE__ */ React373.createElement("div", {
          className: `${prefixCls}-selection`
        }, columnTitleCheckbox, customizeSelections);
      }
      let renderCell;
      if (selectionType === "radio") {
        renderCell = (_, record, index3) => {
          const key = getRowKey(record, index3);
          const checked = keySet.has(key);
          const checkboxProps = checkboxPropsMap.get(key);
          return {
            node: /* @__PURE__ */ React373.createElement(radio_default2, Object.assign({}, checkboxProps, {
              checked,
              onClick: (e3) => {
                var _a2;
                e3.stopPropagation();
                (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e3);
              },
              onChange: (event) => {
                var _a2;
                if (!keySet.has(key)) {
                  triggerSingleSelection(key, true, [key], event.nativeEvent);
                }
                (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, event);
              }
            })),
            checked
          };
        };
      } else {
        renderCell = (_, record, index3) => {
          var _a2;
          const key = getRowKey(record, index3);
          const checked = keySet.has(key);
          const indeterminate = derivedHalfSelectedKeySet.has(key);
          const checkboxProps = checkboxPropsMap.get(key);
          let mergedIndeterminate;
          if (expandType === "nest") {
            mergedIndeterminate = indeterminate;
            true ? warning6(typeof (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== "boolean", "usage", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.") : void 0;
          } else {
            mergedIndeterminate = (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a2 !== void 0 ? _a2 : indeterminate;
          }
          return {
            node: /* @__PURE__ */ React373.createElement(checkbox_default, Object.assign({}, checkboxProps, {
              indeterminate: mergedIndeterminate,
              checked,
              skipGroup: true,
              onClick: (e3) => {
                var _a3;
                e3.stopPropagation();
                (_a3 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(checkboxProps, e3);
              },
              onChange: (event) => {
                var _a3;
                const {
                  nativeEvent
                } = event;
                const {
                  shiftKey
                } = nativeEvent;
                const currentSelectedIndex = recordKeys.findIndex((item) => item === key);
                const isMultiple3 = derivedSelectedKeys.some((item) => recordKeys.includes(item));
                if (shiftKey && checkStrictly && isMultiple3) {
                  const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet);
                  const keys2 = Array.from(keySet);
                  onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
                  setSelectedKeys(keys2, "multiple");
                } else {
                  const originCheckedKeys = derivedSelectedKeys;
                  if (checkStrictly) {
                    const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                    triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                  } else {
                    const result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
                    const {
                      checkedKeys,
                      halfCheckedKeys
                    } = result;
                    let nextCheckedKeys = checkedKeys;
                    if (checked) {
                      const tempKeySet = new Set(checkedKeys);
                      tempKeySet.delete(key);
                      nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                        checked: false,
                        halfCheckedKeys
                      }, keyEntities, isCheckboxDisabled).checkedKeys;
                    }
                    triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                  }
                }
                if (checked) {
                  updatePrevSelectedIndex(null);
                } else {
                  updatePrevSelectedIndex(currentSelectedIndex);
                }
                (_a3 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(checkboxProps, event);
              }
            })),
            checked
          };
        };
      }
      const renderSelectionCell = (_, record, index3) => {
        const {
          node: node2,
          checked
        } = renderCell(_, record, index3);
        if (customizeRenderCell) {
          return customizeRenderCell(checked, record, index3, node2);
        }
        return node2;
      };
      if (!cloneColumns.includes(SELECTION_COLUMN)) {
        if (cloneColumns.findIndex((col) => {
          var _a2;
          return ((_a2 = col[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
        }) === 0) {
          const [expandColumn, ...restColumns] = cloneColumns;
          cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
        } else {
          cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
        }
      }
      const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
      true ? warning6(cloneColumns.filter((col) => col === SELECTION_COLUMN).length <= 1, "usage", "Multiple `SELECTION_COLUMN` exist in `columns`.") : void 0;
      cloneColumns = cloneColumns.filter((column2, index3) => column2 !== SELECTION_COLUMN || index3 === selectionColumnIndex);
      const prevCol = cloneColumns[selectionColumnIndex - 1];
      const nextCol = cloneColumns[selectionColumnIndex + 1];
      let mergedFixed = fixed;
      if (mergedFixed === void 0) {
        if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
          mergedFixed = nextCol.fixed;
        } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
          mergedFixed = prevCol.fixed;
        }
      }
      if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
        prevCol.fixed = mergedFixed;
      }
      const columnCls = (0, import_classnames137.default)(`${prefixCls}-selection-col`, {
        [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox"
      });
      const renderColumnTitle2 = () => {
        if (!(rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.columnTitle)) {
          return title;
        }
        if (typeof rowSelection.columnTitle === "function") {
          return rowSelection.columnTitle(columnTitleCheckbox);
        }
        return rowSelection.columnTitle;
      };
      const selectionColumn = {
        fixed: mergedFixed,
        width: selectionColWidth,
        className: `${prefixCls}-selection-column`,
        title: renderColumnTitle2(),
        render: renderSelectionCell,
        onCell: rowSelection.onCell,
        align: rowSelection.align,
        [INTERNAL_COL_DEFINE]: {
          className: columnCls
        }
      };
      return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
    }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
    return [transformColumns, derivedSelectedKeySet];
  };
  var useSelection_default = useSelection;

  // node_modules/antd/es/table/InternalTable.js
  var React392 = __toESM(require_react());
  var import_classnames146 = __toESM(require_classnames());

  // node_modules/antd/es/_util/hooks/useProxyImperativeHandle.js
  var import_react117 = __toESM(require_react());
  function fillProxy(element, handler) {
    element._antProxy = element._antProxy || {};
    Object.keys(handler).forEach((key) => {
      if (!(key in element._antProxy)) {
        const ori = element[key];
        element._antProxy[key] = ori;
        element[key] = handler[key];
      }
    });
    return element;
  }
  function useProxyImperativeHandle(ref, init) {
    return (0, import_react117.useImperativeHandle)(ref, () => {
      const refObj = init();
      const {
        nativeElement
      } = refObj;
      if (typeof Proxy !== "undefined") {
        return new Proxy(nativeElement, {
          get(obj, prop) {
            if (refObj[prop]) {
              return refObj[prop];
            }
            return Reflect.get(obj, prop);
          }
        });
      }
      return fillProxy(nativeElement, refObj);
    });
  }

  // node_modules/antd/es/table/ExpandIcon.js
  var React374 = __toESM(require_react());
  var import_classnames138 = __toESM(require_classnames());
  function renderExpandIcon2(locale6) {
    return (props) => {
      const {
        prefixCls,
        onExpand,
        record,
        expanded,
        expandable
      } = props;
      const iconPrefix = `${prefixCls}-row-expand-icon`;
      return /* @__PURE__ */ React374.createElement("button", {
        type: "button",
        onClick: (e3) => {
          onExpand(record, e3);
          e3.stopPropagation();
        },
        className: (0, import_classnames138.default)(iconPrefix, {
          [`${iconPrefix}-spaced`]: !expandable,
          [`${iconPrefix}-expanded`]: expandable && expanded,
          [`${iconPrefix}-collapsed`]: expandable && !expanded
        }),
        "aria-label": expanded ? locale6.collapse : locale6.expand,
        "aria-expanded": expanded
      });
    };
  }
  var ExpandIcon_default = renderExpandIcon2;

  // node_modules/antd/es/table/hooks/useContainerWidth.js
  function useContainerWidth(prefixCls) {
    const getContainerWidth = (ele, width) => {
      const container = ele.querySelector(`.${prefixCls}-container`);
      let returnWidth = width;
      if (container) {
        const style2 = getComputedStyle(container);
        const borderLeft = parseInt(style2.borderLeftWidth, 10);
        const borderRight = parseInt(style2.borderRightWidth, 10);
        returnWidth = width - borderLeft - borderRight;
      }
      return returnWidth;
    };
    return getContainerWidth;
  }

  // node_modules/antd/es/table/hooks/useFilter/index.js
  var React388 = __toESM(require_react());

  // node_modules/antd/es/table/util.js
  var getColumnKey = (column2, defaultKey) => {
    if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
      return column2.key;
    }
    if (column2.dataIndex) {
      return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
    }
    return defaultKey;
  };
  function getColumnPos(index3, pos) {
    return pos ? `${pos}-${index3}` : `${index3}`;
  }
  var renderColumnTitle = (title, props) => {
    if (typeof title === "function") {
      return title(props);
    }
    return title;
  };
  var safeColumnTitle = (title, props) => {
    const res = renderColumnTitle(title, props);
    if (Object.prototype.toString.call(res) === "[object Object]") {
      return "";
    }
    return res;
  };

  // node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
  var React387 = __toESM(require_react());
  var import_classnames144 = __toESM(require_classnames());

  // node_modules/antd/es/_util/hooks/useSyncState.js
  var React375 = __toESM(require_react());
  function useSyncState3(initialValue) {
    const ref = React375.useRef(initialValue);
    const forceUpdate = useForceUpdate();
    return [() => ref.current, (newValue) => {
      ref.current = newValue;
      forceUpdate();
    }];
  }

  // node_modules/rc-tree/es/Tree.js
  var import_classnames140 = __toESM(require_classnames());
  var React380 = __toESM(require_react());

  // node_modules/rc-tree/es/DropIndicator.js
  var import_react118 = __toESM(require_react());
  var DropIndicator = function DropIndicator2(props) {
    var dropPosition = props.dropPosition, dropLevelOffset = props.dropLevelOffset, indent = props.indent;
    var style2 = {
      pointerEvents: "none",
      position: "absolute",
      right: 0,
      backgroundColor: "red",
      height: 2
    };
    switch (dropPosition) {
      case -1:
        style2.top = 0;
        style2.left = -dropLevelOffset * indent;
        break;
      case 1:
        style2.bottom = 0;
        style2.left = -dropLevelOffset * indent;
        break;
      case 0:
        style2.bottom = 0;
        style2.left = indent;
        break;
    }
    return /* @__PURE__ */ import_react118.default.createElement("div", {
      style: style2
    });
  };
  if (true) {
    DropIndicator.displayName = "DropIndicator";
  }
  var DropIndicator_default = DropIndicator;

  // node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js
  function _objectDestructuringEmpty(t2) {
    if (null == t2) throw new TypeError("Cannot destructure " + t2);
  }

  // node_modules/rc-tree/es/NodeList.js
  var React379 = __toESM(require_react());

  // node_modules/rc-tree/es/MotionTreeNode.js
  var import_classnames139 = __toESM(require_classnames());
  var React378 = __toESM(require_react());

  // node_modules/rc-tree/es/useUnmount.js
  var React377 = __toESM(require_react());
  function useUnmount(triggerStart, triggerEnd) {
    var _React$useState = React377.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), firstMount = _React$useState2[0], setFirstMount = _React$useState2[1];
    useLayoutEffect_default(function() {
      if (firstMount) {
        triggerStart();
        return function() {
          triggerEnd();
        };
      }
    }, [firstMount]);
    useLayoutEffect_default(function() {
      setFirstMount(true);
      return function() {
        setFirstMount(false);
      };
    }, []);
  }
  var useUnmount_default = useUnmount;

  // node_modules/rc-tree/es/MotionTreeNode.js
  var _excluded56 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];
  var MotionTreeNode = /* @__PURE__ */ React378.forwardRef(function(oriProps, ref) {
    var className = oriProps.className, style2 = oriProps.style, motion2 = oriProps.motion, motionNodes = oriProps.motionNodes, motionType = oriProps.motionType, onOriginMotionStart = oriProps.onMotionStart, onOriginMotionEnd = oriProps.onMotionEnd, active = oriProps.active, treeNodeRequiredProps = oriProps.treeNodeRequiredProps, props = _objectWithoutProperties(oriProps, _excluded56);
    var _React$useState = React378.useState(true), _React$useState2 = _slicedToArray(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
    var _React$useContext = React378.useContext(TreeContext), prefixCls = _React$useContext.prefixCls;
    var targetVisible = motionNodes && motionType !== "hide";
    useLayoutEffect_default(function() {
      if (motionNodes) {
        if (targetVisible !== visible) {
          setVisible(targetVisible);
        }
      }
    }, [motionNodes]);
    var triggerMotionStart = function triggerMotionStart2() {
      if (motionNodes) {
        onOriginMotionStart();
      }
    };
    var triggerMotionEndRef = React378.useRef(false);
    var triggerMotionEnd = function triggerMotionEnd2() {
      if (motionNodes && !triggerMotionEndRef.current) {
        triggerMotionEndRef.current = true;
        onOriginMotionEnd();
      }
    };
    useUnmount_default(triggerMotionStart, triggerMotionEnd);
    var onVisibleChanged = function onVisibleChanged2(nextVisible) {
      if (targetVisible === nextVisible) {
        triggerMotionEnd();
      }
    };
    if (motionNodes) {
      return /* @__PURE__ */ React378.createElement(es_default2, _extends({
        ref,
        visible
      }, motion2, {
        motionAppear: motionType === "show",
        onVisibleChanged
      }), function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        return /* @__PURE__ */ React378.createElement("div", {
          ref: motionRef,
          className: (0, import_classnames139.default)("".concat(prefixCls, "-treenode-motion"), motionClassName),
          style: motionStyle
        }, motionNodes.map(function(treeNode) {
          var restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
          delete restProps.children;
          var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
          return /* @__PURE__ */ React378.createElement(TreeNode_default, _extends({}, restProps, treeNodeProps, {
            title,
            active,
            data: treeNode.data,
            key,
            isStart,
            isEnd
          }));
        }));
      });
    }
    return /* @__PURE__ */ React378.createElement(TreeNode_default, _extends({
      domRef: ref,
      className,
      style: style2
    }, props, {
      active
    }));
  });
  if (true) {
    MotionTreeNode.displayName = "MotionTreeNode";
  }
  var MotionTreeNode_default = MotionTreeNode;

  // node_modules/rc-tree/es/utils/diffUtil.js
  function findExpandedKeys() {
    var prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var prevLen = prev2.length;
    var nextLen = next2.length;
    if (Math.abs(prevLen - nextLen) !== 1) {
      return {
        add: false,
        key: null
      };
    }
    function find(shorter, longer) {
      var cache = /* @__PURE__ */ new Map();
      shorter.forEach(function(key) {
        cache.set(key, true);
      });
      var keys2 = longer.filter(function(key) {
        return !cache.has(key);
      });
      return keys2.length === 1 ? keys2[0] : null;
    }
    if (prevLen < nextLen) {
      return {
        add: true,
        key: find(prev2, next2)
      };
    }
    return {
      add: false,
      key: find(next2, prev2)
    };
  }
  function getExpandRange(shorter, longer, key) {
    var shorterStartIndex = shorter.findIndex(function(data) {
      return data.key === key;
    });
    var shorterEndNode = shorter[shorterStartIndex + 1];
    var longerStartIndex = longer.findIndex(function(data) {
      return data.key === key;
    });
    if (shorterEndNode) {
      var longerEndIndex = longer.findIndex(function(data) {
        return data.key === shorterEndNode.key;
      });
      return longer.slice(longerStartIndex + 1, longerEndIndex);
    }
    return longer.slice(longerStartIndex + 1);
  }

  // node_modules/rc-tree/es/NodeList.js
  var _excluded57 = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "scrollWidth", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
  var HIDDEN_STYLE = {
    width: 0,
    height: 0,
    display: "flex",
    overflow: "hidden",
    opacity: 0,
    border: 0,
    padding: 0,
    margin: 0
  };
  var noop4 = function noop5() {
  };
  var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
  var MotionNode = {
    key: MOTION_KEY
  };
  var MotionEntity = {
    key: MOTION_KEY,
    level: 0,
    index: 0,
    pos: "0",
    node: MotionNode,
    nodes: [MotionNode]
  };
  var MotionFlattenData = {
    parent: null,
    children: [],
    pos: MotionEntity.pos,
    data: MotionNode,
    title: null,
    key: MOTION_KEY,
    /** Hold empty list here since we do not use it */
    isStart: [],
    isEnd: []
  };
  function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
    if (virtual === false || !height) {
      return list;
    }
    return list.slice(0, Math.ceil(height / itemHeight) + 1);
  }
  function itemKey2(item) {
    var key = item.key, pos = item.pos;
    return getKey2(key, pos);
  }
  function getAccessibilityPath(item) {
    var path2 = String(item.data.key);
    var current = item;
    while (current.parent) {
      current = current.parent;
      path2 = "".concat(current.data.key, " > ").concat(path2);
    }
    return path2;
  }
  var NodeList = /* @__PURE__ */ React379.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, data = props.data, selectable = props.selectable, checkable = props.checkable, expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion2 = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, scrollWidth = props.scrollWidth, focusable2 = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, onBlur = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties(props, _excluded57);
    var listRef = React379.useRef(null);
    var indentMeasurerRef = React379.useRef(null);
    React379.useImperativeHandle(ref, function() {
      return {
        scrollTo: function scrollTo2(scroll) {
          listRef.current.scrollTo(scroll);
        },
        getIndentWidth: function getIndentWidth() {
          return indentMeasurerRef.current.offsetWidth;
        }
      };
    });
    var _React$useState = React379.useState(expandedKeys), _React$useState2 = _slicedToArray(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
    var _React$useState3 = React379.useState(data), _React$useState4 = _slicedToArray(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
    var _React$useState5 = React379.useState(data), _React$useState6 = _slicedToArray(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
    var _React$useState7 = React379.useState([]), _React$useState8 = _slicedToArray(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
    var _React$useState9 = React379.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
    var dataRef = React379.useRef(data);
    dataRef.current = data;
    function onMotionEnd() {
      var latestData = dataRef.current;
      setPrevData(latestData);
      setTransitionData(latestData);
      setTransitionRange([]);
      setMotionType(null);
      onListChangeEnd();
    }
    useLayoutEffect_default(function() {
      setPrevExpandedKeys(expandedKeys);
      var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
      if (diffExpanded.key !== null) {
        if (diffExpanded.add) {
          var keyIndex2 = prevData.findIndex(function(_ref) {
            var key = _ref.key;
            return key === diffExpanded.key;
          });
          var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
          var newTransitionData = prevData.slice();
          newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
          setTransitionData(newTransitionData);
          setTransitionRange(rangeNodes);
          setMotionType("show");
        } else {
          var _keyIndex = data.findIndex(function(_ref2) {
            var key = _ref2.key;
            return key === diffExpanded.key;
          });
          var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
          var _newTransitionData = data.slice();
          _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
          setTransitionData(_newTransitionData);
          setTransitionRange(_rangeNodes);
          setMotionType("hide");
        }
      } else if (prevData !== data) {
        setPrevData(data);
        setTransitionData(data);
      }
    }, [expandedKeys, data]);
    React379.useEffect(function() {
      if (!dragging) {
        onMotionEnd();
      }
    }, [dragging]);
    var mergedData = motion2 ? transitionData : data;
    var treeNodeRequiredProps = {
      expandedKeys,
      selectedKeys,
      loadedKeys,
      loadingKeys,
      checkedKeys,
      halfCheckedKeys,
      dragOverNodeKey,
      dropPosition,
      keyEntities
    };
    return /* @__PURE__ */ React379.createElement(React379.Fragment, null, focused && activeItem && /* @__PURE__ */ React379.createElement("span", {
      style: HIDDEN_STYLE,
      "aria-live": "assertive"
    }, getAccessibilityPath(activeItem)), /* @__PURE__ */ React379.createElement("div", null, /* @__PURE__ */ React379.createElement("input", {
      style: HIDDEN_STYLE,
      disabled: focusable2 === false || disabled,
      tabIndex: focusable2 !== false ? tabIndex : null,
      onKeyDown: onKeyDown2,
      onFocus,
      onBlur,
      value: "",
      onChange: noop4,
      "aria-label": "for screen reader"
    })), /* @__PURE__ */ React379.createElement("div", {
      className: "".concat(prefixCls, "-treenode"),
      "aria-hidden": true,
      style: {
        position: "absolute",
        pointerEvents: "none",
        visibility: "hidden",
        height: 0,
        overflow: "hidden",
        border: 0,
        padding: 0
      }
    }, /* @__PURE__ */ React379.createElement("div", {
      className: "".concat(prefixCls, "-indent")
    }, /* @__PURE__ */ React379.createElement("div", {
      ref: indentMeasurerRef,
      className: "".concat(prefixCls, "-indent-unit")
    }))), /* @__PURE__ */ React379.createElement(es_default9, _extends({}, domProps, {
      data: mergedData,
      itemKey: itemKey2,
      height,
      fullHeight: false,
      virtual,
      itemHeight,
      scrollWidth,
      prefixCls: "".concat(prefixCls, "-list"),
      ref: listRef,
      role: "tree",
      onVisibleChange: function onVisibleChange(originList) {
        if (originList.every(function(item) {
          return itemKey2(item) !== MOTION_KEY;
        })) {
          onMotionEnd();
        }
      }
    }), function(treeNode) {
      var pos = treeNode.pos, restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
      var mergedKey = getKey2(key, pos);
      delete restProps.key;
      delete restProps.children;
      var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
      return /* @__PURE__ */ React379.createElement(MotionTreeNode_default, _extends({}, restProps, treeNodeProps, {
        title,
        active: !!activeItem && key === activeItem.key,
        pos,
        data: treeNode.data,
        isStart,
        isEnd,
        motion: motion2,
        motionNodes: key === MOTION_KEY ? transitionRange : null,
        motionType,
        onMotionStart: onListChangeStart,
        onMotionEnd,
        treeNodeRequiredProps,
        onMouseMove: function onMouseMove() {
          onActiveChange(null);
        }
      }));
    }));
  });
  if (true) {
    NodeList.displayName = "NodeList";
  }
  var NodeList_default = NodeList;

  // node_modules/rc-tree/es/Tree.js
  var MAX_RETRY_TIMES = 10;
  var Tree = /* @__PURE__ */ function(_React$Component) {
    _inherits(Tree4, _React$Component);
    var _super = _createSuper(Tree4);
    function Tree4() {
      var _this;
      _classCallCheck(this, Tree4);
      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(_args));
      _defineProperty(_assertThisInitialized(_this), "destroyed", false);
      _defineProperty(_assertThisInitialized(_this), "delayedDragEnterLogic", void 0);
      _defineProperty(_assertThisInitialized(_this), "loadingRetryTimes", {});
      _defineProperty(_assertThisInitialized(_this), "state", {
        keyEntities: {},
        indent: null,
        selectedKeys: [],
        checkedKeys: [],
        halfCheckedKeys: [],
        loadedKeys: [],
        loadingKeys: [],
        expandedKeys: [],
        draggingNodeKey: null,
        dragChildrenKeys: [],
        // dropTargetKey is the key of abstract-drop-node
        // the abstract-drop-node is the real drop node when drag and drop
        // not the DOM drag over node
        dropTargetKey: null,
        dropPosition: null,
        // the drop position of abstract-drop-node, inside 0, top -1, bottom 1
        dropContainerKey: null,
        // the container key of abstract-drop-node if dropPosition is -1 or 1
        dropLevelOffset: null,
        // the drop level offset of abstract-drag-over-node
        dropTargetPos: null,
        // the pos of abstract-drop-node
        dropAllowed: true,
        // if drop to abstract-drop-node is allowed
        // the abstract-drag-over-node
        // if mouse is on the bottom of top dom node or no the top of the bottom dom node
        // abstract-drag-over-node is the top node
        dragOverNodeKey: null,
        treeData: [],
        flattenNodes: [],
        focused: false,
        activeKey: null,
        listChanging: false,
        prevProps: null,
        fieldNames: fillFieldNames2()
      });
      _defineProperty(_assertThisInitialized(_this), "dragStartMousePosition", null);
      _defineProperty(_assertThisInitialized(_this), "dragNodeProps", null);
      _defineProperty(_assertThisInitialized(_this), "currentMouseOverDroppableNodeKey", null);
      _defineProperty(_assertThisInitialized(_this), "listRef", /* @__PURE__ */ React380.createRef());
      _defineProperty(_assertThisInitialized(_this), "onNodeDragStart", function(event, nodeProps) {
        var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
        var onDragStart = _this.props.onDragStart;
        var eventKey = nodeProps.eventKey;
        _this.dragNodeProps = nodeProps;
        _this.dragStartMousePosition = {
          x: event.clientX,
          y: event.clientY
        };
        var newExpandedKeys = arrDel(expandedKeys, eventKey);
        _this.setState({
          draggingNodeKey: eventKey,
          dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
          indent: _this.listRef.current.getIndentWidth()
        });
        _this.setExpandedKeys(newExpandedKeys);
        window.addEventListener("dragend", _this.onWindowDragEnd);
        onDragStart === null || onDragStart === void 0 || onDragStart({
          event,
          node: convertNodePropsToEventData(nodeProps)
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeDragEnter", function(event, nodeProps) {
        var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
        var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop2 = _this$props.allowDrop, direction = _this$props.direction;
        var pos = nodeProps.pos, eventKey = nodeProps.eventKey;
        if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
          _this.currentMouseOverDroppableNodeKey = eventKey;
        }
        if (!_this.dragNodeProps) {
          _this.resetDragState();
          return;
        }
        var _calcDropPosition = calcDropPosition(event, _this.dragNodeProps, nodeProps, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
        if (
          // don't allow drop inside its children
          dragChildrenKeys.includes(dropTargetKey) || // don't allow drop when drop is not allowed caculated by calcDropPosition
          !dropAllowed
        ) {
          _this.resetDragState();
          return;
        }
        if (!_this.delayedDragEnterLogic) {
          _this.delayedDragEnterLogic = {};
        }
        Object.keys(_this.delayedDragEnterLogic).forEach(function(key) {
          clearTimeout(_this.delayedDragEnterLogic[key]);
        });
        if (_this.dragNodeProps.eventKey !== nodeProps.eventKey) {
          event.persist();
          _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
            if (_this.state.draggingNodeKey === null) {
              return;
            }
            var newExpandedKeys = _toConsumableArray(expandedKeys);
            var entity = getEntity(keyEntities, nodeProps.eventKey);
            if (entity && (entity.children || []).length) {
              newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);
            }
            if (!_this.props.hasOwnProperty("expandedKeys")) {
              _this.setExpandedKeys(newExpandedKeys);
            }
            onExpand === null || onExpand === void 0 || onExpand(newExpandedKeys, {
              node: convertNodePropsToEventData(nodeProps),
              expanded: true,
              nativeEvent: event.nativeEvent
            });
          }, 800);
        }
        if (_this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
          _this.resetDragState();
          return;
        }
        _this.setState({
          dragOverNodeKey,
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed
        });
        onDragEnter === null || onDragEnter === void 0 || onDragEnter({
          event,
          node: convertNodePropsToEventData(nodeProps),
          expandedKeys
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeDragOver", function(event, nodeProps) {
        var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
        var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop2 = _this$props2.allowDrop, direction = _this$props2.direction;
        if (!_this.dragNodeProps) {
          return;
        }
        var _calcDropPosition2 = calcDropPosition(event, _this.dragNodeProps, nodeProps, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropTargetPos = _calcDropPosition2.dropTargetPos, dropAllowed = _calcDropPosition2.dropAllowed, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
        if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {
          return;
        }
        if (_this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
          if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
            _this.resetDragState();
          }
        } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
          _this.setState({
            dropPosition,
            dropLevelOffset,
            dropTargetKey,
            dropContainerKey,
            dropTargetPos,
            dropAllowed,
            dragOverNodeKey
          });
        }
        onDragOver === null || onDragOver === void 0 || onDragOver({
          event,
          node: convertNodePropsToEventData(nodeProps)
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeDragLeave", function(event, nodeProps) {
        if (_this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
          _this.resetDragState();
          _this.currentMouseOverDroppableNodeKey = null;
        }
        var onDragLeave = _this.props.onDragLeave;
        onDragLeave === null || onDragLeave === void 0 || onDragLeave({
          event,
          node: convertNodePropsToEventData(nodeProps)
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onWindowDragEnd", function(event) {
        _this.onNodeDragEnd(event, null, true);
        window.removeEventListener("dragend", _this.onWindowDragEnd);
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeDragEnd", function(event, nodeProps) {
        var onDragEnd = _this.props.onDragEnd;
        _this.setState({
          dragOverNodeKey: null
        });
        _this.cleanDragState();
        onDragEnd === null || onDragEnd === void 0 || onDragEnd({
          event,
          node: convertNodePropsToEventData(nodeProps)
        });
        _this.dragNodeProps = null;
        window.removeEventListener("dragend", _this.onWindowDragEnd);
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeDrop", function(event, _) {
        var _this$getActiveItem;
        var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
        if (!dropAllowed) {
          return;
        }
        var onDrop = _this.props.onDrop;
        _this.setState({
          dragOverNodeKey: null
        });
        _this.cleanDragState();
        if (dropTargetKey === null) return;
        var abstractDropNodeProps = _objectSpread2(_objectSpread2({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
          active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
          data: getEntity(_this.state.keyEntities, dropTargetKey).node
        });
        var dropToChild = dragChildrenKeys.includes(dropTargetKey);
        warning_default(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
        var posArr = posToArr(dropTargetPos);
        var dropResult = {
          event,
          node: convertNodePropsToEventData(abstractDropNodeProps),
          dragNode: _this.dragNodeProps ? convertNodePropsToEventData(_this.dragNodeProps) : null,
          dragNodesKeys: [_this.dragNodeProps.eventKey].concat(dragChildrenKeys),
          dropToGap: dropPosition !== 0,
          dropPosition: dropPosition + Number(posArr[posArr.length - 1])
        };
        if (!outsideTree) {
          onDrop === null || onDrop === void 0 || onDrop(dropResult);
        }
        _this.dragNodeProps = null;
      });
      _defineProperty(_assertThisInitialized(_this), "cleanDragState", function() {
        var draggingNodeKey = _this.state.draggingNodeKey;
        if (draggingNodeKey !== null) {
          _this.setState({
            draggingNodeKey: null,
            dropPosition: null,
            dropContainerKey: null,
            dropTargetKey: null,
            dropLevelOffset: null,
            dropAllowed: true,
            dragOverNodeKey: null
          });
        }
        _this.dragStartMousePosition = null;
        _this.currentMouseOverDroppableNodeKey = null;
      });
      _defineProperty(_assertThisInitialized(_this), "triggerExpandActionExpand", function(e3, treeNode) {
        var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
        var expanded = treeNode.expanded, key = treeNode.key, isLeaf = treeNode.isLeaf;
        if (isLeaf || e3.shiftKey || e3.metaKey || e3.ctrlKey) {
          return;
        }
        var node2 = flattenNodes.filter(function(nodeItem) {
          return nodeItem.key === key;
        })[0];
        var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, {
          data: node2.data
        }));
        _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
        _this.onNodeExpand(e3, eventNode);
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeClick", function(e3, treeNode) {
        var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
        if (expandAction === "click") {
          _this.triggerExpandActionExpand(e3, treeNode);
        }
        onClick === null || onClick === void 0 || onClick(e3, treeNode);
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeDoubleClick", function(e3, treeNode) {
        var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
        if (expandAction === "doubleClick") {
          _this.triggerExpandActionExpand(e3, treeNode);
        }
        onDoubleClick === null || onDoubleClick === void 0 || onDoubleClick(e3, treeNode);
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeSelect", function(e3, treeNode) {
        var selectedKeys = _this.state.selectedKeys;
        var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
        var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
        var selected = treeNode.selected;
        var key = treeNode[fieldNames.key];
        var targetSelected = !selected;
        if (!targetSelected) {
          selectedKeys = arrDel(selectedKeys, key);
        } else if (!multiple) {
          selectedKeys = [key];
        } else {
          selectedKeys = arrAdd(selectedKeys, key);
        }
        var selectedNodes = selectedKeys.map(function(selectedKey) {
          var entity = getEntity(keyEntities, selectedKey);
          return entity ? entity.node : null;
        }).filter(Boolean);
        _this.setUncontrolledState({
          selectedKeys
        });
        onSelect === null || onSelect === void 0 || onSelect(selectedKeys, {
          event: "select",
          selected: targetSelected,
          node: treeNode,
          selectedNodes,
          nativeEvent: e3.nativeEvent
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeCheck", function(e3, treeNode, checked) {
        var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
        var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
        var key = treeNode.key;
        var checkedObj;
        var eventObj = {
          event: "check",
          node: treeNode,
          checked,
          nativeEvent: e3.nativeEvent
        };
        if (checkStrictly) {
          var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
          var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
          checkedObj = {
            checked: checkedKeys,
            halfChecked: halfCheckedKeys
          };
          eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
            return getEntity(keyEntities, checkedKey);
          }).filter(Boolean).map(function(entity) {
            return entity.node;
          });
          _this.setUncontrolledState({
            checkedKeys
          });
        } else {
          var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
          if (!checked) {
            var keySet = new Set(_checkedKeys);
            keySet.delete(key);
            var _conductCheck2 = conductCheck(Array.from(keySet), {
              checked: false,
              halfCheckedKeys: _halfCheckedKeys
            }, keyEntities);
            _checkedKeys = _conductCheck2.checkedKeys;
            _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
          }
          checkedObj = _checkedKeys;
          eventObj.checkedNodes = [];
          eventObj.checkedNodesPositions = [];
          eventObj.halfCheckedKeys = _halfCheckedKeys;
          _checkedKeys.forEach(function(checkedKey) {
            var entity = getEntity(keyEntities, checkedKey);
            if (!entity) return;
            var node2 = entity.node, pos = entity.pos;
            eventObj.checkedNodes.push(node2);
            eventObj.checkedNodesPositions.push({
              node: node2,
              pos
            });
          });
          _this.setUncontrolledState({
            checkedKeys: _checkedKeys
          }, false, {
            halfCheckedKeys: _halfCheckedKeys
          });
        }
        onCheck === null || onCheck === void 0 || onCheck(checkedObj, eventObj);
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeLoad", function(treeNode) {
        var _entity$children;
        var key = treeNode.key;
        var keyEntities = _this.state.keyEntities;
        var entity = getEntity(keyEntities, key);
        if (entity !== null && entity !== void 0 && (_entity$children = entity.children) !== null && _entity$children !== void 0 && _entity$children.length) {
          return;
        }
        var loadPromise = new Promise(function(resolve, reject) {
          _this.setState(function(_ref) {
            var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
            var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
            if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {
              return null;
            }
            var promise = loadData(treeNode);
            promise.then(function() {
              var currentLoadedKeys = _this.state.loadedKeys;
              var newLoadedKeys = arrAdd(currentLoadedKeys, key);
              onLoad === null || onLoad === void 0 || onLoad(newLoadedKeys, {
                event: "load",
                node: treeNode
              });
              _this.setUncontrolledState({
                loadedKeys: newLoadedKeys
              });
              _this.setState(function(prevState) {
                return {
                  loadingKeys: arrDel(prevState.loadingKeys, key)
                };
              });
              resolve();
            }).catch(function(e3) {
              _this.setState(function(prevState) {
                return {
                  loadingKeys: arrDel(prevState.loadingKeys, key)
                };
              });
              _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
              if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
                var currentLoadedKeys = _this.state.loadedKeys;
                warning_default(false, "Retry for `loadData` many times but still failed. No more retry.");
                _this.setUncontrolledState({
                  loadedKeys: arrAdd(currentLoadedKeys, key)
                });
                resolve();
              }
              reject(e3);
            });
            return {
              loadingKeys: arrAdd(loadingKeys, key)
            };
          });
        });
        loadPromise.catch(function() {
        });
        return loadPromise;
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeMouseEnter", function(event, node2) {
        var onMouseEnter = _this.props.onMouseEnter;
        onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
          event,
          node: node2
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeMouseLeave", function(event, node2) {
        var onMouseLeave = _this.props.onMouseLeave;
        onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
          event,
          node: node2
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeContextMenu", function(event, node2) {
        var onRightClick = _this.props.onRightClick;
        if (onRightClick) {
          event.preventDefault();
          onRightClick({
            event,
            node: node2
          });
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onFocus", function() {
        var onFocus = _this.props.onFocus;
        _this.setState({
          focused: true
        });
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        onFocus === null || onFocus === void 0 || onFocus.apply(void 0, args);
      });
      _defineProperty(_assertThisInitialized(_this), "onBlur", function() {
        var onBlur = _this.props.onBlur;
        _this.setState({
          focused: false
        });
        _this.onActiveChange(null);
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        onBlur === null || onBlur === void 0 || onBlur.apply(void 0, args);
      });
      _defineProperty(_assertThisInitialized(_this), "getTreeNodeRequiredProps", function() {
        var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
        return {
          expandedKeys: expandedKeys || [],
          selectedKeys: selectedKeys || [],
          loadedKeys: loadedKeys || [],
          loadingKeys: loadingKeys || [],
          checkedKeys: checkedKeys || [],
          halfCheckedKeys: halfCheckedKeys || [],
          dragOverNodeKey,
          dropPosition,
          keyEntities
        };
      });
      _defineProperty(_assertThisInitialized(_this), "setExpandedKeys", function(expandedKeys) {
        var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
        var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
        _this.setUncontrolledState({
          expandedKeys,
          flattenNodes
        }, true);
      });
      _defineProperty(_assertThisInitialized(_this), "onNodeExpand", function(e3, treeNode) {
        var expandedKeys = _this.state.expandedKeys;
        var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
        var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
        var expanded = treeNode.expanded;
        var key = treeNode[fieldNames.key];
        if (listChanging) {
          return;
        }
        var certain = expandedKeys.includes(key);
        var targetExpanded = !expanded;
        warning_default(expanded && certain || !expanded && !certain, "Expand state not sync with index check");
        expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);
        _this.setExpandedKeys(expandedKeys);
        onExpand === null || onExpand === void 0 || onExpand(expandedKeys, {
          node: treeNode,
          expanded: targetExpanded,
          nativeEvent: e3.nativeEvent
        });
        if (targetExpanded && loadData) {
          var loadPromise = _this.onNodeLoad(treeNode);
          if (loadPromise) {
            loadPromise.then(function() {
              var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
              _this.setUncontrolledState({
                flattenNodes: newFlattenTreeData
              });
            }).catch(function() {
              var currentExpandedKeys = _this.state.expandedKeys;
              var expandedKeysToRestore = arrDel(currentExpandedKeys, key);
              _this.setExpandedKeys(expandedKeysToRestore);
            });
          }
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onListChangeStart", function() {
        _this.setUncontrolledState({
          listChanging: true
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onListChangeEnd", function() {
        setTimeout(function() {
          _this.setUncontrolledState({
            listChanging: false
          });
        });
      });
      _defineProperty(_assertThisInitialized(_this), "onActiveChange", function(newActiveKey) {
        var activeKey = _this.state.activeKey;
        var _this$props9 = _this.props, onActiveChange = _this$props9.onActiveChange, _this$props9$itemScro = _this$props9.itemScrollOffset, itemScrollOffset = _this$props9$itemScro === void 0 ? 0 : _this$props9$itemScro;
        if (activeKey === newActiveKey) {
          return;
        }
        _this.setState({
          activeKey: newActiveKey
        });
        if (newActiveKey !== null) {
          _this.scrollTo({
            key: newActiveKey,
            offset: itemScrollOffset
          });
        }
        onActiveChange === null || onActiveChange === void 0 || onActiveChange(newActiveKey);
      });
      _defineProperty(_assertThisInitialized(_this), "getActiveItem", function() {
        var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
        if (activeKey === null) {
          return null;
        }
        return flattenNodes.find(function(_ref2) {
          var key = _ref2.key;
          return key === activeKey;
        }) || null;
      });
      _defineProperty(_assertThisInitialized(_this), "offsetActiveKey", function(offset3) {
        var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
        var index3 = flattenNodes.findIndex(function(_ref3) {
          var key = _ref3.key;
          return key === activeKey;
        });
        if (index3 === -1 && offset3 < 0) {
          index3 = flattenNodes.length;
        }
        index3 = (index3 + offset3 + flattenNodes.length) % flattenNodes.length;
        var item = flattenNodes[index3];
        if (item) {
          var _key4 = item.key;
          _this.onActiveChange(_key4);
        } else {
          _this.onActiveChange(null);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onKeyDown", function(event) {
        var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
        var _this$props10 = _this.props, onKeyDown2 = _this$props10.onKeyDown, checkable = _this$props10.checkable, selectable = _this$props10.selectable;
        switch (event.which) {
          case KeyCode_default.UP: {
            _this.offsetActiveKey(-1);
            event.preventDefault();
            break;
          }
          case KeyCode_default.DOWN: {
            _this.offsetActiveKey(1);
            event.preventDefault();
            break;
          }
        }
        var activeItem = _this.getActiveItem();
        if (activeItem && activeItem.data) {
          var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
          var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
          var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
            data: activeItem.data,
            active: true
          }));
          switch (event.which) {
            // >>> Expand
            case KeyCode_default.LEFT: {
              if (expandable && expandedKeys.includes(activeKey)) {
                _this.onNodeExpand({}, eventNode);
              } else if (activeItem.parent) {
                _this.onActiveChange(activeItem.parent.key);
              }
              event.preventDefault();
              break;
            }
            case KeyCode_default.RIGHT: {
              if (expandable && !expandedKeys.includes(activeKey)) {
                _this.onNodeExpand({}, eventNode);
              } else if (activeItem.children && activeItem.children.length) {
                _this.onActiveChange(activeItem.children[0].key);
              }
              event.preventDefault();
              break;
            }
            // Selection
            case KeyCode_default.ENTER:
            case KeyCode_default.SPACE: {
              if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
                _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
              } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
                _this.onNodeSelect({}, eventNode);
              }
              break;
            }
          }
        }
        onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(event);
      });
      _defineProperty(_assertThisInitialized(_this), "setUncontrolledState", function(state) {
        var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (!_this.destroyed) {
          var needSync = false;
          var allPassed = true;
          var newState = {};
          Object.keys(state).forEach(function(name) {
            if (_this.props.hasOwnProperty(name)) {
              allPassed = false;
              return;
            }
            needSync = true;
            newState[name] = state[name];
          });
          if (needSync && (!atomic || allPassed)) {
            _this.setState(_objectSpread2(_objectSpread2({}, newState), forceState));
          }
        }
      });
      _defineProperty(_assertThisInitialized(_this), "scrollTo", function(scroll) {
        _this.listRef.current.scrollTo(scroll);
      });
      return _this;
    }
    _createClass(Tree4, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.destroyed = false;
        this.onUpdated();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.onUpdated();
      }
    }, {
      key: "onUpdated",
      value: function onUpdated() {
        var _this$props11 = this.props, activeKey = _this$props11.activeKey, _this$props11$itemScr = _this$props11.itemScrollOffset, itemScrollOffset = _this$props11$itemScr === void 0 ? 0 : _this$props11$itemScr;
        if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
          this.setState({
            activeKey
          });
          if (activeKey !== null) {
            this.scrollTo({
              key: activeKey,
              offset: itemScrollOffset
            });
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        window.removeEventListener("dragend", this.onWindowDragEnd);
        this.destroyed = true;
      }
    }, {
      key: "resetDragState",
      value: function resetDragState() {
        this.setState({
          dragOverNodeKey: null,
          dropPosition: null,
          dropLevelOffset: null,
          dropTargetKey: null,
          dropContainerKey: null,
          dropTargetPos: null,
          dropAllowed: false
        });
      }
    }, {
      key: "render",
      value: function render4() {
        var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
        var _this$props12 = this.props, prefixCls = _this$props12.prefixCls, className = _this$props12.className, style2 = _this$props12.style, showLine = _this$props12.showLine, focusable2 = _this$props12.focusable, _this$props12$tabInde = _this$props12.tabIndex, tabIndex = _this$props12$tabInde === void 0 ? 0 : _this$props12$tabInde, selectable = _this$props12.selectable, showIcon = _this$props12.showIcon, icon = _this$props12.icon, switcherIcon = _this$props12.switcherIcon, draggable = _this$props12.draggable, checkable = _this$props12.checkable, checkStrictly = _this$props12.checkStrictly, disabled = _this$props12.disabled, motion2 = _this$props12.motion, loadData = _this$props12.loadData, filterTreeNode = _this$props12.filterTreeNode, height = _this$props12.height, itemHeight = _this$props12.itemHeight, scrollWidth = _this$props12.scrollWidth, virtual = _this$props12.virtual, titleRender = _this$props12.titleRender, dropIndicatorRender2 = _this$props12.dropIndicatorRender, onContextMenu = _this$props12.onContextMenu, onScroll = _this$props12.onScroll, direction = _this$props12.direction, rootClassName = _this$props12.rootClassName, rootStyle = _this$props12.rootStyle;
        var domProps = pickAttrs(this.props, {
          aria: true,
          data: true
        });
        var draggableConfig;
        if (draggable) {
          if (_typeof(draggable) === "object") {
            draggableConfig = draggable;
          } else if (typeof draggable === "function") {
            draggableConfig = {
              nodeDraggable: draggable
            };
          } else {
            draggableConfig = {};
          }
        }
        var contextValue = {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          checkStrictly,
          disabled,
          keyEntities,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          indent,
          direction,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          titleRender,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          onNodeLoad: this.onNodeLoad,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop
        };
        return /* @__PURE__ */ React380.createElement(TreeContext.Provider, {
          value: contextValue
        }, /* @__PURE__ */ React380.createElement("div", {
          className: (0, import_classnames140.default)(prefixCls, className, rootClassName, _defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-show-line"), showLine), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-active-focused"), activeKey !== null)),
          style: rootStyle
        }, /* @__PURE__ */ React380.createElement(NodeList_default, _extends({
          ref: this.listRef,
          prefixCls,
          style: style2,
          data: flattenNodes,
          disabled,
          selectable,
          checkable: !!checkable,
          motion: motion2,
          dragging: draggingNodeKey !== null,
          height,
          itemHeight,
          virtual,
          focusable: focusable2,
          focused,
          tabIndex,
          activeItem: this.getActiveItem(),
          onFocus: this.onFocus,
          onBlur: this.onBlur,
          onKeyDown: this.onKeyDown,
          onActiveChange: this.onActiveChange,
          onListChangeStart: this.onListChangeStart,
          onListChangeEnd: this.onListChangeEnd,
          onContextMenu,
          onScroll,
          scrollWidth
        }, this.getTreeNodeRequiredProps(), domProps))));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, prevState) {
        var prevProps = prevState.prevProps;
        var newState = {
          prevProps: props
        };
        function needSync(name) {
          return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];
        }
        var treeData;
        var fieldNames = prevState.fieldNames;
        if (needSync("fieldNames")) {
          fieldNames = fillFieldNames2(props.fieldNames);
          newState.fieldNames = fieldNames;
        }
        if (needSync("treeData")) {
          treeData = props.treeData;
        } else if (needSync("children")) {
          warning_default(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
          treeData = convertTreeToData(props.children);
        }
        if (treeData) {
          newState.treeData = treeData;
          var entitiesMap = convertDataToEntities(treeData, {
            fieldNames
          });
          newState.keyEntities = _objectSpread2(_defineProperty({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
          if (true) {
            warningWithoutKey(treeData, fieldNames);
          }
        }
        var keyEntities = newState.keyEntities || prevState.keyEntities;
        if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
          newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
        } else if (!prevProps && props.defaultExpandAll) {
          var cloneKeyEntities = _objectSpread2({}, keyEntities);
          delete cloneKeyEntities[MOTION_KEY];
          var nextExpandedKeys = [];
          Object.keys(cloneKeyEntities).forEach(function(key) {
            var entity = cloneKeyEntities[key];
            if (entity.children && entity.children.length) {
              nextExpandedKeys.push(entity.key);
            }
          });
          newState.expandedKeys = nextExpandedKeys;
        } else if (!prevProps && props.defaultExpandedKeys) {
          newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
        }
        if (!newState.expandedKeys) {
          delete newState.expandedKeys;
        }
        if (treeData || newState.expandedKeys) {
          var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
          newState.flattenNodes = flattenNodes;
        }
        if (props.selectable) {
          if (needSync("selectedKeys")) {
            newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
          } else if (!prevProps && props.defaultSelectedKeys) {
            newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
          }
        }
        if (props.checkable) {
          var checkedKeyEntity;
          if (needSync("checkedKeys")) {
            checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
          } else if (!prevProps && props.defaultCheckedKeys) {
            checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
          } else if (treeData) {
            checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
              checkedKeys: prevState.checkedKeys,
              halfCheckedKeys: prevState.halfCheckedKeys
            };
          }
          if (checkedKeyEntity) {
            var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
            if (!props.checkStrictly) {
              var conductKeys = conductCheck(checkedKeys, true, keyEntities);
              checkedKeys = conductKeys.checkedKeys;
              halfCheckedKeys = conductKeys.halfCheckedKeys;
            }
            newState.checkedKeys = checkedKeys;
            newState.halfCheckedKeys = halfCheckedKeys;
          }
        }
        if (needSync("loadedKeys")) {
          newState.loadedKeys = props.loadedKeys;
        }
        return newState;
      }
    }]);
    return Tree4;
  }(React380.Component);
  _defineProperty(Tree, "defaultProps", {
    prefixCls: "rc-tree",
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: DropIndicator_default,
    allowDrop: function allowDrop() {
      return true;
    },
    expandAction: false
  });
  _defineProperty(Tree, "TreeNode", TreeNode_default);
  var Tree_default = Tree;

  // node_modules/rc-tree/es/index.js
  var es_default18 = Tree_default;

  // node_modules/antd/es/tree/DirectoryTree.js
  var React384 = __toESM(require_react());
  var import_classnames143 = __toESM(require_classnames());

  // node_modules/antd/es/tree/Tree.js
  var import_react120 = __toESM(require_react());
  var import_classnames142 = __toESM(require_classnames());

  // node_modules/antd/es/tree/style/directory.js
  var genDirectoryStyle = ({
    treeCls,
    treeNodeCls,
    directoryNodeSelectedBg,
    directoryNodeSelectedColor,
    motionDurationMid,
    borderRadius,
    controlItemBgHover
  }) => ({
    [`${treeCls}${treeCls}-directory ${treeNodeCls}`]: {
      // >>> Title
      [`${treeCls}-node-content-wrapper`]: {
        position: "static",
        [`&:has(${treeCls}-drop-indicator)`]: {
          position: "relative"
        },
        [`> *:not(${treeCls}-drop-indicator)`]: {
          position: "relative"
        },
        "&:hover": {
          background: "transparent"
        },
        // Expand interactive area to whole line
        "&:before": {
          position: "absolute",
          inset: 0,
          transition: `background-color ${motionDurationMid}`,
          content: '""',
          borderRadius
        },
        "&:hover:before": {
          background: controlItemBgHover
        }
      },
      [`${treeCls}-switcher, ${treeCls}-checkbox, ${treeCls}-draggable-icon`]: {
        zIndex: 1
      },
      // ============= Selected =============
      "&-selected": {
        background: directoryNodeSelectedBg,
        borderRadius,
        [`${treeCls}-switcher, ${treeCls}-draggable-icon`]: {
          color: directoryNodeSelectedColor
        },
        // >>> Title
        [`${treeCls}-node-content-wrapper`]: {
          color: directoryNodeSelectedColor,
          background: "transparent",
          "&:before, &:hover:before": {
            background: directoryNodeSelectedBg
          }
        }
      }
    }
  });

  // node_modules/antd/es/tree/style/index.js
  var treeNodeFX = new Keyframes_default("ant-tree-node-fx-do-not-use", {
    "0%": {
      opacity: 0
    },
    "100%": {
      opacity: 1
    }
  });
  var getSwitchStyle = (prefixCls, token2) => ({
    [`.${prefixCls}-switcher-icon`]: {
      display: "inline-block",
      fontSize: 10,
      verticalAlign: "baseline",
      svg: {
        transition: `transform ${token2.motionDurationSlow}`
      }
    }
  });
  var getDropIndicatorStyle = (prefixCls, token2) => ({
    [`.${prefixCls}-drop-indicator`]: {
      position: "absolute",
      // it should displayed over the following node
      zIndex: 1,
      height: 2,
      backgroundColor: token2.colorPrimary,
      borderRadius: 1,
      pointerEvents: "none",
      "&:after": {
        position: "absolute",
        top: -3,
        insetInlineStart: -6,
        width: 8,
        height: 8,
        backgroundColor: "transparent",
        border: `${unit(token2.lineWidthBold)} solid ${token2.colorPrimary}`,
        borderRadius: "50%",
        content: '""'
      }
    }
  });
  var genBaseStyle5 = (prefixCls, token2) => {
    const {
      treeCls,
      treeNodeCls,
      treeNodePadding,
      titleHeight,
      indentSize,
      nodeSelectedBg,
      nodeHoverBg,
      colorTextQuaternary,
      controlItemBgActiveDisabled
    } = token2;
    return {
      [treeCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        // fix https://github.com/ant-design/ant-design/issues/50316
        ["--rc-virtual-list-scrollbar-bg"]: token2.colorSplit,
        background: token2.colorBgContainer,
        borderRadius: token2.borderRadius,
        transition: `background-color ${token2.motionDurationSlow}`,
        "&-rtl": {
          direction: "rtl"
        },
        [`&${treeCls}-rtl ${treeCls}-switcher_close ${treeCls}-switcher-icon svg`]: {
          transform: "rotate(90deg)"
        },
        [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: Object.assign({}, genFocusOutline(token2)),
        // =================== Virtual List ===================
        [`${treeCls}-list-holder-inner`]: {
          alignItems: "flex-start"
        },
        [`&${treeCls}-block-node`]: {
          [`${treeCls}-list-holder-inner`]: {
            alignItems: "stretch",
            // >>> Title
            [`${treeCls}-node-content-wrapper`]: {
              flex: "auto"
            },
            // >>> Drag
            [`${treeNodeCls}.dragging:after`]: {
              position: "absolute",
              inset: 0,
              border: `1px solid ${token2.colorPrimary}`,
              opacity: 0,
              animationName: treeNodeFX,
              animationDuration: token2.motionDurationSlow,
              animationPlayState: "running",
              animationFillMode: "forwards",
              content: '""',
              pointerEvents: "none",
              borderRadius: token2.borderRadius
            }
          }
        },
        // ===================== TreeNode =====================
        [treeNodeCls]: {
          display: "flex",
          alignItems: "flex-start",
          marginBottom: treeNodePadding,
          lineHeight: unit(titleHeight),
          position: "relative",
          // 非常重要，避免 drop-indicator 在拖拽过程中闪烁
          "&:before": {
            content: '""',
            position: "absolute",
            zIndex: 1,
            insetInlineStart: 0,
            width: "100%",
            top: "100%",
            height: treeNodePadding
          },
          // Disabled
          [`&-disabled ${treeCls}-node-content-wrapper`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover": {
              background: "transparent"
            }
          },
          [`${treeCls}-checkbox-disabled + ${treeCls}-node-selected,&${treeNodeCls}-disabled${treeNodeCls}-selected ${treeCls}-node-content-wrapper`]: {
            backgroundColor: controlItemBgActiveDisabled
          },
          // we can not set pointer-events to none for checkbox in tree
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-2605234058
          [`${treeCls}-checkbox-disabled`]: {
            pointerEvents: "unset"
          },
          // not disable
          [`&:not(${treeNodeCls}-disabled)`]: {
            // >>> Title
            [`${treeCls}-node-content-wrapper`]: {
              "&:hover": {
                color: token2.nodeHoverColor
              }
            }
          },
          [`&-active ${treeCls}-node-content-wrapper`]: {
            background: token2.controlItemBgHover
          },
          [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
            color: token2.colorPrimary,
            fontWeight: token2.fontWeightStrong
          },
          "&-draggable": {
            cursor: "grab",
            [`${treeCls}-draggable-icon`]: {
              // https://github.com/ant-design/ant-design/issues/41915
              flexShrink: 0,
              width: titleHeight,
              textAlign: "center",
              visibility: "visible",
              color: colorTextQuaternary
            },
            [`&${treeNodeCls}-disabled ${treeCls}-draggable-icon`]: {
              visibility: "hidden"
            }
          }
        },
        // >>> Indent
        [`${treeCls}-indent`]: {
          alignSelf: "stretch",
          whiteSpace: "nowrap",
          userSelect: "none",
          "&-unit": {
            display: "inline-block",
            width: indentSize
          }
        },
        // >>> Drag Handler
        [`${treeCls}-draggable-icon`]: {
          visibility: "hidden"
        },
        // Switcher / Checkbox
        [`${treeCls}-switcher, ${treeCls}-checkbox`]: {
          marginInlineEnd: token2.calc(token2.calc(titleHeight).sub(token2.controlInteractiveSize)).div(2).equal()
        },
        // >>> Switcher
        [`${treeCls}-switcher`]: Object.assign(Object.assign({}, getSwitchStyle(prefixCls, token2)), {
          position: "relative",
          flex: "none",
          alignSelf: "stretch",
          width: titleHeight,
          textAlign: "center",
          cursor: "pointer",
          userSelect: "none",
          transition: `all ${token2.motionDurationSlow}`,
          "&-noop": {
            cursor: "unset"
          },
          "&:before": {
            pointerEvents: "none",
            content: '""',
            width: titleHeight,
            height: titleHeight,
            position: "absolute",
            left: {
              _skip_check_: true,
              value: 0
            },
            top: 0,
            borderRadius: token2.borderRadius,
            transition: `all ${token2.motionDurationSlow}`
          },
          [`&:not(${treeCls}-switcher-noop):hover:before`]: {
            backgroundColor: token2.colorBgTextHover
          },
          [`&_close ${treeCls}-switcher-icon svg`]: {
            transform: "rotate(-90deg)"
          },
          "&-loading-icon": {
            color: token2.colorPrimary
          },
          "&-leaf-line": {
            position: "relative",
            zIndex: 1,
            display: "inline-block",
            width: "100%",
            height: "100%",
            // https://github.com/ant-design/ant-design/issues/31884
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
              bottom: token2.calc(treeNodePadding).mul(-1).equal(),
              marginInlineStart: -1,
              borderInlineEnd: `1px solid ${token2.colorBorder}`,
              content: '""'
            },
            "&:after": {
              position: "absolute",
              width: token2.calc(token2.calc(titleHeight).div(2).equal()).mul(0.8).equal(),
              height: token2.calc(titleHeight).div(2).equal(),
              borderBottom: `1px solid ${token2.colorBorder}`,
              content: '""'
            }
          }
        }),
        // >>> Title
        // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
        [`${treeCls}-node-content-wrapper`]: Object.assign(Object.assign({
          position: "relative",
          minHeight: titleHeight,
          paddingBlock: 0,
          paddingInline: token2.paddingXS,
          background: "transparent",
          borderRadius: token2.borderRadius,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`
        }, getDropIndicatorStyle(prefixCls, token2)), {
          "&:hover": {
            backgroundColor: nodeHoverBg
          },
          [`&${treeCls}-node-selected`]: {
            color: token2.nodeSelectedColor,
            backgroundColor: nodeSelectedBg
          },
          // Icon
          [`${treeCls}-iconEle`]: {
            display: "inline-block",
            width: titleHeight,
            height: titleHeight,
            textAlign: "center",
            verticalAlign: "top",
            "&:empty": {
              display: "none"
            }
          }
        }),
        // https://github.com/ant-design/ant-design/issues/28217
        [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
          backgroundColor: "transparent"
        },
        [`${treeNodeCls}.drop-container > [draggable]`]: {
          boxShadow: `0 0 0 2px ${token2.colorPrimary}`
        },
        // ==================== Show Line =====================
        "&-show-line": {
          // ================ Indent lines ================
          [`${treeCls}-indent-unit`]: {
            position: "relative",
            height: "100%",
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
              bottom: token2.calc(treeNodePadding).mul(-1).equal(),
              borderInlineEnd: `1px solid ${token2.colorBorder}`,
              content: '""'
            },
            "&-end:before": {
              display: "none"
            }
          },
          // ============== Cover Background ==============
          [`${treeCls}-switcher`]: {
            background: "transparent",
            "&-line-icon": {
              // https://github.com/ant-design/ant-design/issues/32813
              verticalAlign: "-0.15em"
            }
          }
        },
        [`${treeNodeCls}-leaf-last ${treeCls}-switcher-leaf-line:before`]: {
          top: "auto !important",
          bottom: "auto !important",
          height: `${unit(token2.calc(titleHeight).div(2).equal())} !important`
        }
      })
    };
  };
  var genTreeStyle = (prefixCls, token2, enableDirectory = true) => {
    const treeCls = `.${prefixCls}`;
    const treeNodeCls = `${treeCls}-treenode`;
    const treeNodePadding = token2.calc(token2.paddingXS).div(2).equal();
    const treeToken = merge2(token2, {
      treeCls,
      treeNodeCls,
      treeNodePadding
    });
    return [
      // Basic
      genBaseStyle5(prefixCls, treeToken),
      // Directory
      enableDirectory && genDirectoryStyle(treeToken)
    ].filter(Boolean);
  };
  var initComponentToken2 = (token2) => {
    const {
      controlHeightSM,
      controlItemBgHover,
      controlItemBgActive
    } = token2;
    const titleHeight = controlHeightSM;
    return {
      titleHeight,
      indentSize: titleHeight,
      nodeHoverBg: controlItemBgHover,
      nodeHoverColor: token2.colorText,
      nodeSelectedBg: controlItemBgActive,
      nodeSelectedColor: token2.colorText
    };
  };
  var prepareComponentToken18 = (token2) => {
    const {
      colorTextLightSolid,
      colorPrimary
    } = token2;
    return Object.assign(Object.assign({}, initComponentToken2(token2)), {
      directoryNodeSelectedColor: colorTextLightSolid,
      directoryNodeSelectedBg: colorPrimary
    });
  };
  var style_default23 = genStyleHooks("Tree", (token2, {
    prefixCls
  }) => [{
    [token2.componentCls]: getStyle2(`${prefixCls}-checkbox`, token2)
  }, genTreeStyle(prefixCls, token2), collapse_default(token2)], prepareComponentToken18);

  // node_modules/antd/es/tree/utils/dropIndicator.js
  var import_react119 = __toESM(require_react());
  var offset2 = 4;
  function dropIndicatorRender(props) {
    const {
      dropPosition,
      dropLevelOffset,
      prefixCls,
      indent,
      direction = "ltr"
    } = props;
    const startPosition = direction === "ltr" ? "left" : "right";
    const endPosition = direction === "ltr" ? "right" : "left";
    const style2 = {
      [startPosition]: -dropLevelOffset * indent + offset2,
      [endPosition]: 0
    };
    switch (dropPosition) {
      case -1:
        style2.top = -3;
        break;
      case 1:
        style2.bottom = -3;
        break;
      default:
        style2.bottom = -3;
        style2[startPosition] = indent + offset2;
        break;
    }
    return /* @__PURE__ */ import_react119.default.createElement("div", {
      style: style2,
      className: `${prefixCls}-drop-indicator`
    });
  }
  var dropIndicator_default = dropIndicatorRender;

  // node_modules/antd/es/tree/utils/iconUtil.js
  var React382 = __toESM(require_react());
  var import_classnames141 = __toESM(require_classnames());
  var SwitcherIconCom = (props) => {
    var _a, _b;
    const {
      prefixCls,
      switcherIcon,
      treeNodeProps,
      showLine,
      switcherLoadingIcon
    } = props;
    const {
      isLeaf,
      expanded,
      loading
    } = treeNodeProps;
    if (loading) {
      if (/* @__PURE__ */ React382.isValidElement(switcherLoadingIcon)) {
        return switcherLoadingIcon;
      }
      return /* @__PURE__ */ React382.createElement(LoadingOutlined_default2, {
        className: `${prefixCls}-switcher-loading-icon`
      });
    }
    let showLeafIcon;
    if (showLine && typeof showLine === "object") {
      showLeafIcon = showLine.showLeafIcon;
    }
    if (isLeaf) {
      if (!showLine) {
        return null;
      }
      if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
        const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
        const leafCls = `${prefixCls}-switcher-line-custom-icon`;
        if (/* @__PURE__ */ React382.isValidElement(leafIcon)) {
          return cloneElement3(leafIcon, {
            className: (0, import_classnames141.default)((_a = leafIcon.props) === null || _a === void 0 ? void 0 : _a.className, leafCls)
          });
        }
        return leafIcon;
      }
      return showLeafIcon ? /* @__PURE__ */ React382.createElement(FileOutlined_default2, {
        className: `${prefixCls}-switcher-line-icon`
      }) : /* @__PURE__ */ React382.createElement("span", {
        className: `${prefixCls}-switcher-leaf-line`
      });
    }
    const switcherCls = `${prefixCls}-switcher-icon`;
    const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
    if (/* @__PURE__ */ React382.isValidElement(switcher)) {
      return cloneElement3(switcher, {
        className: (0, import_classnames141.default)((_b = switcher.props) === null || _b === void 0 ? void 0 : _b.className, switcherCls)
      });
    }
    if (switcher !== void 0) {
      return switcher;
    }
    if (showLine) {
      return expanded ? /* @__PURE__ */ React382.createElement(MinusSquareOutlined_default2, {
        className: `${prefixCls}-switcher-line-icon`
      }) : /* @__PURE__ */ React382.createElement(PlusSquareOutlined_default2, {
        className: `${prefixCls}-switcher-line-icon`
      });
    }
    return /* @__PURE__ */ React382.createElement(CaretDownFilled_default2, {
      className: switcherCls
    });
  };
  var iconUtil_default = SwitcherIconCom;

  // node_modules/antd/es/tree/Tree.js
  var Tree2 = /* @__PURE__ */ import_react120.default.forwardRef((props, ref) => {
    var _a;
    const {
      getPrefixCls,
      direction,
      virtual,
      tree
    } = import_react120.default.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      className,
      showIcon = false,
      showLine,
      switcherIcon,
      switcherLoadingIcon,
      blockNode = false,
      children,
      checkable = false,
      selectable = true,
      draggable,
      motion: customMotion,
      style: style2
    } = props;
    const prefixCls = getPrefixCls("tree", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const motion2 = customMotion !== null && customMotion !== void 0 ? customMotion : Object.assign(Object.assign({}, motion_default(rootPrefixCls)), {
      motionAppear: false
    });
    const newProps = Object.assign(Object.assign({}, props), {
      checkable,
      selectable,
      showIcon,
      motion: motion2,
      blockNode,
      showLine: Boolean(showLine),
      dropIndicatorRender: dropIndicator_default
    });
    const [wrapCSSVar, hashId, cssVarCls] = style_default23(prefixCls);
    const [, token2] = useToken();
    const itemHeight = token2.paddingXS / 2 + (((_a = token2.Tree) === null || _a === void 0 ? void 0 : _a.titleHeight) || token2.controlHeightSM);
    const draggableConfig = import_react120.default.useMemo(() => {
      if (!draggable) {
        return false;
      }
      let mergedDraggable = {};
      switch (typeof draggable) {
        case "function":
          mergedDraggable.nodeDraggable = draggable;
          break;
        case "object":
          mergedDraggable = Object.assign({}, draggable);
          break;
        default:
          break;
      }
      if (mergedDraggable.icon !== false) {
        mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ import_react120.default.createElement(HolderOutlined_default2, null);
      }
      return mergedDraggable;
    }, [draggable]);
    const renderSwitcherIcon = (nodeProps) => /* @__PURE__ */ import_react120.default.createElement(iconUtil_default, {
      prefixCls,
      switcherIcon,
      switcherLoadingIcon,
      treeNodeProps: nodeProps,
      showLine
    });
    return wrapCSSVar(
      // @ts-ignore
      /* @__PURE__ */ import_react120.default.createElement(es_default18, Object.assign({
        itemHeight,
        ref,
        virtual
      }, newProps, {
        // newProps may contain style so declare style below it
        style: Object.assign(Object.assign({}, tree === null || tree === void 0 ? void 0 : tree.style), style2),
        prefixCls,
        className: (0, import_classnames142.default)({
          [`${prefixCls}-icon-hide`]: !showIcon,
          [`${prefixCls}-block-node`]: blockNode,
          [`${prefixCls}-unselectable`]: !selectable,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, tree === null || tree === void 0 ? void 0 : tree.className, className, hashId, cssVarCls),
        direction,
        checkable: checkable ? /* @__PURE__ */ import_react120.default.createElement("span", {
          className: `${prefixCls}-checkbox-inner`
        }) : checkable,
        selectable,
        switcherIcon: renderSwitcherIcon,
        draggable: draggableConfig
      }), children)
    );
  });
  if (true) {
    Tree2.displayName = "Tree";
  }
  var Tree_default2 = Tree2;

  // node_modules/antd/es/tree/utils/dictUtil.js
  var RECORD_NONE = 0;
  var RECORD_START = 1;
  var RECORD_END = 2;
  function traverseNodesKey(treeData, callback, fieldNames) {
    const {
      key: fieldKey,
      children: fieldChildren
    } = fieldNames;
    function processNode(dataNode) {
      const key = dataNode[fieldKey];
      const children = dataNode[fieldChildren];
      if (callback(key, dataNode) !== false) {
        traverseNodesKey(children || [], callback, fieldNames);
      }
    }
    treeData.forEach(processNode);
  }
  function calcRangeKeys({
    treeData,
    expandedKeys,
    startKey,
    endKey,
    fieldNames
  }) {
    const keys2 = [];
    let record = RECORD_NONE;
    if (startKey && startKey === endKey) {
      return [startKey];
    }
    if (!startKey || !endKey) {
      return [];
    }
    function matchKey(key) {
      return key === startKey || key === endKey;
    }
    traverseNodesKey(treeData, (key) => {
      if (record === RECORD_END) {
        return false;
      }
      if (matchKey(key)) {
        keys2.push(key);
        if (record === RECORD_NONE) {
          record = RECORD_START;
        } else if (record === RECORD_START) {
          record = RECORD_END;
          return false;
        }
      } else if (record === RECORD_START) {
        keys2.push(key);
      }
      return expandedKeys.includes(key);
    }, fillFieldNames2(fieldNames));
    return keys2;
  }
  function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
    const restKeys = _toConsumableArray(keys2);
    const nodes = [];
    traverseNodesKey(treeData, (key, node2) => {
      const index3 = restKeys.indexOf(key);
      if (index3 !== -1) {
        nodes.push(node2);
        restKeys.splice(index3, 1);
      }
      return !!restKeys.length;
    }, fillFieldNames2(fieldNames));
    return nodes;
  }

  // node_modules/antd/es/tree/DirectoryTree.js
  var __rest52 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  function getIcon(props) {
    const {
      isLeaf,
      expanded
    } = props;
    if (isLeaf) {
      return /* @__PURE__ */ React384.createElement(FileOutlined_default2, null);
    }
    return expanded ? /* @__PURE__ */ React384.createElement(FolderOpenOutlined_default2, null) : /* @__PURE__ */ React384.createElement(FolderOutlined_default2, null);
  }
  function getTreeData({
    treeData,
    children
  }) {
    return treeData || convertTreeToData(children);
  }
  var DirectoryTree = (_a, ref) => {
    var {
      defaultExpandAll,
      defaultExpandParent,
      defaultExpandedKeys
    } = _a, props = __rest52(_a, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
    const lastSelectedKey = React384.useRef(null);
    const cachedSelectedKeys = React384.useRef(null);
    const getInitExpandedKeys = () => {
      const {
        keyEntities
      } = convertDataToEntities(getTreeData(props));
      let initExpandedKeys;
      if (defaultExpandAll) {
        initExpandedKeys = Object.keys(keyEntities);
      } else if (defaultExpandParent) {
        initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
      } else {
        initExpandedKeys = props.expandedKeys || defaultExpandedKeys || [];
      }
      return initExpandedKeys;
    };
    const [selectedKeys, setSelectedKeys] = React384.useState(props.selectedKeys || props.defaultSelectedKeys || []);
    const [expandedKeys, setExpandedKeys] = React384.useState(() => getInitExpandedKeys());
    React384.useEffect(() => {
      if ("selectedKeys" in props) {
        setSelectedKeys(props.selectedKeys);
      }
    }, [props.selectedKeys]);
    React384.useEffect(() => {
      if ("expandedKeys" in props) {
        setExpandedKeys(props.expandedKeys);
      }
    }, [props.expandedKeys]);
    const onExpand = (keys2, info) => {
      var _a2;
      if (!("expandedKeys" in props)) {
        setExpandedKeys(keys2);
      }
      return (_a2 = props.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(props, keys2, info);
    };
    const onSelect = (keys2, event) => {
      var _a2;
      const {
        multiple,
        fieldNames
      } = props;
      const {
        node: node2,
        nativeEvent
      } = event;
      const {
        key = ""
      } = node2;
      const treeData = getTreeData(props);
      const newEvent = Object.assign(Object.assign({}, event), {
        selected: true
      });
      const ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
      const shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
      let newSelectedKeys;
      if (multiple && ctrlPick) {
        newSelectedKeys = keys2;
        lastSelectedKey.current = key;
        cachedSelectedKeys.current = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
      } else if (multiple && shiftPick) {
        newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
          treeData,
          expandedKeys,
          startKey: key,
          endKey: lastSelectedKey.current,
          fieldNames
        })))));
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
      } else {
        newSelectedKeys = [key];
        lastSelectedKey.current = key;
        cachedSelectedKeys.current = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
      }
      (_a2 = props.onSelect) === null || _a2 === void 0 ? void 0 : _a2.call(props, newSelectedKeys, newEvent);
      if (!("selectedKeys" in props)) {
        setSelectedKeys(newSelectedKeys);
      }
    };
    const {
      getPrefixCls,
      direction
    } = React384.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      className,
      showIcon = true,
      expandAction = "click"
    } = props, otherProps = __rest52(props, ["prefixCls", "className", "showIcon", "expandAction"]);
    const prefixCls = getPrefixCls("tree", customizePrefixCls);
    const connectClassName = (0, import_classnames143.default)(`${prefixCls}-directory`, {
      [`${prefixCls}-directory-rtl`]: direction === "rtl"
    }, className);
    return /* @__PURE__ */ React384.createElement(Tree_default2, Object.assign({
      icon: getIcon,
      ref,
      blockNode: true
    }, otherProps, {
      showIcon,
      expandAction,
      prefixCls,
      className: connectClassName,
      expandedKeys,
      selectedKeys,
      onSelect,
      onExpand
    }));
  };
  var ForwardDirectoryTree = /* @__PURE__ */ React384.forwardRef(DirectoryTree);
  if (true) {
    ForwardDirectoryTree.displayName = "DirectoryTree";
  }
  var DirectoryTree_default = ForwardDirectoryTree;

  // node_modules/antd/es/tree/index.js
  var Tree3 = Tree_default2;
  Tree3.DirectoryTree = DirectoryTree_default;
  Tree3.TreeNode = TreeNode_default;
  var tree_default = Tree3;

  // node_modules/antd/es/table/hooks/useFilter/FilterSearch.js
  var React385 = __toESM(require_react());
  var FilterSearch = (props) => {
    const {
      value,
      filterSearch,
      tablePrefixCls,
      locale: locale6,
      onChange
    } = props;
    if (!filterSearch) {
      return null;
    }
    return /* @__PURE__ */ React385.createElement("div", {
      className: `${tablePrefixCls}-filter-dropdown-search`
    }, /* @__PURE__ */ React385.createElement(Input_default4, {
      prefix: /* @__PURE__ */ React385.createElement(SearchOutlined_default2, null),
      placeholder: locale6.filterSearchPlaceholder,
      onChange,
      value,
      // for skip min-width of input
      htmlSize: 1,
      className: `${tablePrefixCls}-filter-dropdown-search-input`
    }));
  };
  var FilterSearch_default = FilterSearch;

  // node_modules/antd/es/table/hooks/useFilter/FilterWrapper.js
  var React386 = __toESM(require_react());
  var onKeyDown = (event) => {
    const {
      keyCode
    } = event;
    if (keyCode === KeyCode_default.ENTER) {
      event.stopPropagation();
    }
  };
  var FilterDropdownMenuWrapper = /* @__PURE__ */ React386.forwardRef((props, ref) => /* @__PURE__ */ React386.createElement("div", {
    className: props.className,
    onClick: (e3) => e3.stopPropagation(),
    onKeyDown,
    ref
  }, props.children));
  if (true) {
    FilterDropdownMenuWrapper.displayName = "FilterDropdownMenuWrapper";
  }
  var FilterWrapper_default = FilterDropdownMenuWrapper;

  // node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
  function flattenKeys(filters) {
    let keys2 = [];
    (filters || []).forEach(({
      value,
      children
    }) => {
      keys2.push(value);
      if (children) {
        keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
      }
    });
    return keys2;
  }
  function hasSubMenu(filters) {
    return filters.some(({
      children
    }) => children);
  }
  function searchValueMatched(searchValue, text) {
    if (typeof text === "string" || typeof text === "number") {
      return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
    }
    return false;
  }
  function renderFilterItems({
    filters,
    prefixCls,
    filteredKeys,
    filterMultiple,
    searchValue,
    filterSearch
  }) {
    return filters.map((filter3, index3) => {
      const key = String(filter3.value);
      if (filter3.children) {
        return {
          key: key || index3,
          label: filter3.text,
          popupClassName: `${prefixCls}-dropdown-submenu`,
          children: renderFilterItems({
            filters: filter3.children,
            prefixCls,
            filteredKeys,
            filterMultiple,
            searchValue,
            filterSearch
          })
        };
      }
      const Component9 = filterMultiple ? checkbox_default : radio_default2;
      const item = {
        key: filter3.value !== void 0 ? key : index3,
        label: /* @__PURE__ */ React387.createElement(React387.Fragment, null, /* @__PURE__ */ React387.createElement(Component9, {
          checked: filteredKeys.includes(key)
        }), /* @__PURE__ */ React387.createElement("span", null, filter3.text))
      };
      if (searchValue.trim()) {
        if (typeof filterSearch === "function") {
          return filterSearch(searchValue, filter3) ? item : null;
        }
        return searchValueMatched(searchValue, filter3.text) ? item : null;
      }
      return item;
    });
  }
  function wrapStringListType(keys2) {
    return keys2 || [];
  }
  var FilterDropdown = (props) => {
    var _a, _b, _c, _d;
    const {
      tablePrefixCls,
      prefixCls,
      column: column2,
      dropdownPrefixCls,
      columnKey,
      filterOnClose,
      filterMultiple,
      filterMode = "menu",
      filterSearch = false,
      filterState,
      triggerFilter,
      locale: locale6,
      children,
      getPopupContainer,
      rootClassName
    } = props;
    const {
      filterResetToDefaultFilteredValue,
      defaultFilteredValue,
      filterDropdownProps = {},
      // Deprecated
      filterDropdownOpen,
      filterDropdownVisible,
      onFilterDropdownVisibleChange,
      onFilterDropdownOpenChange
    } = column2;
    const [visible, setVisible] = React387.useState(false);
    const filtered = !!(filterState && (((_a = filterState.filteredKeys) === null || _a === void 0 ? void 0 : _a.length) || filterState.forceFiltered));
    const triggerVisible = (newVisible) => {
      var _a2;
      setVisible(newVisible);
      (_a2 = filterDropdownProps.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(filterDropdownProps, newVisible);
      onFilterDropdownOpenChange === null || onFilterDropdownOpenChange === void 0 ? void 0 : onFilterDropdownOpenChange(newVisible);
      onFilterDropdownVisibleChange === null || onFilterDropdownVisibleChange === void 0 ? void 0 : onFilterDropdownVisibleChange(newVisible);
    };
    if (true) {
      const warning6 = devUseWarning("Table");
      const deprecatedList = [["filterDropdownOpen", "filterDropdownProps.open"], ["filterDropdownVisible", "filterDropdownProps.open"], ["onFilterDropdownOpenChange", "filterDropdownProps.onOpenChange"], ["onFilterDropdownVisibleChange", "filterDropdownProps.onOpenChange"]];
      deprecatedList.forEach(([deprecatedName, newName]) => {
        warning6.deprecated(!(deprecatedName in column2), deprecatedName, newName);
      });
      warning6.deprecated(!("filterCheckall" in locale6), "filterCheckall", "locale.filterCheckAll");
    }
    const mergedVisible = (_d = (_c = (_b = filterDropdownProps.open) !== null && _b !== void 0 ? _b : filterDropdownOpen) !== null && _c !== void 0 ? _c : filterDropdownVisible) !== null && _d !== void 0 ? _d : visible;
    const propFilteredKeys = filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys;
    const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState3(wrapStringListType(propFilteredKeys));
    const onSelectKeys = ({
      selectedKeys
    }) => {
      setFilteredKeysSync(selectedKeys);
    };
    const onCheck = (keys2, {
      node: node2,
      checked
    }) => {
      if (!filterMultiple) {
        onSelectKeys({
          selectedKeys: checked && node2.key ? [node2.key] : []
        });
      } else {
        onSelectKeys({
          selectedKeys: keys2
        });
      }
    };
    React387.useEffect(() => {
      if (!visible) {
        return;
      }
      onSelectKeys({
        selectedKeys: wrapStringListType(propFilteredKeys)
      });
    }, [propFilteredKeys]);
    const [openKeys, setOpenKeys] = React387.useState([]);
    const onOpenChange = (keys2) => {
      setOpenKeys(keys2);
    };
    const [searchValue, setSearchValue] = React387.useState("");
    const onSearch = (e3) => {
      const {
        value
      } = e3.target;
      setSearchValue(value);
    };
    React387.useEffect(() => {
      if (!visible) {
        setSearchValue("");
      }
    }, [visible]);
    const internalTriggerFilter = (keys2) => {
      const mergedKeys = (keys2 === null || keys2 === void 0 ? void 0 : keys2.length) ? keys2 : null;
      if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
        return null;
      }
      if (isEqual_default(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys, true)) {
        return null;
      }
      triggerFilter({
        column: column2,
        key: columnKey,
        filteredKeys: mergedKeys
      });
    };
    const onConfirm = () => {
      triggerVisible(false);
      internalTriggerFilter(getFilteredKeysSync());
    };
    const onReset = ({
      confirm: confirm2,
      closeDropdown
    } = {
      confirm: false,
      closeDropdown: false
    }) => {
      if (confirm2) {
        internalTriggerFilter([]);
      }
      if (closeDropdown) {
        triggerVisible(false);
      }
      setSearchValue("");
      if (filterResetToDefaultFilteredValue) {
        setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
      } else {
        setFilteredKeysSync([]);
      }
    };
    const doFilter = ({
      closeDropdown
    } = {
      closeDropdown: true
    }) => {
      if (closeDropdown) {
        triggerVisible(false);
      }
      internalTriggerFilter(getFilteredKeysSync());
    };
    const onVisibleChange = (newVisible, info) => {
      if (info.source === "trigger") {
        if (newVisible && propFilteredKeys !== void 0) {
          setFilteredKeysSync(wrapStringListType(propFilteredKeys));
        }
        triggerVisible(newVisible);
        if (!newVisible && !column2.filterDropdown && filterOnClose) {
          onConfirm();
        }
      }
    };
    const dropdownMenuClass = (0, import_classnames144.default)({
      [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column2.filters || [])
    });
    const onCheckAll = (e3) => {
      if (e3.target.checked) {
        const allFilterKeys = flattenKeys(column2 === null || column2 === void 0 ? void 0 : column2.filters).map((key) => String(key));
        setFilteredKeysSync(allFilterKeys);
      } else {
        setFilteredKeysSync([]);
      }
    };
    const getTreeData2 = ({
      filters
    }) => (filters || []).map((filter3, index3) => {
      const key = String(filter3.value);
      const item = {
        title: filter3.text,
        key: filter3.value !== void 0 ? key : String(index3)
      };
      if (filter3.children) {
        item.children = getTreeData2({
          filters: filter3.children
        });
      }
      return item;
    });
    const getFilterData2 = (node2) => {
      var _a2;
      return Object.assign(Object.assign({}, node2), {
        text: node2.title,
        value: node2.key,
        children: ((_a2 = node2.children) === null || _a2 === void 0 ? void 0 : _a2.map((item) => getFilterData2(item))) || []
      });
    };
    let dropdownContent;
    const {
      direction,
      renderEmpty
    } = React387.useContext(ConfigContext);
    if (typeof column2.filterDropdown === "function") {
      dropdownContent = column2.filterDropdown({
        prefixCls: `${dropdownPrefixCls}-custom`,
        setSelectedKeys: (selectedKeys) => onSelectKeys({
          selectedKeys
        }),
        selectedKeys: getFilteredKeysSync(),
        confirm: doFilter,
        clearFilters: onReset,
        filters: column2.filters,
        visible: mergedVisible,
        close: () => {
          triggerVisible(false);
        }
      });
    } else if (column2.filterDropdown) {
      dropdownContent = column2.filterDropdown;
    } else {
      const selectedKeys = getFilteredKeysSync() || [];
      const getFilterComponent = () => {
        var _a2, _b2;
        const empty2 = (_a2 = renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Table.filter")) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ React387.createElement(empty_default2, {
          image: empty_default2.PRESENTED_IMAGE_SIMPLE,
          description: locale6.filterEmptyText,
          styles: {
            image: {
              height: 24
            }
          },
          style: {
            margin: 0,
            padding: "16px 0"
          }
        });
        if ((column2.filters || []).length === 0) {
          return empty2;
        }
        if (filterMode === "tree") {
          return /* @__PURE__ */ React387.createElement(React387.Fragment, null, /* @__PURE__ */ React387.createElement(FilterSearch_default, {
            filterSearch,
            value: searchValue,
            onChange: onSearch,
            tablePrefixCls,
            locale: locale6
          }), /* @__PURE__ */ React387.createElement("div", {
            className: `${tablePrefixCls}-filter-dropdown-tree`
          }, filterMultiple ? /* @__PURE__ */ React387.createElement(checkbox_default, {
            checked: selectedKeys.length === flattenKeys(column2.filters).length,
            indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column2.filters).length,
            className: `${tablePrefixCls}-filter-dropdown-checkall`,
            onChange: onCheckAll
          }, (_b2 = locale6 === null || locale6 === void 0 ? void 0 : locale6.filterCheckall) !== null && _b2 !== void 0 ? _b2 : locale6 === null || locale6 === void 0 ? void 0 : locale6.filterCheckAll) : null, /* @__PURE__ */ React387.createElement(tree_default, {
            checkable: true,
            selectable: false,
            blockNode: true,
            multiple: filterMultiple,
            checkStrictly: !filterMultiple,
            className: `${dropdownPrefixCls}-menu`,
            onCheck,
            checkedKeys: selectedKeys,
            selectedKeys,
            showIcon: false,
            treeData: getTreeData2({
              filters: column2.filters
            }),
            autoExpandParent: true,
            defaultExpandAll: true,
            filterTreeNode: searchValue.trim() ? (node2) => {
              if (typeof filterSearch === "function") {
                return filterSearch(searchValue, getFilterData2(node2));
              }
              return searchValueMatched(searchValue, node2.title);
            } : void 0
          })));
        }
        const items = renderFilterItems({
          filters: column2.filters || [],
          filterSearch,
          prefixCls,
          filteredKeys: getFilteredKeysSync(),
          filterMultiple,
          searchValue
        });
        const isEmpty = items.every((item) => item === null);
        return /* @__PURE__ */ React387.createElement(React387.Fragment, null, /* @__PURE__ */ React387.createElement(FilterSearch_default, {
          filterSearch,
          value: searchValue,
          onChange: onSearch,
          tablePrefixCls,
          locale: locale6
        }), isEmpty ? empty2 : /* @__PURE__ */ React387.createElement(menu_default2, {
          selectable: true,
          multiple: filterMultiple,
          prefixCls: `${dropdownPrefixCls}-menu`,
          className: dropdownMenuClass,
          onSelect: onSelectKeys,
          onDeselect: onSelectKeys,
          selectedKeys,
          getPopupContainer,
          openKeys,
          onOpenChange,
          items
        }));
      };
      const getResetDisabled = () => {
        if (filterResetToDefaultFilteredValue) {
          return isEqual_default((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, true);
        }
        return selectedKeys.length === 0;
      };
      dropdownContent = /* @__PURE__ */ React387.createElement(React387.Fragment, null, getFilterComponent(), /* @__PURE__ */ React387.createElement("div", {
        className: `${prefixCls}-dropdown-btns`
      }, /* @__PURE__ */ React387.createElement(button_default2, {
        type: "link",
        size: "small",
        disabled: getResetDisabled(),
        onClick: () => onReset()
      }, locale6.filterReset), /* @__PURE__ */ React387.createElement(button_default2, {
        type: "primary",
        size: "small",
        onClick: onConfirm
      }, locale6.filterConfirm)));
    }
    if (column2.filterDropdown) {
      dropdownContent = /* @__PURE__ */ React387.createElement(OverrideProvider, {
        selectable: void 0
      }, dropdownContent);
    }
    dropdownContent = /* @__PURE__ */ React387.createElement(FilterWrapper_default, {
      className: `${prefixCls}-dropdown`
    }, dropdownContent);
    const getDropdownTrigger = () => {
      let filterIcon;
      if (typeof column2.filterIcon === "function") {
        filterIcon = column2.filterIcon(filtered);
      } else if (column2.filterIcon) {
        filterIcon = column2.filterIcon;
      } else {
        filterIcon = /* @__PURE__ */ React387.createElement(FilterFilled_default2, null);
      }
      return /* @__PURE__ */ React387.createElement("span", {
        role: "button",
        tabIndex: -1,
        className: (0, import_classnames144.default)(`${prefixCls}-trigger`, {
          active: filtered
        }),
        onClick: (e3) => {
          e3.stopPropagation();
        }
      }, filterIcon);
    };
    const mergedDropdownProps = extendsObject_default({
      trigger: ["click"],
      placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
      children: getDropdownTrigger(),
      getPopupContainer
    }, Object.assign(Object.assign({}, filterDropdownProps), {
      rootClassName: (0, import_classnames144.default)(rootClassName, filterDropdownProps.rootClassName),
      open: mergedVisible,
      onOpenChange: onVisibleChange,
      popupRender: () => {
        if (typeof (filterDropdownProps === null || filterDropdownProps === void 0 ? void 0 : filterDropdownProps.dropdownRender) === "function") {
          return filterDropdownProps.dropdownRender(dropdownContent);
        }
        return dropdownContent;
      }
    }));
    return /* @__PURE__ */ React387.createElement("div", {
      className: `${prefixCls}-column`
    }, /* @__PURE__ */ React387.createElement("span", {
      className: `${tablePrefixCls}-column-title`
    }, children), /* @__PURE__ */ React387.createElement(dropdown_default3, Object.assign({}, mergedDropdownProps)));
  };
  var FilterDropdown_default = FilterDropdown;

  // node_modules/antd/es/table/hooks/useFilter/index.js
  var collectFilterStates = (columns, init, pos) => {
    let filterStates = [];
    (columns || []).forEach((column2, index3) => {
      var _a;
      const columnPos = getColumnPos(index3, pos);
      const filterDropdownIsDefined = column2.filterDropdown !== void 0;
      if (column2.filters || filterDropdownIsDefined || "onFilter" in column2) {
        if ("filteredValue" in column2) {
          let filteredValues = column2.filteredValue;
          if (!filterDropdownIsDefined) {
            filteredValues = (_a = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _a !== void 0 ? _a : filteredValues;
          }
          filterStates.push({
            column: column2,
            key: getColumnKey(column2, columnPos),
            filteredKeys: filteredValues,
            forceFiltered: column2.filtered
          });
        } else {
          filterStates.push({
            column: column2,
            key: getColumnKey(column2, columnPos),
            filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
            forceFiltered: column2.filtered
          });
        }
      }
      if ("children" in column2) {
        filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column2.children, init, columnPos)));
      }
    });
    return filterStates;
  };
  function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale6, triggerFilter, getPopupContainer, pos, rootClassName) {
    return columns.map((column2, index3) => {
      const columnPos = getColumnPos(index3, pos);
      const {
        filterOnClose = true,
        filterMultiple = true,
        filterMode,
        filterSearch
      } = column2;
      let newColumn = column2;
      if (newColumn.filters || newColumn.filterDropdown) {
        const columnKey = getColumnKey(newColumn, columnPos);
        const filterState = filterStates.find(({
          key
        }) => columnKey === key);
        newColumn = Object.assign(Object.assign({}, newColumn), {
          title: (renderProps) => /* @__PURE__ */ React388.createElement(FilterDropdown_default, {
            tablePrefixCls: prefixCls,
            prefixCls: `${prefixCls}-filter`,
            dropdownPrefixCls,
            column: newColumn,
            columnKey,
            filterState,
            filterOnClose,
            filterMultiple,
            filterMode,
            filterSearch,
            triggerFilter,
            locale: locale6,
            getPopupContainer,
            rootClassName
          }, renderColumnTitle(column2.title, renderProps))
        });
      }
      if ("children" in newColumn) {
        newColumn = Object.assign(Object.assign({}, newColumn), {
          children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale6, triggerFilter, getPopupContainer, columnPos, rootClassName)
        });
      }
      return newColumn;
    });
  }
  var generateFilterInfo = (filterStates) => {
    const currentFilters = {};
    filterStates.forEach(({
      key,
      filteredKeys,
      column: column2
    }) => {
      const keyAsString = key;
      const {
        filters,
        filterDropdown
      } = column2;
      if (filterDropdown) {
        currentFilters[keyAsString] = filteredKeys || null;
      } else if (Array.isArray(filteredKeys)) {
        const keys2 = flattenKeys(filters);
        currentFilters[keyAsString] = keys2.filter((originKey) => filteredKeys.includes(String(originKey)));
      } else {
        currentFilters[keyAsString] = null;
      }
    });
    return currentFilters;
  };
  var getFilterData = (data, filterStates, childrenColumnName) => {
    const filterDatas = filterStates.reduce((currentData, filterState) => {
      const {
        column: {
          onFilter,
          filters
        },
        filteredKeys
      } = filterState;
      if (onFilter && filteredKeys && filteredKeys.length) {
        return currentData.map((record) => Object.assign({}, record)).filter((record) => filteredKeys.some((key) => {
          const keys2 = flattenKeys(filters);
          const keyIndex2 = keys2.findIndex((k) => String(k) === String(key));
          const realKey = keyIndex2 !== -1 ? keys2[keyIndex2] : key;
          if (record[childrenColumnName]) {
            record[childrenColumnName] = getFilterData(record[childrenColumnName], filterStates, childrenColumnName);
          }
          return onFilter(realKey, record);
        }));
      }
      return currentData;
    }, data);
    return filterDatas;
  };
  var getMergedColumns = (rawMergedColumns) => rawMergedColumns.flatMap((column2) => {
    if ("children" in column2) {
      return [column2].concat(_toConsumableArray(getMergedColumns(column2.children || [])));
    }
    return [column2];
  });
  var useFilter = (props) => {
    const {
      prefixCls,
      dropdownPrefixCls,
      mergedColumns: rawMergedColumns,
      onFilterChange,
      getPopupContainer,
      locale: tableLocale,
      rootClassName
    } = props;
    const warning6 = devUseWarning("Table");
    const mergedColumns = React388.useMemo(() => getMergedColumns(rawMergedColumns || []), [rawMergedColumns]);
    const [filterStates, setFilterStates] = React388.useState(() => collectFilterStates(mergedColumns, true));
    const mergedFilterStates = React388.useMemo(() => {
      const collectedStates = collectFilterStates(mergedColumns, false);
      if (collectedStates.length === 0) {
        return collectedStates;
      }
      let filteredKeysIsAllNotControlled = true;
      let filteredKeysIsAllControlled = true;
      collectedStates.forEach(({
        filteredKeys
      }) => {
        if (filteredKeys !== void 0) {
          filteredKeysIsAllNotControlled = false;
        } else {
          filteredKeysIsAllControlled = false;
        }
      });
      if (filteredKeysIsAllNotControlled) {
        const keyList = (mergedColumns || []).map((column2, index3) => getColumnKey(column2, getColumnPos(index3)));
        return filterStates.filter(({
          key
        }) => keyList.includes(key)).map((item) => {
          const col = mergedColumns[keyList.findIndex((key) => key === item.key)];
          return Object.assign(Object.assign({}, item), {
            column: Object.assign(Object.assign({}, item.column), col),
            forceFiltered: col.filtered
          });
        });
      }
      true ? warning6(filteredKeysIsAllControlled, "usage", "Columns should all contain `filteredValue` or not contain `filteredValue`.") : void 0;
      return collectedStates;
    }, [mergedColumns, filterStates]);
    const filters = React388.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
    const triggerFilter = (filterState) => {
      const newFilterStates = mergedFilterStates.filter(({
        key
      }) => key !== filterState.key);
      newFilterStates.push(filterState);
      setFilterStates(newFilterStates);
      onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
    };
    const transformColumns = (innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer, void 0, rootClassName);
    return [transformColumns, mergedFilterStates, filters];
  };
  var useFilter_default = useFilter;

  // node_modules/antd/es/table/hooks/useLazyKVMap.js
  var React389 = __toESM(require_react());
  var useLazyKVMap = (data, childrenColumnName, getRowKey) => {
    const mapCacheRef = React389.useRef({});
    function getRecordByKey(key) {
      var _a;
      if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
        let dig = function(records) {
          records.forEach((record, index3) => {
            const rowKey = getRowKey(record, index3);
            kvMap.set(rowKey, record);
            if (record && typeof record === "object" && childrenColumnName in record) {
              dig(record[childrenColumnName] || []);
            }
          });
        };
        const kvMap = /* @__PURE__ */ new Map();
        dig(data);
        mapCacheRef.current = {
          data,
          childrenColumnName,
          kvMap,
          getRowKey
        };
      }
      return (_a = mapCacheRef.current.kvMap) === null || _a === void 0 ? void 0 : _a.get(key);
    }
    return [getRecordByKey];
  };
  var useLazyKVMap_default = useLazyKVMap;

  // node_modules/antd/es/table/hooks/usePagination.js
  var import_react121 = __toESM(require_react());
  var __rest53 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var DEFAULT_PAGE_SIZE = 10;
  function getPaginationParam(mergedPagination, pagination) {
    const param = {
      current: mergedPagination.current,
      pageSize: mergedPagination.pageSize
    };
    const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
    Object.keys(paginationObj).forEach((pageProp) => {
      const value = mergedPagination[pageProp];
      if (typeof value !== "function") {
        param[pageProp] = value;
      }
    });
    return param;
  }
  function usePagination(total, onChange, pagination) {
    const _a = pagination && typeof pagination === "object" ? pagination : {}, {
      total: paginationTotal = 0
    } = _a, paginationObj = __rest53(_a, ["total"]);
    const [innerPagination, setInnerPagination] = (0, import_react121.useState)(() => ({
      current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
      pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
    }));
    const mergedPagination = extendsObject_default(innerPagination, paginationObj, {
      total: paginationTotal > 0 ? paginationTotal : total
    });
    const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
    if (mergedPagination.current > maxPage) {
      mergedPagination.current = maxPage || 1;
    }
    const refreshPagination = (current, pageSize) => {
      setInnerPagination({
        current: current !== null && current !== void 0 ? current : 1,
        pageSize: pageSize || mergedPagination.pageSize
      });
    };
    const onInternalChange = (current, pageSize) => {
      var _a2;
      if (pagination) {
        (_a2 = pagination.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(pagination, current, pageSize);
      }
      refreshPagination(current, pageSize);
      onChange(current, pageSize || (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize));
    };
    if (pagination === false) {
      return [{}, () => {
      }];
    }
    return [Object.assign(Object.assign({}, mergedPagination), {
      onChange: onInternalChange
    }), refreshPagination];
  }
  var usePagination_default = usePagination;

  // node_modules/antd/es/table/hooks/useSorter.js
  var React390 = __toESM(require_react());
  var import_classnames145 = __toESM(require_classnames());
  var ASCEND = "ascend";
  var DESCEND = "descend";
  var getMultiplePriority = (column2) => {
    if (typeof column2.sorter === "object" && typeof column2.sorter.multiple === "number") {
      return column2.sorter.multiple;
    }
    return false;
  };
  var getSortFunction = (sorter) => {
    if (typeof sorter === "function") {
      return sorter;
    }
    if (sorter && typeof sorter === "object" && sorter.compare) {
      return sorter.compare;
    }
    return false;
  };
  var nextSortDirection = (sortDirections, current) => {
    if (!current) {
      return sortDirections[0];
    }
    return sortDirections[sortDirections.indexOf(current) + 1];
  };
  var collectSortStates = (columns, init, pos) => {
    let sortStates = [];
    const pushState = (column2, columnPos) => {
      sortStates.push({
        column: column2,
        key: getColumnKey(column2, columnPos),
        multiplePriority: getMultiplePriority(column2),
        sortOrder: column2.sortOrder
      });
    };
    (columns || []).forEach((column2, index3) => {
      const columnPos = getColumnPos(index3, pos);
      if (column2.children) {
        if ("sortOrder" in column2) {
          pushState(column2, columnPos);
        }
        sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column2.children, init, columnPos)));
      } else if (column2.sorter) {
        if ("sortOrder" in column2) {
          pushState(column2, columnPos);
        } else if (init && column2.defaultSortOrder) {
          sortStates.push({
            column: column2,
            key: getColumnKey(column2, columnPos),
            multiplePriority: getMultiplePriority(column2),
            sortOrder: column2.defaultSortOrder
          });
        }
      }
    });
    return sortStates;
  };
  var injectSorter = (prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) => {
    const finalColumns = (columns || []).map((column2, index3) => {
      const columnPos = getColumnPos(index3, pos);
      let newColumn = column2;
      if (newColumn.sorter) {
        const sortDirections = newColumn.sortDirections || defaultSortDirections;
        const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
        const columnKey = getColumnKey(newColumn, columnPos);
        const sorterState = sorterStates.find(({
          key
        }) => key === columnKey);
        const sortOrder = sorterState ? sorterState.sortOrder : null;
        const nextSortOrder = nextSortDirection(sortDirections, sortOrder);
        let sorter;
        if (column2.sortIcon) {
          sorter = column2.sortIcon({
            sortOrder
          });
        } else {
          const upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ React390.createElement(CaretUpOutlined_default2, {
            className: (0, import_classnames145.default)(`${prefixCls}-column-sorter-up`, {
              active: sortOrder === ASCEND
            })
          });
          const downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ React390.createElement(CaretDownOutlined_default2, {
            className: (0, import_classnames145.default)(`${prefixCls}-column-sorter-down`, {
              active: sortOrder === DESCEND
            })
          });
          sorter = /* @__PURE__ */ React390.createElement("span", {
            className: (0, import_classnames145.default)(`${prefixCls}-column-sorter`, {
              [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
            })
          }, /* @__PURE__ */ React390.createElement("span", {
            className: `${prefixCls}-column-sorter-inner`,
            "aria-hidden": "true"
          }, upNode, downNode));
        }
        const {
          cancelSort,
          triggerAsc,
          triggerDesc
        } = tableLocale || {};
        let sortTip = cancelSort;
        if (nextSortOrder === DESCEND) {
          sortTip = triggerDesc;
        } else if (nextSortOrder === ASCEND) {
          sortTip = triggerAsc;
        }
        const tooltipProps = typeof showSorterTooltip === "object" ? Object.assign({
          title: sortTip
        }, showSorterTooltip) : {
          title: sortTip
        };
        newColumn = Object.assign(Object.assign({}, newColumn), {
          className: (0, import_classnames145.default)(newColumn.className, {
            [`${prefixCls}-column-sort`]: sortOrder
          }),
          title: (renderProps) => {
            const columnSortersClass = `${prefixCls}-column-sorters`;
            const renderColumnTitleWrapper = /* @__PURE__ */ React390.createElement("span", {
              className: `${prefixCls}-column-title`
            }, renderColumnTitle(column2.title, renderProps));
            const renderSortTitle = /* @__PURE__ */ React390.createElement("div", {
              className: columnSortersClass
            }, renderColumnTitleWrapper, sorter);
            if (showSorterTooltip) {
              if (typeof showSorterTooltip !== "boolean" && (showSorterTooltip === null || showSorterTooltip === void 0 ? void 0 : showSorterTooltip.target) === "sorter-icon") {
                return /* @__PURE__ */ React390.createElement("div", {
                  className: `${columnSortersClass} ${prefixCls}-column-sorters-tooltip-target-sorter`
                }, renderColumnTitleWrapper, /* @__PURE__ */ React390.createElement(tooltip_default, Object.assign({}, tooltipProps), sorter));
              }
              return /* @__PURE__ */ React390.createElement(tooltip_default, Object.assign({}, tooltipProps), renderSortTitle);
            }
            return renderSortTitle;
          },
          onHeaderCell: (col) => {
            var _a;
            const cell = ((_a = column2.onHeaderCell) === null || _a === void 0 ? void 0 : _a.call(column2, col)) || {};
            const originOnClick = cell.onClick;
            const originOKeyDown = cell.onKeyDown;
            cell.onClick = (event) => {
              triggerSorter({
                column: column2,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column2)
              });
              originOnClick === null || originOnClick === void 0 ? void 0 : originOnClick(event);
            };
            cell.onKeyDown = (event) => {
              if (event.keyCode === KeyCode_default.ENTER) {
                triggerSorter({
                  column: column2,
                  key: columnKey,
                  sortOrder: nextSortOrder,
                  multiplePriority: getMultiplePriority(column2)
                });
                originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
              }
            };
            const renderTitle = safeColumnTitle(column2.title, {});
            const displayTitle = renderTitle === null || renderTitle === void 0 ? void 0 : renderTitle.toString();
            if (sortOrder) {
              cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending";
            }
            cell["aria-label"] = displayTitle || "";
            cell.className = (0, import_classnames145.default)(cell.className, `${prefixCls}-column-has-sorters`);
            cell.tabIndex = 0;
            if (column2.ellipsis) {
              cell.title = (renderTitle !== null && renderTitle !== void 0 ? renderTitle : "").toString();
            }
            return cell;
          }
        });
      }
      if ("children" in newColumn) {
        newColumn = Object.assign(Object.assign({}, newColumn), {
          children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
        });
      }
      return newColumn;
    });
    return finalColumns;
  };
  var stateToInfo = (sorterState) => {
    const {
      column: column2,
      sortOrder
    } = sorterState;
    return {
      column: column2,
      order: sortOrder,
      field: column2.dataIndex,
      columnKey: column2.key
    };
  };
  var generateSorterInfo = (sorterStates) => {
    const activeSorters = sorterStates.filter(({
      sortOrder
    }) => sortOrder).map(stateToInfo);
    if (activeSorters.length === 0 && sorterStates.length) {
      const lastIndex = sorterStates.length - 1;
      return Object.assign(Object.assign({}, stateToInfo(sorterStates[lastIndex])), {
        column: void 0,
        order: void 0,
        field: void 0,
        columnKey: void 0
      });
    }
    if (activeSorters.length <= 1) {
      return activeSorters[0] || {};
    }
    return activeSorters;
  };
  var getSortData = (data, sortStates, childrenColumnName) => {
    const innerSorterStates = sortStates.slice().sort((a, b) => b.multiplePriority - a.multiplePriority);
    const cloneData = data.slice();
    const runningSorters = innerSorterStates.filter(({
      column: {
        sorter
      },
      sortOrder
    }) => getSortFunction(sorter) && sortOrder);
    if (!runningSorters.length) {
      return cloneData;
    }
    return cloneData.sort((record1, record2) => {
      for (let i = 0; i < runningSorters.length; i += 1) {
        const sorterState = runningSorters[i];
        const {
          column: {
            sorter
          },
          sortOrder
        } = sorterState;
        const compareFn = getSortFunction(sorter);
        if (compareFn && sortOrder) {
          const compareResult = compareFn(record1, record2, sortOrder);
          if (compareResult !== 0) {
            return sortOrder === ASCEND ? compareResult : -compareResult;
          }
        }
      }
      return 0;
    }).map((record) => {
      const subRecords = record[childrenColumnName];
      if (subRecords) {
        return Object.assign(Object.assign({}, record), {
          [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
        });
      }
      return record;
    });
  };
  var useFilterSorter = (props) => {
    const {
      prefixCls,
      mergedColumns,
      sortDirections,
      tableLocale,
      showSorterTooltip,
      onSorterChange
    } = props;
    const [sortStates, setSortStates] = React390.useState(() => collectSortStates(mergedColumns, true));
    const getColumnKeys = (columns, pos) => {
      const newKeys = [];
      columns.forEach((item, index3) => {
        const columnPos = getColumnPos(index3, pos);
        newKeys.push(getColumnKey(item, columnPos));
        if (Array.isArray(item.children)) {
          const childKeys = getColumnKeys(item.children, columnPos);
          newKeys.push.apply(newKeys, _toConsumableArray(childKeys));
        }
      });
      return newKeys;
    };
    const mergedSorterStates = React390.useMemo(() => {
      let validate = true;
      const collectedStates = collectSortStates(mergedColumns, false);
      if (!collectedStates.length) {
        const mergedColumnsKeys = getColumnKeys(mergedColumns);
        return sortStates.filter(({
          key
        }) => mergedColumnsKeys.includes(key));
      }
      const validateStates = [];
      function patchStates(state) {
        if (validate) {
          validateStates.push(state);
        } else {
          validateStates.push(Object.assign(Object.assign({}, state), {
            sortOrder: null
          }));
        }
      }
      let multipleMode = null;
      collectedStates.forEach((state) => {
        if (multipleMode === null) {
          patchStates(state);
          if (state.sortOrder) {
            if (state.multiplePriority === false) {
              validate = false;
            } else {
              multipleMode = true;
            }
          }
        } else if (multipleMode && state.multiplePriority !== false) {
          patchStates(state);
        } else {
          validate = false;
          patchStates(state);
        }
      });
      return validateStates;
    }, [mergedColumns, sortStates]);
    const columnTitleSorterProps = React390.useMemo(() => {
      var _a, _b;
      const sortColumns = mergedSorterStates.map(({
        column: column2,
        sortOrder
      }) => ({
        column: column2,
        order: sortOrder
      }));
      return {
        sortColumns,
        // Legacy
        sortColumn: (_a = sortColumns[0]) === null || _a === void 0 ? void 0 : _a.column,
        sortOrder: (_b = sortColumns[0]) === null || _b === void 0 ? void 0 : _b.order
      };
    }, [mergedSorterStates]);
    const triggerSorter = (sortState) => {
      let newSorterStates;
      if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
        newSorterStates = [sortState];
      } else {
        newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(({
          key
        }) => key !== sortState.key)), [sortState]);
      }
      setSortStates(newSorterStates);
      onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
    };
    const transformColumns = (innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip);
    const getSorters = () => generateSorterInfo(mergedSorterStates);
    return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
  };
  var useSorter_default = useFilterSorter;

  // node_modules/antd/es/table/hooks/useTitleColumns.js
  var React391 = __toESM(require_react());
  var fillTitle = (columns, columnTitleProps) => {
    const finalColumns = columns.map((column2) => {
      const cloneColumn = Object.assign({}, column2);
      cloneColumn.title = renderColumnTitle(column2.title, columnTitleProps);
      if ("children" in cloneColumn) {
        cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
      }
      return cloneColumn;
    });
    return finalColumns;
  };
  var useTitleColumns = (columnTitleProps) => {
    const filledColumns = React391.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps]);
    return [filledColumns];
  };
  var useTitleColumns_default = useTitleColumns;

  // node_modules/antd/es/table/RcTable/index.js
  var RcTable = genTable((prev2, next2) => {
    const {
      _renderTimes: prevRenderTimes
    } = prev2;
    const {
      _renderTimes: nextRenderTimes
    } = next2;
    return prevRenderTimes !== nextRenderTimes;
  });
  var RcTable_default = RcTable;

  // node_modules/antd/es/table/RcTable/VirtualTable.js
  var RcVirtualTable = genVirtualTable((prev2, next2) => {
    const {
      _renderTimes: prevRenderTimes
    } = prev2;
    const {
      _renderTimes: nextRenderTimes
    } = next2;
    return prevRenderTimes !== nextRenderTimes;
  });
  var VirtualTable_default2 = RcVirtualTable;

  // node_modules/antd/es/table/style/bordered.js
  var genBorderedStyle2 = (token2) => {
    const {
      componentCls,
      lineWidth,
      lineType,
      tableBorderColor,
      tableHeaderBg,
      tablePaddingVertical,
      tablePaddingHorizontal,
      calc
    } = token2;
    const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
    const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({
      [`&${componentCls}-${size}`]: {
        [`> ${componentCls}-container`]: {
          [`> ${componentCls}-content, > ${componentCls}-body`]: {
            [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: {
              [`> ${componentCls}-expanded-row-fixed`]: {
                margin: `${unit(calc(paddingVertical).mul(-1).equal())}
              ${unit(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}`
              }
            }
          }
        }
      }
    });
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}${componentCls}-bordered`]: Object.assign(Object.assign(Object.assign({
          // ============================ Title =============================
          [`> ${componentCls}-title`]: {
            border: tableBorder,
            borderBottom: 0
          },
          // ============================ Content ============================
          [`> ${componentCls}-container`]: {
            borderInlineStart: tableBorder,
            borderTop: tableBorder,
            [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
              "> table": {
                // ============================= Cell =============================
                [`
                > thead > tr > th,
                > thead > tr > td,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                  borderInlineEnd: tableBorder
                },
                // ============================ Header ============================
                "> thead": {
                  "> tr:not(:last-child) > th": {
                    borderBottom: tableBorder
                  },
                  "> tr > th::before": {
                    backgroundColor: "transparent !important"
                  }
                },
                // Fixed right should provides additional border
                [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                  [`> ${componentCls}-cell-fix-right-first::after`]: {
                    borderInlineEnd: tableBorder
                  }
                },
                // ========================== Expandable ==========================
                [`
                > tbody > tr > th,
                > tbody > tr > td
              `]: {
                  [`> ${componentCls}-expanded-row-fixed`]: {
                    margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal())}`,
                    "&::after": {
                      position: "absolute",
                      top: 0,
                      insetInlineEnd: lineWidth,
                      bottom: 0,
                      borderInlineEnd: tableBorder,
                      content: '""'
                    }
                  }
                }
              }
            }
          },
          // ============================ Scroll ============================
          [`&${componentCls}-scroll-horizontal`]: {
            [`> ${componentCls}-container > ${componentCls}-body`]: {
              "> table > tbody": {
                [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                  "> th, > td": {
                    borderInlineEnd: 0
                  }
                }
              }
            }
          }
        }, getSizeBorderStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle)), getSizeBorderStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall)), {
          // ============================ Footer ============================
          [`> ${componentCls}-footer`]: {
            border: tableBorder,
            borderTop: 0
          }
        }),
        // ============================ Nested ============================
        [`${componentCls}-cell`]: {
          [`${componentCls}-container:first-child`]: {
            // :first-child to avoid the case when bordered and title is set
            borderTop: 0
          },
          // https://github.com/ant-design/ant-design/issues/35577
          "&-scrollbar:not([rowspan])": {
            boxShadow: `0 ${unit(lineWidth)} 0 ${unit(lineWidth)} ${tableHeaderBg}`
          }
        },
        [`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: {
          borderInlineEnd: tableBorder
        }
      }
    };
  };
  var bordered_default2 = genBorderedStyle2;

  // node_modules/antd/es/table/style/ellipsis.js
  var genEllipsisStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-cell-ellipsis`]: Object.assign(Object.assign({}, textEllipsis), {
          wordBreak: "keep-all",
          // Fixed first or last should special process
          [`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
            overflow: "visible",
            [`${componentCls}-cell-content`]: {
              display: "block",
              overflow: "hidden",
              textOverflow: "ellipsis"
            }
          },
          [`${componentCls}-column-title`]: {
            overflow: "hidden",
            textOverflow: "ellipsis",
            wordBreak: "keep-all"
          }
        })
      }
    };
  };
  var ellipsis_default = genEllipsisStyle;

  // node_modules/antd/es/table/style/empty.js
  var genEmptyStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
          textAlign: "center",
          color: token2.colorTextDisabled,
          [`
          &:hover > th,
          &:hover > td,
        `]: {
            background: token2.colorBgContainer
          }
        }
      }
    };
  };
  var empty_default3 = genEmptyStyle;

  // node_modules/antd/es/table/style/expand.js
  var genExpandStyle = (token2) => {
    const {
      componentCls,
      antCls,
      motionDurationSlow,
      lineWidth,
      paddingXS,
      lineType,
      tableBorderColor,
      tableExpandIconBg,
      tableExpandColumnWidth,
      borderRadius,
      tablePaddingVertical,
      tablePaddingHorizontal,
      tableExpandedRowBg,
      paddingXXS,
      expandIconMarginTop,
      expandIconSize,
      expandIconHalfInner,
      expandIconScale,
      calc
    } = token2;
    const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
    const expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-expand-icon-col`]: {
          width: tableExpandColumnWidth
        },
        [`${componentCls}-row-expand-icon-cell`]: {
          textAlign: "center",
          [`${componentCls}-row-expand-icon`]: {
            display: "inline-flex",
            float: "none",
            verticalAlign: "sub"
          }
        },
        [`${componentCls}-row-indent`]: {
          height: 1,
          float: "left"
        },
        [`${componentCls}-row-expand-icon`]: Object.assign(Object.assign({}, operationUnit(token2)), {
          position: "relative",
          float: "left",
          width: expandIconSize,
          height: expandIconSize,
          color: "inherit",
          lineHeight: unit(expandIconSize),
          background: tableExpandIconBg,
          border: tableBorder,
          borderRadius,
          transform: `scale(${expandIconScale})`,
          "&:focus, &:hover, &:active": {
            borderColor: "currentcolor"
          },
          "&::before, &::after": {
            position: "absolute",
            background: "currentcolor",
            transition: `transform ${motionDurationSlow} ease-out`,
            content: '""'
          },
          "&::before": {
            top: expandIconHalfInner,
            insetInlineEnd: expandIconLineOffset,
            insetInlineStart: expandIconLineOffset,
            height: lineWidth
          },
          "&::after": {
            top: expandIconLineOffset,
            bottom: expandIconLineOffset,
            insetInlineStart: expandIconHalfInner,
            width: lineWidth,
            transform: "rotate(90deg)"
          },
          // Motion effect
          "&-collapsed::before": {
            transform: "rotate(-180deg)"
          },
          "&-collapsed::after": {
            transform: "rotate(0deg)"
          },
          "&-spaced": {
            "&::before, &::after": {
              display: "none",
              content: "none"
            },
            background: "transparent",
            border: 0,
            visibility: "hidden"
          }
        }),
        [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
          marginTop: expandIconMarginTop,
          marginInlineEnd: paddingXS
        },
        [`tr${componentCls}-expanded-row`]: {
          "&, &:hover": {
            "> th, > td": {
              background: tableExpandedRowBg
            }
          },
          // https://github.com/ant-design/ant-design/issues/25573
          [`${antCls}-descriptions-view`]: {
            display: "flex",
            table: {
              flex: "auto",
              width: "100%"
            }
          }
        },
        // With fixed
        [`${componentCls}-expanded-row-fixed`]: {
          position: "relative",
          margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
          padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
        }
      }
    };
  };
  var expand_default = genExpandStyle;

  // node_modules/antd/es/table/style/filter.js
  var genFilterStyle = (token2) => {
    const {
      componentCls,
      antCls,
      iconCls,
      tableFilterDropdownWidth,
      tableFilterDropdownSearchWidth,
      paddingXXS,
      paddingXS,
      colorText,
      lineWidth,
      lineType,
      tableBorderColor,
      headerIconColor,
      fontSizeSM,
      tablePaddingHorizontal,
      borderRadius,
      motionDurationSlow,
      colorIcon,
      colorPrimary,
      tableHeaderFilterActiveBg,
      colorTextDisabled,
      tableFilterDropdownBg,
      tableFilterDropdownHeight,
      controlItemBgHover,
      controlItemBgActive,
      boxShadowSecondary,
      filterDropdownMenuBg,
      calc
    } = token2;
    const dropdownPrefixCls = `${antCls}-dropdown`;
    const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
    const treePrefixCls = `${antCls}-tree`;
    const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
    return [
      {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-filter-column`]: {
            display: "flex",
            justifyContent: "space-between"
          },
          [`${componentCls}-filter-trigger`]: {
            position: "relative",
            display: "flex",
            alignItems: "center",
            marginBlock: calc(paddingXXS).mul(-1).equal(),
            marginInline: `${unit(paddingXXS)} ${unit(calc(tablePaddingHorizontal).div(2).mul(-1).equal())}`,
            padding: `0 ${unit(paddingXXS)}`,
            color: headerIconColor,
            fontSize: fontSizeSM,
            borderRadius,
            cursor: "pointer",
            transition: `all ${motionDurationSlow}`,
            "&:hover": {
              color: colorIcon,
              background: tableHeaderFilterActiveBg
            },
            "&.active": {
              color: colorPrimary
            }
          }
        }
      },
      {
        // Dropdown
        [`${antCls}-dropdown`]: {
          [tableFilterDropdownPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            minWidth: tableFilterDropdownWidth,
            backgroundColor: tableFilterDropdownBg,
            borderRadius,
            boxShadow: boxShadowSecondary,
            overflow: "hidden",
            // Reset menu
            [`${dropdownPrefixCls}-menu`]: {
              // https://github.com/ant-design/ant-design/issues/4916
              // https://github.com/ant-design/ant-design/issues/19542
              maxHeight: tableFilterDropdownHeight,
              overflowX: "hidden",
              border: 0,
              boxShadow: "none",
              borderRadius: "unset",
              backgroundColor: filterDropdownMenuBg,
              "&:empty::after": {
                display: "block",
                padding: `${unit(paddingXS)} 0`,
                color: colorTextDisabled,
                fontSize: fontSizeSM,
                textAlign: "center",
                content: '"Not Found"'
              }
            },
            [`${tableFilterDropdownPrefixCls}-tree`]: {
              paddingBlock: `${unit(paddingXS)} 0`,
              paddingInline: paddingXS,
              [treePrefixCls]: {
                padding: 0
              },
              [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
                backgroundColor: controlItemBgHover
              },
              [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
                "&, &:hover": {
                  backgroundColor: controlItemBgActive
                }
              }
            },
            [`${tableFilterDropdownPrefixCls}-search`]: {
              padding: paddingXS,
              borderBottom: tableBorder,
              "&-input": {
                input: {
                  minWidth: tableFilterDropdownSearchWidth
                },
                [iconCls]: {
                  color: colorTextDisabled
                }
              }
            },
            [`${tableFilterDropdownPrefixCls}-checkall`]: {
              width: "100%",
              marginBottom: paddingXXS,
              marginInlineStart: paddingXXS
            },
            // Operation
            [`${tableFilterDropdownPrefixCls}-btns`]: {
              display: "flex",
              justifyContent: "space-between",
              padding: `${unit(calc(paddingXS).sub(lineWidth).equal())} ${unit(paddingXS)}`,
              overflow: "hidden",
              borderTop: tableBorder
            }
          })
        }
      },
      // Dropdown Menu & SubMenu
      {
        // submenu of table filter dropdown
        [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
          // Checkbox
          [`${antCls}-checkbox-wrapper + span`]: {
            paddingInlineStart: paddingXS,
            color: colorText
          },
          "> ul": {
            maxHeight: "calc(100vh - 130px)",
            overflowX: "hidden",
            overflowY: "auto"
          }
        }
      }
    ];
  };
  var filter_default = genFilterStyle;

  // node_modules/antd/es/table/style/fixed.js
  var genFixedStyle = (token2) => {
    const {
      componentCls,
      lineWidth,
      colorSplit,
      motionDurationSlow,
      zIndexTableFixed: zIndexTableFixed2,
      tableBg,
      zIndexTableSticky,
      calc
    } = token2;
    const shadowColor = colorSplit;
    return {
      [`${componentCls}-wrapper`]: {
        [`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
          position: "sticky !important",
          zIndex: zIndexTableFixed2,
          background: tableBg
        },
        [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
          position: "absolute",
          top: 0,
          right: {
            _skip_check_: true,
            value: 0
          },
          bottom: calc(lineWidth).mul(-1).equal(),
          width: 30,
          transform: "translateX(100%)",
          transition: `box-shadow ${motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        },
        [`${componentCls}-cell-fix-left-all::after`]: {
          display: "none"
        },
        [`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
          position: "absolute",
          top: 0,
          bottom: calc(lineWidth).mul(-1).equal(),
          left: {
            _skip_check_: true,
            value: 0
          },
          width: 30,
          transform: "translateX(-100%)",
          transition: `box-shadow ${motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        },
        [`${componentCls}-container`]: {
          position: "relative",
          "&::before, &::after": {
            position: "absolute",
            top: 0,
            bottom: 0,
            zIndex: calc(zIndexTableSticky).add(1).equal({
              unit: false
            }),
            width: 30,
            transition: `box-shadow ${motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          },
          "&::before": {
            insetInlineStart: 0
          },
          "&::after": {
            insetInlineEnd: 0
          }
        },
        [`${componentCls}-ping-left`]: {
          [`&:not(${componentCls}-has-fix-left) ${componentCls}-container::before`]: {
            boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
          },
          [`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: {
            boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
          },
          [`${componentCls}-cell-fix-left-last::before`]: {
            backgroundColor: "transparent !important"
          }
        },
        [`${componentCls}-ping-right`]: {
          [`&:not(${componentCls}-has-fix-right) ${componentCls}-container::after`]: {
            boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
          },
          [`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: {
            boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
          }
        },
        // Gapped fixed Columns do not show the shadow
        [`${componentCls}-fixed-column-gapped`]: {
          [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after,
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
            boxShadow: "none"
          }
        }
      }
    };
  };
  var fixed_default = genFixedStyle;

  // node_modules/antd/es/table/style/pagination.js
  var genPaginationStyle2 = (token2) => {
    const {
      componentCls,
      antCls,
      margin
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        // ========================== Pagination ==========================
        [`${componentCls}-pagination${antCls}-pagination`]: {
          margin: `${unit(margin)} 0`
        },
        [`${componentCls}-pagination`]: {
          display: "flex",
          flexWrap: "wrap",
          rowGap: token2.paddingXS,
          "> *": {
            flex: "none"
          },
          "&-left": {
            justifyContent: "flex-start"
          },
          "&-center": {
            justifyContent: "center"
          },
          "&-right": {
            justifyContent: "flex-end"
          }
        }
      }
    };
  };
  var pagination_default2 = genPaginationStyle2;

  // node_modules/antd/es/table/style/radius.js
  var genRadiusStyle = (token2) => {
    const {
      componentCls,
      tableRadius
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [componentCls]: {
          // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
          [`${componentCls}-title, ${componentCls}-header`]: {
            borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`
          },
          [`${componentCls}-title + ${componentCls}-container`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0,
            // https://github.com/ant-design/ant-design/issues/41975
            [`${componentCls}-header, table`]: {
              borderRadius: 0
            },
            "table > thead > tr:first-child": {
              "th:first-child, th:last-child, td:first-child, td:last-child": {
                borderRadius: 0
              }
            }
          },
          "&-container": {
            borderStartStartRadius: tableRadius,
            borderStartEndRadius: tableRadius,
            "table > thead > tr:first-child": {
              "> *:first-child": {
                borderStartStartRadius: tableRadius
              },
              "> *:last-child": {
                borderStartEndRadius: tableRadius
              }
            }
          },
          "&-footer": {
            borderRadius: `0 0 ${unit(tableRadius)} ${unit(tableRadius)}`
          }
        }
      }
    };
  };
  var radius_default = genRadiusStyle;

  // node_modules/antd/es/table/style/rtl.js
  var genStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-wrapper-rtl`]: {
        direction: "rtl",
        table: {
          direction: "rtl"
        },
        [`${componentCls}-pagination-left`]: {
          justifyContent: "flex-end"
        },
        [`${componentCls}-pagination-right`]: {
          justifyContent: "flex-start"
        },
        [`${componentCls}-row-expand-icon`]: {
          float: "right",
          "&::after": {
            transform: "rotate(-90deg)"
          },
          "&-collapsed::before": {
            transform: "rotate(180deg)"
          },
          "&-collapsed::after": {
            transform: "rotate(0deg)"
          }
        },
        [`${componentCls}-container`]: {
          "&::before": {
            insetInlineStart: "unset",
            insetInlineEnd: 0
          },
          "&::after": {
            insetInlineStart: 0,
            insetInlineEnd: "unset"
          },
          [`${componentCls}-row-indent`]: {
            float: "right"
          }
        }
      }
    };
  };
  var rtl_default2 = genStyle;

  // node_modules/antd/es/table/style/selection.js
  var genSelectionStyle2 = (token2) => {
    const {
      componentCls,
      antCls,
      iconCls,
      fontSizeIcon,
      padding,
      paddingXS,
      headerIconColor,
      headerIconHoverColor,
      tableSelectionColumnWidth,
      tableSelectedRowBg,
      tableSelectedRowHoverBg,
      tableRowHoverBg,
      tablePaddingHorizontal,
      calc
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        // ========================== Selections ==========================
        [`${componentCls}-selection-col`]: {
          width: tableSelectionColumnWidth,
          [`&${componentCls}-selection-col-with-dropdown`]: {
            width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal()
          }
        },
        [`${componentCls}-bordered ${componentCls}-selection-col`]: {
          width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
          [`&${componentCls}-selection-col-with-dropdown`]: {
            width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal()
          }
        },
        [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
          paddingInlineEnd: token2.paddingXS,
          paddingInlineStart: token2.paddingXS,
          textAlign: "center",
          [`${antCls}-radio-wrapper`]: {
            marginInlineEnd: 0
          }
        },
        [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
          zIndex: calc(token2.zIndexTableFixed).add(1).equal({
            unit: false
          })
        },
        [`table tr th${componentCls}-selection-column::after`]: {
          backgroundColor: "transparent !important"
        },
        [`${componentCls}-selection`]: {
          position: "relative",
          display: "inline-flex",
          flexDirection: "column"
        },
        [`${componentCls}-selection-extra`]: {
          position: "absolute",
          top: 0,
          zIndex: 1,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          marginInlineStart: "100%",
          paddingInlineStart: unit(calc(tablePaddingHorizontal).div(4).equal()),
          [iconCls]: {
            color: headerIconColor,
            fontSize: fontSizeIcon,
            verticalAlign: "baseline",
            "&:hover": {
              color: headerIconHoverColor
            }
          }
        },
        // ============================= Rows =============================
        [`${componentCls}-tbody`]: {
          [`${componentCls}-row`]: {
            [`&${componentCls}-row-selected`]: {
              [`> ${componentCls}-cell`]: {
                background: tableSelectedRowBg,
                "&-row-hover": {
                  background: tableSelectedRowHoverBg
                }
              }
            },
            [`> ${componentCls}-cell-row-hover`]: {
              background: tableRowHoverBg
            }
          }
        }
      }
    };
  };
  var selection_default = genSelectionStyle2;

  // node_modules/antd/es/table/style/size.js
  var genSizeStyle4 = (token2) => {
    const {
      componentCls,
      tableExpandColumnWidth,
      calc
    } = token2;
    const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({
      [`${componentCls}${componentCls}-${size}`]: {
        fontSize,
        [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
          padding: `${unit(paddingVertical)} ${unit(paddingHorizontal)}`
        },
        [`${componentCls}-filter-trigger`]: {
          marginInlineEnd: unit(calc(paddingHorizontal).div(2).mul(-1).equal())
        },
        [`${componentCls}-expanded-row-fixed`]: {
          margin: `${unit(calc(paddingVertical).mul(-1).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
        },
        [`${componentCls}-tbody`]: {
          // ========================= Nest Table ===========================
          [`${componentCls}-wrapper:only-child ${componentCls}`]: {
            marginBlock: unit(calc(paddingVertical).mul(-1).equal()),
            marginInline: `${unit(calc(tableExpandColumnWidth).sub(paddingHorizontal).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
          }
        },
        // https://github.com/ant-design/ant-design/issues/35167
        [`${componentCls}-selection-extra`]: {
          paddingInlineStart: unit(calc(paddingHorizontal).div(4).equal())
        }
      }
    });
    return {
      [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, getSizeStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle, token2.tableFontSizeMiddle)), getSizeStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall, token2.tableFontSizeSmall))
    };
  };
  var size_default = genSizeStyle4;

  // node_modules/antd/es/table/style/sorter.js
  var genSorterStyle = (token2) => {
    const {
      componentCls,
      marginXXS,
      fontSizeIcon,
      headerIconColor,
      headerIconHoverColor
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
          outline: "none",
          cursor: "pointer",
          // why left 0s? Avoid column header move with transition when left is changed
          // https://github.com/ant-design/ant-design/issues/50588
          transition: `all ${token2.motionDurationSlow}, left 0s`,
          "&:hover": {
            background: token2.tableHeaderSortHoverBg,
            "&::before": {
              backgroundColor: "transparent !important"
            }
          },
          "&:focus-visible": {
            color: token2.colorPrimary
          },
          // https://github.com/ant-design/ant-design/issues/30969
          [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
            background: token2.tableFixedHeaderSortActiveBg
          }
        },
        [`${componentCls}-thead th${componentCls}-column-sort`]: {
          background: token2.tableHeaderSortBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        [`td${componentCls}-column-sort`]: {
          background: token2.tableBodySortBg
        },
        [`${componentCls}-column-title`]: {
          position: "relative",
          zIndex: 1,
          flex: 1,
          minWidth: 0
        },
        [`${componentCls}-column-sorters`]: {
          display: "flex",
          flex: "auto",
          alignItems: "center",
          justifyContent: "space-between",
          "&::after": {
            position: "absolute",
            inset: 0,
            width: "100%",
            height: "100%",
            content: '""'
          }
        },
        [`${componentCls}-column-sorters-tooltip-target-sorter`]: {
          "&::after": {
            content: "none"
          }
        },
        [`${componentCls}-column-sorter`]: {
          marginInlineStart: marginXXS,
          color: headerIconColor,
          fontSize: 0,
          transition: `color ${token2.motionDurationSlow}`,
          "&-inner": {
            display: "inline-flex",
            flexDirection: "column",
            alignItems: "center"
          },
          "&-up, &-down": {
            fontSize: fontSizeIcon,
            "&.active": {
              color: token2.colorPrimary
            }
          },
          [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
            marginTop: "-0.3em"
          }
        },
        [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
          color: headerIconHoverColor
        }
      }
    };
  };
  var sorter_default = genSorterStyle;

  // node_modules/antd/es/table/style/sticky.js
  var genStickyStyle = (token2) => {
    const {
      componentCls,
      opacityLoading,
      tableScrollThumbBg,
      tableScrollThumbBgHover,
      tableScrollThumbSize,
      tableScrollBg,
      zIndexTableSticky,
      stickyScrollBarBorderRadius,
      lineWidth,
      lineType,
      tableBorderColor
    } = token2;
    const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-sticky`]: {
          "&-holder": {
            position: "sticky",
            zIndex: zIndexTableSticky,
            background: token2.colorBgContainer
          },
          "&-scroll": {
            position: "sticky",
            bottom: 0,
            height: `${unit(tableScrollThumbSize)} !important`,
            zIndex: zIndexTableSticky,
            display: "flex",
            alignItems: "center",
            background: tableScrollBg,
            borderTop: tableBorder,
            opacity: opacityLoading,
            "&:hover": {
              transformOrigin: "center bottom"
            },
            // fake scrollbar style of sticky
            "&-bar": {
              height: tableScrollThumbSize,
              backgroundColor: tableScrollThumbBg,
              borderRadius: stickyScrollBarBorderRadius,
              transition: `all ${token2.motionDurationSlow}, transform 0s`,
              position: "absolute",
              bottom: 0,
              "&:hover, &-active": {
                backgroundColor: tableScrollThumbBgHover
              }
            }
          }
        }
      }
    };
  };
  var sticky_default = genStickyStyle;

  // node_modules/antd/es/table/style/summary.js
  var genSummaryStyle = (token2) => {
    const {
      componentCls,
      lineWidth,
      tableBorderColor,
      calc
    } = token2;
    const tableBorder = `${unit(lineWidth)} ${token2.lineType} ${tableBorderColor}`;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-summary`]: {
          position: "relative",
          zIndex: token2.zIndexTableFixed,
          background: token2.tableBg,
          "> tr": {
            "> th, > td": {
              borderBottom: tableBorder
            }
          }
        },
        [`div${componentCls}-summary`]: {
          boxShadow: `0 ${unit(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}`
        }
      }
    };
  };
  var summary_default = genSummaryStyle;

  // node_modules/antd/es/table/style/virtual.js
  var genVirtualStyle = (token2) => {
    const {
      componentCls,
      motionDurationMid,
      lineWidth,
      lineType,
      tableBorderColor,
      calc
    } = token2;
    const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
    const rowCellCls = `${componentCls}-expanded-row-cell`;
    return {
      [`${componentCls}-wrapper`]: {
        // ========================== Row ==========================
        [`${componentCls}-tbody-virtual`]: {
          [`${componentCls}-tbody-virtual-holder-inner`]: {
            [`
            & > ${componentCls}-row, 
            & > div:not(${componentCls}-row) > ${componentCls}-row
          `]: {
              display: "flex",
              boxSizing: "border-box",
              width: "100%"
            }
          },
          [`${componentCls}-cell`]: {
            borderBottom: tableBorder,
            transition: `background ${motionDurationMid}`
          },
          [`${componentCls}-expanded-row`]: {
            [`${rowCellCls}${rowCellCls}-fixed`]: {
              position: "sticky",
              insetInlineStart: 0,
              overflow: "hidden",
              width: `calc(var(--virtual-width) - ${unit(lineWidth)})`,
              borderInlineEnd: "none"
            }
          }
        },
        // ======================== Border =========================
        [`${componentCls}-bordered`]: {
          [`${componentCls}-tbody-virtual`]: {
            "&:after": {
              content: '""',
              insetInline: 0,
              bottom: 0,
              borderBottom: tableBorder,
              position: "absolute"
            },
            [`${componentCls}-cell`]: {
              borderInlineEnd: tableBorder,
              [`&${componentCls}-cell-fix-right-first:before`]: {
                content: '""',
                position: "absolute",
                insetBlock: 0,
                insetInlineStart: calc(lineWidth).mul(-1).equal(),
                borderInlineStart: tableBorder
              }
            }
          },
          // Empty placeholder
          [`&${componentCls}-virtual`]: {
            [`${componentCls}-placeholder ${componentCls}-cell`]: {
              borderInlineEnd: tableBorder,
              borderBottom: tableBorder
            }
          }
        }
      }
    };
  };
  var virtual_default = genVirtualStyle;

  // node_modules/antd/es/table/style/index.js
  var genTableStyle = (token2) => {
    const {
      componentCls,
      fontWeightStrong,
      tablePaddingVertical,
      tablePaddingHorizontal,
      tableExpandColumnWidth,
      lineWidth,
      lineType,
      tableBorderColor,
      tableFontSize,
      tableBg,
      tableRadius,
      tableHeaderTextColor,
      motionDurationMid,
      tableHeaderBg,
      tableHeaderCellSplitColor,
      tableFooterTextColor,
      tableFooterBg,
      calc
    } = token2;
    const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
    return {
      [`${componentCls}-wrapper`]: Object.assign(Object.assign({
        clear: "both",
        maxWidth: "100%",
        // fix https://github.com/ant-design/ant-design/issues/46177
        ["--rc-virtual-list-scrollbar-bg"]: token2.tableScrollBg
      }, clearFix()), {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          fontSize: tableFontSize,
          background: tableBg,
          borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
          // https://github.com/ant-design/ant-design/issues/47486
          scrollbarColor: `${token2.tableScrollThumbBg} ${token2.tableScrollBg}`
        }),
        // https://github.com/ant-design/ant-design/issues/17611
        table: {
          width: "100%",
          textAlign: "start",
          borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
          borderCollapse: "separate",
          borderSpacing: 0
        },
        // ============================= Cell ==============================
        [`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
          position: "relative",
          padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
          overflowWrap: "break-word"
        },
        // ============================ Title =============================
        [`${componentCls}-title`]: {
          padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
        },
        // ============================ Header ============================
        [`${componentCls}-thead`]: {
          [`
          > tr > th,
          > tr > td
        `]: {
            position: "relative",
            color: tableHeaderTextColor,
            fontWeight: fontWeightStrong,
            textAlign: "start",
            background: tableHeaderBg,
            borderBottom: tableBorder,
            transition: `background ${motionDurationMid} ease`,
            "&[colspan]:not([colspan='1'])": {
              textAlign: "center"
            },
            [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
              position: "absolute",
              top: "50%",
              insetInlineEnd: 0,
              width: 1,
              height: "1.6em",
              backgroundColor: tableHeaderCellSplitColor,
              transform: "translateY(-50%)",
              transition: `background-color ${motionDurationMid}`,
              content: '""'
            }
          },
          "> tr:not(:last-child) > th[colspan]": {
            borderBottom: 0
          }
        },
        // ============================ Body ============================
        [`${componentCls}-tbody`]: {
          "> tr": {
            "> th, > td": {
              transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
              borderBottom: tableBorder,
              // ========================= Nest Table ===========================
              [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
                [componentCls]: {
                  marginBlock: unit(calc(tablePaddingVertical).mul(-1).equal()),
                  marginInline: `${unit(calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal())}
                ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
                  [`${componentCls}-tbody > tr:last-child > td`]: {
                    borderBottomWidth: 0,
                    "&:first-child, &:last-child": {
                      borderRadius: 0
                    }
                  }
                }
              }
            },
            "> th": {
              position: "relative",
              color: tableHeaderTextColor,
              fontWeight: fontWeightStrong,
              textAlign: "start",
              background: tableHeaderBg,
              borderBottom: tableBorder,
              transition: `background ${motionDurationMid} ease`
            }
          }
        },
        // ============================ Footer ============================
        [`${componentCls}-footer`]: {
          padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
          color: tableFooterTextColor,
          background: tableFooterBg
        }
      })
    };
  };
  var prepareComponentToken19 = (token2) => {
    const {
      colorFillAlter,
      colorBgContainer,
      colorTextHeading,
      colorFillSecondary,
      colorFillContent,
      controlItemBgActive,
      controlItemBgActiveHover,
      padding,
      paddingSM,
      paddingXS,
      colorBorderSecondary,
      borderRadiusLG,
      controlHeight,
      colorTextPlaceholder,
      fontSize,
      fontSizeSM,
      lineHeight,
      lineWidth,
      colorIcon,
      colorIconHover,
      opacityLoading,
      controlInteractiveSize
    } = token2;
    const colorFillSecondarySolid = new FastColor(colorFillSecondary).onBackground(colorBgContainer).toHexString();
    const colorFillContentSolid = new FastColor(colorFillContent).onBackground(colorBgContainer).toHexString();
    const colorFillAlterSolid = new FastColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
    const baseColorAction = new FastColor(colorIcon);
    const baseColorActionHover = new FastColor(colorIconHover);
    const expandIconHalfInner = controlInteractiveSize / 2 - lineWidth;
    const expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
    return {
      headerBg: colorFillAlterSolid,
      headerColor: colorTextHeading,
      headerSortActiveBg: colorFillSecondarySolid,
      headerSortHoverBg: colorFillContentSolid,
      bodySortBg: colorFillAlterSolid,
      rowHoverBg: colorFillAlterSolid,
      rowSelectedBg: controlItemBgActive,
      rowSelectedHoverBg: controlItemBgActiveHover,
      rowExpandedBg: colorFillAlter,
      cellPaddingBlock: padding,
      cellPaddingInline: padding,
      cellPaddingBlockMD: paddingSM,
      cellPaddingInlineMD: paddingXS,
      cellPaddingBlockSM: paddingXS,
      cellPaddingInlineSM: paddingXS,
      borderColor: colorBorderSecondary,
      headerBorderRadius: borderRadiusLG,
      footerBg: colorFillAlterSolid,
      footerColor: colorTextHeading,
      cellFontSize: fontSize,
      cellFontSizeMD: fontSize,
      cellFontSizeSM: fontSize,
      headerSplitColor: colorBorderSecondary,
      fixedHeaderSortActiveBg: colorFillSecondarySolid,
      headerFilterHoverBg: colorFillContent,
      filterDropdownMenuBg: colorBgContainer,
      filterDropdownBg: colorBgContainer,
      expandIconBg: colorBgContainer,
      selectionColumnWidth: controlHeight,
      stickyScrollBarBg: colorTextPlaceholder,
      stickyScrollBarBorderRadius: 100,
      expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
      headerIconColor: baseColorAction.clone().setA(baseColorAction.a * opacityLoading).toRgbString(),
      headerIconHoverColor: baseColorActionHover.clone().setA(baseColorActionHover.a * opacityLoading).toRgbString(),
      expandIconHalfInner,
      expandIconSize,
      expandIconScale: controlInteractiveSize / expandIconSize
    };
  };
  var zIndexTableFixed = 2;
  var style_default24 = genStyleHooks("Table", (token2) => {
    const {
      colorTextHeading,
      colorSplit,
      colorBgContainer,
      controlInteractiveSize: checkboxSize,
      headerBg,
      headerColor,
      headerSortActiveBg,
      headerSortHoverBg,
      bodySortBg,
      rowHoverBg,
      rowSelectedBg,
      rowSelectedHoverBg,
      rowExpandedBg,
      cellPaddingBlock,
      cellPaddingInline,
      cellPaddingBlockMD,
      cellPaddingInlineMD,
      cellPaddingBlockSM,
      cellPaddingInlineSM,
      borderColor,
      footerBg,
      footerColor,
      headerBorderRadius,
      cellFontSize,
      cellFontSizeMD,
      cellFontSizeSM,
      headerSplitColor,
      fixedHeaderSortActiveBg,
      headerFilterHoverBg,
      filterDropdownBg,
      expandIconBg,
      selectionColumnWidth,
      stickyScrollBarBg,
      calc
    } = token2;
    const tableToken = merge2(token2, {
      tableFontSize: cellFontSize,
      tableBg: colorBgContainer,
      tableRadius: headerBorderRadius,
      tablePaddingVertical: cellPaddingBlock,
      tablePaddingHorizontal: cellPaddingInline,
      tablePaddingVerticalMiddle: cellPaddingBlockMD,
      tablePaddingHorizontalMiddle: cellPaddingInlineMD,
      tablePaddingVerticalSmall: cellPaddingBlockSM,
      tablePaddingHorizontalSmall: cellPaddingInlineSM,
      tableBorderColor: borderColor,
      tableHeaderTextColor: headerColor,
      tableHeaderBg: headerBg,
      tableFooterTextColor: footerColor,
      tableFooterBg: footerBg,
      tableHeaderCellSplitColor: headerSplitColor,
      tableHeaderSortBg: headerSortActiveBg,
      tableHeaderSortHoverBg: headerSortHoverBg,
      tableBodySortBg: bodySortBg,
      tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
      tableHeaderFilterActiveBg: headerFilterHoverBg,
      tableFilterDropdownBg: filterDropdownBg,
      tableRowHoverBg: rowHoverBg,
      tableSelectedRowBg: rowSelectedBg,
      tableSelectedRowHoverBg: rowSelectedHoverBg,
      zIndexTableFixed,
      zIndexTableSticky: calc(zIndexTableFixed).add(1).equal({
        unit: false
      }),
      tableFontSizeMiddle: cellFontSizeMD,
      tableFontSizeSmall: cellFontSizeSM,
      tableSelectionColumnWidth: selectionColumnWidth,
      tableExpandIconBg: expandIconBg,
      tableExpandColumnWidth: calc(checkboxSize).add(calc(token2.padding).mul(2)).equal(),
      tableExpandedRowBg: rowExpandedBg,
      // Dropdown
      tableFilterDropdownWidth: 120,
      tableFilterDropdownHeight: 264,
      tableFilterDropdownSearchWidth: 140,
      // Virtual Scroll Bar
      tableScrollThumbSize: 8,
      // Mac scroll bar size
      tableScrollThumbBg: stickyScrollBarBg,
      tableScrollThumbBgHover: colorTextHeading,
      tableScrollBg: colorSplit
    });
    return [genTableStyle(tableToken), pagination_default2(tableToken), summary_default(tableToken), sorter_default(tableToken), filter_default(tableToken), bordered_default2(tableToken), radius_default(tableToken), expand_default(tableToken), summary_default(tableToken), empty_default3(tableToken), selection_default(tableToken), fixed_default(tableToken), sticky_default(tableToken), ellipsis_default(tableToken), size_default(tableToken), rtl_default2(tableToken), virtual_default(tableToken)];
  }, prepareComponentToken19, {
    unitless: {
      expandIconScale: true
    }
  });

  // node_modules/antd/es/table/InternalTable.js
  var EMPTY_LIST5 = [];
  var InternalTable = (props, ref) => {
    var _a, _b;
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      size: customizeSize,
      bordered,
      dropdownPrefixCls: customizeDropdownPrefixCls,
      dataSource,
      pagination,
      rowSelection,
      rowKey = "key",
      rowClassName,
      columns,
      children,
      childrenColumnName: legacyChildrenColumnName,
      onChange,
      getPopupContainer,
      loading,
      expandIcon,
      expandable,
      expandedRowRender,
      expandIconColumnIndex,
      indentSize,
      scroll,
      sortDirections,
      locale: locale6,
      showSorterTooltip = {
        target: "full-header"
      },
      virtual
    } = props;
    const warning6 = devUseWarning("Table");
    if (true) {
      true ? warning6(!(typeof rowKey === "function" && rowKey.length > 1), "usage", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.") : void 0;
    }
    const baseColumns = React392.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]);
    const needResponsive = React392.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]);
    const screens = useBreakpoint_default(needResponsive);
    const mergedColumns = React392.useMemo(() => {
      const matched = new Set(Object.keys(screens).filter((m) => screens[m]));
      return baseColumns.filter((c) => !c.responsive || c.responsive.some((r2) => matched.has(r2)));
    }, [baseColumns, screens]);
    const tableProps = omit(props, ["className", "style", "columns"]);
    const {
      locale: contextLocale = en_US_default6,
      direction,
      table,
      renderEmpty,
      getPrefixCls,
      getPopupContainer: getContextPopupContainer
    } = React392.useContext(ConfigContext);
    const mergedSize = useSize_default(customizeSize);
    const tableLocale = Object.assign(Object.assign({}, contextLocale.Table), locale6);
    const rawData = dataSource || EMPTY_LIST5;
    const prefixCls = getPrefixCls("table", customizePrefixCls);
    const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
    const [, token2] = useToken();
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default24(prefixCls, rootCls);
    const mergedExpandable = Object.assign(Object.assign({
      childrenColumnName: legacyChildrenColumnName,
      expandIconColumnIndex
    }, expandable), {
      expandIcon: (_a = expandable === null || expandable === void 0 ? void 0 : expandable.expandIcon) !== null && _a !== void 0 ? _a : (_b = table === null || table === void 0 ? void 0 : table.expandable) === null || _b === void 0 ? void 0 : _b.expandIcon
    });
    const {
      childrenColumnName = "children"
    } = mergedExpandable;
    const expandType = React392.useMemo(() => {
      if (rawData.some((item) => item === null || item === void 0 ? void 0 : item[childrenColumnName])) {
        return "nest";
      }
      if (expandedRowRender || (expandable === null || expandable === void 0 ? void 0 : expandable.expandedRowRender)) {
        return "row";
      }
      return null;
    }, [rawData]);
    const internalRefs = {
      body: React392.useRef(null)
    };
    const getContainerWidth = useContainerWidth(prefixCls);
    const rootRef = React392.useRef(null);
    const tblRef = React392.useRef(null);
    useProxyImperativeHandle(ref, () => Object.assign(Object.assign({}, tblRef.current), {
      nativeElement: rootRef.current
    }));
    const getRowKey = React392.useMemo(() => {
      if (typeof rowKey === "function") {
        return rowKey;
      }
      return (record) => record === null || record === void 0 ? void 0 : record[rowKey];
    }, [rowKey]);
    const [getRecordByKey] = useLazyKVMap_default(rawData, childrenColumnName, getRowKey);
    const changeEventInfo = {};
    const triggerOnChange = (info, action, reset = false) => {
      var _a2, _b2, _c, _d;
      const changeInfo = Object.assign(Object.assign({}, changeEventInfo), info);
      if (reset) {
        (_a2 = changeEventInfo.resetPagination) === null || _a2 === void 0 ? void 0 : _a2.call(changeEventInfo);
        if ((_b2 = changeInfo.pagination) === null || _b2 === void 0 ? void 0 : _b2.current) {
          changeInfo.pagination.current = 1;
        }
        if (pagination) {
          (_c = pagination.onChange) === null || _c === void 0 ? void 0 : _c.call(pagination, 1, (_d = changeInfo.pagination) === null || _d === void 0 ? void 0 : _d.pageSize);
        }
      }
      if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
        scrollTo(0, {
          getContainer: () => internalRefs.body.current
        });
      }
      onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
        currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates, childrenColumnName),
        action
      });
    };
    const onSorterChange = (sorter, sorterStates) => {
      triggerOnChange({
        sorter,
        sorterStates
      }, "sort", false);
    };
    const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useSorter_default({
      prefixCls,
      mergedColumns,
      onSorterChange,
      sortDirections: sortDirections || ["ascend", "descend"],
      tableLocale,
      showSorterTooltip
    });
    const sortedData = React392.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [rawData, sortStates]);
    changeEventInfo.sorter = getSorters();
    changeEventInfo.sorterStates = sortStates;
    const onFilterChange = (filters2, filterStates2) => {
      triggerOnChange({
        filters: filters2,
        filterStates: filterStates2
      }, "filter", true);
    };
    const [transformFilterColumns, filterStates, filters] = useFilter_default({
      prefixCls,
      locale: tableLocale,
      dropdownPrefixCls,
      mergedColumns,
      onFilterChange,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      rootClassName: (0, import_classnames146.default)(rootClassName, rootCls)
    });
    const mergedData = getFilterData(sortedData, filterStates, childrenColumnName);
    changeEventInfo.filters = filters;
    changeEventInfo.filterStates = filterStates;
    const columnTitleProps = React392.useMemo(() => {
      const mergedFilters = {};
      Object.keys(filters).forEach((filterKey) => {
        if (filters[filterKey] !== null) {
          mergedFilters[filterKey] = filters[filterKey];
        }
      });
      return Object.assign(Object.assign({}, sorterTitleProps), {
        filters: mergedFilters
      });
    }, [sorterTitleProps, filters]);
    const [transformTitleColumns] = useTitleColumns_default(columnTitleProps);
    const onPaginationChange = (current, pageSize) => {
      triggerOnChange({
        pagination: Object.assign(Object.assign({}, changeEventInfo.pagination), {
          current,
          pageSize
        })
      }, "paginate");
    };
    const [mergedPagination, resetPagination] = usePagination_default(mergedData.length, onPaginationChange, pagination);
    changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
    changeEventInfo.resetPagination = resetPagination;
    const pageData = React392.useMemo(() => {
      if (pagination === false || !mergedPagination.pageSize) {
        return mergedData;
      }
      const {
        current = 1,
        total,
        pageSize = DEFAULT_PAGE_SIZE
      } = mergedPagination;
      true ? warning6(current > 0, "usage", "`current` should be positive number.") : void 0;
      if (mergedData.length < total) {
        if (mergedData.length > pageSize) {
          true ? warning6(false, "usage", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.") : void 0;
          return mergedData.slice((current - 1) * pageSize, current * pageSize);
        }
        return mergedData;
      }
      return mergedData.slice((current - 1) * pageSize, current * pageSize);
    }, [!!pagination, mergedData, mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.current, mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize, mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total]);
    const [transformSelectionColumns, selectedKeySet] = useSelection_default({
      prefixCls,
      data: mergedData,
      pageData,
      getRowKey,
      getRecordByKey,
      expandType,
      childrenColumnName,
      locale: tableLocale,
      getPopupContainer: getPopupContainer || getContextPopupContainer
    }, rowSelection);
    const internalRowClassName = (record, index3, indent) => {
      let mergedRowClassName;
      if (typeof rowClassName === "function") {
        mergedRowClassName = (0, import_classnames146.default)(rowClassName(record, index3, indent));
      } else {
        mergedRowClassName = (0, import_classnames146.default)(rowClassName);
      }
      return (0, import_classnames146.default)({
        [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index3))
      }, mergedRowClassName);
    };
    mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
    mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || ExpandIcon_default(tableLocale);
    if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
      mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
    } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
      mergedExpandable.expandIconColumnIndex -= 1;
    }
    if (typeof mergedExpandable.indentSize !== "number") {
      mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
    }
    const transformColumns = React392.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
    let topPaginationNode;
    let bottomPaginationNode;
    if (pagination !== false && (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total)) {
      let paginationSize;
      if (mergedPagination.size) {
        paginationSize = mergedPagination.size;
      } else {
        paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
      }
      const renderPagination = (position4) => /* @__PURE__ */ React392.createElement(pagination_default, Object.assign({}, mergedPagination, {
        className: (0, import_classnames146.default)(`${prefixCls}-pagination ${prefixCls}-pagination-${position4}`, mergedPagination.className),
        size: paginationSize
      }));
      const defaultPosition = direction === "rtl" ? "left" : "right";
      const {
        position: position3
      } = mergedPagination;
      if (position3 !== null && Array.isArray(position3)) {
        const topPos = position3.find((p) => p.includes("top"));
        const bottomPos = position3.find((p) => p.includes("bottom"));
        const isDisable = position3.every((p) => `${p}` === "none");
        if (!topPos && !bottomPos && !isDisable) {
          bottomPaginationNode = renderPagination(defaultPosition);
        }
        if (topPos) {
          topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
        }
        if (bottomPos) {
          bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
        }
      } else {
        bottomPaginationNode = renderPagination(defaultPosition);
      }
    }
    let spinProps;
    if (typeof loading === "boolean") {
      spinProps = {
        spinning: loading
      };
    } else if (typeof loading === "object") {
      spinProps = Object.assign({
        spinning: true
      }, loading);
    }
    const wrapperClassNames = (0, import_classnames146.default)(cssVarCls, rootCls, `${prefixCls}-wrapper`, table === null || table === void 0 ? void 0 : table.className, {
      [`${prefixCls}-wrapper-rtl`]: direction === "rtl"
    }, className, rootClassName, hashId);
    const mergedStyle = Object.assign(Object.assign({}, table === null || table === void 0 ? void 0 : table.style), style2);
    const emptyText = typeof (locale6 === null || locale6 === void 0 ? void 0 : locale6.emptyText) !== "undefined" ? locale6.emptyText : (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Table")) || /* @__PURE__ */ React392.createElement(defaultRenderEmpty_default, {
      componentName: "Table"
    });
    const TableComponent = virtual ? VirtualTable_default2 : RcTable_default;
    const virtualProps = {};
    const listItemHeight = React392.useMemo(() => {
      const {
        fontSize,
        lineHeight,
        lineWidth,
        padding,
        paddingXS,
        paddingSM
      } = token2;
      const fontHeight = Math.floor(fontSize * lineHeight);
      switch (mergedSize) {
        case "middle":
          return paddingSM * 2 + fontHeight + lineWidth;
        case "small":
          return paddingXS * 2 + fontHeight + lineWidth;
        default:
          return padding * 2 + fontHeight + lineWidth;
      }
    }, [token2, mergedSize]);
    if (virtual) {
      virtualProps.listItemHeight = listItemHeight;
    }
    return wrapCSSVar(/* @__PURE__ */ React392.createElement("div", {
      ref: rootRef,
      className: wrapperClassNames,
      style: mergedStyle
    }, /* @__PURE__ */ React392.createElement(spin_default, Object.assign({
      spinning: false
    }, spinProps), topPaginationNode, /* @__PURE__ */ React392.createElement(TableComponent, Object.assign({}, virtualProps, tableProps, {
      ref: tblRef,
      columns: mergedColumns,
      direction,
      expandable: mergedExpandable,
      prefixCls,
      className: (0, import_classnames146.default)({
        [`${prefixCls}-middle`]: mergedSize === "middle",
        [`${prefixCls}-small`]: mergedSize === "small",
        [`${prefixCls}-bordered`]: bordered,
        [`${prefixCls}-empty`]: rawData.length === 0
      }, cssVarCls, rootCls, hashId),
      data: pageData,
      rowKey: getRowKey,
      rowClassName: internalRowClassName,
      emptyText,
      // Internal
      internalHooks: INTERNAL_HOOKS,
      internalRefs,
      transformColumns,
      getContainerWidth
    })), bottomPaginationNode)));
  };
  var InternalTable_default = /* @__PURE__ */ React392.forwardRef(InternalTable);

  // node_modules/antd/es/table/Table.js
  var Table2 = (props, ref) => {
    const renderTimesRef = React393.useRef(0);
    renderTimesRef.current += 1;
    return /* @__PURE__ */ React393.createElement(InternalTable_default, Object.assign({}, props, {
      ref,
      _renderTimes: renderTimesRef.current
    }));
  };
  var ForwardTable = /* @__PURE__ */ React393.forwardRef(Table2);
  ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
  ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
  ForwardTable.SELECTION_ALL = SELECTION_ALL;
  ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
  ForwardTable.SELECTION_NONE = SELECTION_NONE;
  ForwardTable.Column = Column_default2;
  ForwardTable.ColumnGroup = ColumnGroup_default2;
  ForwardTable.Summary = FooterComponents;
  if (true) {
    ForwardTable.displayName = "Table";
  }
  var Table_default2 = ForwardTable;

  // node_modules/antd/es/table/index.js
  var table_default = Table_default2;

  // node_modules/antd/es/tag/index.js
  var React395 = __toESM(require_react());
  var import_classnames148 = __toESM(require_classnames());

  // node_modules/antd/es/tag/CheckableTag.js
  var React394 = __toESM(require_react());
  var import_classnames147 = __toESM(require_classnames());

  // node_modules/antd/es/tag/style/index.js
  var genBaseStyle6 = (token2) => {
    const {
      paddingXXS,
      lineWidth,
      tagPaddingHorizontal,
      componentCls,
      calc
    } = token2;
    const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
    const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
    return {
      // Result
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-block",
        height: "auto",
        // https://github.com/ant-design/ant-design/pull/47504
        marginInlineEnd: token2.marginXS,
        paddingInline,
        fontSize: token2.tagFontSize,
        lineHeight: token2.tagLineHeight,
        whiteSpace: "nowrap",
        background: token2.defaultBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusSM,
        opacity: 1,
        transition: `all ${token2.motionDurationMid}`,
        textAlign: "start",
        position: "relative",
        // RTL
        [`&${componentCls}-rtl`]: {
          direction: "rtl"
        },
        "&, a, a:hover": {
          color: token2.defaultColor
        },
        [`${componentCls}-close-icon`]: {
          marginInlineStart: iconMarginInline,
          fontSize: token2.tagIconSize,
          color: token2.colorIcon,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorTextHeading
          }
        },
        [`&${componentCls}-has-color`]: {
          borderColor: "transparent",
          [`&, a, a:hover, ${token2.iconCls}-close, ${token2.iconCls}-close:hover`]: {
            color: token2.colorTextLightSolid
          }
        },
        "&-checkable": {
          backgroundColor: "transparent",
          borderColor: "transparent",
          cursor: "pointer",
          [`&:not(${componentCls}-checkable-checked):hover`]: {
            color: token2.colorPrimary,
            backgroundColor: token2.colorFillSecondary
          },
          "&:active, &-checked": {
            color: token2.colorTextLightSolid
          },
          "&-checked": {
            backgroundColor: token2.colorPrimary,
            "&:hover": {
              backgroundColor: token2.colorPrimaryHover
            }
          },
          "&:active": {
            backgroundColor: token2.colorPrimaryActive
          }
        },
        "&-hidden": {
          display: "none"
        },
        // To ensure that a space will be placed between character and `Icon`.
        [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
          marginInlineStart: paddingInline
        }
      }),
      [`${componentCls}-borderless`]: {
        borderColor: "transparent",
        background: token2.tagBorderlessBg
      }
    };
  };
  var prepareToken5 = (token2) => {
    const {
      lineWidth,
      fontSizeIcon,
      calc
    } = token2;
    const tagFontSize = token2.fontSizeSM;
    const tagToken = merge2(token2, {
      tagFontSize,
      tagLineHeight: unit(calc(token2.lineHeightSM).mul(tagFontSize).equal()),
      tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
      // Tag icon is much smaller
      tagPaddingHorizontal: 8,
      // Fixed padding.
      tagBorderlessBg: token2.defaultBg
    });
    return tagToken;
  };
  var prepareComponentToken20 = (token2) => ({
    defaultBg: new FastColor(token2.colorFillQuaternary).onBackground(token2.colorBgContainer).toHexString(),
    defaultColor: token2.colorText
  });
  var style_default25 = genStyleHooks("Tag", (token2) => {
    const tagToken = prepareToken5(token2);
    return genBaseStyle6(tagToken);
  }, prepareComponentToken20);

  // node_modules/antd/es/tag/CheckableTag.js
  var __rest54 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var CheckableTag = /* @__PURE__ */ React394.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      style: style2,
      className,
      checked,
      onChange,
      onClick
    } = props, restProps = __rest54(props, ["prefixCls", "style", "className", "checked", "onChange", "onClick"]);
    const {
      getPrefixCls,
      tag
    } = React394.useContext(ConfigContext);
    const handleClick = (e3) => {
      onChange === null || onChange === void 0 ? void 0 : onChange(!checked);
      onClick === null || onClick === void 0 ? void 0 : onClick(e3);
    };
    const prefixCls = getPrefixCls("tag", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
    const cls3 = (0, import_classnames147.default)(prefixCls, `${prefixCls}-checkable`, {
      [`${prefixCls}-checkable-checked`]: checked
    }, tag === null || tag === void 0 ? void 0 : tag.className, className, hashId, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React394.createElement("span", Object.assign({}, restProps, {
      ref,
      style: Object.assign(Object.assign({}, style2), tag === null || tag === void 0 ? void 0 : tag.style),
      className: cls3,
      onClick: handleClick
    })));
  });
  var CheckableTag_default = CheckableTag;

  // node_modules/antd/es/tag/style/presetCmp.js
  var genPresetStyle = (token2) => genPresetColor(token2, (colorKey, {
    textColor,
    lightBorderColor,
    lightColor,
    darkColor
  }) => ({
    [`${token2.componentCls}${token2.componentCls}-${colorKey}`]: {
      color: textColor,
      background: lightColor,
      borderColor: lightBorderColor,
      // Inverse color
      "&-inverse": {
        color: token2.colorTextLightSolid,
        background: darkColor,
        borderColor: darkColor
      },
      [`&${token2.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  }));
  var presetCmp_default = genSubStyleComponent(["Tag", "preset"], (token2) => {
    const tagToken = prepareToken5(token2);
    return genPresetStyle(tagToken);
  }, prepareComponentToken20);

  // node_modules/antd/es/_util/capitalize.js
  function capitalize(str) {
    if (typeof str !== "string") {
      return str;
    }
    const ret = str.charAt(0).toUpperCase() + str.slice(1);
    return ret;
  }

  // node_modules/antd/es/tag/style/statusCmp.js
  var genTagStatusStyle = (token2, status, cssVariableType) => {
    const capitalizedCssVariableType = capitalize(cssVariableType);
    return {
      [`${token2.componentCls}${token2.componentCls}-${status}`]: {
        color: token2[`color${cssVariableType}`],
        background: token2[`color${capitalizedCssVariableType}Bg`],
        borderColor: token2[`color${capitalizedCssVariableType}Border`],
        [`&${token2.componentCls}-borderless`]: {
          borderColor: "transparent"
        }
      }
    };
  };
  var statusCmp_default = genSubStyleComponent(["Tag", "status"], (token2) => {
    const tagToken = prepareToken5(token2);
    return [genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
  }, prepareComponentToken20);

  // node_modules/antd/es/tag/index.js
  var __rest55 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var InternalTag = /* @__PURE__ */ React395.forwardRef((tagProps, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      children,
      icon,
      color,
      onClose,
      bordered = true,
      visible: deprecatedVisible
    } = tagProps, props = __rest55(tagProps, ["prefixCls", "className", "rootClassName", "style", "children", "icon", "color", "onClose", "bordered", "visible"]);
    const {
      getPrefixCls,
      direction,
      tag: tagContext
    } = React395.useContext(ConfigContext);
    const [visible, setVisible] = React395.useState(true);
    const domProps = omit(props, ["closeIcon", "closable"]);
    if (true) {
      const warning6 = devUseWarning("Tag");
      warning6.deprecated(!("visible" in tagProps), "visible", "visible && <Tag />");
    }
    React395.useEffect(() => {
      if (deprecatedVisible !== void 0) {
        setVisible(deprecatedVisible);
      }
    }, [deprecatedVisible]);
    const isPreset = isPresetColor(color);
    const isStatus = isPresetStatusColor(color);
    const isInternalColor = isPreset || isStatus;
    const tagStyle = Object.assign(Object.assign({
      backgroundColor: color && !isInternalColor ? color : void 0
    }, tagContext === null || tagContext === void 0 ? void 0 : tagContext.style), style2);
    const prefixCls = getPrefixCls("tag", customizePrefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
    const tagClassName = (0, import_classnames148.default)(prefixCls, tagContext === null || tagContext === void 0 ? void 0 : tagContext.className, {
      [`${prefixCls}-${color}`]: isInternalColor,
      [`${prefixCls}-has-color`]: color && !isInternalColor,
      [`${prefixCls}-hidden`]: !visible,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-borderless`]: !bordered
    }, className, rootClassName, hashId, cssVarCls);
    const handleCloseClick = (e3) => {
      e3.stopPropagation();
      onClose === null || onClose === void 0 ? void 0 : onClose(e3);
      if (e3.defaultPrevented) {
        return;
      }
      setVisible(false);
    };
    const [, mergedCloseIcon] = useClosable(pickClosable(tagProps), pickClosable(tagContext), {
      closable: false,
      closeIconRender: (iconNode2) => {
        const replacement = /* @__PURE__ */ React395.createElement("span", {
          className: `${prefixCls}-close-icon`,
          onClick: handleCloseClick
        }, iconNode2);
        return replaceElement(iconNode2, replacement, (originProps) => ({
          onClick: (e3) => {
            var _a;
            (_a = originProps === null || originProps === void 0 ? void 0 : originProps.onClick) === null || _a === void 0 ? void 0 : _a.call(originProps, e3);
            handleCloseClick(e3);
          },
          className: (0, import_classnames148.default)(originProps === null || originProps === void 0 ? void 0 : originProps.className, `${prefixCls}-close-icon`)
        }));
      }
    });
    const isNeedWave = typeof props.onClick === "function" || children && children.type === "a";
    const iconNode = icon || null;
    const kids = iconNode ? /* @__PURE__ */ React395.createElement(React395.Fragment, null, iconNode, children && /* @__PURE__ */ React395.createElement("span", null, children)) : children;
    const tagNode = /* @__PURE__ */ React395.createElement("span", Object.assign({}, domProps, {
      ref,
      className: tagClassName,
      style: tagStyle
    }), kids, mergedCloseIcon, isPreset && /* @__PURE__ */ React395.createElement(presetCmp_default, {
      key: "preset",
      prefixCls
    }), isStatus && /* @__PURE__ */ React395.createElement(statusCmp_default, {
      key: "status",
      prefixCls
    }));
    return wrapCSSVar(isNeedWave ? /* @__PURE__ */ React395.createElement(wave_default, {
      component: "Tag"
    }, tagNode) : tagNode);
  });
  var Tag = InternalTag;
  if (true) {
    Tag.displayName = "Tag";
  }
  Tag.CheckableTag = CheckableTag_default;
  var tag_default = Tag;

  // node_modules/antd/es/upload/Dragger.js
  var React401 = __toESM(require_react());

  // node_modules/antd/es/upload/Upload.js
  var React400 = __toESM(require_react());
  var import_react_dom9 = __toESM(require_react_dom());
  var import_classnames152 = __toESM(require_classnames());

  // node_modules/rc-upload/es/Upload.js
  var import_react123 = __toESM(require_react());

  // node_modules/rc-upload/es/AjaxUploader.js
  var import_classnames149 = __toESM(require_classnames());
  var import_react122 = __toESM(require_react());

  // node_modules/rc-upload/es/attr-accept.js
  var attr_accept_default = function(file, acceptedFiles) {
    if (file && acceptedFiles) {
      var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
      var fileName = file.name || "";
      var mimeType = file.type || "";
      var baseMimeType = mimeType.replace(/\/.*$/, "");
      return acceptedFilesArray.some(function(type5) {
        var validType = type5.trim();
        if (/^\*(\/\*)?$/.test(type5)) {
          return true;
        }
        if (validType.charAt(0) === ".") {
          var lowerFileName = fileName.toLowerCase();
          var lowerType = validType.toLowerCase();
          var affixList = [lowerType];
          if (lowerType === ".jpg" || lowerType === ".jpeg") {
            affixList = [".jpg", ".jpeg"];
          }
          return affixList.some(function(affix) {
            return lowerFileName.endsWith(affix);
          });
        }
        if (/\/\*$/.test(validType)) {
          return baseMimeType === validType.replace(/\/.*$/, "");
        }
        if (mimeType === validType) {
          return true;
        }
        if (/^\w+$/.test(validType)) {
          warning_default(false, "Upload takes an invalidate 'accept' type '".concat(validType, "'.Skip for check."));
          return true;
        }
        return false;
      });
    }
    return true;
  };

  // node_modules/rc-upload/es/request.js
  function getError(option, xhr) {
    var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr.status, "'");
    var err = new Error(msg);
    err.status = xhr.status;
    err.method = option.method;
    err.url = option.action;
    return err;
  }
  function getBody(xhr) {
    var text = xhr.responseText || xhr.response;
    if (!text) {
      return text;
    }
    try {
      return JSON.parse(text);
    } catch (e3) {
      return text;
    }
  }
  function upload(option) {
    var xhr = new XMLHttpRequest();
    if (option.onProgress && xhr.upload) {
      xhr.upload.onprogress = function progress(e3) {
        if (e3.total > 0) {
          e3.percent = e3.loaded / e3.total * 100;
        }
        option.onProgress(e3);
      };
    }
    var formData = new FormData();
    if (option.data) {
      Object.keys(option.data).forEach(function(key) {
        var value = option.data[key];
        if (Array.isArray(value)) {
          value.forEach(function(item) {
            formData.append("".concat(key, "[]"), item);
          });
          return;
        }
        formData.append(key, value);
      });
    }
    if (option.file instanceof Blob) {
      formData.append(option.filename, option.file, option.file.name);
    } else {
      formData.append(option.filename, option.file);
    }
    xhr.onerror = function error(e3) {
      option.onError(e3);
    };
    xhr.onload = function onload() {
      if (xhr.status < 200 || xhr.status >= 300) {
        return option.onError(getError(option, xhr), getBody(xhr));
      }
      return option.onSuccess(getBody(xhr), xhr);
    };
    xhr.open(option.method, option.action, true);
    if (option.withCredentials && "withCredentials" in xhr) {
      xhr.withCredentials = true;
    }
    var headers = option.headers || {};
    if (headers["X-Requested-With"] !== null) {
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    Object.keys(headers).forEach(function(h) {
      if (headers[h] !== null) {
        xhr.setRequestHeader(h, headers[h]);
      }
    });
    xhr.send(formData);
    return {
      abort: function abort() {
        xhr.abort();
      }
    };
  }

  // node_modules/rc-upload/es/traverseFileTree.js
  var traverseFileTree = /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(files, isAccepted) {
      var flattenFileList, progressFileList, readDirectory, _readDirectory, readFile, _readFile, _traverseFileTree, wipIndex;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _readFile = function _readFile3() {
              _readFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(item) {
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      return _context3.abrupt("return", new Promise(function(reslove) {
                        item.file(function(file) {
                          if (isAccepted(file)) {
                            if (item.fullPath && !file.webkitRelativePath) {
                              Object.defineProperties(file, {
                                webkitRelativePath: {
                                  writable: true
                                }
                              });
                              file.webkitRelativePath = item.fullPath.replace(/^\//, "");
                              Object.defineProperties(file, {
                                webkitRelativePath: {
                                  writable: false
                                }
                              });
                            }
                            reslove(file);
                          } else {
                            reslove(null);
                          }
                        });
                      }));
                    case 1:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }));
              return _readFile.apply(this, arguments);
            };
            readFile = function _readFile2(_x4) {
              return _readFile.apply(this, arguments);
            };
            _readDirectory = function _readDirectory3() {
              _readDirectory = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(directory) {
                var dirReader, entries, results, n2, i;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      dirReader = directory.createReader();
                      entries = [];
                    case 2:
                      if (false) {
                        _context2.next = 12;
                        break;
                      }
                      _context2.next = 5;
                      return new Promise(function(resolve) {
                        dirReader.readEntries(resolve, function() {
                          return resolve([]);
                        });
                      });
                    case 5:
                      results = _context2.sent;
                      n2 = results.length;
                      if (n2) {
                        _context2.next = 9;
                        break;
                      }
                      return _context2.abrupt("break", 12);
                    case 9:
                      for (i = 0; i < n2; i++) {
                        entries.push(results[i]);
                      }
                      _context2.next = 2;
                      break;
                    case 12:
                      return _context2.abrupt("return", entries);
                    case 13:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              }));
              return _readDirectory.apply(this, arguments);
            };
            readDirectory = function _readDirectory2(_x3) {
              return _readDirectory.apply(this, arguments);
            };
            flattenFileList = [];
            progressFileList = [];
            files.forEach(function(file) {
              return progressFileList.push(file.webkitGetAsEntry());
            });
            _traverseFileTree = /* @__PURE__ */ function() {
              var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(item, path2) {
                var _file, entries;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      if (item) {
                        _context.next = 2;
                        break;
                      }
                      return _context.abrupt("return");
                    case 2:
                      item.path = path2 || "";
                      if (!item.isFile) {
                        _context.next = 10;
                        break;
                      }
                      _context.next = 6;
                      return readFile(item);
                    case 6:
                      _file = _context.sent;
                      if (_file) {
                        flattenFileList.push(_file);
                      }
                      _context.next = 15;
                      break;
                    case 10:
                      if (!item.isDirectory) {
                        _context.next = 15;
                        break;
                      }
                      _context.next = 13;
                      return readDirectory(item);
                    case 13:
                      entries = _context.sent;
                      progressFileList.push.apply(progressFileList, _toConsumableArray(entries));
                    case 15:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              return function _traverseFileTree2(_x5, _x6) {
                return _ref2.apply(this, arguments);
              };
            }();
            wipIndex = 0;
          case 9:
            if (!(wipIndex < progressFileList.length)) {
              _context4.next = 15;
              break;
            }
            _context4.next = 12;
            return _traverseFileTree(progressFileList[wipIndex]);
          case 12:
            wipIndex++;
            _context4.next = 9;
            break;
          case 15:
            return _context4.abrupt("return", flattenFileList);
          case 16:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function traverseFileTree2(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var traverseFileTree_default = traverseFileTree;

  // node_modules/rc-upload/es/uid.js
  var now = +/* @__PURE__ */ new Date();
  var index2 = 0;
  function uid() {
    return "rc-upload-".concat(now, "-").concat(++index2);
  }

  // node_modules/rc-upload/es/AjaxUploader.js
  var _excluded58 = ["component", "prefixCls", "className", "classNames", "disabled", "id", "name", "style", "styles", "multiple", "accept", "capture", "children", "directory", "openFileDialogOnClick", "onMouseEnter", "onMouseLeave", "hasControlInside"];
  var AjaxUploader = /* @__PURE__ */ function(_Component) {
    _inherits(AjaxUploader2, _Component);
    var _super = _createSuper(AjaxUploader2);
    function AjaxUploader2() {
      var _this;
      _classCallCheck(this, AjaxUploader2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "state", {
        uid: uid()
      });
      _defineProperty(_assertThisInitialized(_this), "reqs", {});
      _defineProperty(_assertThisInitialized(_this), "fileInput", void 0);
      _defineProperty(_assertThisInitialized(_this), "_isMounted", void 0);
      _defineProperty(_assertThisInitialized(_this), "onChange", function(e3) {
        var _this$props = _this.props, accept = _this$props.accept, directory = _this$props.directory;
        var files = e3.target.files;
        var acceptedFiles = _toConsumableArray(files).filter(function(file) {
          return !directory || attr_accept_default(file, accept);
        });
        _this.uploadFiles(acceptedFiles);
        _this.reset();
      });
      _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
        var el = _this.fileInput;
        if (!el) {
          return;
        }
        var target = event.target;
        var onClick = _this.props.onClick;
        if (target && target.tagName === "BUTTON") {
          var parent = el.parentNode;
          parent.focus();
          target.blur();
        }
        el.click();
        if (onClick) {
          onClick(event);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onKeyDown", function(e3) {
        if (e3.key === "Enter") {
          _this.onClick(e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onDataTransferFiles", /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(dataTransfer, existFileCallback) {
          var _this$props2, multiple, accept, directory, items, files, acceptFiles;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _this$props2 = _this.props, multiple = _this$props2.multiple, accept = _this$props2.accept, directory = _this$props2.directory;
                items = _toConsumableArray(dataTransfer.items || []);
                files = _toConsumableArray(dataTransfer.files || []);
                if (files.length > 0 || items.some(function(item) {
                  return item.kind === "file";
                })) {
                  existFileCallback === null || existFileCallback === void 0 || existFileCallback();
                }
                if (!directory) {
                  _context.next = 11;
                  break;
                }
                _context.next = 7;
                return traverseFileTree_default(Array.prototype.slice.call(items), function(_file) {
                  return attr_accept_default(_file, _this.props.accept);
                });
              case 7:
                files = _context.sent;
                _this.uploadFiles(files);
                _context.next = 14;
                break;
              case 11:
                acceptFiles = _toConsumableArray(files).filter(function(file) {
                  return attr_accept_default(file, accept);
                });
                if (multiple === false) {
                  acceptFiles = files.slice(0, 1);
                }
                _this.uploadFiles(acceptFiles);
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function(_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
      _defineProperty(_assertThisInitialized(_this), "onFilePaste", /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(e3) {
          var pastable, clipboardData;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                pastable = _this.props.pastable;
                if (pastable) {
                  _context2.next = 3;
                  break;
                }
                return _context2.abrupt("return");
              case 3:
                if (!(e3.type === "paste")) {
                  _context2.next = 6;
                  break;
                }
                clipboardData = e3.clipboardData;
                return _context2.abrupt("return", _this.onDataTransferFiles(clipboardData, function() {
                  e3.preventDefault();
                }));
              case 6:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function(_x3) {
          return _ref2.apply(this, arguments);
        };
      }());
      _defineProperty(_assertThisInitialized(_this), "onFileDragOver", function(e3) {
        e3.preventDefault();
      });
      _defineProperty(_assertThisInitialized(_this), "onFileDrop", /* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(e3) {
          var dataTransfer;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                e3.preventDefault();
                if (!(e3.type === "drop")) {
                  _context3.next = 4;
                  break;
                }
                dataTransfer = e3.dataTransfer;
                return _context3.abrupt("return", _this.onDataTransferFiles(dataTransfer));
              case 4:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        return function(_x4) {
          return _ref3.apply(this, arguments);
        };
      }());
      _defineProperty(_assertThisInitialized(_this), "uploadFiles", function(files) {
        var originFiles = _toConsumableArray(files);
        var postFiles = originFiles.map(function(file) {
          file.uid = uid();
          return _this.processFile(file, originFiles);
        });
        Promise.all(postFiles).then(function(fileList) {
          var onBatchStart = _this.props.onBatchStart;
          onBatchStart === null || onBatchStart === void 0 || onBatchStart(fileList.map(function(_ref4) {
            var origin2 = _ref4.origin, parsedFile = _ref4.parsedFile;
            return {
              file: origin2,
              parsedFile
            };
          }));
          fileList.filter(function(file) {
            return file.parsedFile !== null;
          }).forEach(function(file) {
            _this.post(file);
          });
        });
      });
      _defineProperty(_assertThisInitialized(_this), "processFile", /* @__PURE__ */ function() {
        var _ref5 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(file, fileList) {
          var beforeUpload, transformedFile, action, mergedAction, data, mergedData, parsedData, parsedFile, mergedParsedFile;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                beforeUpload = _this.props.beforeUpload;
                transformedFile = file;
                if (!beforeUpload) {
                  _context4.next = 14;
                  break;
                }
                _context4.prev = 3;
                _context4.next = 6;
                return beforeUpload(file, fileList);
              case 6:
                transformedFile = _context4.sent;
                _context4.next = 12;
                break;
              case 9:
                _context4.prev = 9;
                _context4.t0 = _context4["catch"](3);
                transformedFile = false;
              case 12:
                if (!(transformedFile === false)) {
                  _context4.next = 14;
                  break;
                }
                return _context4.abrupt("return", {
                  origin: file,
                  parsedFile: null,
                  action: null,
                  data: null
                });
              case 14:
                action = _this.props.action;
                if (!(typeof action === "function")) {
                  _context4.next = 21;
                  break;
                }
                _context4.next = 18;
                return action(file);
              case 18:
                mergedAction = _context4.sent;
                _context4.next = 22;
                break;
              case 21:
                mergedAction = action;
              case 22:
                data = _this.props.data;
                if (!(typeof data === "function")) {
                  _context4.next = 29;
                  break;
                }
                _context4.next = 26;
                return data(file);
              case 26:
                mergedData = _context4.sent;
                _context4.next = 30;
                break;
              case 29:
                mergedData = data;
              case 30:
                parsedData = // string type is from legacy `transformFile`.
                // Not sure if this will work since no related test case works with it
                (_typeof(transformedFile) === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file;
                if (parsedData instanceof File) {
                  parsedFile = parsedData;
                } else {
                  parsedFile = new File([parsedData], file.name, {
                    type: file.type
                  });
                }
                mergedParsedFile = parsedFile;
                mergedParsedFile.uid = file.uid;
                return _context4.abrupt("return", {
                  origin: file,
                  data: mergedData,
                  parsedFile: mergedParsedFile,
                  action: mergedAction
                });
              case 35:
              case "end":
                return _context4.stop();
            }
          }, _callee4, null, [[3, 9]]);
        }));
        return function(_x5, _x6) {
          return _ref5.apply(this, arguments);
        };
      }());
      _defineProperty(_assertThisInitialized(_this), "saveFileInput", function(node2) {
        _this.fileInput = node2;
      });
      return _this;
    }
    _createClass(AjaxUploader2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._isMounted = true;
        var pastable = this.props.pastable;
        if (pastable) {
          document.addEventListener("paste", this.onFilePaste);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._isMounted = false;
        this.abort();
        document.removeEventListener("paste", this.onFilePaste);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var pastable = this.props.pastable;
        if (pastable && !prevProps.pastable) {
          document.addEventListener("paste", this.onFilePaste);
        } else if (!pastable && prevProps.pastable) {
          document.removeEventListener("paste", this.onFilePaste);
        }
      }
    }, {
      key: "post",
      value: function post(_ref6) {
        var _this2 = this;
        var data = _ref6.data, origin2 = _ref6.origin, action = _ref6.action, parsedFile = _ref6.parsedFile;
        if (!this._isMounted) {
          return;
        }
        var _this$props3 = this.props, onStart = _this$props3.onStart, customRequest = _this$props3.customRequest, name = _this$props3.name, headers = _this$props3.headers, withCredentials = _this$props3.withCredentials, method4 = _this$props3.method;
        var uid2 = origin2.uid;
        var request = customRequest || upload;
        var requestOption = {
          action,
          filename: name,
          data,
          file: parsedFile,
          headers,
          withCredentials,
          method: method4 || "post",
          onProgress: function onProgress(e3) {
            var onProgress2 = _this2.props.onProgress;
            onProgress2 === null || onProgress2 === void 0 || onProgress2(e3, parsedFile);
          },
          onSuccess: function onSuccess(ret, xhr) {
            var onSuccess2 = _this2.props.onSuccess;
            onSuccess2 === null || onSuccess2 === void 0 || onSuccess2(ret, parsedFile, xhr);
            delete _this2.reqs[uid2];
          },
          onError: function onError(err, ret) {
            var onError2 = _this2.props.onError;
            onError2 === null || onError2 === void 0 || onError2(err, ret, parsedFile);
            delete _this2.reqs[uid2];
          }
        };
        onStart(origin2);
        this.reqs[uid2] = request(requestOption);
      }
    }, {
      key: "reset",
      value: function reset() {
        this.setState({
          uid: uid()
        });
      }
    }, {
      key: "abort",
      value: function abort(file) {
        var reqs = this.reqs;
        if (file) {
          var uid2 = file.uid ? file.uid : file;
          if (reqs[uid2] && reqs[uid2].abort) {
            reqs[uid2].abort();
          }
          delete reqs[uid2];
        } else {
          Object.keys(reqs).forEach(function(uid3) {
            if (reqs[uid3] && reqs[uid3].abort) {
              reqs[uid3].abort();
            }
            delete reqs[uid3];
          });
        }
      }
    }, {
      key: "render",
      value: function render4() {
        var _this$props4 = this.props, Tag2 = _this$props4.component, prefixCls = _this$props4.prefixCls, className = _this$props4.className, _this$props4$classNam = _this$props4.classNames, classNames146 = _this$props4$classNam === void 0 ? {} : _this$props4$classNam, disabled = _this$props4.disabled, id = _this$props4.id, name = _this$props4.name, style2 = _this$props4.style, _this$props4$styles = _this$props4.styles, styles = _this$props4$styles === void 0 ? {} : _this$props4$styles, multiple = _this$props4.multiple, accept = _this$props4.accept, capture = _this$props4.capture, children = _this$props4.children, directory = _this$props4.directory, openFileDialogOnClick = _this$props4.openFileDialogOnClick, onMouseEnter = _this$props4.onMouseEnter, onMouseLeave = _this$props4.onMouseLeave, hasControlInside = _this$props4.hasControlInside, otherProps = _objectWithoutProperties(_this$props4, _excluded58);
        var cls3 = (0, import_classnames149.default)(_defineProperty(_defineProperty(_defineProperty({}, prefixCls, true), "".concat(prefixCls, "-disabled"), disabled), className, className));
        var dirProps = directory ? {
          directory: "directory",
          webkitdirectory: "webkitdirectory"
        } : {};
        var events = disabled ? {} : {
          onClick: openFileDialogOnClick ? this.onClick : function() {
          },
          onKeyDown: openFileDialogOnClick ? this.onKeyDown : function() {
          },
          onMouseEnter,
          onMouseLeave,
          onDrop: this.onFileDrop,
          onDragOver: this.onFileDragOver,
          tabIndex: hasControlInside ? void 0 : "0"
        };
        return /* @__PURE__ */ import_react122.default.createElement(Tag2, _extends({}, events, {
          className: cls3,
          role: hasControlInside ? void 0 : "button",
          style: style2
        }), /* @__PURE__ */ import_react122.default.createElement("input", _extends({}, pickAttrs(otherProps, {
          aria: true,
          data: true
        }), {
          id,
          name,
          disabled,
          type: "file",
          ref: this.saveFileInput,
          onClick: function onClick(e3) {
            return e3.stopPropagation();
          },
          key: this.state.uid,
          style: _objectSpread2({
            display: "none"
          }, styles.input),
          className: classNames146.input,
          accept
        }, dirProps, {
          multiple,
          onChange: this.onChange
        }, capture != null ? {
          capture
        } : {})), children);
      }
    }]);
    return AjaxUploader2;
  }(import_react122.Component);
  var AjaxUploader_default = AjaxUploader;

  // node_modules/rc-upload/es/Upload.js
  function empty() {
  }
  var Upload = /* @__PURE__ */ function(_Component) {
    _inherits(Upload4, _Component);
    var _super = _createSuper(Upload4);
    function Upload4() {
      var _this;
      _classCallCheck(this, Upload4);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "uploader", void 0);
      _defineProperty(_assertThisInitialized(_this), "saveUploader", function(node2) {
        _this.uploader = node2;
      });
      return _this;
    }
    _createClass(Upload4, [{
      key: "abort",
      value: function abort(file) {
        this.uploader.abort(file);
      }
    }, {
      key: "render",
      value: function render4() {
        return /* @__PURE__ */ import_react123.default.createElement(AjaxUploader_default, _extends({}, this.props, {
          ref: this.saveUploader
        }));
      }
    }]);
    return Upload4;
  }(import_react123.Component);
  _defineProperty(Upload, "defaultProps", {
    component: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: false,
    onStart: empty,
    onError: empty,
    onSuccess: empty,
    multiple: false,
    beforeUpload: null,
    customRequest: null,
    withCredentials: false,
    openFileDialogOnClick: true,
    hasControlInside: false
  });
  var Upload_default = Upload;

  // node_modules/rc-upload/es/index.js
  var es_default19 = Upload_default;

  // node_modules/antd/es/upload/style/dragger.js
  var genDraggerStyle = (token2) => {
    const {
      componentCls,
      iconCls
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-drag`]: {
          position: "relative",
          width: "100%",
          height: "100%",
          textAlign: "center",
          background: token2.colorFillAlter,
          border: `${unit(token2.lineWidth)} dashed ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusLG,
          cursor: "pointer",
          transition: `border-color ${token2.motionDurationSlow}`,
          [componentCls]: {
            padding: token2.padding
          },
          [`${componentCls}-btn`]: {
            display: "table",
            width: "100%",
            height: "100%",
            outline: "none",
            borderRadius: token2.borderRadiusLG,
            "&:focus-visible": {
              outline: `${unit(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`
            }
          },
          [`${componentCls}-drag-container`]: {
            display: "table-cell",
            verticalAlign: "middle"
          },
          [`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: {
            borderColor: token2.colorPrimaryHover
          },
          [`p${componentCls}-drag-icon`]: {
            marginBottom: token2.margin,
            [iconCls]: {
              color: token2.colorPrimary,
              fontSize: token2.uploadThumbnailSize
            }
          },
          [`p${componentCls}-text`]: {
            margin: `0 0 ${unit(token2.marginXXS)}`,
            color: token2.colorTextHeading,
            fontSize: token2.fontSizeLG
          },
          [`p${componentCls}-hint`]: {
            color: token2.colorTextDescription,
            fontSize: token2.fontSize
          },
          // ===================== Disabled =====================
          [`&${componentCls}-disabled`]: {
            [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
              color: token2.colorTextDisabled
            }
          }
        }
      }
    };
  };
  var dragger_default = genDraggerStyle;

  // node_modules/antd/es/upload/style/list.js
  var genListStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      fontSize,
      lineHeight,
      calc
    } = token2;
    const itemCls = `${componentCls}-list-item`;
    const actionsCls = `${itemCls}-actions`;
    const actionCls = `${itemCls}-action`;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-list`]: Object.assign(Object.assign({}, clearFix()), {
          lineHeight: token2.lineHeight,
          [itemCls]: {
            position: "relative",
            height: calc(token2.lineHeight).mul(fontSize).equal(),
            marginTop: token2.marginXS,
            fontSize,
            display: "flex",
            alignItems: "center",
            transition: `background-color ${token2.motionDurationSlow}`,
            borderRadius: token2.borderRadiusSM,
            "&:hover": {
              backgroundColor: token2.controlItemBgHover
            },
            [`${itemCls}-name`]: Object.assign(Object.assign({}, textEllipsis), {
              padding: `0 ${unit(token2.paddingXS)}`,
              lineHeight,
              flex: "auto",
              transition: `all ${token2.motionDurationSlow}`
            }),
            [actionsCls]: {
              whiteSpace: "nowrap",
              [actionCls]: {
                opacity: 0
              },
              [iconCls]: {
                color: token2.actionsColor,
                transition: `all ${token2.motionDurationSlow}`
              },
              [`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: {
                opacity: 1
              }
            },
            [`${componentCls}-icon ${iconCls}`]: {
              color: token2.colorIcon,
              fontSize
            },
            [`${itemCls}-progress`]: {
              position: "absolute",
              bottom: token2.calc(token2.uploadProgressOffset).mul(-1).equal(),
              width: "100%",
              paddingInlineStart: calc(fontSize).add(token2.paddingXS).equal(),
              fontSize,
              lineHeight: 0,
              pointerEvents: "none",
              "> div": {
                margin: 0
              }
            }
          },
          [`${itemCls}:hover ${actionCls}`]: {
            opacity: 1
          },
          [`${itemCls}-error`]: {
            color: token2.colorError,
            [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
              color: token2.colorError
            },
            [actionsCls]: {
              [`${iconCls}, ${iconCls}:hover`]: {
                color: token2.colorError
              },
              [actionCls]: {
                opacity: 1
              }
            }
          },
          [`${componentCls}-list-item-container`]: {
            transition: `opacity ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
            // For smooth removing animation
            "&::before": {
              display: "table",
              width: 0,
              height: 0,
              content: '""'
            }
          }
        })
      }
    };
  };
  var list_default = genListStyle;

  // node_modules/antd/es/upload/style/motion.js
  var genMotionStyle2 = (token2) => {
    const {
      componentCls
    } = token2;
    const uploadAnimateInlineIn = new Keyframes_default("uploadAnimateInlineIn", {
      from: {
        width: 0,
        height: 0,
        padding: 0,
        opacity: 0,
        margin: token2.calc(token2.marginXS).div(-2).equal()
      }
    });
    const uploadAnimateInlineOut = new Keyframes_default("uploadAnimateInlineOut", {
      to: {
        width: 0,
        height: 0,
        padding: 0,
        opacity: 0,
        margin: token2.calc(token2.marginXS).div(-2).equal()
      }
    });
    const inlineCls = `${componentCls}-animate-inline`;
    return [{
      [`${componentCls}-wrapper`]: {
        [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseInOutCirc,
          animationFillMode: "forwards"
        },
        [`${inlineCls}-appear, ${inlineCls}-enter`]: {
          animationName: uploadAnimateInlineIn
        },
        [`${inlineCls}-leave`]: {
          animationName: uploadAnimateInlineOut
        }
      }
    }, {
      [`${componentCls}-wrapper`]: initFadeMotion(token2)
    }, uploadAnimateInlineIn, uploadAnimateInlineOut];
  };
  var motion_default3 = genMotionStyle2;

  // node_modules/antd/es/upload/style/picture.js
  var genPictureStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      uploadThumbnailSize,
      uploadProgressOffset,
      calc
    } = token2;
    const listCls = `${componentCls}-list`;
    const itemCls = `${listCls}-item`;
    return {
      [`${componentCls}-wrapper`]: {
        // ${listCls} 增加优先级
        [`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
          [itemCls]: {
            position: "relative",
            height: calc(uploadThumbnailSize).add(calc(token2.lineWidth).mul(2)).add(calc(token2.paddingXS).mul(2)).equal(),
            padding: token2.paddingXS,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusLG,
            "&:hover": {
              background: "transparent"
            },
            [`${itemCls}-thumbnail`]: Object.assign(Object.assign({}, textEllipsis), {
              width: uploadThumbnailSize,
              height: uploadThumbnailSize,
              lineHeight: unit(calc(uploadThumbnailSize).add(token2.paddingSM).equal()),
              textAlign: "center",
              flex: "none",
              [iconCls]: {
                fontSize: token2.fontSizeHeading2,
                color: token2.colorPrimary
              },
              img: {
                display: "block",
                width: "100%",
                height: "100%",
                overflow: "hidden"
              }
            }),
            [`${itemCls}-progress`]: {
              bottom: uploadProgressOffset,
              width: `calc(100% - ${unit(calc(token2.paddingSM).mul(2).equal())})`,
              marginTop: 0,
              paddingInlineStart: calc(uploadThumbnailSize).add(token2.paddingXS).equal()
            }
          },
          [`${itemCls}-error`]: {
            borderColor: token2.colorError,
            // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
            [`${itemCls}-thumbnail ${iconCls}`]: {
              [`svg path[fill='${blue[0]}']`]: {
                fill: token2.colorErrorBg
              },
              [`svg path[fill='${blue.primary}']`]: {
                fill: token2.colorError
              }
            }
          },
          [`${itemCls}-uploading`]: {
            borderStyle: "dashed",
            [`${itemCls}-name`]: {
              marginBottom: uploadProgressOffset
            }
          }
        },
        [`${listCls}${listCls}-picture-circle ${itemCls}`]: {
          [`&, &::before, ${itemCls}-thumbnail`]: {
            borderRadius: "50%"
          }
        }
      }
    };
  };
  var genPictureCardStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      fontSizeLG,
      colorTextLightSolid,
      calc
    } = token2;
    const listCls = `${componentCls}-list`;
    const itemCls = `${listCls}-item`;
    const uploadPictureCardSize = token2.uploadPicCardSize;
    return {
      [`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: Object.assign(Object.assign({}, clearFix()), {
        display: "block",
        [`${componentCls}${componentCls}-select`]: {
          width: uploadPictureCardSize,
          height: uploadPictureCardSize,
          textAlign: "center",
          verticalAlign: "top",
          backgroundColor: token2.colorFillAlter,
          border: `${unit(token2.lineWidth)} dashed ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusLG,
          cursor: "pointer",
          transition: `border-color ${token2.motionDurationSlow}`,
          [`> ${componentCls}`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            textAlign: "center"
          },
          [`&:not(${componentCls}-disabled):hover`]: {
            borderColor: token2.colorPrimary
          }
        },
        // list
        [`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
          display: "flex",
          flexWrap: "wrap",
          "@supports not (gap: 1px)": {
            "& > *": {
              marginBlockEnd: token2.marginXS,
              marginInlineEnd: token2.marginXS
            }
          },
          "@supports (gap: 1px)": {
            gap: token2.marginXS
          },
          [`${listCls}-item-container`]: {
            display: "inline-block",
            width: uploadPictureCardSize,
            height: uploadPictureCardSize,
            verticalAlign: "top"
          },
          "&::after": {
            display: "none"
          },
          "&::before": {
            display: "none"
          },
          [itemCls]: {
            height: "100%",
            margin: 0,
            "&::before": {
              position: "absolute",
              zIndex: 1,
              width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
              height: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
              backgroundColor: token2.colorBgMask,
              opacity: 0,
              transition: `all ${token2.motionDurationSlow}`,
              content: '" "'
            }
          },
          [`${itemCls}:hover`]: {
            [`&::before, ${itemCls}-actions`]: {
              opacity: 1
            }
          },
          [`${itemCls}-actions`]: {
            position: "absolute",
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            whiteSpace: "nowrap",
            textAlign: "center",
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            [`
            ${iconCls}-eye,
            ${iconCls}-download,
            ${iconCls}-delete
          `]: {
              zIndex: 10,
              width: fontSizeLG,
              margin: `0 ${unit(token2.marginXXS)}`,
              fontSize: fontSizeLG,
              cursor: "pointer",
              transition: `all ${token2.motionDurationSlow}`,
              color: colorTextLightSolid,
              "&:hover": {
                color: colorTextLightSolid
              },
              svg: {
                verticalAlign: "baseline"
              }
            }
          },
          [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
            position: "static",
            display: "block",
            width: "100%",
            height: "100%",
            objectFit: "contain"
          },
          [`${itemCls}-name`]: {
            display: "none",
            textAlign: "center"
          },
          [`${itemCls}-file + ${itemCls}-name`]: {
            position: "absolute",
            bottom: token2.margin,
            display: "block",
            width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`
          },
          [`${itemCls}-uploading`]: {
            [`&${itemCls}`]: {
              backgroundColor: token2.colorFillAlter
            },
            [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
              display: "none"
            }
          },
          [`${itemCls}-progress`]: {
            bottom: token2.marginXL,
            width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
            paddingInlineStart: 0
          }
        }
      }),
      [`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: {
        [`${componentCls}${componentCls}-select`]: {
          borderRadius: "50%"
        }
      }
    };
  };

  // node_modules/antd/es/upload/style/rtl.js
  var genRtlStyle2 = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    };
  };
  var rtl_default3 = genRtlStyle2;

  // node_modules/antd/es/upload/style/index.js
  var genBaseStyle7 = (token2) => {
    const {
      componentCls,
      colorTextDisabled
    } = token2;
    return {
      [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        [componentCls]: {
          outline: 0,
          "input[type='file']": {
            cursor: "pointer"
          }
        },
        [`${componentCls}-select`]: {
          display: "inline-block"
        },
        [`${componentCls}-hidden`]: {
          display: "none"
        },
        [`${componentCls}-disabled`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      })
    };
  };
  var prepareComponentToken21 = (token2) => ({
    actionsColor: token2.colorIcon
  });
  var style_default26 = genStyleHooks("Upload", (token2) => {
    const {
      fontSizeHeading3,
      fontHeight,
      lineWidth,
      controlHeightLG,
      calc
    } = token2;
    const uploadToken = merge2(token2, {
      uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
      uploadProgressOffset: calc(calc(fontHeight).div(2)).add(lineWidth).equal(),
      uploadPicCardSize: calc(controlHeightLG).mul(2.55).equal()
    });
    return [genBaseStyle7(uploadToken), dragger_default(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), list_default(uploadToken), motion_default3(uploadToken), rtl_default3(uploadToken), collapse_default(uploadToken)];
  }, prepareComponentToken21);

  // node_modules/antd/es/upload/UploadList/index.js
  var React399 = __toESM(require_react());
  var import_classnames151 = __toESM(require_classnames());

  // node_modules/antd/es/upload/utils.js
  function file2Obj(file) {
    return Object.assign(Object.assign({}, file), {
      lastModified: file.lastModified,
      lastModifiedDate: file.lastModifiedDate,
      name: file.name,
      size: file.size,
      type: file.type,
      uid: file.uid,
      percent: 0,
      originFileObj: file
    });
  }
  function updateFileList(file, fileList) {
    const nextFileList = _toConsumableArray(fileList);
    const fileIndex = nextFileList.findIndex(({
      uid: uid2
    }) => uid2 === file.uid);
    if (fileIndex === -1) {
      nextFileList.push(file);
    } else {
      nextFileList[fileIndex] = file;
    }
    return nextFileList;
  }
  function getFileItem(file, fileList) {
    const matchKey = file.uid !== void 0 ? "uid" : "name";
    return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
  }
  function removeFileItem(file, fileList) {
    const matchKey = file.uid !== void 0 ? "uid" : "name";
    const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
    if (removed.length === fileList.length) {
      return null;
    }
    return removed;
  }
  var extname = (url2 = "") => {
    const temp = url2.split("/");
    const filename = temp[temp.length - 1];
    const filenameWithoutSuffix = filename.split(/#|\?/)[0];
    return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
  };
  var isImageFileType = (type5) => type5.indexOf("image/") === 0;
  var isImageUrl = (file) => {
    if (file.type && !file.thumbUrl) {
      return isImageFileType(file.type);
    }
    const url2 = file.thumbUrl || file.url || "";
    const extension = extname(url2);
    if (/^data:image\//.test(url2) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) {
      return true;
    }
    if (/^data:/.test(url2)) {
      return false;
    }
    if (extension) {
      return false;
    }
    return true;
  };
  var MEASURE_SIZE = 200;
  function previewImage(file) {
    return new Promise((resolve) => {
      if (!file.type || !isImageFileType(file.type)) {
        resolve("");
        return;
      }
      const canvas = document.createElement("canvas");
      canvas.width = MEASURE_SIZE;
      canvas.height = MEASURE_SIZE;
      canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
      document.body.appendChild(canvas);
      const ctx = canvas.getContext("2d");
      const img = new Image();
      img.onload = () => {
        const {
          width,
          height
        } = img;
        let drawWidth = MEASURE_SIZE;
        let drawHeight = MEASURE_SIZE;
        let offsetX = 0;
        let offsetY = 0;
        if (width > height) {
          drawHeight = height * (MEASURE_SIZE / width);
          offsetY = -(drawHeight - drawWidth) / 2;
        } else {
          drawWidth = width * (MEASURE_SIZE / height);
          offsetX = -(drawWidth - drawHeight) / 2;
        }
        ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        const dataURL = canvas.toDataURL();
        document.body.removeChild(canvas);
        window.URL.revokeObjectURL(img.src);
        resolve(dataURL);
      };
      img.crossOrigin = "anonymous";
      if (file.type.startsWith("image/svg+xml")) {
        const reader = new FileReader();
        reader.onload = () => {
          if (reader.result && typeof reader.result === "string") {
            img.src = reader.result;
          }
        };
        reader.readAsDataURL(file);
      } else if (file.type.startsWith("image/gif")) {
        const reader = new FileReader();
        reader.onload = () => {
          if (reader.result) {
            resolve(reader.result);
          }
        };
        reader.readAsDataURL(file);
      } else {
        img.src = window.URL.createObjectURL(file);
      }
    });
  }

  // node_modules/antd/es/upload/UploadList/ListItem.js
  var React398 = __toESM(require_react());
  var import_classnames150 = __toESM(require_classnames());
  var ListItem = /* @__PURE__ */ React398.forwardRef(({
    prefixCls,
    className,
    style: style2,
    locale: locale6,
    listType,
    file,
    items,
    progress: progressProps,
    iconRender,
    actionIconRender,
    itemRender,
    isImgUrl,
    showPreviewIcon,
    showRemoveIcon,
    showDownloadIcon,
    previewIcon: customPreviewIcon,
    removeIcon: customRemoveIcon,
    downloadIcon: customDownloadIcon,
    extra: customExtra,
    onPreview,
    onDownload,
    onClose
  }, ref) => {
    var _a, _b;
    const {
      status
    } = file;
    const [mergedStatus, setMergedStatus] = React398.useState(status);
    React398.useEffect(() => {
      if (status !== "removed") {
        setMergedStatus(status);
      }
    }, [status]);
    const [showProgress, setShowProgress] = React398.useState(false);
    React398.useEffect(() => {
      const timer = setTimeout(() => {
        setShowProgress(true);
      }, 300);
      return () => {
        clearTimeout(timer);
      };
    }, []);
    const iconNode = iconRender(file);
    let icon = /* @__PURE__ */ React398.createElement("div", {
      className: `${prefixCls}-icon`
    }, iconNode);
    if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") {
      if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
        const uploadingClassName = (0, import_classnames150.default)(`${prefixCls}-list-item-thumbnail`, {
          [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading"
        });
        icon = /* @__PURE__ */ React398.createElement("div", {
          className: uploadingClassName
        }, iconNode);
      } else {
        const thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? /* @__PURE__ */ React398.createElement("img", {
          src: file.thumbUrl || file.url,
          alt: file.name,
          className: `${prefixCls}-list-item-image`,
          crossOrigin: file.crossOrigin
        }) : iconNode;
        const aClassName = (0, import_classnames150.default)(`${prefixCls}-list-item-thumbnail`, {
          [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
        });
        icon = /* @__PURE__ */ React398.createElement("a", {
          className: aClassName,
          onClick: (e3) => onPreview(file, e3),
          href: file.url || file.thumbUrl,
          target: "_blank",
          rel: "noopener noreferrer"
        }, thumbnail);
      }
    }
    const listItemClassName = (0, import_classnames150.default)(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`);
    const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
    const removeIcon = (typeof showRemoveIcon === "function" ? showRemoveIcon(file) : showRemoveIcon) ? actionIconRender(
      (typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || /* @__PURE__ */ React398.createElement(DeleteOutlined_default2, null),
      () => onClose(file),
      prefixCls,
      locale6.removeFile,
      // acceptUploadDisabled is true, only remove icon will follow Upload disabled prop
      // https://github.com/ant-design/ant-design/issues/46171
      true
    ) : null;
    const downloadIcon = (typeof showDownloadIcon === "function" ? showDownloadIcon(file) : showDownloadIcon) && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || /* @__PURE__ */ React398.createElement(DownloadOutlined_default2, null), () => onDownload(file), prefixCls, locale6.downloadFile) : null;
    const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && /* @__PURE__ */ React398.createElement("span", {
      key: "download-delete",
      className: (0, import_classnames150.default)(`${prefixCls}-list-item-actions`, {
        picture: listType === "picture"
      })
    }, downloadIcon, removeIcon);
    const extraContent = typeof customExtra === "function" ? customExtra(file) : customExtra;
    const extra = extraContent && /* @__PURE__ */ React398.createElement("span", {
      className: `${prefixCls}-list-item-extra`
    }, extraContent);
    const listItemNameClass = (0, import_classnames150.default)(`${prefixCls}-list-item-name`);
    const fileName = file.url ? /* @__PURE__ */ React398.createElement("a", Object.assign({
      key: "view",
      target: "_blank",
      rel: "noopener noreferrer",
      className: listItemNameClass,
      title: file.name
    }, linkProps, {
      href: file.url,
      onClick: (e3) => onPreview(file, e3)
    }), file.name, extra) : /* @__PURE__ */ React398.createElement("span", {
      key: "view",
      className: listItemNameClass,
      onClick: (e3) => onPreview(file, e3),
      title: file.name
    }, file.name, extra);
    const previewIcon = (typeof showPreviewIcon === "function" ? showPreviewIcon(file) : showPreviewIcon) && (file.url || file.thumbUrl) ? /* @__PURE__ */ React398.createElement("a", {
      href: file.url || file.thumbUrl,
      target: "_blank",
      rel: "noopener noreferrer",
      onClick: (e3) => onPreview(file, e3),
      title: locale6.previewFile
    }, typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || /* @__PURE__ */ React398.createElement(EyeOutlined_default2, null)) : null;
    const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && /* @__PURE__ */ React398.createElement("span", {
      className: `${prefixCls}-list-item-actions`
    }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
    const {
      getPrefixCls
    } = React398.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const dom = /* @__PURE__ */ React398.createElement("div", {
      className: listItemClassName
    }, icon, fileName, downloadOrDelete, pictureCardActions, showProgress && /* @__PURE__ */ React398.createElement(es_default2, {
      motionName: `${rootPrefixCls}-fade`,
      visible: mergedStatus === "uploading",
      motionDeadline: 2e3
    }, ({
      className: motionClassName
    }) => {
      const loadingProgress = "percent" in file ? /* @__PURE__ */ React398.createElement(progress_default2, Object.assign({
        type: "line",
        percent: file.percent,
        "aria-label": file["aria-label"],
        "aria-labelledby": file["aria-labelledby"]
      }, progressProps)) : null;
      return /* @__PURE__ */ React398.createElement("div", {
        className: (0, import_classnames150.default)(`${prefixCls}-list-item-progress`, motionClassName)
      }, loadingProgress);
    }));
    const message2 = file.response && typeof file.response === "string" ? file.response : ((_a = file.error) === null || _a === void 0 ? void 0 : _a.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale6.uploadError;
    const item = mergedStatus === "error" ? /* @__PURE__ */ React398.createElement(tooltip_default, {
      title: message2,
      getPopupContainer: (node2) => node2.parentNode
    }, dom) : dom;
    return /* @__PURE__ */ React398.createElement("div", {
      className: (0, import_classnames150.default)(`${prefixCls}-list-item-container`, className),
      style: style2,
      ref
    }, itemRender ? itemRender(item, file, items, {
      download: onDownload.bind(null, file),
      preview: onPreview.bind(null, file),
      remove: onClose.bind(null, file)
    }) : item);
  });
  var ListItem_default = ListItem;

  // node_modules/antd/es/upload/UploadList/index.js
  var InternalUploadList = (props, ref) => {
    const {
      listType = "text",
      previewFile = previewImage,
      onPreview,
      onDownload,
      onRemove,
      locale: locale6,
      iconRender,
      isImageUrl: isImgUrl = isImageUrl,
      prefixCls: customizePrefixCls,
      items = [],
      showPreviewIcon = true,
      showRemoveIcon = true,
      showDownloadIcon = false,
      removeIcon,
      previewIcon,
      downloadIcon,
      extra,
      progress = {
        size: [-1, 2],
        showInfo: false
      },
      appendAction,
      appendActionVisible = true,
      itemRender,
      disabled
    } = props;
    const forceUpdate = useForceUpdate();
    const [motionAppear, setMotionAppear] = React399.useState(false);
    const isPictureCardOrCirle = ["picture-card", "picture-circle"].includes(listType);
    React399.useEffect(() => {
      if (!listType.startsWith("picture")) {
        return;
      }
      (items || []).forEach((file) => {
        if (!(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
          return;
        }
        file.thumbUrl = "";
        previewFile === null || previewFile === void 0 ? void 0 : previewFile(file.originFileObj).then((previewDataUrl) => {
          file.thumbUrl = previewDataUrl || "";
          forceUpdate();
        });
      });
    }, [listType, items, previewFile]);
    React399.useEffect(() => {
      setMotionAppear(true);
    }, []);
    const onInternalPreview = (file, e3) => {
      if (!onPreview) {
        return;
      }
      e3 === null || e3 === void 0 ? void 0 : e3.preventDefault();
      return onPreview(file);
    };
    const onInternalDownload = (file) => {
      if (typeof onDownload === "function") {
        onDownload(file);
      } else if (file.url) {
        window.open(file.url);
      }
    };
    const onInternalClose = (file) => {
      onRemove === null || onRemove === void 0 ? void 0 : onRemove(file);
    };
    const internalIconRender = (file) => {
      if (iconRender) {
        return iconRender(file, listType);
      }
      const isLoading = file.status === "uploading";
      if (listType.startsWith("picture")) {
        const loadingIcon = listType === "picture" ? /* @__PURE__ */ React399.createElement(LoadingOutlined_default2, null) : locale6.uploading;
        const fileIcon = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? /* @__PURE__ */ React399.createElement(PictureTwoTone_default2, null) : /* @__PURE__ */ React399.createElement(FileTwoTone_default2, null);
        return isLoading ? loadingIcon : fileIcon;
      }
      return isLoading ? /* @__PURE__ */ React399.createElement(LoadingOutlined_default2, null) : /* @__PURE__ */ React399.createElement(PaperClipOutlined_default2, null);
    };
    const actionIconRender = (customIcon, callback, prefixCls2, title, acceptUploadDisabled) => {
      const btnProps = {
        type: "text",
        size: "small",
        title,
        onClick: (e3) => {
          var _a, _b;
          callback();
          if (/* @__PURE__ */ React399.isValidElement(customIcon)) {
            (_b = (_a = customIcon.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e3);
          }
        },
        className: `${prefixCls2}-list-item-action`,
        disabled: acceptUploadDisabled ? disabled : false
      };
      return /* @__PURE__ */ React399.isValidElement(customIcon) ? /* @__PURE__ */ React399.createElement(button_default2, Object.assign({}, btnProps, {
        icon: cloneElement3(customIcon, Object.assign(Object.assign({}, customIcon.props), {
          onClick: () => {
          }
        }))
      })) : /* @__PURE__ */ React399.createElement(button_default2, Object.assign({}, btnProps), /* @__PURE__ */ React399.createElement("span", null, customIcon));
    };
    React399.useImperativeHandle(ref, () => ({
      handlePreview: onInternalPreview,
      handleDownload: onInternalDownload
    }));
    const {
      getPrefixCls
    } = React399.useContext(ConfigContext);
    const prefixCls = getPrefixCls("upload", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const listClassNames = (0, import_classnames151.default)(`${prefixCls}-list`, `${prefixCls}-list-${listType}`);
    const listItemMotion = React399.useMemo(() => omit(motion_default(rootPrefixCls), ["onAppearEnd", "onEnterEnd", "onLeaveEnd"]), [rootPrefixCls]);
    const motionConfig = Object.assign(Object.assign({}, isPictureCardOrCirle ? {} : listItemMotion), {
      motionDeadline: 2e3,
      motionName: `${prefixCls}-${isPictureCardOrCirle ? "animate-inline" : "animate"}`,
      keys: _toConsumableArray(items.map((file) => ({
        key: file.uid,
        file
      }))),
      motionAppear
    });
    return /* @__PURE__ */ React399.createElement("div", {
      className: listClassNames
    }, /* @__PURE__ */ React399.createElement(CSSMotionList_default, Object.assign({}, motionConfig, {
      component: false
    }), ({
      key,
      file,
      className: motionClassName,
      style: motionStyle
    }) => /* @__PURE__ */ React399.createElement(ListItem_default, {
      key,
      locale: locale6,
      prefixCls,
      className: motionClassName,
      style: motionStyle,
      file,
      items,
      progress,
      listType,
      isImgUrl,
      showPreviewIcon,
      showRemoveIcon,
      showDownloadIcon,
      removeIcon,
      previewIcon,
      downloadIcon,
      extra,
      iconRender: internalIconRender,
      actionIconRender,
      itemRender,
      onPreview: onInternalPreview,
      onDownload: onInternalDownload,
      onClose: onInternalClose
    })), appendAction && /* @__PURE__ */ React399.createElement(es_default2, Object.assign({}, motionConfig, {
      visible: appendActionVisible,
      forceRender: true
    }), ({
      className: motionClassName,
      style: motionStyle
    }) => cloneElement3(appendAction, (oriProps) => ({
      className: (0, import_classnames151.default)(oriProps.className, motionClassName),
      style: Object.assign(Object.assign(Object.assign({}, motionStyle), {
        // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
        pointerEvents: motionClassName ? "none" : void 0
      }), oriProps.style)
    }))));
  };
  var UploadList = /* @__PURE__ */ React399.forwardRef(InternalUploadList);
  if (true) {
    UploadList.displayName = "UploadList";
  }
  var UploadList_default = UploadList;

  // node_modules/antd/es/upload/Upload.js
  var __awaiter = function(thisArg, _arguments, P, generator2) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator2.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator2["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
    });
  };
  var LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
  var InternalUpload = (props, ref) => {
    const {
      fileList,
      defaultFileList,
      onRemove,
      showUploadList = true,
      listType = "text",
      onPreview,
      onDownload,
      onChange,
      onDrop,
      previewFile,
      disabled: customDisabled,
      locale: propLocale,
      iconRender,
      isImageUrl: isImageUrl2,
      progress,
      prefixCls: customizePrefixCls,
      className,
      type: type5 = "select",
      children,
      style: style2,
      itemRender,
      maxCount,
      data = {},
      multiple = false,
      hasControlInside = true,
      action = "",
      accept = "",
      supportServerRender = true,
      rootClassName
    } = props;
    const disabled = React400.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const [mergedFileList, setMergedFileList] = useMergedState(defaultFileList || [], {
      value: fileList,
      postState: (list) => list !== null && list !== void 0 ? list : []
    });
    const [dragState, setDragState] = React400.useState("drop");
    const upload2 = React400.useRef(null);
    const wrapRef = React400.useRef(null);
    if (true) {
      const warning6 = devUseWarning("Upload");
      true ? warning6("fileList" in props || !("value" in props), "usage", "`value` is not a valid prop, do you mean `fileList`?") : void 0;
      warning6.deprecated(!("transformFile" in props), "transformFile", "beforeUpload");
    }
    React400.useMemo(() => {
      const timestamp = Date.now();
      (fileList || []).forEach((file, index3) => {
        if (!file.uid && !Object.isFrozen(file)) {
          file.uid = `__AUTO__${timestamp}_${index3}__`;
        }
      });
    }, [fileList]);
    const onInternalChange = (file, changedFileList, event) => {
      let cloneList = _toConsumableArray(changedFileList);
      let exceedMaxCount = false;
      if (maxCount === 1) {
        cloneList = cloneList.slice(-1);
      } else if (maxCount) {
        exceedMaxCount = cloneList.length > maxCount;
        cloneList = cloneList.slice(0, maxCount);
      }
      (0, import_react_dom9.flushSync)(() => {
        setMergedFileList(cloneList);
      });
      const changeInfo = {
        file,
        fileList: cloneList
      };
      if (event) {
        changeInfo.event = event;
      }
      if (!exceedMaxCount || file.status === "removed" || // We should ignore event if current file is exceed `maxCount`
      cloneList.some((f) => f.uid === file.uid)) {
        (0, import_react_dom9.flushSync)(() => {
          onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo);
        });
      }
    };
    const mergedBeforeUpload = (file, fileListArgs) => __awaiter(void 0, void 0, void 0, function* () {
      const {
        beforeUpload,
        transformFile
      } = props;
      let parsedFile = file;
      if (beforeUpload) {
        const result = yield beforeUpload(file, fileListArgs);
        if (result === false) {
          return false;
        }
        delete file[LIST_IGNORE];
        if (result === LIST_IGNORE) {
          Object.defineProperty(file, LIST_IGNORE, {
            value: true,
            configurable: true
          });
          return false;
        }
        if (typeof result === "object" && result) {
          parsedFile = result;
        }
      }
      if (transformFile) {
        parsedFile = yield transformFile(parsedFile);
      }
      return parsedFile;
    });
    const onBatchStart = (batchFileInfoList) => {
      const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
      if (!filteredFileInfoList.length) {
        return;
      }
      const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
      let newFileList = _toConsumableArray(mergedFileList);
      objectFileList.forEach((fileObj) => {
        newFileList = updateFileList(fileObj, newFileList);
      });
      objectFileList.forEach((fileObj, index3) => {
        let triggerFileObj = fileObj;
        if (!filteredFileInfoList[index3].parsedFile) {
          const {
            originFileObj
          } = fileObj;
          let clone;
          try {
            clone = new File([originFileObj], originFileObj.name, {
              type: originFileObj.type
            });
          } catch (_a) {
            clone = new Blob([originFileObj], {
              type: originFileObj.type
            });
            clone.name = originFileObj.name;
            clone.lastModifiedDate = /* @__PURE__ */ new Date();
            clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
          }
          clone.uid = fileObj.uid;
          triggerFileObj = clone;
        } else {
          fileObj.status = "uploading";
        }
        onInternalChange(triggerFileObj, newFileList);
      });
    };
    const onSuccess = (response, file, xhr) => {
      try {
        if (typeof response === "string") {
          response = JSON.parse(response);
        }
      } catch (_a) {
      }
      if (!getFileItem(file, mergedFileList)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.status = "done";
      targetItem.percent = 100;
      targetItem.response = response;
      targetItem.xhr = xhr;
      const nextFileList = updateFileList(targetItem, mergedFileList);
      onInternalChange(targetItem, nextFileList);
    };
    const onProgress = (e3, file) => {
      if (!getFileItem(file, mergedFileList)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.status = "uploading";
      targetItem.percent = e3.percent;
      const nextFileList = updateFileList(targetItem, mergedFileList);
      onInternalChange(targetItem, nextFileList, e3);
    };
    const onError = (error, response, file) => {
      if (!getFileItem(file, mergedFileList)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.error = error;
      targetItem.response = response;
      targetItem.status = "error";
      const nextFileList = updateFileList(targetItem, mergedFileList);
      onInternalChange(targetItem, nextFileList);
    };
    const handleRemove = (file) => {
      let currentFile;
      Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
        var _a;
        if (ret === false) {
          return;
        }
        const removedFileList = removeFileItem(file, mergedFileList);
        if (removedFileList) {
          currentFile = Object.assign(Object.assign({}, file), {
            status: "removed"
          });
          mergedFileList === null || mergedFileList === void 0 ? void 0 : mergedFileList.forEach((item) => {
            const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
            if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
              item.status = "removed";
            }
          });
          (_a = upload2.current) === null || _a === void 0 ? void 0 : _a.abort(currentFile);
          onInternalChange(currentFile, removedFileList);
        }
      });
    };
    const onFileDrop = (e3) => {
      setDragState(e3.type);
      if (e3.type === "drop") {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(e3);
      }
    };
    React400.useImperativeHandle(ref, () => ({
      onBatchStart,
      onSuccess,
      onProgress,
      onError,
      fileList: mergedFileList,
      upload: upload2.current,
      nativeElement: wrapRef.current
    }));
    const {
      getPrefixCls,
      direction,
      upload: ctxUpload
    } = React400.useContext(ConfigContext);
    const prefixCls = getPrefixCls("upload", customizePrefixCls);
    const rcUploadProps = Object.assign(Object.assign({
      onBatchStart,
      onError,
      onProgress,
      onSuccess
    }, props), {
      data,
      multiple,
      action,
      accept,
      supportServerRender,
      prefixCls,
      disabled: mergedDisabled,
      beforeUpload: mergedBeforeUpload,
      onChange: void 0,
      hasControlInside
    });
    delete rcUploadProps.className;
    delete rcUploadProps.style;
    if (!children || mergedDisabled) {
      delete rcUploadProps.id;
    }
    const wrapperCls = `${prefixCls}-wrapper`;
    const [wrapCSSVar, hashId, cssVarCls] = style_default26(prefixCls, wrapperCls);
    const [contextLocale] = useLocale_default("Upload", en_US_default6.Upload);
    const {
      showRemoveIcon,
      showPreviewIcon,
      showDownloadIcon,
      removeIcon,
      previewIcon,
      downloadIcon,
      extra
    } = typeof showUploadList === "boolean" ? {} : showUploadList;
    const realShowRemoveIcon = typeof showRemoveIcon === "undefined" ? !mergedDisabled : showRemoveIcon;
    const renderUploadList = (button, buttonVisible) => {
      if (!showUploadList) {
        return button;
      }
      return /* @__PURE__ */ React400.createElement(UploadList_default, {
        prefixCls,
        listType,
        items: mergedFileList,
        previewFile,
        onPreview,
        onDownload,
        onRemove: handleRemove,
        showRemoveIcon: realShowRemoveIcon,
        showPreviewIcon,
        showDownloadIcon,
        removeIcon,
        previewIcon,
        downloadIcon,
        iconRender,
        extra,
        locale: Object.assign(Object.assign({}, contextLocale), propLocale),
        isImageUrl: isImageUrl2,
        progress,
        appendAction: button,
        appendActionVisible: buttonVisible,
        itemRender,
        disabled: mergedDisabled
      });
    };
    const mergedCls = (0, import_classnames152.default)(wrapperCls, className, rootClassName, hashId, cssVarCls, ctxUpload === null || ctxUpload === void 0 ? void 0 : ctxUpload.className, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
      [`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
    });
    const mergedStyle = Object.assign(Object.assign({}, ctxUpload === null || ctxUpload === void 0 ? void 0 : ctxUpload.style), style2);
    if (type5 === "drag") {
      const dragCls = (0, import_classnames152.default)(hashId, prefixCls, `${prefixCls}-drag`, {
        [`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
        [`${prefixCls}-drag-hover`]: dragState === "dragover",
        [`${prefixCls}-disabled`]: mergedDisabled,
        [`${prefixCls}-rtl`]: direction === "rtl"
      });
      return wrapCSSVar(/* @__PURE__ */ React400.createElement("span", {
        className: mergedCls,
        ref: wrapRef
      }, /* @__PURE__ */ React400.createElement("div", {
        className: dragCls,
        style: mergedStyle,
        onDrop: onFileDrop,
        onDragOver: onFileDrop,
        onDragLeave: onFileDrop
      }, /* @__PURE__ */ React400.createElement(es_default19, Object.assign({}, rcUploadProps, {
        ref: upload2,
        className: `${prefixCls}-btn`
      }), /* @__PURE__ */ React400.createElement("div", {
        className: `${prefixCls}-drag-container`
      }, children))), renderUploadList()));
    }
    const uploadBtnCls = (0, import_classnames152.default)(prefixCls, `${prefixCls}-select`, {
      [`${prefixCls}-disabled`]: mergedDisabled,
      [`${prefixCls}-hidden`]: !children
    });
    const uploadButton = /* @__PURE__ */ React400.createElement("div", {
      className: uploadBtnCls,
      style: mergedStyle
    }, /* @__PURE__ */ React400.createElement(es_default19, Object.assign({}, rcUploadProps, {
      ref: upload2
    })));
    if (listType === "picture-card" || listType === "picture-circle") {
      return wrapCSSVar(/* @__PURE__ */ React400.createElement("span", {
        className: mergedCls,
        ref: wrapRef
      }, renderUploadList(uploadButton, !!children)));
    }
    return wrapCSSVar(/* @__PURE__ */ React400.createElement("span", {
      className: mergedCls,
      ref: wrapRef
    }, uploadButton, renderUploadList()));
  };
  var Upload2 = /* @__PURE__ */ React400.forwardRef(InternalUpload);
  if (true) {
    Upload2.displayName = "Upload";
  }
  var Upload_default2 = Upload2;

  // node_modules/antd/es/upload/Dragger.js
  var __rest56 = function(s, e3) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0) t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t2[p[i]] = s[p[i]];
    }
    return t2;
  };
  var Dragger = /* @__PURE__ */ React401.forwardRef((_a, ref) => {
    var {
      style: style2,
      height,
      hasControlInside = false
    } = _a, restProps = __rest56(_a, ["style", "height", "hasControlInside"]);
    return /* @__PURE__ */ React401.createElement(Upload_default2, Object.assign({
      ref,
      hasControlInside
    }, restProps, {
      type: "drag",
      style: Object.assign(Object.assign({}, style2), {
        height
      })
    }));
  });
  if (true) {
    Dragger.displayName = "Dragger";
  }
  var Dragger_default = Dragger;

  // node_modules/antd/es/upload/index.js
  var Upload3 = Upload_default2;
  Upload3.Dragger = Dragger_default;
  Upload3.LIST_IGNORE = LIST_IGNORE;
  var upload_default = Upload3;

  // node_modules/axios/lib/helpers/bind.js
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }

  // node_modules/axios/lib/utils.js
  var { toString } = Object.prototype;
  var { getPrototypeOf } = Object;
  var { iterator, toStringTag } = Symbol;
  var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  var kindOfTest = (type5) => {
    type5 = type5.toLowerCase();
    return (thing) => kindOf(thing) === type5;
  };
  var typeOfTest = (type5) => (thing) => typeof thing === type5;
  var { isArray } = Array;
  var isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  var isString2 = typeOfTest("string");
  var isFunction = typeOfTest("function");
  var isNumber = typeOfTest("number");
  var isObject2 = (thing) => thing !== null && typeof thing === "object";
  var isBoolean = (thing) => thing === true || thing === false;
  var isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype3 = getPrototypeOf(val);
    return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
  };
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  var isStream = (val) => isObject2(val) && isFunction(val.pipe);
  var isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  var isURLSearchParams = kindOfTest("URLSearchParams");
  var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  var trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l2 = obj.length; i < l2; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i = keys2.length;
    let _key;
    while (i-- > 0) {
      _key = keys2[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  var _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  var isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge3() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge3(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge3({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l2 = arguments.length; i < l2; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  var stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  var inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  var endsWith = (str, searchString, position3) => {
    str = String(str);
    if (position3 === void 0 || position3 > str.length) {
      position3 = str.length;
    }
    position3 -= searchString.length;
    const lastIndex = str.indexOf(searchString, position3);
    return lastIndex !== -1 && lastIndex === position3;
  };
  var toArray8 = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  var forEachEntry = (obj, fn) => {
    const generator2 = obj && obj[iterator];
    const _iterator = generator2.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  var matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  var isHTMLForm = kindOfTest("HTMLFormElement");
  var toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  var isRegExp = kindOfTest("RegExp");
  var reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  var freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  var toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define2 = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
    return obj;
  };
  var noop6 = () => {
  };
  var toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  var toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject2(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  var isAsyncFn = kindOfTest("AsyncFunction");
  var isThenable2 = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token2, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token2) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token2, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction(_global.postMessage)
  );
  var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
  var utils_default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString2,
    isNumber,
    isBoolean,
    isObject: isObject2,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge: merge3,
    extend,
    trim: trim2,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray: toArray8,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop6,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable: isThenable2,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };

  // node_modules/axios/lib/core/AxiosError.js
  function AxiosError(message2, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message2;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils_default.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils_default.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  var prototype = AxiosError.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype);
    utils_default.toFlatObject(error, axiosError, function filter3(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var AxiosError_default = AxiosError;

  // node_modules/axios/lib/helpers/null.js
  var null_default = null;

  // node_modules/axios/lib/helpers/toFormData.js
  function isVisitable(thing) {
    return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
  }
  function removeBrackets(key) {
    return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path2, key, dots) {
    if (!path2) return key;
    return path2.concat(key).map(function each(token2, i) {
      token2 = removeBrackets(token2);
      return !dots && i ? "[" + token2 + "]" : token2;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils_default.isArray(arr) && !arr.some(isVisitable);
  }
  var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils_default.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (null_default || FormData)();
    options = utils_default.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils_default.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
    if (!utils_default.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils_default.isDate(value)) {
        return value.toISOString();
      }
      if (utils_default.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils_default.isBlob(value)) {
        throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
      }
      if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path2) {
      let arr = value;
      if (value && !path2 && typeof value === "object") {
        if (utils_default.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index3) {
            !(utils_default.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index3, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path2, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path2) {
      if (utils_default.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path2.join("."));
      }
      stack.push(value);
      utils_default.forEach(value, function each(el, key) {
        const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils_default.isString(key) ? key.trim() : key,
          path2,
          exposedHelpers
        );
        if (result === true) {
          build(el, path2 ? path2.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils_default.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  var toFormData_default = toFormData;

  // node_modules/axios/lib/helpers/AxiosURLSearchParams.js
  function encode(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
      return charMap[match2];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData_default(params, this, options);
  }
  var prototype2 = AxiosURLSearchParams.prototype;
  prototype2.append = function append2(name, value) {
    this._pairs.push([name, value]);
  };
  prototype2.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  var AxiosURLSearchParams_default = AxiosURLSearchParams;

  // node_modules/axios/lib/helpers/buildURL.js
  function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url2, params, options) {
    if (!params) {
      return url2;
    }
    const _encode = options && options.encode || encode2;
    if (utils_default.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  }

  // node_modules/axios/lib/core/InterceptorManager.js
  var InterceptorManager = class {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils_default.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  };
  var InterceptorManager_default = InterceptorManager;

  // node_modules/axios/lib/defaults/transitional.js
  var transitional_default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };

  // node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
  var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

  // node_modules/axios/lib/platform/browser/classes/FormData.js
  var FormData_default = typeof FormData !== "undefined" ? FormData : null;

  // node_modules/axios/lib/platform/browser/classes/Blob.js
  var Blob_default = typeof Blob !== "undefined" ? Blob : null;

  // node_modules/axios/lib/platform/browser/index.js
  var browser_default = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams_default,
      FormData: FormData_default,
      Blob: Blob_default
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };

  // node_modules/axios/lib/platform/common/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    hasBrowserEnv: () => hasBrowserEnv,
    hasStandardBrowserEnv: () => hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
    navigator: () => _navigator,
    origin: () => origin
  });
  var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  var _navigator = typeof navigator === "object" && navigator || void 0;
  var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  var hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  var origin = hasBrowserEnv && window.location.href || "http://localhost";

  // node_modules/axios/lib/platform/index.js
  var platform_default = {
    ...utils_exports,
    ...browser_default
  };

  // node_modules/axios/lib/helpers/toURLEncodedForm.js
  function toURLEncodedForm(data, options) {
    return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path2, helpers) {
        if (platform_default.isNode && utils_default.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }

  // node_modules/axios/lib/helpers/formDataToJSON.js
  function parsePropPath(name) {
    return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
      return match2[0] === "[]" ? "" : match2[1] || match2[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i;
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path2, value, target, index3) {
      let name = path2[index3++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index3 >= path2.length;
      name = !name && utils_default.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils_default.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils_default.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path2, value, target[name], index3);
      if (result && utils_default.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
      const obj = {};
      utils_default.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  var formDataToJSON_default = formDataToJSON;

  // node_modules/axios/lib/defaults/index.js
  function stringifySafely(rawValue, parser, encoder) {
    if (utils_default.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils_default.trim(rawValue);
      } catch (e3) {
        if (e3.name !== "SyntaxError") {
          throw e3;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults = {
    transitional: transitional_default,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils_default.isObject(data);
      if (isObjectPayload && utils_default.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils_default.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
      }
      if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
        return data;
      }
      if (utils_default.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils_default.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData_default(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional2 = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
        return data;
      }
      if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e3) {
          if (strictJSONParsing) {
            if (e3.name === "SyntaxError") {
              throw AxiosError_default.from(e3, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e3;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform_default.classes.FormData,
      Blob: platform_default.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method4) => {
    defaults.headers[method4] = {};
  });
  var defaults_default = defaults;

  // node_modules/axios/lib/helpers/parseHeaders.js
  var ignoreDuplicateOf = utils_default.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders_default = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
      i = line2.indexOf(":");
      key = line2.substring(0, i).trim().toLowerCase();
      val = line2.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };

  // node_modules/axios/lib/core/AxiosHeaders.js
  var $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match2;
    while (match2 = tokensRE.exec(str)) {
      tokens[match2[1]] = match2[2];
    }
    return tokens;
  }
  var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
    if (utils_default.isFunction(filter3)) {
      return filter3.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils_default.isString(value)) return;
    if (utils_default.isString(filter3)) {
      return value.indexOf(filter3) !== -1;
    }
    if (utils_default.isRegExp(filter3)) {
      return filter3.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char2, str) => {
      return char2.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils_default.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  var AxiosHeaders = class {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils_default.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders_default(header), valueOrRewrite);
      } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
        let obj = {}, dest, key;
        for (const entry of header) {
          if (!utils_default.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils_default.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils_default.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils_default.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils_default.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i = keys2.length;
      let deleted = false;
      while (i--) {
        const key = keys2[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils_default.forEach(this, (value, header) => {
        const key = utils_default.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils_default.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype3 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype3, _header);
          accessors[lHeader] = true;
        }
      }
      utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils_default.freezeMethods(AxiosHeaders);
  var AxiosHeaders_default = AxiosHeaders;

  // node_modules/axios/lib/core/transformData.js
  function transformData(fns, response) {
    const config = this || defaults_default;
    const context = response || config;
    const headers = AxiosHeaders_default.from(context.headers);
    let data = context.data;
    utils_default.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }

  // node_modules/axios/lib/cancel/isCancel.js
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }

  // node_modules/axios/lib/cancel/CanceledError.js
  function CanceledError(message2, config, request) {
    AxiosError_default.call(this, message2 == null ? "canceled" : message2, AxiosError_default.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils_default.inherits(CanceledError, AxiosError_default, {
    __CANCEL__: true
  });
  var CanceledError_default = CanceledError;

  // node_modules/axios/lib/core/settle.js
  function settle(resolve, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError_default(
        "Request failed with status code " + response.status,
        [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }

  // node_modules/axios/lib/helpers/parseProtocol.js
  function parseProtocol(url2) {
    const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match2 && match2[1] || "";
  }

  // node_modules/axios/lib/helpers/speedometer.js
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now2 = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now2;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now2;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now2 - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now2 - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  var speedometer_default = speedometer;

  // node_modules/axios/lib/helpers/throttle.js
  function throttle3(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now2 = Date.now()) => {
      timestamp = now2;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(null, args);
    };
    const throttled = (...args) => {
      const now2 = Date.now();
      const passed = now2 - timestamp;
      if (passed >= threshold) {
        invoke(args, now2);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  var throttle_default = throttle3;

  // node_modules/axios/lib/helpers/progressEventReducer.js
  var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer_default(50, 250);
    return throttle_default((e3) => {
      const loaded = e3.loaded;
      const total = e3.lengthComputable ? e3.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e3,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  var progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
    url2 = new URL(url2, platform_default.origin);
    return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
  })(
    new URL(platform_default.origin),
    platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
  ) : () => true;

  // node_modules/axios/lib/helpers/cookies.js
  var cookies_default = platform_default.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path2, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils_default.isString(path2) && cookie.push("path=" + path2);
        utils_default.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  }

  // node_modules/axios/lib/helpers/combineURLs.js
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }

  // node_modules/axios/lib/core/buildFullPath.js
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }

  // node_modules/axios/lib/core/mergeConfig.js
  var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
  function mergeConfig2(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
        return utils_default.merge.call({ caseless }, target, source);
      } else if (utils_default.isPlainObject(source)) {
        return utils_default.merge({}, source);
      } else if (utils_default.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils_default.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils_default.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge4 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge4(config1[prop], config2[prop], prop);
      utils_default.isUndefined(configValue) && merge4 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }

  // node_modules/axios/lib/helpers/resolveConfig.js
  var resolveConfig_default = (config) => {
    const newConfig = mergeConfig2({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders_default.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils_default.isFormData(data)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type5, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
        headers.setContentType([type5 || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };

  // node_modules/axios/lib/adapters/xhr.js
  var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhr_default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig_default(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders_default.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = _config.transitional || transitional_default;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils_default.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };

  // node_modules/axios/lib/helpers/composeSignals.js
  var composeSignals = (signals, timeout) => {
    const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length2) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils_default.asap(unsubscribe);
      return signal;
    }
  };
  var composeSignals_default = composeSignals;

  // node_modules/axios/lib/helpers/trackStream.js
  var streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  var readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  var readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  var trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e3) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e3);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator2.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };

  // node_modules/axios/lib/adapters/fetch.js
  var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  var test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e3) {
      return false;
    }
  };
  var supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  var DEFAULT_CHUNK_SIZE = 64 * 1024;
  var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  var resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type5) => {
      !resolvers[type5] && (resolvers[type5] = utils_default.isFunction(res[type5]) ? (res2) => res2[type5]() : (_, config) => {
        throw new AxiosError_default(`Response type '${type5}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  var getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  var resolveBodyLength = async (headers, body) => {
    const length2 = utils_default.toFiniteNumber(headers.getContentLength());
    return length2 == null ? getBodyLength(body) : length2;
  };
  var fetch_default = isFetchSupported && (async (config) => {
    let {
      url: url2,
      method: method4,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method4 !== "get" && method4 !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url2, {
        ...fetchOptions,
        signal: composedSignal,
        method: method4.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request, fetchOptions);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request);
    }
  });

  // node_modules/axios/lib/adapters/adapters.js
  var knownAdapters = {
    http: null_default,
    xhr: xhr_default,
    fetch: fetch_default
  };
  utils_default.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e3) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  var renderReason = (reason) => `- ${reason}`;
  var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
  var adapters_default = {
    getAdapter: (adapters) => {
      adapters = utils_default.isArray(adapters) ? adapters : [adapters];
      const { length: length2 } = adapters;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length2; i++) {
        nameOrAdapter = adapters[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError_default(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError_default(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };

  // node_modules/axios/lib/core/dispatchRequest.js
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError_default(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders_default.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders_default.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }

  // node_modules/axios/lib/env/data.js
  var VERSION = "1.10.0";

  // node_modules/axios/lib/helpers/validator.js
  var validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type5, i) => {
    validators[type5] = function validator(thing) {
      return typeof thing === type5 || "a" + (i < 1 ? "n " : " ") + type5;
    };
  });
  var deprecatedWarnings = {};
  validators.transitional = function transitional(validator, version4, message2) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
    }
    return (value, opt, opts) => {
      if (validator === false) {
        throw new AxiosError_default(
          formatMessage(opt, " has been removed" + (version4 ? " in " + version4 : "")),
          AxiosError_default.ERR_DEPRECATED
        );
      }
      if (version4 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version4 + " and will be removed in the near future"
          )
        );
      }
      return validator ? validator(value, opt, opts) : true;
    };
  };
  validators.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i = keys2.length;
    while (i-- > 0) {
      const opt = keys2[i];
      const validator = schema[opt];
      if (validator) {
        const value = options[opt];
        const result = value === void 0 || validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
      }
    }
  }
  var validator_default2 = {
    assertOptions,
    validators
  };

  // node_modules/axios/lib/core/Axios.js
  var validators2 = validator_default2.validators;
  var Axios = class {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager_default(),
        response: new InterceptorManager_default()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e3) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig2(this.defaults, config);
      const { transitional: transitional2, paramsSerializer, headers } = config;
      if (transitional2 !== void 0) {
        validator_default2.assertOptions(transitional2, {
          silentJSONParsing: validators2.transitional(validators2.boolean),
          forcedJSONParsing: validators2.transitional(validators2.boolean),
          clarifyTimeoutError: validators2.transitional(validators2.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils_default.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator_default2.assertOptions(paramsSerializer, {
            encode: validators2.function,
            serialize: validators2.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) {
      } else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator_default2.assertOptions(config, {
        baseUrl: validators2.spelling("baseURL"),
        withXsrfToken: validators2.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils_default.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils_default.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method4) => {
          delete headers[method4];
        }
      );
      config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig2(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };
  utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method4) {
    Axios.prototype[method4] = function(url2, config) {
      return this.request(mergeConfig2(config || {}, {
        method: method4,
        url: url2,
        data: (config || {}).data
      }));
    };
  });
  utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method4) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data, config) {
        return this.request(mergeConfig2(config || {}, {
          method: method4,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data
        }));
      };
    }
    Axios.prototype[method4] = generateHTTPMethod();
    Axios.prototype[method4 + "Form"] = generateHTTPMethod(true);
  });
  var Axios_default = Axios;

  // node_modules/axios/lib/cancel/CancelToken.js
  var CancelToken = class _CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token2 = this;
      this.promise.then((cancel) => {
        if (!token2._listeners) return;
        let i = token2._listeners.length;
        while (i-- > 0) {
          token2._listeners[i](cancel);
        }
        token2._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token2.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token2.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message2, config, request) {
        if (token2.reason) {
          return;
        }
        token2.reason = new CanceledError_default(message2, config, request);
        resolvePromise(token2.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index3 = this._listeners.indexOf(listener);
      if (index3 !== -1) {
        this._listeners.splice(index3, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token2 = new _CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token2,
        cancel
      };
    }
  };
  var CancelToken_default = CancelToken;

  // node_modules/axios/lib/helpers/spread.js
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }

  // node_modules/axios/lib/helpers/isAxiosError.js
  function isAxiosError(payload) {
    return utils_default.isObject(payload) && payload.isAxiosError === true;
  }

  // node_modules/axios/lib/helpers/HttpStatusCode.js
  var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  var HttpStatusCode_default = HttpStatusCode;

  // node_modules/axios/lib/axios.js
  function createInstance(defaultConfig2) {
    const context = new Axios_default(defaultConfig2);
    const instance = bind(Axios_default.prototype.request, context);
    utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
    utils_default.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig2(defaultConfig2, instanceConfig));
    };
    return instance;
  }
  var axios = createInstance(defaults_default);
  axios.Axios = Axios_default;
  axios.CanceledError = CanceledError_default;
  axios.CancelToken = CancelToken_default;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData_default;
  axios.AxiosError = AxiosError_default;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig2;
  axios.AxiosHeaders = AxiosHeaders_default;
  axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters_default.getAdapter;
  axios.HttpStatusCode = HttpStatusCode_default;
  axios.default = axios;
  var axios_default = axios;

  // node_modules/axios/index.js
  var {
    Axios: Axios2,
    AxiosError: AxiosError2,
    CanceledError: CanceledError2,
    isCancel: isCancel2,
    CancelToken: CancelToken2,
    VERSION: VERSION2,
    all: all2,
    Cancel,
    isAxiosError: isAxiosError2,
    spread: spread2,
    toFormData: toFormData2,
    AxiosHeaders: AxiosHeaders2,
    HttpStatusCode: HttpStatusCode2,
    formToJSON,
    getAdapter,
    mergeConfig: mergeConfig3
  } = axios_default;

  // public/js/components/Dashboard.tsx
  var { Header: Header4, Content: Content3, Footer: Footer4 } = layout_default2;
  var { Option: Option3 } = select_default;
  var API_BASE = "/api/v1";
  var Dashboard = () => {
    const [activeTab, setActiveTab] = (0, import_react124.useState)("dashboard");
    const [stats, setStats] = (0, import_react124.useState)({});
    const [campaigns, setCampaigns] = (0, import_react124.useState)([]);
    const [prospects, setProspects] = (0, import_react124.useState)([]);
    const [bulkJobs, setBulkJobs] = (0, import_react124.useState)([]);
    (0, import_react124.useEffect)(() => {
      loadDashboardData();
      loadCampaigns();
      loadProspects();
      loadBulkImportJobs();
      const ws = new WebSocket(`ws://${window.location.host}`);
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === "campaign_progress") {
          loadCampaigns();
        }
        if (data.type === "prospect_update") {
          loadProspects();
        }
        if (data.type === "bulk_job_update") {
          loadBulkImportJobs();
        }
        loadDashboardData();
      };
      return () => {
        ws.close();
      };
    }, []);
    const loadDashboardData = async () => {
      const statusResponse = await axios_default.get(`${API_BASE}/status`);
      const prospectsResponse = await axios_default.get(`${API_BASE}/prospects/stats/overview`);
      const campaignsResponse = await axios_default.get(`${API_BASE}/campaigns`);
      setStats({
        status: statusResponse.data.data,
        prospectStats: prospectsResponse.data.data,
        campaigns: campaignsResponse.data.data.campaigns
      });
    };
    const loadCampaigns = async () => {
      const response = await axios_default.get(`${API_BASE}/campaigns`);
      setCampaigns(response.data.data.campaigns);
    };
    const loadProspects = async () => {
      const response = await axios_default.get(`${API_BASE}/prospects`);
      setProspects(response.data.data.prospects);
    };
    const loadBulkImportJobs = async () => {
      const response = await axios_default.get(`${API_BASE}/bulk/jobs`);
      setBulkJobs(response.data.data.jobs);
    };
    const renderContent = () => {
      switch (activeTab) {
        case "dashboard":
          return /* @__PURE__ */ import_react124.default.createElement(DashboardContent, { stats });
        case "campaigns":
          return /* @__PURE__ */ import_react124.default.createElement(CampaignsContent, { campaigns, refresh: loadCampaigns });
        case "prospects":
          return /* @__PURE__ */ import_react124.default.createElement(ProspectsContent, { prospects, refresh: loadProspects });
        case "bulk":
          return /* @__PURE__ */ import_react124.default.createElement(BulkImportContent, { jobs: bulkJobs, refresh: loadBulkImportJobs });
        default:
          return null;
      }
    };
    return /* @__PURE__ */ import_react124.default.createElement(layout_default2, { className: "layout" }, /* @__PURE__ */ import_react124.default.createElement(Header4, null, /* @__PURE__ */ import_react124.default.createElement("div", { className: "logo" }), /* @__PURE__ */ import_react124.default.createElement(menu_default2, { theme: "dark", mode: "horizontal", defaultSelectedKeys: ["dashboard"], onSelect: (e3) => setActiveTab(e3.key) }, /* @__PURE__ */ import_react124.default.createElement(menu_default2.Item, { key: "dashboard" }, "Dashboard"), /* @__PURE__ */ import_react124.default.createElement(menu_default2.Item, { key: "campaigns" }, "Campaigns"), /* @__PURE__ */ import_react124.default.createElement(menu_default2.Item, { key: "prospects" }, "Prospects"), /* @__PURE__ */ import_react124.default.createElement(menu_default2.Item, { key: "bulk" }, "Bulk Import"))), /* @__PURE__ */ import_react124.default.createElement(Content3, { style: { padding: "0 50px" } }, /* @__PURE__ */ import_react124.default.createElement("div", { className: "site-layout-content", style: { background: "#fff", padding: 24, minHeight: 280 } }, renderContent())), /* @__PURE__ */ import_react124.default.createElement(Footer4, { style: { textAlign: "center" } }, "Missive Email Generator \xA92025"));
  };
  var DashboardContent = ({ stats }) => /* @__PURE__ */ import_react124.default.createElement(import_react124.default.Fragment, null, /* @__PURE__ */ import_react124.default.createElement(row_default2, { gutter: 16 }, /* @__PURE__ */ import_react124.default.createElement(col_default2, { span: 6 }, /* @__PURE__ */ import_react124.default.createElement(card_default, null, /* @__PURE__ */ import_react124.default.createElement(statistic_default2, { title: "Total Prospects", value: stats.prospectStats?.total || 0 }))), /* @__PURE__ */ import_react124.default.createElement(col_default2, { span: 6 }, /* @__PURE__ */ import_react124.default.createElement(card_default, null, /* @__PURE__ */ import_react124.default.createElement(statistic_default2, { title: "Active Campaigns", value: stats.campaigns?.filter((c) => c.status === "active").length || 0 }))), /* @__PURE__ */ import_react124.default.createElement(col_default2, { span: 6 }, /* @__PURE__ */ import_react124.default.createElement(card_default, null, /* @__PURE__ */ import_react124.default.createElement(statistic_default2, { title: "Emails Generated", value: stats.status?.generation?.completed || 0 }))), /* @__PURE__ */ import_react124.default.createElement(col_default2, { span: 6 }, /* @__PURE__ */ import_react124.default.createElement(card_default, null, /* @__PURE__ */ import_react124.default.createElement(statistic_default2, { title: "Drafts Created", value: stats.status?.drafts?.draftsCreated || 0 })))));
  var CampaignsContent = ({ campaigns, refresh }) => {
    const [isCreateModalVisible, setIsCreateModalVisible] = (0, import_react124.useState)(false);
    const [isProgressModalVisible, setIsProgressModalVisible] = (0, import_react124.useState)(false);
    const [isProspectsModalVisible, setIsProspectsModalVisible] = (0, import_react124.useState)(false);
    const [selectedCampaign, setSelectedCampaign] = (0, import_react124.useState)(null);
    const getStatusColor = (status) => {
      const colors = {
        pending: "gold",
        active: "green",
        paused: "orange",
        completed: "blue",
        failed: "red"
      };
      return colors[status] || "default";
    };
    const handleAction = async (action, campaignId) => {
      try {
        await axios_default.post(`${API_BASE}/campaigns/${campaignId}/${action}`);
        message_default.success(`Campaign ${action}ed successfully`);
        refresh();
      } catch (error) {
        message_default.error(`Failed to ${action} campaign`);
      }
    };
    const showProgress = async (campaign) => {
      try {
        const response = await axios_default.get(`${API_BASE}/campaigns/${campaign._id}/progress`);
        setSelectedCampaign({ ...campaign, progress: response.data.data });
        setIsProgressModalVisible(true);
      } catch (error) {
        message_default.error("Failed to get campaign progress");
      }
    };
    const showCampaignProspects = async (campaign) => {
      try {
        const response = await axios_default.get(`${API_BASE}/campaigns/${campaign._id}/prospects`);
        setSelectedCampaign({ ...campaign, prospects: response.data.data.prospects });
        setIsProspectsModalVisible(true);
      } catch (error) {
        message_default.error("Failed to get campaign prospects");
      }
    };
    const columns = [
      { title: "Name", dataIndex: "name", key: "name" },
      { title: "Status", dataIndex: "status", key: "status", render: (status) => /* @__PURE__ */ import_react124.default.createElement(tag_default, { color: getStatusColor(status) }, status) },
      { title: "Email Style", dataIndex: "emailStyle", key: "emailStyle" },
      { title: "USPs", dataIndex: "usps", key: "usps", render: (usps) => usps?.length || 0 },
      { title: "Created", dataIndex: "createdAt", key: "createdAt", render: (date4) => new Date(date4).toLocaleDateString() },
      {
        title: "Actions",
        key: "actions",
        render: (text, record) => /* @__PURE__ */ import_react124.default.createElement(import_react124.default.Fragment, null, /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => handleAction("start", record._id), style: { marginRight: 8 } }, "Start"), /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => handleAction("pause", record._id), style: { marginRight: 8 } }, "Pause"), /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => showProgress(record), style: { marginRight: 8 } }, "Progress"), /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => showCampaignProspects(record) }, "Prospects"))
      }
    ];
    return /* @__PURE__ */ import_react124.default.createElement(import_react124.default.Fragment, null, /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => setIsCreateModalVisible(true), type: "primary", style: { marginBottom: 16 } }, "Create Campaign"), /* @__PURE__ */ import_react124.default.createElement(table_default, { dataSource: campaigns, columns, rowKey: "_id" }), /* @__PURE__ */ import_react124.default.createElement(
      CreateCampaignModal,
      {
        visible: isCreateModalVisible,
        onCancel: () => setIsCreateModalVisible(false),
        onSuccess: () => {
          setIsCreateModalVisible(false);
          refresh();
        }
      }
    ), /* @__PURE__ */ import_react124.default.createElement(
      modal_default,
      {
        title: "Campaign Progress",
        visible: isProgressModalVisible,
        onCancel: () => setIsProgressModalVisible(false),
        footer: null
      },
      selectedCampaign && selectedCampaign.progress && /* @__PURE__ */ import_react124.default.createElement("div", null, /* @__PURE__ */ import_react124.default.createElement("p", null, "Percentage: ", selectedCampaign.progress.progress.percentage, "%"), /* @__PURE__ */ import_react124.default.createElement(progress_default2, { percent: selectedCampaign.progress.progress.percentage }), /* @__PURE__ */ import_react124.default.createElement("p", null, "Completed: ", selectedCampaign.progress.progress.completed), /* @__PURE__ */ import_react124.default.createElement("p", null, "Failed: ", selectedCampaign.progress.progress.failed), /* @__PURE__ */ import_react124.default.createElement("p", null, "Queued: ", selectedCampaign.progress.progress.queued))
    ), /* @__PURE__ */ import_react124.default.createElement(
      modal_default,
      {
        title: "Campaign Prospects",
        visible: isProspectsModalVisible,
        onCancel: () => setIsProspectsModalVisible(false),
        footer: null
      },
      selectedCampaign && selectedCampaign.prospects && /* @__PURE__ */ import_react124.default.createElement("ul", null, selectedCampaign.prospects.map((prospect) => /* @__PURE__ */ import_react124.default.createElement("li", { key: prospect._id }, prospect.website)))
    ));
  };
  var ProspectsContent = ({ prospects, refresh }) => {
    const [selectedRowKeys, setSelectedRowKeys] = (0, import_react124.useState)([]);
    const [isAssignModalVisible, setIsAssignModalVisible] = (0, import_react124.useState)(false);
    const [isCreateModalVisible, setIsCreateModalVisible] = (0, import_react124.useState)(false);
    const [isIndividualAssignModalVisible, setIsIndividualAssignModalVisible] = (0, import_react124.useState)(false);
    const [selectedProspect, setSelectedProspect] = (0, import_react124.useState)(null);
    const [campaigns, setCampaigns] = (0, import_react124.useState)([]);
    const [selectedCampaign, setSelectedCampaign] = (0, import_react124.useState)(null);
    (0, import_react124.useEffect)(() => {
      loadCampaigns();
    }, []);
    const loadCampaigns = async () => {
      const response = await axios_default.get(`${API_BASE}/campaigns`);
      setCampaigns(response.data.data.campaigns);
    };
    const handleAction = async (action, prospectId) => {
      try {
        if (action === "delete") {
          await axios_default.delete(`${API_BASE}/prospects/${prospectId}`);
          message_default.success("Prospect deleted successfully");
        } else {
          await axios_default.post(`${API_BASE}/prospects/${prospectId}/${action}`);
          message_default.success(`Prospect ${action}ed successfully`);
        }
        refresh();
      } catch (error) {
        message_default.error(`Failed to ${action} prospect`);
      }
    };
    const onSelectChange = (newSelectedRowKeys) => {
      setSelectedRowKeys(newSelectedRowKeys);
    };
    const rowSelection = {
      selectedRowKeys,
      onChange: onSelectChange
    };
    const handleBulkAssign = async () => {
      if (!selectedCampaign) {
        message_default.error("Please select a campaign");
        return;
      }
      try {
        await axios_default.post(`${API_BASE}/prospects/bulk/assign-campaign`, {
          prospectIds: selectedRowKeys,
          campaignId: selectedCampaign
        });
        message_default.success("Prospects assigned successfully");
        setSelectedRowKeys([]);
        setIsAssignModalVisible(false);
        refresh();
      } catch (error) {
        message_default.error("Failed to assign prospects");
      }
    };
    const showAssignProspectModal = (prospect) => {
      setSelectedProspect(prospect);
      setIsIndividualAssignModalVisible(true);
    };
    const handleIndividualAssign = async (campaignId) => {
      try {
        await axios_default.post(`${API_BASE}/prospects/${selectedProspect._id}/assign-campaign`, { campaignId });
        message_default.success("Prospect assigned successfully");
        setIsIndividualAssignModalVisible(false);
        refresh();
      } catch (error) {
        message_default.error("Failed to assign prospect");
      }
    };
    const columns = [
      { title: "Website", dataIndex: "website", key: "website", render: (url2) => /* @__PURE__ */ import_react124.default.createElement("a", { href: url2, target: "_blank", rel: "noopener noreferrer" }, url2) },
      { title: "Contact", dataIndex: "contactEmail", key: "contactEmail" },
      { title: "Company", dataIndex: "companyName", key: "companyName" },
      { title: "Status", dataIndex: "status", key: "status", render: (status) => /* @__PURE__ */ import_react124.default.createElement(tag_default, null, status) },
      {
        title: "Actions",
        key: "actions",
        render: (text, record) => /* @__PURE__ */ import_react124.default.createElement(import_react124.default.Fragment, null, /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => handleAction("scrape", record._id), style: { marginRight: 8 } }, "Scrape"), /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => showAssignProspectModal(record), style: { marginRight: 8 } }, "Assign"), /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => handleAction("delete", record._id), danger: true }, "Delete"))
      }
    ];
    return /* @__PURE__ */ import_react124.default.createElement(import_react124.default.Fragment, null, /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => setIsCreateModalVisible(true), type: "primary", style: { marginBottom: 16, marginRight: 8 } }, "Add Prospect"), /* @__PURE__ */ import_react124.default.createElement(button_default2, { onClick: () => setIsAssignModalVisible(true), disabled: selectedRowKeys.length === 0, style: { marginBottom: 16 } }, "Bulk Assign to Campaign"), /* @__PURE__ */ import_react124.default.createElement(table_default, { rowSelection, dataSource: prospects, columns, rowKey: "_id" }), /* @__PURE__ */ import_react124.default.createElement(
      modal_default,
      {
        title: "Assign to Campaign",
        visible: isAssignModalVisible,
        onOk: handleBulkAssign,
        onCancel: () => setIsAssignModalVisible(false)
      },
      /* @__PURE__ */ import_react124.default.createElement(select_default, { style: { width: "100%" }, onChange: (value) => setSelectedCampaign(value), placeholder: "Select a campaign" }, campaigns.map((campaign) => /* @__PURE__ */ import_react124.default.createElement(Option3, { key: campaign._id, value: campaign._id }, campaign.name)))
    ), /* @__PURE__ */ import_react124.default.createElement(
      AssignProspectModal,
      {
        visible: isIndividualAssignModalVisible,
        onCancel: () => setIsIndividualAssignModalVisible(false),
        onSuccess: handleIndividualAssign,
        campaigns
      }
    ), /* @__PURE__ */ import_react124.default.createElement(
      CreateProspectModal,
      {
        visible: isCreateModalVisible,
        onCancel: () => setIsCreateModalVisible(false),
        onSuccess: () => {
          setIsCreateModalVisible(false);
          refresh();
        }
      }
    ));
  };
  var BulkImportContent = ({ jobs, refresh }) => {
    const [campaigns, setCampaigns] = (0, import_react124.useState)([]);
    const [selectedCampaign, setSelectedCampaign] = (0, import_react124.useState)(null);
    (0, import_react124.useEffect)(() => {
      loadCampaigns();
    }, []);
    const loadCampaigns = async () => {
      const response = await axios_default.get(`${API_BASE}/campaigns`);
      setCampaigns(response.data.data.campaigns);
    };
    const handleUpload = async (options) => {
      const { file, onSuccess, onError } = options;
      const formData = new FormData();
      formData.append("file", file);
      if (selectedCampaign) {
        formData.append("campaignId", selectedCampaign);
      }
      try {
        await axios_default.post(`${API_BASE}/bulk/import`, formData, {
          headers: {
            "Content-Type": "multipart/form-data"
          }
        });
        onSuccess();
        message_default.success("File uploaded successfully");
        refresh();
      } catch (error) {
        onError(error);
        message_default.error("File upload failed");
      }
    };
    const columns = [
      { title: "Filename", dataIndex: "filename", key: "filename" },
      { title: "Status", dataIndex: "status", key: "status", render: (status) => /* @__PURE__ */ import_react124.default.createElement(tag_default, null, status) },
      { title: "Processed", dataIndex: "processedProspects", key: "processedProspects" },
      { title: "Total", dataIndex: "totalProspects", key: "totalProspects" }
    ];
    return /* @__PURE__ */ import_react124.default.createElement(import_react124.default.Fragment, null, /* @__PURE__ */ import_react124.default.createElement(form_default, { layout: "inline", style: { marginBottom: 16 } }, /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { label: "Campaign" }, /* @__PURE__ */ import_react124.default.createElement(select_default, { style: { width: 200 }, onChange: (value) => setSelectedCampaign(value), placeholder: "Select a campaign (optional)" }, campaigns.map((campaign) => /* @__PURE__ */ import_react124.default.createElement(Option3, { key: campaign._id, value: campaign._id }, campaign.name)))), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, null, /* @__PURE__ */ import_react124.default.createElement(upload_default, { customRequest: handleUpload, showUploadList: false }, /* @__PURE__ */ import_react124.default.createElement(button_default2, { icon: /* @__PURE__ */ import_react124.default.createElement(UploadOutlined_default2, null) }, "Upload CSV"))), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, null, /* @__PURE__ */ import_react124.default.createElement("a", { href: "/api/v1/bulk/template", download: true }, /* @__PURE__ */ import_react124.default.createElement(button_default2, null, "Download Template")))), /* @__PURE__ */ import_react124.default.createElement(table_default, { dataSource: jobs, columns, rowKey: "_id" }));
  };
  var CreateCampaignModal = ({ visible, onCancel, onSuccess }) => {
    const [form] = form_default.useForm();
    const handleCreate = async () => {
      try {
        const values = await form.validateFields();
        await axios_default.post(`${API_BASE}/campaigns`, values);
        message_default.success("Campaign created successfully");
        onSuccess();
        form.resetFields();
      } catch (error) {
        message_default.error("Failed to create campaign");
      }
    };
    return /* @__PURE__ */ import_react124.default.createElement(
      modal_default,
      {
        title: "Create Campaign",
        visible,
        onOk: handleCreate,
        onCancel
      },
      /* @__PURE__ */ import_react124.default.createElement(form_default, { form, layout: "vertical" }, /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "name", label: "Campaign Name", rules: [{ required: true }] }, /* @__PURE__ */ import_react124.default.createElement(input_default, null)), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "marketingDocument", label: "Marketing Document", rules: [{ required: true }] }, /* @__PURE__ */ import_react124.default.createElement(input_default.TextArea, { rows: 4 })), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "missiveAccountId", label: "Missive Account ID", rules: [{ required: true }] }, /* @__PURE__ */ import_react124.default.createElement(input_default, null)), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "tone", label: "Tone", initialValue: "professional" }, /* @__PURE__ */ import_react124.default.createElement(select_default, null, /* @__PURE__ */ import_react124.default.createElement(Option3, { value: "professional" }, "Professional"), /* @__PURE__ */ import_react124.default.createElement(Option3, { value: "casual" }, "Casual"), /* @__PURE__ */ import_react124.default.createElement(Option3, { value: "friendly" }, "Friendly"), /* @__PURE__ */ import_react124.default.createElement(Option3, { value: "formal" }, "Formal"))), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "emailStyle", label: "Email Style", initialValue: "statement" }, /* @__PURE__ */ import_react124.default.createElement(select_default, null, /* @__PURE__ */ import_react124.default.createElement(Option3, { value: "statement" }, "Statement-Based"), /* @__PURE__ */ import_react124.default.createElement(Option3, { value: "question" }, "Question-Based"))))
    );
  };
  var CreateProspectModal = ({ visible, onCancel, onSuccess }) => {
    const [form] = form_default.useForm();
    const handleCreate = async () => {
      try {
        const values = await form.validateFields();
        await axios_default.post(`${API_BASE}/prospects`, values);
        message_default.success("Prospect created successfully");
        onSuccess();
        form.resetFields();
      } catch (error) {
        message_default.error("Failed to create prospect");
      }
    };
    return /* @__PURE__ */ import_react124.default.createElement(
      modal_default,
      {
        title: "Add Prospect",
        visible,
        onOk: handleCreate,
        onCancel
      },
      /* @__PURE__ */ import_react124.default.createElement(form_default, { form, layout: "vertical" }, /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "website", label: "Website", rules: [{ required: true, type: "url" }] }, /* @__PURE__ */ import_react124.default.createElement(input_default, null)), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "contactEmail", label: "Contact Email", rules: [{ required: true, type: "email" }] }, /* @__PURE__ */ import_react124.default.createElement(input_default, null)), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "contactName", label: "Contact Name" }, /* @__PURE__ */ import_react124.default.createElement(input_default, null)), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "companyName", label: "Company Name" }, /* @__PURE__ */ import_react124.default.createElement(input_default, null)), /* @__PURE__ */ import_react124.default.createElement(form_default.Item, { name: "industry", label: "Industry" }, /* @__PURE__ */ import_react124.default.createElement(input_default, null)))
    );
  };
  var AssignProspectModal = ({ visible, onCancel, onSuccess, campaigns }) => {
    const [selectedCampaign, setSelectedCampaign] = (0, import_react124.useState)(null);
    return /* @__PURE__ */ import_react124.default.createElement(
      modal_default,
      {
        title: "Assign Prospect to Campaign",
        visible,
        onOk: () => onSuccess(selectedCampaign),
        onCancel,
        okButtonProps: { disabled: !selectedCampaign }
      },
      /* @__PURE__ */ import_react124.default.createElement(select_default, { style: { width: "100%" }, onChange: (value) => setSelectedCampaign(value), placeholder: "Select a campaign" }, campaigns.map((campaign) => /* @__PURE__ */ import_react124.default.createElement(Option3, { key: campaign._id, value: campaign._id }, campaign.name)))
    );
  };
  var Dashboard_default = Dashboard;

  // public/js/main.js
  var root = import_client.default.createRoot(document.getElementById("root"));
  root.render(/* @__PURE__ */ import_react125.default.createElement(Dashboard_default, null));
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@babel/runtime/helpers/esm/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
*/
